(globalThis["webpackChunkappbuilder_pwa"] = globalThis["webpackChunkappbuilder_pwa"] || []).push([["app"],{

/***/ 48644:
/*!**********************************!*\
  !*** ./src/js/views/form.f7.jsx ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewForm)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formButton_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formButton.f7.jsx */ 32864);
/* harmony import */ var _formCheckbox_f7_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formCheckbox.f7.jsx */ 91298);
/* harmony import */ var _formConnect_f7_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formConnect.f7.jsx */ 15210);
/* harmony import */ var _formDatepicker_f7_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formDatepicker.f7.jsx */ 11487);
/* harmony import */ var _formJSON_f7_jsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formJSON.f7.jsx */ 959);
/* harmony import */ var _formNumber_f7_jsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formNumber.f7.jsx */ 67670);
/* harmony import */ var _formSelectMultiple_f7_jsx__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formSelectMultiple.f7.jsx */ 72124);
/* harmony import */ var _formSelectSingle_f7_jsx__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./formSelectSingle.f7.jsx */ 68220);
/* harmony import */ var _formTextbox_f7_jsx__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./formTextbox.f7.jsx */ 14377);
/** @jsx $jsx */










class F7ViewForm {
  #AB;
  #settings;
  constructor(AB, settings) {
    this.#AB = AB;
    this.#settings = settings;
    this.record = null;
    this.isLoading = false;
    const definitions = this.datacollection.datasource.fields().map(f => ({
      id: f.id,
      key: f.formComponent().common().key,
      field: f.columnName,
      fieldType: f.key,
      label: f.label,
      // placeholder: f.placeholder,
      settings: f.settings
    })).concat({
      id: "saveButton",
      key: "button",
      field: null,
      fieldType: null,
      label: "Save"
      // placeholder: null,
    });

    this.views = definitions.map(definition => {
      if (definition.settings) definition.settings.required = 1;
      switch (definition.key) {
        case "button":
          return new _formButton_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"](AB, this, definition);
        case "checkbox":
          return new _formCheckbox_f7_jsx__WEBPACK_IMPORTED_MODULE_1__["default"](AB, this, definition);
        case "connect":
          return new _formConnect_f7_jsx__WEBPACK_IMPORTED_MODULE_2__["default"](AB, this, definition);
        case "datepicker":
          return new _formDatepicker_f7_jsx__WEBPACK_IMPORTED_MODULE_3__["default"](AB, this, definition);
        case "json":
          return new _formJSON_f7_jsx__WEBPACK_IMPORTED_MODULE_4__["default"](AB, this, definition);
        case "numberbox":
          return new _formNumber_f7_jsx__WEBPACK_IMPORTED_MODULE_5__["default"](AB, this, definition);
        case "selectmultiple":
          return new _formSelectMultiple_f7_jsx__WEBPACK_IMPORTED_MODULE_6__["default"](AB, this, definition);
        case "selectsingle":
          return new _formSelectSingle_f7_jsx__WEBPACK_IMPORTED_MODULE_7__["default"](AB, this, definition);
        default:
          return new _formTextbox_f7_jsx__WEBPACK_IMPORTED_MODULE_8__["default"](AB, this, definition);
      }
    });
  }
  get id() {
    return this.#settings.id;
  }
  get datacollection() {
    return this.#AB.datacollectionByID(this.#settings.dcID);
  }

  /**
   * @method getFormValues
   *
   * @param {webix form} formView
   * @param {ABObject} obj
   * @param {ABDatacollection} dc
   * @param {ABDatacollection} dcLink [optional]
   */
  /*   getFormValues(formView, obj, dc, dcLink) {
     // get the fields that are on this form
     const visibleFields = ["id"]; // we always want the id so we can udpate records
     formView.getValues(function (obj) {
        visibleFields.push(obj.config.name);
     });
      // only get data passed from form
     const allVals = formView.getValues();
     const formVals = {};
     visibleFields.forEach((val) => {
        formVals[val] = allVals[val];
     });
      // get custom values
     this.fieldComponents(
        (comp) =>
           comp instanceof ABViewFormCustom ||
           comp instanceof ABViewFormConnect ||
           comp instanceof ABViewFormDatepicker ||
           comp instanceof ABViewFormSelectMultiple ||
           (comp instanceof ABViewFormJson && comp.settings.type == "filter")
     ).forEach((f) => {
        const vComponent = this.viewComponents[f.id];
        if (vComponent == null) return;
         const field = f.field();
        if (field) {
           const getValue = vComponent.getValue ?? vComponent.logic.getValue;
           if (getValue)
              formVals[field.columnName] = getValue.call(vComponent, formVals);
        }
     });
      // remove connected fields if they were not on the form and they are present in the formVals because it is a datacollection
     obj.connectFields().forEach((f) => {
        if (
           visibleFields.indexOf(f.columnName) == -1 &&
           formVals[f.columnName]
        ) {
           delete formVals[f.columnName];
           delete formVals[f.relationName()];
        }
     });
      // clear undefined values or empty arrays
     for (const prop in formVals) {
        if (formVals[prop] == null || formVals[prop].length == 0)
           formVals[prop] = "";
     }
      // Add parent's data collection cursor when a connect field does not show
     let linkValues;
      if (dcLink) {
        linkValues = dcLink.getCursor();
     }
      if (linkValues) {
        const objectLink = dcLink.datasource;
         const connectFields = obj.connectFields();
        connectFields.forEach((f) => {
           const formFieldCom = this.fieldComponents(
              (fComp) => fComp?.field?.()?.id === f?.id
           );
            if (
              objectLink.id == f.settings.linkObject &&
              formFieldCom.length < 1 && // check field does not show
              formVals[f.columnName] === undefined
           ) {
              const linkColName = f.indexField
                 ? f.indexField.columnName
                 : objectLink.PK();
               formVals[f.columnName] = {};
              formVals[f.columnName][linkColName] =
                 linkValues[linkColName] ?? linkValues.id;
           }
        });
     }
      // NOTE: need to pull data of current cursor to calculate Calculate & Formula fields
     // .formVals variable does not include data that does not display in the Form widget
     const cursorFormVals = Object.assign(dc.getCursor() ?? {}, formVals);
      // Set value of calculate or formula fields to use in record rule
     obj.fields((f) => f.key == "calculate" || f.key == "formula").forEach(
        (f) => {
           if (formVals[f.columnName] == null) {
              let reCalculate = true;
               // WORKAROUND: If "Formula" field will have Filter conditions,
              // Then it is not able to re-calculate on client side
              // because relational data is not full data so FilterComplex will not have data to check
              if (f.key == "formula" && f.settings?.where?.rules?.length > 0) {
                 reCalculate = false;
              }
               formVals[f.columnName] = f.format(cursorFormVals, reCalculate);
           }
        }
     );
      return formVals;
  }
  */

  async init() {
    const AB = this.#AB;
    const record = this.record = this.datacollection.getCursor();
    if (record == null) return;

    //convert boolean for toggle UI
    const parsedRecord = {};
    this.views.forEach(view => {
      if (view.definition.fieldType == null || view instanceof _formButton_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"]) return;
      switch (view.definition.fieldType) {
        case "boolean":
          parsedRecord[view.definition.field] = record[view.definition.field] === 1 ? ["on"] : [];
          break;
        case "date":
          {
            const date = record[view.definition.field];
            if (date) {
              parsedRecord[view.definition.field] = `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
            }
          }
          break;
        case "datetime":
          {
            const datetime = new Date(record[view.definition.field]);
            const hours = datetime.getHours();
            const minutes = datetime.getMinutes();
            parsedRecord[view.definition.field] = `${datetime.getMonth() + 1}/${datetime.getDate()}/${datetime.getFullYear()}, ${hours <= 12 ? hours : hours % 12}:${minutes < 10 ? `0${minutes.toString()}` : minutes.toString()} ${hours < 12 ? "AM" : "PM"}`;
          }
          break;
        case "number":
          parsedRecord[view.definition.field] = record[view.definition.field].toString();
          break;
        default:
          parsedRecord[view.definition.field] = record[view.definition.field];
          break;
      }
    });

    //fill in form
    AB.$f7.form.fillFromData(`#${this.id}`, parsedRecord);

    // // listen for when we remove the preloader on the smart select then set the value to the select
    // // this is just a hack to get the value of the smart select set we may be able to take this out
    // if (AB.$f7.$(".smartSelectCountry .item-after .preloader").length) {
    //    AB.$(
    //       ".smartSelectCountry .item-after .preloader"
    //    )[0].addEventListener("DOMNodeRemoved", () => {
    //       AB.$f7
    //          .$(
    //             "select[name='Country'] option[value='" +
    //                this.#record.Country +
    //                "']"
    //          )
    //          .prop("selected", "selected");
    //    });
    // }
  }

  viewHTML() {
    const allResults = [];
    let fields = [];
    this.views.forEach(view => {
      if (view.definition.fieldType == null) {
        if (view instanceof _formButton_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"]) {
          const renderedFieldElements = [...fields];
          if (fields.length > 0) allResults.push(() => (0,framework7__WEBPACK_IMPORTED_MODULE_9__["default"])("ul", null, renderedFieldElements));
          allResults.push(view.html());
          fields = [];
        }
        return;
      }
      switch (view.definition.fieldType) {
        case "LongText":
          fields.push((0,framework7__WEBPACK_IMPORTED_MODULE_9__["default"])("li", {
            class: "align-top"
          }, view.html()()));
          break;
        default:
          fields.push((0,framework7__WEBPACK_IMPORTED_MODULE_9__["default"])("li", null, view.html()()));
          break;
      }
    });
    if (fields.length > 0) allResults.push(() => (0,framework7__WEBPACK_IMPORTED_MODULE_9__["default"])("ul", null, fields.map(r => r())));
    return allResults.map(r => r()); // render each jsx template
  }

  html() {
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_9__["default"])("form", {
      class: "list list-inset list-strong-ios list-dividers-ios list-outline-ios",
      id: this.id
    }, this.viewHTML());
  }
}

/***/ }),

/***/ 32864:
/*!****************************************!*\
  !*** ./src/js/views/formButton.f7.jsx ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormButton)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormButton extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  async #save() {
    const AB = this.#AB;
    const form = this.#form;
    const definition = this.definition;
    AB.$(`#${definition.id}`).addClass("button-loading");
    const formData = AB.$f7.form.convertToData(`#${form.id}`);
    const parsedFormData = {};
    form.views.forEach(view => {
      const field = view.definition.field;
      parsedFormData[field] = view.parseFormData(formData[field]);
    });
    if (!AB.$f7.input.validateInputs(`#${form.id}`)) {
      AB.$(`#${definition.id}`).removeClass("button-loading");
      return;
    }
    const dc = form.datacollection;
    try {
      if (form.record == null) await dc.model.create(parsedFormData);else await dc.model.update(form.record[dc.datasource.PK()], parsedFormData);
      if (definition.afterSubmitView == null) {
        AB.$f7.views.current.router.back();
        return;
      }
      const afterSubmitView = this.application.pageByID(definition.afterSubmitView.id);
      afterSubmitView.openView(definition.afterSubmitView.props);
    } catch (e) {
      console.error(e);

      // TODO: popup here:
      const L = AB.Label();
      let text = L("Save Failed");

      // @TODO: instead of stuffing errors into popup message, find the input controls
      // and set them to invalid markers, and add the message to them if possible.

      if (e.errors) {
        try {
          if ("string" == typeof e.errors) e.errors = JSON.parse(e.errors);
        } catch (e) {
          // ignore
        }
        (e.errors || []).forEach(valError => {
          text = `${text}<br>${valError.name}: ${valError.message}`;
        });
      }
      AB.$f7.toast.create({
        icon: '<i class="material-icons">error</i>',
        text,
        position: "center",
        closeTimeout: 2000
      }).open();
    }
    AB.$(`#${definition.id}`).removeClass("button-loading");
  }
  html() {
    const definition = this.definition;
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "block"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("a", {
      onClick: () => this.#save(),
      id: definition.id,
      class: "button button-large button-fill button-preloader",
      href: "#"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "preloader"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("span", null, definition.label)));
  }
}

/***/ }),

/***/ 91298:
/*!******************************************!*\
  !*** ./src/js/views/formCheckbox.f7.jsx ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormCheckbox)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormCheckbox extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  parseFormData(value) {
    return super.parseFormData(value).length === 0 ? 0 : 1;
  }
  html() {
    const definition = this.definition;
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title"
    }, definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-after"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("label", {
      class: "toggle toggle-init"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      name: definition.field,
      type: "checkbox"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("i", {
      class: "toggle-icon"
    })))));
  }
}

/***/ }),

/***/ 15210:
/*!*****************************************!*\
  !*** ./src/js/views/formConnect.f7.jsx ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormConnect)
/* harmony export */ });
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/* harmony import */ var _formSelectMultiple_f7_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formSelectMultiple.f7.jsx */ 72124);
/* harmony import */ var _formSelectSingle_f7_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formSelectSingle.f7.jsx */ 68220);
/** @jsx $jsx */




class F7ViewFormConnect extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  parseFormData(value) {
    if (this.definition.settings.linkType === "many") return this.#AB.$(`#${this.#form.id}`).find(`select[name="${this.definition.field}"]`).val();
    return super.parseFormData(value);
  }
  html() {
    const definition = this.definition;
    const definitionCopy = Object.assign({}, definition, {
      settings: Object.assign({
        options: [] // conected object's records,
      }, definition.settings)
    });
    const formComponent = definition.settings.linkType !== "one" ? new _formSelectSingle_f7_jsx__WEBPACK_IMPORTED_MODULE_2__["default"](this.#AB, this.#form, definitionCopy) : new _formSelectMultiple_f7_jsx__WEBPACK_IMPORTED_MODULE_1__["default"](this.#AB, this.#form, definitionCopy);
    return formComponent.html();
  }
}

/***/ }),

/***/ 11487:
/*!********************************************!*\
  !*** ./src/js/views/formDatepicker.f7.jsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormDatepicker)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormDatepicker extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  parseFormData(value) {
    if (this.definition.fieldType === "datetime") return new Date(value).toISOString();
    return super.parseFormData(value);
  }
  viewHTML() {
    const definition = this.definition;
    switch (definition.fieldType) {
      case "datetime":
        return definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "text",
          name: definition.field,
          class: "form-datepicker-datetime",
          placeholder: definition.placeholder,
          readonly: "readonly",
          required: true,
          validate: true
        }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "text",
          name: definition.field,
          class: "form-datepicker-datetime",
          placeholder: definition.placeholder,
          readonly: "readonly"
        });
      default:
        return definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "text",
          name: definition.field,
          class: "form-datepicker-date",
          placeholder: definition.placeholder,
          readonly: "readonly",
          required: true,
          validate: true
        }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "text",
          name: definition.field,
          class: "form-datepicker-date",
          placeholder: definition.placeholder,
          readonly: "readonly"
        });
    }
  }
  html() {
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title item-label"
    }, this.definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-input-wrap"
    }, this.viewHTML())));
  }
}

/***/ }),

/***/ 66382:
/*!**************************************!*\
  !*** ./src/js/views/formItem.f7.jsx ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormItem)
/* harmony export */ });
/** @jsx $jsx */

class F7ViewFormItem {
  #definition;
  constructor(definition) {
    // definition.*
    // .id {uuid} the ID of our ABViewForm*.
    // .key {string} the key of ABViewForm*.
    // .field {string} the input.name of the form element that contains this value.
    // .fieldType {string} The keys of ABField*. So, some field types reuse the same form component views. We can classify this.
    // .placeholder {string} the default display if no value is set.
    // .label {string} the label for this component.
    // .settings {object} the same default settings of ABFied*Core in ABDesigner.
    this.#definition = definition;
  }
  get definition() {
    return this.#definition;
  }
  parseFormData(value) {
    return value;
  }
  html() {
    return () => {};
  }
}

/***/ }),

/***/ 959:
/*!**************************************!*\
  !*** ./src/js/views/formJSON.f7.jsx ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormJSON)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormJSON extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  parseFormData(value) {
    const AB = this.#AB;
    const $inputElements = AB.$(`#${this.#form.id}`).find(`textarea[name="${this.definition.field}"]`);
    try {
      $inputElements[0].setCustomValidity("");
      JSON.parse(value);
    } catch (err) {
      $inputElements[0].setCustomValidity(AB.Label()("Invalid JSON!"));
      $inputElements[0].checkValidity();
    }
    return super.parseFormData(value);
  }
  html() {
    const definition = this.definition;
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title item-label"
    }, definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-input-wrap"
    }, definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("textarea", {
      name: definition.field,
      placeholder: definition.placeholder,
      class: "resizable",
      required: true,
      validate: true
    }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("textarea", {
      name: definition.field,
      placeholder: definition.placeholder,
      class: "resizable"
    }))));
  }
}

/***/ }),

/***/ 67670:
/*!****************************************!*\
  !*** ./src/js/views/formNumber.f7.jsx ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormNumber)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormNumber extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  parseFormData(value) {
    return parseInt(super.parseFormData(value));
  }
  html() {
    const definition = this.definition;
    const errorMessage = this.#AB.Label()("Only numbers please!");
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title item-label"
    }, definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-input-wrap"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "range-slider range-slider-init",
      "data-label": "true"
    }, definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      name: definition.field,
      type: "range",
      value: "50",
      min: "0",
      max: "100",
      step: "1",
      required: true,
      validate: true,
      pattern: "[0-9]*",
      "data-error-message": errorMessage
    }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      name: definition.field,
      type: "range",
      value: "50",
      min: "0",
      max: "100",
      step: "1",
      pattern: "[0-9]*",
      "data-error-message": errorMessage
    })))));
  }
}

/***/ }),

/***/ 72124:
/*!************************************************!*\
  !*** ./src/js/views/formSelectMultiple.f7.jsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormSelectMultiple)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormSelectMultiple extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  parseFormData(value) {
    return this.#AB.$(`#${this.#form.id}`).find(`select[name="${this.definition.field}"]`).val();
  }
  html() {
    const definition = this.definition;
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("a", {
      href: "#",
      class: "item-link smart-select smart-select-init"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("select", {
      name: definition.name,
      placeholder: definition.placeholder,
      multiple: true
    }, definition.settings.options.map(item => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("option", {
      value: item.id
    }, item.text))), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title"
    }, definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-after"
    }))));
  }
}

/***/ }),

/***/ 68220:
/*!**********************************************!*\
  !*** ./src/js/views/formSelectSingle.f7.jsx ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormSelectSingle)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormSelectSingle extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    const definition = this.definition;
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title item-label"
    }, definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-input-wrap"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("select", {
      name: definition.field
    }, definition.settings.options.map(item => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("option", {
      value: item.id
    }, item.text))))));
  }
}

/***/ }),

/***/ 14377:
/*!*****************************************!*\
  !*** ./src/js/views/formTextbox.f7.jsx ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormTextbox)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormTextbox extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    const definition = this.definition;
    let $inputElement = "";
    switch (definition.fieldType) {
      case "LongText":
        $inputElement = definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("textarea", {
          name: definition.field,
          placeholder: definition.placeholder,
          class: "resizable",
          required: true,
          validate: true
        }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("textarea", {
          name: definition.field,
          placeholder: definition.placeholder,
          class: "resizable"
        });
        break;
      case "email":
        $inputElement = definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "email",
          name: definition.field,
          placeholder: definition.placeholder,
          required: true,
          validate: true
        }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "email",
          name: definition.field,
          placeholder: definition.placeholder,
          required: true,
          validate: true
        });
        break;
      default:
        $inputElement = definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          name: definition.field,
          type: "text",
          placeholder: definition.placeholder,
          required: true,
          validate: true
        }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          name: definition.field,
          type: "text",
          placeholder: definition.placeholder
        });
        break;
    }
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title item-label"
    }, definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-input-wrap"
    }, $inputElement)));
  }
}

/***/ }),

/***/ 83186:
/*!**********************************!*\
  !*** ./src/js/views/list.f7.jsx ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewList)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7 */ 73449);
/** @jsx $jsx */

class F7ViewList {
  #AB;
  #settings;
  constructor(AB, settings) {
    this.#AB = AB;
    this.#settings = settings;
    this.application = AB.applications()[0];
  }
  get id() {
    return this.#settings.id;
  }
  get datacollection() {
    return this.#AB.datacollectionByID(this.#settings.dcID);
  }
  async init() {}
  itemSelected(item) {
    // if there is a detailPage set, then transition there:
    if (this.#settings.detailPage) {
      // const DetailPage = this.application.pageByID(
      //    this.#settings.detailPage
      // );

      this.#AB.$f7.view.main.router.navigate("/form", {
        data: item,
        isEditMode: true
      });
    }

    // Make sure our DC registers which item was just selected.
    const dc = this.datacollection;
    if (dc) {
      dc.setCursor(item[dc.datasource.PK()] || item.id || item.uuid);
    }
  }

  // NOTE: this now means OPEN THIS VIEW.
  openView(props) {
    this.#AB.$f7.view.main.router.navigate(this.settings.route, {
      props,
      ignoreCache: true
    });
  }
  loadMore() {
    // if (this.$store.getters[this.#settings.dcID].value.hasMore) {
    if (this.datacollection.hasMore()) {
      this.#AB.$store.dispatch("getAppBuilderData", this.#settings.dcID);
    }
  }
  hasMore() {
    if (this.datacollection.hasMore()) {
      return (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
        class: "preloader infinite-scroll-preloader"
      });
    }
  }
  viewHTML() {
    const L = this.#AB.Label();
    return this.#AB.$store.getters[this.#settings.dcID].value.map(item => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", {
      id: item.uuid,
      class: "swipeout deleted-callback"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "swipeout-content item-content",
      onClick: () => this.itemSelected(item)
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title"
    }, item.Name))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "swipeout-actions-right"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      href: "#",
      class: "swipeout-delete",
      "data-confirm": L("Are you sure want to delete this item?"),
      "data-confirm-title": L("Delete?")
    }, "Delete"))));
  }
  html() {
    if (this.#AB.$store.getters[this.#settings.dcID].value.length === 0) return () => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page-content infinite-scroll-content"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "list links-list list-outline list-strong list-dividers skeleton-text skeleton-effect-fade"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("ul", null, [...Array(20)].map((x, i) => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      href: "#"
    }, "Skeleton text will go here"))))));
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page-content infinite-scroll-content",
      onInfinite: () => this.loadMore()
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "list links-list list-outline list-strong list-dividers"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("ul", null, this.viewHTML())), this.hasMore());
  }
}

/***/ }),

/***/ 22167:
/*!******************************!*\
  !*** ./src/pages/404.f7.jsx ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7 */ 73449);
/** @jsx $jsx */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB => {
  const L = AB.Label();
  return () => {
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar-bg"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar-inner sliding"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "left"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      href: "#",
      class: "link back"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
      class: "icon icon-back"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "if-not-md"
    }, L("Back")))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "title"
    }, L("Not found")))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page-content"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block block-strong inset"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("center", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("h1", null, L("Sorry")), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("p", null, L("Requested content not found."))))));
  };
});

/***/ }),

/***/ 18388:
/*!******************************!*\
  !*** ./src/pages/app.f7.jsx ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7 */ 73449);
/** @jsx $jsx */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB => {
  const Application = AB.applications()[0]; // AB.applicationByID("4b7a489a-5fe5-4044-8565-aaa3654300f2");
  const L = AB.Label();
  return (props, {
    $,
    $h,
    $f7,
    $on,
    $store,
    $update
  }) => {
    // Login screen demo data
    // let path = document?.location?.pathname ? document.location.pathname : "/";
    let defaultPath = "/";
    let username = "";
    let password = "";
    let versionNumber = Application?.version;
    let showingUpdate = false;
    let apiUrl = document?.location?.origin ?? "http://localhost:8080";
    // process.env.NODE_ENV === "production"
    //    ? "https://design.digiserve.org"
    //    : "http://localhost:8010/proxy";

    // check for a specified Route:
    let params = new URL(document.location).searchParams;
    let route = params.get("route");
    if (route) {
      defaultPath = `/${route}`;
    }
    $store.dispatch("getVersion");
    $on("pageInit", () => {
      // checkForUpdate();
    });
    document.addEventListener("visibilitychange", e => {
      if (document.visibilityState == "visible") {
        checkForUpdate();
      }
    });
    const updatePassword = e => {
      password = $("#" + e).value();
      $update();
    };
    const close = e => {
      $f7.loginScreen.close("#my-login-screen");
    };
    const logout = () => {
      $f7.loginScreen.open("#my-login-screen");
      // $f7.preloader.show();
      // password = "";
      // $update();
      // fetchJson(Api.urls.logout, { method: 'GET' })
      //   .then(data => {
      //     store.dispatch('addCsrfToken', "");
      //     $f7.loginScreen.open("#my-login-screen");
      //     $f7.preloader.hide();
      //   })
      //   .catch(err => {
      //     console.error("logout failed but pretending it didn't");
      //     store.dispatch('addCsrfToken', "");
      //     $f7.loginScreen.open("#my-login-screen");
      //     $f7.preloader.hide();
      //   });
    };

    const authenticate = async () => {
      $(".button-preloader").addClass("button-loading");
      let tempUser = $("#username").value();
      try {
        var data = await AB.Network.post({
          url: apiUrl + "/auth/login",
          params: {
            email: tempUser,
            password: $("#password").value()
          }
        });
        $store.dispatch("setUser", data.user);
        // $store.dispatch("setUsername", $("#username").value());

        // Now attempt to ensure our cookie is set:
        // var result = await AB.Network.get({
        //    url: `${apiUrl}/__getCookie`,
        // });

        $("#password")[0].value = "";
        $f7.loginScreen.close();
        $(".button-preloader").removeClass("button-loading");
        AB.isInitialized = true;
        await checkForUpdate();

        // NOTE: replace this with:
        // const Page = Application.pageByID(LastViewedPageID);
        // Page.openView();
        $f7.view.main.router.navigate("/list", {
          transition: "f7-fade"
        });
      } catch (err) {
        $f7.toast.create({
          icon: '<i class="material-icons">error</i>',
          text: L("Login Failed"),
          position: "center",
          closeTimeout: 2000
        }).open();
        $(".button-preloader").removeClass("button-loading");
      }
    };
    const showPasswordPreview = e => {
      $("#passwordPreviewHolder").show();
      $("#passwordHolder").hide();
      $("#passwordPreview").focus();
    };
    const showPassword = e => {
      $("#passwordHolder").show();
      $("#passwordPreviewHolder").hide();
      $("#password").focus();
    };
    async function checkForUpdate() {
      if (!showingUpdate) {
        let getVersionPath = `${apiUrl}${Application?.urlCurrentVersion}`;
        const response = await AB.Network.get({
          url: getVersionPath
        });
        const version = response?.version ?? "0.0.0";
        const currVersion = Application?.version;
        console.log("getVersionPath: ", version);
        console.log("getCurrVersion: ", currVersion);
        if (currVersion.trim() != version.trim()) {
          showingUpdate = true;
          if ("serviceWorker" in navigator) {
            $f7.dialog.create({
              title: L(`Update Available`),
              content: L(`There is an app update avaiable, tap "Update" to get the latest version.`),
              buttons: [{
                text: L("Cancel"),
                onClick: function (dialog, e) {
                  showingUpdate = false;
                }
              }, {
                text: L(`Update to version {0}`, [version]),
                bold: true,
                cssClass: "bg-color-primary text-color-white",
                onClick: function (dialog, e) {
                  $f7.progressbar.show();
                  navigator.serviceWorker.getRegistrations().then(function (registrations) {
                    let complete = registrations.length;
                    let index = 0;
                    for (let registration of registrations) {
                      registration.unregister().then(boolean => {
                        index++;
                        if (index == complete) {
                          showingUpdate = false;
                          window.location.reload(true);
                        }
                      });
                    }
                    if (complete == 0) {
                      showingUpdate = false;
                      window.location.reload(true);
                    }
                  });
                }
              }],
              verticalButtons: true
            }).open();
          }
        } else {
          // alert("up to date");
        }
      }
    }
    let pagesMenu = Application?.pages(p => p.menuType == "menu") ?? [];
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      id: "app"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "panel panel-left panel-cover dark panel-init"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "view"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page bg-color-primary"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar-bg"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "title"
    }, Application?.label ?? L("PWA")))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page-content"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block text-align-center no-margin-bottom"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("img", {
      src: "assets/mobile/images/digiServe_logo.png",
      width: "70%",
      class: "sidebar_logo"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("p", null)), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "list list-outline list-strong list-dividers list-translucent"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("ul", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      href: "/list",
      class: "item-link item-content panel-close"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-media"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
      class: "material-icons"
    }, L("contacts"))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title"
    }, L("List of People"))))), pagesMenu.map(p => {
      return (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
        href: `/${p.route}`,
        class: "item-link item-content panel-close"
      }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
        class: "item-media"
      }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
        class: "material-icons"
      }, p.label)), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
        class: "item-inner"
      }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
        class: "item-title"
      }, p.label))));
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      href: "#",
      class: "item-link item-content",
      onClick: () => logout()
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-media"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
      class: "material-icons"
    }, L("logout"))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title"
    }, L("Log out"))))))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block text-align-center",
      style: "position: absolute; width: 100%; margin-bottom: 15px; bottom: 0px;"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("p", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("img", {
      src: "assets/mobile/images/digiServe_logo.png",
      width: "30%"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("br", null), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "version"
    }, "v", versionNumber))))))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "view view-main view-init safe-areas",
      "data-url": defaultPath
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "login-screen",
      id: "my-login-screen"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "view"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page bg-color-primary dark"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page-content login-screen-content bg-color-primary"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block text-align-center no-margin-bottom"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("img", {
      src: "assets/mobile/images/digiServe_logo.png",
      width: "60%",
      class: "sidebar_logo"
    })), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("form", {
      action: "javascript: null;",
      onSubmit: () => authenticate()
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "list"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("ul", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", {
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title item-label"
    }, L("E-mail")), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-input-wrap"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
      autocorrect: "off",
      autocomplete: "username",
      spellcheck: "false",
      type: "text",
      id: "username",
      name: "username",
      placeholder: L("Your e-mail address")
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "input-clear-button"
    })))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", {
      id: "passwordHolder",
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title item-label"
    }, L("Password")), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-input-wrap"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      onClick: () => showPasswordPreview(),
      style: "color: var(--f7-input-clear-button-color); position: absolute; right: 0; padding: 10px; margin-right: -15px; margin-top: -5px;",
      href: "#"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
      class: "material-icons"
    }, "visibility_off")), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
      type: "password",
      id: "password",
      name: "password",
      placeholder: L("Your password"),
      value: password,
      onInput: () => updatePassword("password"),
      autocomplete: "current-password",
      autocorrect: "off",
      spellcheck: "false"
    })))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", {
      id: "passwordPreviewHolder",
      style: "display: none;",
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title item-label"
    }, L("Password")), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-input-wrap"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      onClick: () => showPassword(),
      style: "color: var(--f7-input-clear-button-color); position: absolute; right: 0; padding: 10px; margin-right: -15px; margin-top: -5px;",
      href: "#"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
      class: "material-icons"
    }, "visibility")), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
      type: "text",
      id: "passwordPreview",
      name: "passwordPreview",
      placeholder: L("Your password"),
      value: password,
      onInput: () => updatePassword("passwordPreview"),
      autocomplete: "current-password",
      autocorrect: "off",
      spellcheck: "false"
    })))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", {
      class: "item-content item-input"
    }))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("button", {
      class: "button color-primary button-outline button-round bg-color-white button-large login-button button-preloader"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "preloader"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "if-ios"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    })), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "if-md"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("svg", {
      viewBox: "0 0 36 36"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("circle", {
      cx: "18",
      cy: "18",
      r: "16"
    }))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "if-aurora"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-circle"
    })))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", null, L("Sign In"))))))))));
  };
});

/***/ }),

/***/ 84723:
/*!*******************************!*\
  !*** ./src/pages/form.f7.jsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _js_views_form_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../js/views/form.f7.jsx */ 48644);
/** @jsx $jsx */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB => {
  const L = AB.Label();
  return (props, {
    $,
    $h,
    $f7,
    $on,
    $store,
    $update
  }) => {
    const title = props.isEditMode ? L("Edit Person") : L("Add Person");

    // // NOTE: Programming Quirk:
    // // We seem to need to access our getters for this Page from
    // // within this PageComponent definition.  (maybe) this is how
    // // it registers the components that need to be redrawn when the
    // // related state is updated.
    // let pageID = "ABPage.id";
    // let Page = AB.pageByID(pageID);
    // let allViews = Page.views();
    // allViews.forEach((v) => {
    //    let dc = v.datacollection;
    //    if (dc) {
    //       allGetters[dc.id] = $store.getters[dc.id];
    //    }
    // })

    const dcGetter = $store.getters["0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"];
    const views = [{
      id: "my-form",
      key: "form",
      dcID: "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"
    }];

    // for each view on this Page, do:
    const allViews = [];

    // let views = Page.views();
    // views.forEach((v) => {
    // allViews.push(v.html(...));
    // })
    views.forEach(view => {
      switch (view.key) {
        case "form":
          {
            let form = new _js_views_form_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"](AB, view);
            /* new Form(
               view.dcID,
               allDCs,
               $,
               $f7,
               $store,
               person
            ); */
            allViews.push(form);
            break;
          }
        default:
        // code block
      }
    });

    let formDatepickerDate = null;
    let formDatepickerDatetime = null;
    $on("pageInit", async (e, page) => {
      const pendingInit = [];
      allViews.forEach(view => {
        const dc = view.datacollection;
        dc?.init();
        const viewInit = async (view, callback) => {
          await view.init();
          callback();
        };
        const init = () => new Promise(resolve => {
          if (dc && !dc.isDataInitialized) {
            $store.dispatch("getAppBuilderData", dc.id);
            const waitDCInit = setInterval(async () => {
              if (dc.isDataInitialized) {
                clearInterval(waitDCInit);
                await viewInit(view, resolve);
              }
            }, 1000);
            return;
          }
          viewInit(view, resolve);
        });
        pendingInit.push(init());
      });
      await Promise.all(pendingInit);
      formDatepickerDate = $f7.calendar.create({
        inputEl: ".form-datepicker-date"
      });
      formDatepickerDatetime = $f7.calendar.create({
        inputEl: ".form-datepicker-datetime",
        timePicker: true,
        dateFormat: {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric"
        }
      });
    });
    $on("pageBeforeRemove", () => {
      formDatepickerDate.destroy();
      formDatepickerDatetime.destroy();
    });
    function viewHTML() {
      const allHTML = [];
      allViews.forEach(view => {
        allHTML.push(view.html());
      });
      return allHTML.map(r => r()); // render each jsx template
    }

    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "page",
      "data-name": "form"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar-bg"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar-inner sliding"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "left"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("a", {
      href: "#",
      class: "link back"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("i", {
      class: "icon icon-back"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "if-not-md"
    }, L("Back")))), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "title"
    }, title))), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "page-content"
    }, viewHTML()));
  };
});

/***/ }),

/***/ 59289:
/*!*******************************!*\
  !*** ./src/pages/home.f7.jsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7 */ 73449);
/** @jsx $jsx */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB => {
  const init = async () => {
    if (!AB.isInitialized) {
      try {
        // const user = await AB.Network.get({ url: "/mobile/whoami" });
        // perform Inbox Lookup now?

        AB.isInitialized = true;

        // now we route to our Default Page:
        const Application = AB.applications()[0];
        let DefaultPage = Application.pageByID(Application.pageDefault, true);
        if (!DefaultPage) {
          DefaultPage = Application.pages()[0]; // just pick 1st one:
        }

        DefaultPage.show();
      } catch (e) {
        // NOTE: this will catch errors OTHER than the "Reauth" notification
        // errors.  Those will be caught by listening to the AB.Network object
        AB.$f7.loginScreen.open("#my-login-screen");
      }
    } else {
      console.warn("Why is page(/).onPageInit() still getting called?");
    }
  };
  return (props, {
    $,
    $h,
    $f7,
    $on,
    $store,
    $update
  }) => {
    AB.$ = $;
    AB.$f7 = $f7;
    AB.$store = $store;
    $on("pageInit", async (e, page) => {
      // var panel = $f7.panel.get(".panel-left");
      // panel.open();
      await init();
    });
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block no-margin text-align-center vertical-container"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "preloader vertical-center"
    })));
  };
});

/***/ }),

/***/ 42767:
/*!*******************************!*\
  !*** ./src/pages/list.f7.jsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _js_views_list_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../js/views/list.f7.jsx */ 83186);
/** @jsx $jsx */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB => {
  const L = AB.Label();
  return (props, {
    $,
    $h,
    $f7,
    $on,
    $store,
    $update
  }) => {
    const title = L("List of People");
    let allGetters = {};

    // // NOTE: Programming Quirk:
    // // We seem to need to access our getters for this Page from
    // // within this PageComponent definition.  (maybe) this is how
    // // it registers the components that need to be redrawn when the
    // // related state is updated.
    // let pageID = "ABPage.id";
    // let Page = AB.pageByID(pageID);
    // let allViews = Page.views();
    // allViews.forEach((v) => {
    //    let dc = v.datacollection;
    //    if (dc) {
    //       allGetters[dc.id] = $store.getters[dc.id];
    //    }
    // })
    const dcGetter = $store.getters["0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"];
    const allViews = [];
    $on("pageInit", async (e, page) => {
      const pendingInit = [];
      allViews.forEach(view => {
        const dc = view.datacollection;
        dc?.init();
        const viewInit = async (view, callback) => {
          await view.init();
          callback();
        };
        const init = () => new Promise(resolve => {
          if (dc && !dc.isDataInitialized) {
            $store.dispatch("getAppBuilderData", dc.id);
            const waitDCInit = setInterval(async () => {
              if (dc.isDataInitialized) {
                clearInterval(waitDCInit);
                await viewInit(view, resolve);
              }
            }, 1000);
            return;
          }
          viewInit(view, resolve);
        });
        pendingInit.push(init());
      });
      await Promise.all(pendingInit);
      $(".deleted-callback").on("swipeout:deleted", async function (value) {
        await delItem(this.getAttribute("id"));
      });
    });
    let views = [{
      id: "my-list",
      key: "list",
      dcID: "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322",
      detailPage: "ABPage.id"
    }];
    function viewHTML() {
      const allResults = [];

      // allViews.forEach((v) => {
      //    allResults.push(v.html(...));
      // })

      views.forEach(view => {
        switch (view.key) {
          case "list":
            var list = new _js_views_list_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"](AB, view);
            allResults.push(list.html());
            allViews.push(list);
            break;
          default:
          // code block
        }
      });

      return allResults.map(r => r()); // render each jsx template
    }

    async function delItem(id) {
      let dc = allViews[0].datacollection;
      let item = id ? dc.$dc.getItem(id) : dc.getCursor();
      if (!item) {
        item = dc.getFirstRecord();
      }
      console.log("record to delete:", item);
      try {
        await dc.datasource.model().delete(item[dc.datasource.PK()] || item.id || item.uuid);
      } catch (e) {
        console.error(e);
      }
    }

    //
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "page"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar-bg"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "left"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("a", {
      href: "#",
      "data-panel": ".panel-left",
      class: "link icon-only panel-open"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("i", {
      class: "icon material-icons"
    }, "menu"))), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "title"
    }, title), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "title-large"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "title-large-text"
    }, title)), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "right"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("a", {
      class: "link icon-only",
      href: "#",
      onclick: () => {
        AB.$f7.view.main.router.navigate("/form", {
          props: {
            isEditMode: false
          },
          ignoreCache: true
        });
      }
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("i", {
      class: "icon f7-icons if-not-md"
    }, "plus"), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("i", {
      class: "icon material-icons md-only"
    }, "add"))))), viewHTML());
  };
});

/***/ }),

/***/ 40453:
/*!*******************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/css/app.less ***!
  \*******************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ 94015);
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ 23645);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Your app custom styles here */\n/* login */\n.md .item-input-focused .item-label,\n.md .item-input-focused .item-floating-label {\n  color: inherit;\n}\n.version {\n  font-family: roboto mono, source code pro, Menlo, Monaco, Consolas,\n\t\tcourier new, monospace;\n  font-size: 10px;\n}\n.list-translucent {\n  background-color: rgba(var(--f7-navbar-bg-color-rgb, var(--f7-bars-bg-color-rgb)), var(--f7-bars-translucent-opacity)) !important;\n  -webkit-backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur)) !important;\n  backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur)) !important;\n}\n.list-translucent ul {\n  background-color: transparent !important;\n}\n/* Change Autocomplete styles in Chrome*/\ninput:autofill,\ninput:-webkit-autofill-strong-password,\ninput:-webkit-autofill-strong-password-viewable,\ninput:-webkit-autofill-and-obscured,\ninput:-webkit-autofill,\ninput:-webkit-autofill:hover,\ninput:-webkit-autofill:focus,\ntextarea:-webkit-autofill,\ntextarea:-webkit-autofill:hover,\ntextarea:-webkit-autofill:focus,\nselect:-webkit-autofill,\nselect:-webkit-autofill:hover,\nselect:-webkit-autofill:focus {\n  border: 0;\n  -webkit-text-fill-color: #f0582b;\n  -webkit-box-shadow: 0 0 0px 1000px #366889 inset;\n  -webkit-transition: background-color 5000s ease-in-out 0s;\n  transition: background-color 5000s ease-in-out 0s;\n}\n.vertical-container {\n  position: relative;\n  height: 100vh;\n}\n.vertical-center {\n  margin: 0;\n  position: absolute;\n  top: 50%;\n  -ms-transform: translateY(-50%);\n  transform: translateY(-50%);\n}\n/*ABMobileViewFormFile File Upload*/\n.fileUpload {\n  position: relative;\n  overflow: hidden;\n}\n.fileUpload input.upload {\n  position: absolute;\n  top: 0;\n  right: 0;\n  margin: 0;\n  padding: 0;\n  font-size: 20px;\n  cursor: pointer;\n  opacity: 0;\n  filter: alpha(opacity=0);\n}\n.ico_upload {\n  padding-left: 8px;\n  font-size: 25px;\n}\n", "",{"version":3,"sources":["webpack://./src/css/app.less"],"names":[],"mappings":"AAAA,gCAAgC;AAChC,UAAU;AACV;;EAEC,cAAA;AACD;AACA;EACC;wBAAA;EAEA,eAAA;AACD;AACA;EACC,iIAAA;EAIA,wFAAA;EAEA,gFAAA;AAHD;AAKA;EACC,wCAAA;AAHD;AACA,wCAAwC;AAKxC;;;;;;;;;;;;;EAaC,SAAA;EACA,gCAAA;EACA,gDAAA;EACA,yDAAA;EACA,iDAAA;AAHD;AAKA;EACC,kBAAA;EACA,aAAA;AAHD;AAKA;EACC,SAAA;EACA,kBAAA;EACA,QAAA;EACA,+BAAA;EACA,2BAAA;AAHD;AACA,mCAAmC;AAOnC;EAEI,kBAAA;EACA,gBAAA;AANJ;AASA;EAEI,kBAAA;EACA,MAAA;EACA,QAAA;EACA,SAAA;EACA,UAAA;EACA,eAAA;EACA,eAAA;EACA,UAAA;EACA,wBAAA;AARJ;AAWA;EAEE,iBAAA;EAAmB,eAAA;AATrB","sourcesContent":["/* Your app custom styles here */\n/* login */\n.md .item-input-focused .item-label,\n.md .item-input-focused .item-floating-label {\n\tcolor: inherit;\n}\n.version {\n\tfont-family: roboto mono, source code pro, Menlo, Monaco, Consolas,\n\t\tcourier new, monospace;\n\tfont-size: 10px;\n}\n.list-translucent {\n\tbackground-color: rgba(\n\t\tvar(--f7-navbar-bg-color-rgb, var(--f7-bars-bg-color-rgb)),\n\t\tvar(--f7-bars-translucent-opacity)\n\t) !important;\n\t-webkit-backdrop-filter: saturate(180%)\n\t\tblur(var(--f7-bars-translucent-blur)) !important;\n\tbackdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur)) !important;\n}\n.list-translucent ul {\n\tbackground-color: transparent !important;\n}\n/* Change Autocomplete styles in Chrome*/\ninput:autofill,\ninput:-webkit-autofill-strong-password,\ninput:-webkit-autofill-strong-password-viewable,\ninput:-webkit-autofill-and-obscured,\ninput:-webkit-autofill,\ninput:-webkit-autofill:hover,\ninput:-webkit-autofill:focus,\ntextarea:-webkit-autofill,\ntextarea:-webkit-autofill:hover,\ntextarea:-webkit-autofill:focus,\nselect:-webkit-autofill,\nselect:-webkit-autofill:hover,\nselect:-webkit-autofill:focus {\n\tborder: 0;\n\t-webkit-text-fill-color: #f0582b;\n\t-webkit-box-shadow: 0 0 0px 1000px #366889 inset;\n\t-webkit-transition: background-color 5000s ease-in-out 0s;\n\ttransition: background-color 5000s ease-in-out 0s;\n}\n.vertical-container {\n\tposition: relative;\n\theight: 100vh;\n}\n.vertical-center {\n\tmargin: 0;\n\tposition: absolute;\n\ttop: 50%;\n\t-ms-transform: translateY(-50%);\n\ttransform: translateY(-50%);\n}\n\n\n /*ABMobileViewFormFile File Upload*/\n.fileUpload \n{\n    position: relative;\n    overflow: hidden;           \n}\n\n.fileUpload input.upload \n{\n    position: absolute;\n    top: 0;\n    right: 0;\n    margin: 0;\n    padding: 0;\n    font-size: 20px;\n    cursor: pointer;\n    opacity: 0;\n    filter: alpha(opacity=0);\n}\n\n.ico_upload\n{\n  padding-left: 8px; font-size:25px\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 22373:
/*!***************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js?url=false!./src/css/icons.css ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ 94015);
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ 23645);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Material Icons Font (for MD theme) */\n@font-face {\n  font-family: 'Material Icons';\n  font-style: normal;\n  font-weight: 400;\n  src: local('Material Icons'), local('MaterialIcons-Regular'),\n    url(/assets/mobile/fonts/material-icons.woff2) format('woff2'),\n    url(/assets/mobile/fonts/material-icons.woff) format('woff');\n}\n.material-icons {\n  font-family: 'Material Icons';\n  font-weight: normal;\n  font-style: normal;\n  font-size: 24px;\n  display: inline-block;\n  line-height: 1;\n  text-transform: none;\n  letter-spacing: normal;\n  word-wrap: normal;\n  white-space: nowrap;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: 'liga';\n}\n\n/* Framework7 Icons Font (for iOS theme) */\n@font-face {\n  font-family: 'Framework7 Icons';\n  font-style: normal;\n  font-weight: 400;\n  src: url('/assets/mobile/fonts/Framework7Icons-Regular.woff2') format('woff2'),\n    url('/assets/mobile/fonts/Framework7Icons-Regular.woff') format('woff');\n}\n.f7-icons {\n  font-family: 'Framework7 Icons';\n  font-weight: normal;\n  font-style: normal;\n  font-size: 28px;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  display: inline-block;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-feature-settings: 'liga';\n  -moz-font-feature-settings: 'liga=1';\n  -moz-font-feature-settings: 'liga';\n  font-feature-settings: 'liga';\n  text-align: center;\n}\n", "",{"version":3,"sources":["webpack://./src/css/icons.css"],"names":[],"mappings":"AAAA,uCAAuC;AACvC;EACE,6BAA6B;EAC7B,kBAAkB;EAClB,gBAAgB;EAChB;;gEAE8D;AAChE;AACA;EACE,6BAA6B;EAC7B,mBAAmB;EACnB,kBAAkB;EAClB,eAAe;EACf,qBAAqB;EACrB,cAAc;EACd,oBAAoB;EACpB,sBAAsB;EACtB,iBAAiB;EACjB,mBAAmB;EACnB,cAAc;EACd,mCAAmC;EACnC,kCAAkC;EAClC,kCAAkC;EAClC,6BAA6B;AAC/B;;AAEA,0CAA0C;AAC1C;EACE,+BAA+B;EAC/B,kBAAkB;EAClB,gBAAgB;EAChB;2EACyE;AAC3E;AACA;EACE,+BAA+B;EAC/B,mBAAmB;EACnB,kBAAkB;EAClB,eAAe;EACf,cAAc;EACd,sBAAsB;EACtB,oBAAoB;EACpB,qBAAqB;EACrB,mBAAmB;EACnB,iBAAiB;EACjB,cAAc;EACd,mCAAmC;EACnC,kCAAkC;EAClC,kCAAkC;EAClC,qCAAqC;EACrC,oCAAoC;EACpC,kCAAkC;EAClC,6BAA6B;EAC7B,kBAAkB;AACpB","sourcesContent":["/* Material Icons Font (for MD theme) */\n@font-face {\n  font-family: 'Material Icons';\n  font-style: normal;\n  font-weight: 400;\n  src: local('Material Icons'), local('MaterialIcons-Regular'),\n    url(/assets/mobile/fonts/material-icons.woff2) format('woff2'),\n    url(/assets/mobile/fonts/material-icons.woff) format('woff');\n}\n.material-icons {\n  font-family: 'Material Icons';\n  font-weight: normal;\n  font-style: normal;\n  font-size: 24px;\n  display: inline-block;\n  line-height: 1;\n  text-transform: none;\n  letter-spacing: normal;\n  word-wrap: normal;\n  white-space: nowrap;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: 'liga';\n}\n\n/* Framework7 Icons Font (for iOS theme) */\n@font-face {\n  font-family: 'Framework7 Icons';\n  font-style: normal;\n  font-weight: 400;\n  src: url('/assets/mobile/fonts/Framework7Icons-Regular.woff2') format('woff2'),\n    url('/assets/mobile/fonts/Framework7Icons-Regular.woff') format('woff');\n}\n.f7-icons {\n  font-family: 'Framework7 Icons';\n  font-weight: normal;\n  font-style: normal;\n  font-size: 28px;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  display: inline-block;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-feature-settings: 'liga';\n  -moz-font-feature-settings: 'liga=1';\n  -moz-font-feature-settings: 'liga';\n  font-feature-settings: 'liga';\n  text-align: center;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 46700:
/*!***************************************************!*\
  !*** ./node_modules/moment/locale/ sync ^\.\/.*$ ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./af": 42786,
	"./af.js": 42786,
	"./ar": 30867,
	"./ar-dz": 14130,
	"./ar-dz.js": 14130,
	"./ar-kw": 96135,
	"./ar-kw.js": 96135,
	"./ar-ly": 56440,
	"./ar-ly.js": 56440,
	"./ar-ma": 47702,
	"./ar-ma.js": 47702,
	"./ar-sa": 16040,
	"./ar-sa.js": 16040,
	"./ar-tn": 37100,
	"./ar-tn.js": 37100,
	"./ar.js": 30867,
	"./az": 31083,
	"./az.js": 31083,
	"./be": 9808,
	"./be.js": 9808,
	"./bg": 68338,
	"./bg.js": 68338,
	"./bm": 67438,
	"./bm.js": 67438,
	"./bn": 8905,
	"./bn-bd": 76225,
	"./bn-bd.js": 76225,
	"./bn.js": 8905,
	"./bo": 11560,
	"./bo.js": 11560,
	"./br": 1278,
	"./br.js": 1278,
	"./bs": 80622,
	"./bs.js": 80622,
	"./ca": 2468,
	"./ca.js": 2468,
	"./cs": 5822,
	"./cs.js": 5822,
	"./cv": 50877,
	"./cv.js": 50877,
	"./cy": 47373,
	"./cy.js": 47373,
	"./da": 24780,
	"./da.js": 24780,
	"./de": 59740,
	"./de-at": 60217,
	"./de-at.js": 60217,
	"./de-ch": 60894,
	"./de-ch.js": 60894,
	"./de.js": 59740,
	"./dv": 5300,
	"./dv.js": 5300,
	"./el": 50837,
	"./el.js": 50837,
	"./en-au": 78348,
	"./en-au.js": 78348,
	"./en-ca": 77925,
	"./en-ca.js": 77925,
	"./en-gb": 22243,
	"./en-gb.js": 22243,
	"./en-ie": 46436,
	"./en-ie.js": 46436,
	"./en-il": 47207,
	"./en-il.js": 47207,
	"./en-in": 44175,
	"./en-in.js": 44175,
	"./en-nz": 76319,
	"./en-nz.js": 76319,
	"./en-sg": 31662,
	"./en-sg.js": 31662,
	"./eo": 92915,
	"./eo.js": 92915,
	"./es": 55655,
	"./es-do": 55251,
	"./es-do.js": 55251,
	"./es-mx": 96112,
	"./es-mx.js": 96112,
	"./es-us": 71146,
	"./es-us.js": 71146,
	"./es.js": 55655,
	"./et": 5603,
	"./et.js": 5603,
	"./eu": 77763,
	"./eu.js": 77763,
	"./fa": 76959,
	"./fa.js": 76959,
	"./fi": 11897,
	"./fi.js": 11897,
	"./fil": 42549,
	"./fil.js": 42549,
	"./fo": 94694,
	"./fo.js": 94694,
	"./fr": 94470,
	"./fr-ca": 63049,
	"./fr-ca.js": 63049,
	"./fr-ch": 52330,
	"./fr-ch.js": 52330,
	"./fr.js": 94470,
	"./fy": 5044,
	"./fy.js": 5044,
	"./ga": 29295,
	"./ga.js": 29295,
	"./gd": 2101,
	"./gd.js": 2101,
	"./gl": 38794,
	"./gl.js": 38794,
	"./gom-deva": 27884,
	"./gom-deva.js": 27884,
	"./gom-latn": 23168,
	"./gom-latn.js": 23168,
	"./gu": 95349,
	"./gu.js": 95349,
	"./he": 24206,
	"./he.js": 24206,
	"./hi": 30094,
	"./hi.js": 30094,
	"./hr": 30316,
	"./hr.js": 30316,
	"./hu": 22138,
	"./hu.js": 22138,
	"./hy-am": 11423,
	"./hy-am.js": 11423,
	"./id": 29218,
	"./id.js": 29218,
	"./is": 90135,
	"./is.js": 90135,
	"./it": 90626,
	"./it-ch": 10150,
	"./it-ch.js": 10150,
	"./it.js": 90626,
	"./ja": 39183,
	"./ja.js": 39183,
	"./jv": 24286,
	"./jv.js": 24286,
	"./ka": 12105,
	"./ka.js": 12105,
	"./kk": 47772,
	"./kk.js": 47772,
	"./km": 18758,
	"./km.js": 18758,
	"./kn": 79282,
	"./kn.js": 79282,
	"./ko": 33730,
	"./ko.js": 33730,
	"./ku": 1408,
	"./ku.js": 1408,
	"./ky": 33291,
	"./ky.js": 33291,
	"./lb": 36841,
	"./lb.js": 36841,
	"./lo": 55466,
	"./lo.js": 55466,
	"./lt": 57010,
	"./lt.js": 57010,
	"./lv": 37595,
	"./lv.js": 37595,
	"./me": 39861,
	"./me.js": 39861,
	"./mi": 35493,
	"./mi.js": 35493,
	"./mk": 95966,
	"./mk.js": 95966,
	"./ml": 87341,
	"./ml.js": 87341,
	"./mn": 5115,
	"./mn.js": 5115,
	"./mr": 10370,
	"./mr.js": 10370,
	"./ms": 9847,
	"./ms-my": 41237,
	"./ms-my.js": 41237,
	"./ms.js": 9847,
	"./mt": 72126,
	"./mt.js": 72126,
	"./my": 56165,
	"./my.js": 56165,
	"./nb": 64924,
	"./nb.js": 64924,
	"./ne": 16744,
	"./ne.js": 16744,
	"./nl": 93901,
	"./nl-be": 59814,
	"./nl-be.js": 59814,
	"./nl.js": 93901,
	"./nn": 83877,
	"./nn.js": 83877,
	"./oc-lnc": 92135,
	"./oc-lnc.js": 92135,
	"./pa-in": 15858,
	"./pa-in.js": 15858,
	"./pl": 64495,
	"./pl.js": 64495,
	"./pt": 89520,
	"./pt-br": 57971,
	"./pt-br.js": 57971,
	"./pt.js": 89520,
	"./ro": 96459,
	"./ro.js": 96459,
	"./ru": 21793,
	"./ru.js": 21793,
	"./sd": 40950,
	"./sd.js": 40950,
	"./se": 10490,
	"./se.js": 10490,
	"./si": 90124,
	"./si.js": 90124,
	"./sk": 64249,
	"./sk.js": 64249,
	"./sl": 14985,
	"./sl.js": 14985,
	"./sq": 51104,
	"./sq.js": 51104,
	"./sr": 49131,
	"./sr-cyrl": 79915,
	"./sr-cyrl.js": 79915,
	"./sr.js": 49131,
	"./ss": 85893,
	"./ss.js": 85893,
	"./sv": 98760,
	"./sv.js": 98760,
	"./sw": 91172,
	"./sw.js": 91172,
	"./ta": 27333,
	"./ta.js": 27333,
	"./te": 23110,
	"./te.js": 23110,
	"./tet": 52095,
	"./tet.js": 52095,
	"./tg": 27321,
	"./tg.js": 27321,
	"./th": 9041,
	"./th.js": 9041,
	"./tk": 19005,
	"./tk.js": 19005,
	"./tl-ph": 75768,
	"./tl-ph.js": 75768,
	"./tlh": 89444,
	"./tlh.js": 89444,
	"./tr": 72397,
	"./tr.js": 72397,
	"./tzl": 28254,
	"./tzl.js": 28254,
	"./tzm": 51106,
	"./tzm-latn": 30699,
	"./tzm-latn.js": 30699,
	"./tzm.js": 51106,
	"./ug-cn": 9288,
	"./ug-cn.js": 9288,
	"./uk": 67691,
	"./uk.js": 67691,
	"./ur": 13795,
	"./ur.js": 13795,
	"./uz": 6791,
	"./uz-latn": 60588,
	"./uz-latn.js": 60588,
	"./uz.js": 6791,
	"./vi": 65666,
	"./vi.js": 65666,
	"./x-pseudo": 14378,
	"./x-pseudo.js": 14378,
	"./yo": 75805,
	"./yo.js": 75805,
	"./zh-cn": 83839,
	"./zh-cn.js": 83839,
	"./zh-hk": 55726,
	"./zh-hk.js": 55726,
	"./zh-mo": 99807,
	"./zh-mo.js": 99807,
	"./zh-tw": 74152,
	"./zh-tw.js": 74152
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 46700;

/***/ }),

/***/ 6120:
/*!**************************!*\
  !*** ./src/css/app.less ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ 93379);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_app_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/less-loader/dist/cjs.js!./app.less */ 40453);

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_app_less__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_app_less__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ 22254:
/*!***************************!*\
  !*** ./src/css/icons.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ 93379);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_url_false_icons_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js?url=false!./icons.css */ 22373);

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_url_false_icons_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_url_false_icons_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ 63133:
/*!****************************************!*\
  !*** ./src/js/AppBuilder/ABFactory.js ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/ABFactoryCore */ 45800);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ 96486);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moment */ 30381);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! nanoid */ 53416);
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! papaparse */ 57460);
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ 55877);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./platform/FilterComplex */ 10758);
/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../definitions.js */ 49670);
/* harmony import */ var _resources_Config_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../resources/Config.js */ 77269);
/* harmony import */ var _resources_Account_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../resources/Account.js */ 12968);
/* harmony import */ var _resources_Multilingual_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../resources/Multilingual.js */ 28917);
/* harmony import */ var _resources_Network_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../resources/Network.js */ 93360);
/* harmony import */ var _resources_Storage_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../resources/Storage.js */ 35397);
/* harmony import */ var _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/ABViewManagerCore */ 85642);
/* harmony import */ var _resources_Tenant_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../resources/Tenant.js */ 75342);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_0__, _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_12__]);
([_core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_0__, _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_12__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// const ABFactoryCore = require("./core/ABFactoryCore");





// @TODO: what is F7 method of working with dates?  can we swap libraries with moment?





// import FilterComplex from "./platform/FilterComplex";




//
// Our Common Resources
//

// Config : responsible for all the configuration/settings of our instance.


// Account : manages the current Logged in User and Account information.

// import ClassUI from "../ui/ClassUI.js";

// import Dialog from "./_factory_utils/Dialog.js";
// // Dialog : common UI dialogs.


// Multilingual: our interface Labels and language options


// Network: our interface for communicating to our server


// Storage: manages our interface for local storage




// Tenant: manages the Tenant information of the current instance

// import UISettings from "./uiSettings/config.js";
// // UISettings: detailed settings for our common UI elements

// import Webix from "../js/webix/webix.js";
// // NOTE: moved to require() because using import with webix_debug.js
// // really messed things up!
// // var Webix = require("../js/webix/webix-debug.js");

class ABValidator {
   constructor(AB) {
      this.AB = AB;
      this.errors = [];
   }

   addError(name, message) {
      this.errors.push({ name: name, message: message });
   }

   pass() {
      return this.errors.length == 0;
   }

   fail() {
      return this.errors.length > 0;
   }

   toValidationObject() {
      var obj = {
         error: "E_VALIDATION",
         invalidAttributes: {},
      };

      var attr = obj.invalidAttributes;

      this.errors.forEach((e) => {
         attr[e.name] = attr[e.name] || [];
         attr[e.name].push(e);
      });

      return obj;
   }

   updateForm(form) {
      var vObj = this.toValidationObject();
      this.AB.Validation.isFormValidationError(vObj, form);
   }

   updateGrid(rowID, grid) {
      var vObj = this.toValidationObject();
      this.AB.Validation.isGridValidationError(vObj, rowID, grid);
   }
}

//
// AppBuilder Objects
//

class ABFactory extends _core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(definitions) {
      super(definitions);

      // Common Reference to Configuration Values
      this.Config = _resources_Config_js__WEBPACK_IMPORTED_MODULE_7__["default"];
      let appDiv = document.querySelector("#app");
      this.Config.settingsFromDiv(appDiv);

      //
      // Resources
      //
      this.Account = _resources_Account_js__WEBPACK_IMPORTED_MODULE_8__["default"];
      // this.Dialog = Dialog;
      this.Multilingual = _resources_Multilingual_js__WEBPACK_IMPORTED_MODULE_9__["default"];
      this.Network = _resources_Network_js__WEBPACK_IMPORTED_MODULE_10__["default"];
      this.Storage = _resources_Storage_js__WEBPACK_IMPORTED_MODULE_11__["default"];
      this.Tenant = _resources_Tenant_js__WEBPACK_IMPORTED_MODULE_13__["default"];
      // this.Webix = Webix;

      // Plugin Classes
      // this.ClassUI = ClassUI;

      // additional Class definitions
      this.Class.FilterComplex = _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_5__["default"];
      this.Class.ABViewManager = _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_12__["default"];

      // Temp placeholders until Resources are implemented:
      this.Analytics = {
         log: () => {},
         logError: () => {},
      };
      this.Lock = class Lock {
         constructor() {}

         acquire() {
            return Promise.resolve();
         }
         release() {
            return Promise.resolve();
         }
      };

      // this.UISettings = UISettings;

      this.Validation = {
         validator: () => {
            return new ABValidator(this);
         },

         errorSailsCleanup: function (error) {
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               // dig down to sails provided error object:
               if (
                  error.error &&
                  error.error == "E_UNKNOWN" &&
                  error.raw &&
                  error.raw.length > 0
               ) {
                  error = error.raw[0];
               }

               // drill down to the embedded .err object if it exists
               if (error.err) {
                  error = error.err;
               }

               // if this is from our server response:
               if (
                  error.data &&
                  error.data.error &&
                  error.data.error == "E_VALIDATION"
               ) {
                  error = error.data;
               }
            }

            return error;
         },

         /**
          * @function AB.Validation.isFormValidationError
          *
          * scans the given error to see if it is a sails' response about an invalid
          * value from one of the form elements.
          *
          * @codestart
          * var form = $$('formID');
          * var values = form.getValues();
          * model.attr(values);
          * model.save()
          * .fail(function(err){
          *     if (!OP.Form.isFormValidationError(err, form)) {
          *         OP.error.log('Error saving current model ()', {error:err, values:values});
          *     }
          * })
          * .then(function(newData){
          *
          * });
          * @codeend
          *
          * @param {obj} error
          *        the error response object
          * @param {obj} form
          *        the webix form instance (or reference)
          * @return {bool}
          *         true if error was about a form element.
          *         false otherwise.
          */
         isFormValidationError: function (error, form) {
            var hasFocused = false;
            // {bool} have we set focus to form component?

            // if we have an error object:
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               error = this.errorSailsCleanup(error);

               //// Now process the error object
               ////
               if (
                  (error.error && error.error == "E_VALIDATION") ||
                  (error.code && error.code == "E_VALIDATION")
               ) {
                  var attrs = error.invalidAttributes;
                  if (attrs) {
                     var wasForm = false;
                     for (var attr in attrs) {
                        // if this is a field in the form:
                        if (form.elements[attr]) {
                           var errors = attrs[attr];
                           var msg = [];
                           errors.forEach(function (err) {
                              msg.push(err.message);
                           });

                           // set the invalid error message
                           form.markInvalid(attr, msg.join(", "));

                           // set focus to the 1st form element we mark:
                           if (!hasFocused) {
                              form.elements[attr].focus();
                              hasFocused = true;
                           }

                           wasForm = true;
                        }
                     }

                     if (wasForm) {
                        return true;
                     }
                  }
               }
            }

            // if we missed updating our form with an error
            // this was not a validation error so return false
            return false;
         },

         /**
          * @method AB.Validation.isGridValidationError
          *
          * scans the given error to see if it is a sails' response about an invalid
          * value from one of our grid columns.
          *
          * @codestart
          * var grid = $$('myGrid');
          * model.attr(values);
          * model.save()
          * .fail(function(err){
          *     if (!OP.Validation.isGridValidationError(err, editor, grid)) {
          *         OP.error.log('Error saving current model ()', {error:err, values:values});
          *     }
          * })
          * .then(function(newData){
          *
          * });
          * @codeend
          *
          * @param {Error} error
          *        the error response object
          * @param {integer} row
          *        the row id of the Grid to update.
          * @param {webix.datatable} Grid
          *        the webix grid instance (or reference)
          * @return {bool}
          *         true if error was about a grid column.
          *         false otherwise.
          */
         isGridValidationError: function (error, row, Grid) {
            // if we have an error object:
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               error = this.errorSailsCleanup(error);

               //// Now process the error object
               ////
               if (
                  (error.error && error.error == "E_VALIDATION") ||
                  (error.code && error.code == "E_VALIDATION")
               ) {
                  var attrs = error.invalidAttributes;
                  if (attrs) {
                     var wasGrid = false;
                     for (var attr in attrs) {
                        Grid.addCellCss(row, attr, "webix_invalid");
                        Grid.addCellCss(row, attr, "webix_invalid_cell");

                        var msg = [];
                        attrs[attr].forEach((e) => {
                           msg.push(e.message);
                        });

                        webix.alert({
                           text: attr + ": " + msg.join(", "),
                        });

                        wasGrid = true;
                     }

                     Grid.refresh(row);
                     Grid.clearSelection();

                     if (wasGrid) {
                        return true;
                     }
                  }
               }
            }

            // if we missed updating our Grid with an error
            // this was not a validation error so return false
            return false;
         },
      };

      // TODO: make sure "error" s are handled and sent to logs
      // this.on("error", ()=>{ Analytics.error })

      this.Definitions = {};
      // {obj} the provided interface for working with the ABDefinition table.
      // NOTE: on the web client, we simply perform web API calls to perform
      // the actions.  These are defined below.

      this.on("error", (err) => {
         // this simply prevents thrown errors if there are no listeners.
         console.error(err);
      });

      this._plugins = [];
      // {array} of loaded Plugin.applications.

      this._pendingNetworkRequests = {};
      // {hash}   uuid : {Promise}
      // convert our definitionsXXXX() operations to be Relay/offline compatible.
      // if a queued operation is sent after a web browser refresh, then
      // we will NOT have a pending promise to .resolve()/.reject()

      this.Network.on("definition.create", (context, err, fullDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            // this.error(err);
            pending?.reject(err);
            return;
         }

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: fullDef.id,
            data: fullDef,
         };
         this.emit("ab.abdefinition.create", pkt);

         let newDef = this.definitionNew(fullDef);
         pending?.resolve(newDef);
      });

      this.Network.on("definition.update", (context, err, serverDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            if (err.toString().indexOf("Not Found") > -1) {
               return this.definitionCreate(context.values)
                  .then(pending?.resolve)
                  .catch(pending?.reject);
            }
            // log the error
            // this.error(err);
            pending?.reject(err);
            return;
         }

         this._definitions[context.id] = serverDef;

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: serverDef.id,
            data: serverDef,
         };
         this.emit("ab.abdefinition.update", pkt);

         pending?.resolve(serverDef);
      });

      this.Network.on("definition.delete", (context, err, serverDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            // log the error
            // this.error(err);
            pending?.reject(err);
            return;
         }

         delete this._definitions[context.id];

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: context.id,
            data: serverDef,
         };
         this.emit("ab.abdefinition.delete", pkt);

         pending?.resolve();
      });

      //
      // Rules
      //
      const platformRules = {
         /**
          * @method toDate
          *
          * @param {string} dateText
          * @param {Object} options - {
          *                               format: "string",
          *                               ignoreTime: boolean
          *                            }
          * @return {Date}
          */
         toDate: (dateText = "", options = {}) => {
            if (!dateText) return;

            if (options.ignoreTime) dateText = dateText.replace(/T.*/, "");

            let result = options.format
               ? moment__WEBPACK_IMPORTED_MODULE_2___default()(dateText, options.format)
               : moment__WEBPACK_IMPORTED_MODULE_2___default()(dateText);

            let supportFormats = [
               "YYYY-MM-DD",
               "YYYY/MM/DD",
               "DD/MM/YYYY",
               "MM/DD/YYYY",
               "DD-MM-YYYY",
               "MM-DD-YYYY",
            ];

            supportFormats.forEach((format) => {
               if (!result || !result.isValid())
                  result = moment__WEBPACK_IMPORTED_MODULE_2___default()(dateText, format);
            });

            return new Date(result);
         },

         /**
          * @method toDateFormat
          *
          * @param {Date} date
          * @param {Object} options - {
          *           format: "string",
          *           localeCode: "string"
          *         }
          *
          * @return {string}
          */
         toDateFormat: (date, options) => {
            if (!date) return "";

            let momentObj = moment__WEBPACK_IMPORTED_MODULE_2___default()(date);

            if (options.localeCode) momentObj.locale(options.localeCode);

            return momentObj.format(options.format);
         },

         /**
          * @method subtractDate
          *
          * @param {Date} date
          * @param {number} number
          * @param {string} unit
          *
          * @return {Date}
          */
         subtractDate: (date, number, unit = "hours") => {
            // Prevent Depreciation warning:
            if (unit == "") unit = "hours";
            return moment__WEBPACK_IMPORTED_MODULE_2___default()(date).subtract(number, unit).toDate();
         },

         /**
          * @method addDate
          *
          * @param {Date} date
          * @param {number} number
          * @param {string} unit
          *
          * @return {Date}
          */
         addDate: (date, number, unit = "hours") => {
            // Prevent Depreciation warning:
            if (unit == "") unit = "hours";
            return moment__WEBPACK_IMPORTED_MODULE_2___default()(date).add(number, unit).toDate();
         },
      };
      (Object.keys(platformRules) || []).forEach((k) => {
         this.rules[k] = platformRules[k];
      });
   }

   /**
    * init()
    * prepare the ABFactory for operation. This includes parsing the
    * definitions into useable objects, preparing the System Resources, etc.
    * @return {Promise}
    */
   async init() {
      //
      // Prepare our Resources First
      //
      var allInits = [];

      allInits.push(this.Account.init(this));
      allInits.push(this.Multilingual.init(this));
      allInits.push(this.Network.init(this));
      allInits.push(this.Tenant.init(this));

      await Promise.all(allInits);
      await this.Storage.init(this);
      var data = await this.Storage.get("local_settings");
      this._localSettings = data || {};

      //
      // Real Time Update Handlers
      //

      // new ABDefinition created:
      this.on("ab.abdefinition.create", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition

         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         this._definitions[pkt.id] = pkt.data;
         this.definitionSync("created", pkt.id, pkt.data);
      });

      // ABDefinition updated:
      this.on("ab.abdefinition.update", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition
         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         this._definitions[pkt.id] = pkt.data;
         this.definitionSync("updated", pkt.id, pkt.data);
      });

      // ABDefinition delete:
      this.on("ab.abdefinition.delete", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition
         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         delete this._definitions[pkt.id];
         this.definitionSync("destroyed", pkt.id, pkt.data);
      });

      return super.init();

      // return Promise.all(allInits)
      //    .then(() => {
      //       // some Resources depend on the above to be .init() before they can
      //       // .init() themselves.
      //       return this.Storage.init(this).then(() => {
      //          return this.Storage.get("local_settings").then((data) => {
      //             this._localSettings = data || {};
      //          });
      //       });
      //    })
      //    .then(() => {
      //       //
      //       // RealTime Updates of our ABDefinitions
      //       //

      //       // new ABDefinition created:
      //       this.on("ab.abdefinition.create", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition

      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          this._definitions[pkt.id] = pkt.data;
      //          this.definitionSync("created", pkt.id, pkt.data);
      //       });

      //       // ABDefinition updated:
      //       this.on("ab.abdefinition.update", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition
      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          this._definitions[pkt.id] = pkt.data;
      //          this.definitionSync("updated", pkt.id, pkt.data);
      //       });

      //       // ABDefinition delete:
      //       this.on("ab.abdefinition.delete", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition
      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          delete this._definitions[pkt.id];
      //          this.definitionSync("destroyed", pkt.id, pkt.data);
      //       });

      //       return super.init();
      //    });
   }

   /**
    * definiitonCreate(def)
    * create a new ABDefinition
    * @param {obj} def
    *        the value hash of the new definition entry
    * @return {Promise}
    *        resolved with a new {ABDefinition} for the entry.
    */
   async definitionCreate(def) {
      // we will set our uuid
      if (typeof def.id == "undefined") {
         def.id = this.uuid();
         def.json.id = def.id;
      }

      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.create",
            context: {
               uuid,
            },
         };
         this.Network.post(
            {
               url: `/definition/create`,
               data: def,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to CREATE definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to CREATE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionCreate()",
               message,
               def,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionDestroy(id)
    * delete an ABDefinition
    * @param {string} id
    *        the uuid of the ABDefinition to delete
    * @return {Promise}
    */
   async definitionDestroy(id) {
      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.delete",
            context: {
               id,
               uuid,
            },
         };
         this.Network.delete(
            {
               url: `/definition/${id}`,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to DESTROY definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to DELETE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionDestroy()",
               message,
               id,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionUpdate(id, def)
    * update an existing ABDefinition
    * @param {string} id
    *        the uuid of the ABDefinition to update.
    * @param {obj} values
    *        the value hash of the new definition values
    * @return {Promise}
    *        resolved with a new {ABDefinition} for the entry.
    */
   async definitionUpdate(id, values) {
      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.update",
            context: {
               id,
               uuid,
               values,
            },
         };
         this.Network.put(
            {
               url: `/definition/${id}`,
               data: values,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to UPDATE definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to UPDATE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionUpdate()",
               message,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionsParse()
    * include the incoming definitions into our ABFactory. These new
    * definitions will replace any existing ones with the same .id.
    * @param {array[ABDefinitioin]} defs
    *     the incoming array of ABDefinitions to parse.
    * @return {Promise}
    */
   // definitionsParse(defs = []) {
   //    if (!Array.isArray(defs)) {
   //       defs = [defs];
   //    }

   //    // store/replace the incoming definitions
   //    // 1st: insert ALL our definitions internally
   //    defs.forEach((d) => {
   //       this._definitions[d.id] = d;
   //    });
   //    // 2nd: Now we can then go through and signal the "updates"
   //    // and the related objects can find their dependent definitions.
   //    defs.forEach((d) => {
   //       this.definitionSync("updated", d.id, d);
   //    });

   //    return Promise.resolve();
   // }

   /**
    * notify()
    * will send alerts to a group of people. These alerts are usually about
    * configuration errors, or software problems.
    * @param {string} domain
    *     which group of people we are sending a notification to.
    * @param {Error} error
    *     An error object generated at the point of issue.
    * @param {json} info
    *     Additional related information concerning the issue.
    */
   notify(domain, error, info) {
      console.error("TODO: ABFactory.notify(): pass error off to analytics");
      console.error(error);
      console.error(info);
   }

   plugins() {
      return this._plugins;
   }
   pluginLoad(p) {
      this._plugins.push(p);
   }

   //
   // Utilities
   //
   alert(options) {
      console.error("ABFactory.alert(): Who is calling this!");
      // Webix.alert(options);
   }

   cloneDeep(value) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().cloneDeep(value);
   }

   error(message, ...rest) {
      var emitData = {
         message: `ABFactory[${this.Tenant.id()}]:${message.toString()}`,
      };

      console.error(emitData.message);
      if (message instanceof Error) {
         emitData.error = message;
         // this dumps the error.stack
         console.error(message);
      }

      if (rest && rest.length > 0) {
         rest.forEach((r) => {
            if (r instanceof Error) {
               emitData.error = r;
               // this dumps the error.stack
               console.error(r);
            }

            if (typeof r == "object") {
               for (var k in r) {
                  emitData[k] = r[k];
                  console.error(k, r[k]);
               }
            }
         });
      }
      this.emit("error", emitData);
   }

   jobID() {
      return (0,nanoid__WEBPACK_IMPORTED_MODULE_14__.nanoid)();
   }

   Label() {
      return (...params) => {
         return this.Multilingual.labelPlugin("mobile", ...params);
      };
   }

   localSettings(key, value) {
      if (typeof value == "undefined") {
         // this is a getter:
         return this._localSettings[key];
      } else {
         // setting a value:
         this._localSettings[key] = value;
         return this.Storage.set(`local_settings`, this._localSettings);
      }
   }

   log(message, ...rest) {
      console.log(message);
      rest.forEach((r) => {
         console.log(r);
      });
   }

   isEmail(value) {
      const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().matches(value, emailRegex);
   }

   isNil(value) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().isNil(value);
   }

   /**
    * @method rules.isUUID
    * evaluate a given value to see if it matches the format of a uuid
    * @param {string} key
    * @return {boolean}
    */
   isUUID(key) {
      var checker = RegExp(
         "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
         "i"
      );
      return checker.test(key);
   }

   merge(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().merge(...params);
   }

   orderBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().orderBy(...params);
   }

   uniq(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().uniq(...params);
   }

   kebabCase(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().kebabCase(...params);
   }

   sumBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().sumBy(...params);
   }

   meanBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().meanBy(...params);
   }

   maxBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().maxBy(...params);
   }

   minBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().minBy(...params);
   }

   uuid() {
      return (0,uuid__WEBPACK_IMPORTED_MODULE_4__.v4)();
   }

   warn(message, ...rest) {
      console.warn(message);
      rest.forEach((r) => {
         console.warn(r);
      });
   }

   isString(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().isString(params);
   }

   csvToJson(csvData) {
      return papaparse__WEBPACK_IMPORTED_MODULE_3___default().parse(csvData, {
         header: true,
         skipEmptyLines: true,
      });
   }

   jsonToCsv(jsonData) {
      return papaparse__WEBPACK_IMPORTED_MODULE_3___default().unparse(jsonData);
   }
}
await window.__AB_preload;
const AB = new ABFactory(window.__ab_definitions.definitions);
AB.Config.config(window.__ab_config);
await AB.init();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 71750:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/core/ABApplicationCore.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABApplicationCore)
/* harmony export */ });
/* harmony import */ var _platform_ABViewManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABViewManager */ 67348);
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_platform_ABViewManager__WEBPACK_IMPORTED_MODULE_0__]);
_platform_ABViewManager__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
/**
 * ABApplicationCore
 *
 * This is the core ABApplication class that manages the common operations
 * of an ABApplication across platforms.
 *
 * It's primary responsibility is to decode a given set of attributes into
 * a working instance of an ABApplication that can return instances of
 * it's defined sub objects.
 *
 * Platform Specific versions of those objects should be defined in a peer
 * directory named platform. These versions of the objects should override
 * these Core objects with platform specific methods of operation (like
 * .save()).
 *
 * Initially your target application should load your platform/ABApplication.js
 * file, which will include this file and sub class it.
 *
 * However, this file will include the remaining files from your platform/*
 * versions.
 */

// webpack can handle 'require()' statements, but node can't handle import
// so let's use require():
// const ABViewManager = require("../platform/ABViewManager");


// var ABMLClass = require("../platform/ABMLClass");


function toBool(val) {
   if (typeof val == "undefined") {
      return false;
   }

   if (val === "" || val === "false" || val === "0") {
      return false;
   }

   if (val === "true" || val === "1") {
      return true;
   }

   return val;
}

class ABApplicationCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_1__["default"] {
   constructor(attributes, AB) {
      super(["label", "description"], AB);

      // attributes should be in format:
      // {
      //    id:##,
      //    json:{},
      //    name:"XYZ"
      // }
      attributes.json = attributes.json || {};

      // ABApplication Attributes
      this.id = attributes.id;
      // {string} uuid

      this.type = attributes.type || "application";
      // {string} .type
      // the ABDefinition.type of this object.

      this.appType = attributes.appType || "web";
      // {string} .appType
      // the kind of Application this is. ["web", "mobile"]

      this.json = attributes.json;
      if (typeof this.json == "string") this.json = JSON.parse(this.json);
      // {obj} .json
      // the full settings of this ABApplication

      this.json["versionData"] = attributes.json?.versionData || {
         versionNumber: "1.0.0",
         changeLog: {
            "1.0.0": {
               author: "N/A",
               version: "1.0.0",
               keepVersion: 0,
               commitMessage: "Initial Version",
               timestamp: new Date().toISOString(),
            },
         },
      };

      if (typeof this.json.versionData == "string")
         this.json.versionData = JSON.parse(this.json.versionData);
      // {obj} .json
      // the full version log data of this ABApplication

      this.name = attributes.name || this.json.name || "";
      // {string} .name
      // the hard coded name of this ABDefinition Object, not to be confused
      // with the .label.  The .name is created at design time and is a text
      // reference for this object.

      this.icon = attributes.icon || "fa-rocket";
      // {string} .icon
      // this is a reference to a font awesome icon including the `fa-`
      // example `fa-child` should be stored for the `child` icon to be used
      // if user wants to get creative they can add more to this field following
      // these examples https://fontawesome.com/v4/examples/

      this.isSystemObject = toBool(attributes.isSystemObject);
      // {bool} .isSystemObject
      // is this one of the integrated System Objects used by our framework?
      // Some ABApplications and ABObjects are central to the running of the
      // AppBuilder site.  They are marked with .isSystemObject = true;  It
      // requires the role "System Designer" in order to edit/modify them.

      this.roleAccess = attributes.roleAccess || [];
      if (!Array.isArray(this.roleAccess)) {
         this.roleAccess = [this.roleAccess];
      }
      this.roleAccess = this.roleAccess.filter((r) => r);
      // {array}
      // the {ABSiteRole.id}s of the roles allowed to work with this
      // ABApplication. (see .isAccessManaged for more info)

      this.isAccessManaged = JSON.parse(attributes.isAccessManaged || false);
      // {bool} .isAccessManaged
      // does this Application imploy the more sophisticated  Access
      // permissions, or the simpler Role access permissions.
      // {true} : allows an administrator to set which role can View|Edit|Delete
      //          elements of an application.
      // {false}: indicates users having one of the .roleAccess values can have
      //          full access to this application

      this.accessManagers = attributes.accessManagers;
      if (typeof this.accessManagers == "string")
         this.accessManagers = JSON.parse(this.accessManagers);
      // {??} .accessManagers
      // if .isAccessManaged == true, then .accessManagers contain the definitions
      // of the detailed access permissions.

      this.isTranslationManaged = JSON.parse(
         attributes.isTranslationManaged || false
      );
      this.translationManagers = attributes.translationManagers;
      if (typeof this.translationManagers == "string")
         this.translationManagers = JSON.parse(this.translationManagers);

      this.isTutorialManaged = JSON.parse(
         attributes.isTutorialManaged || false
      );
      this.tutorialManagers = attributes.tutorialManagers;
      if (typeof this.tutorialManagers == "string")
         this.tutorialManagers = JSON.parse(this.tutorialManagers);

      this.hintIDs = attributes.json.hintIDs || [];
      // {array} .hintIDs
      // All the {ABHint.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABHint}s are included or excluded from
      // this app.

      this.objectIDs = attributes.json.objectIDs || [];
      // {array} .objectIDs
      // All the {ABObject.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABObject}s are included or excluded from this app.

      this.queryIDs = attributes.json.queryIDs || [];
      // {array} .queryIDs
      // All the {ABObjectQuery.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABObjectQueries}s are included or excluded from
      // this app.

      this.datacollectionIDs = attributes.json.datacollectionIDs || [];
      // {array} .datacollectionIDs
      // All the {ABDataCollection.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABDataCollection}s are included or excluded from
      // this app.

      // import all our {ABViewPage}s
      let newPages = [];
      (attributes.json.pageIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            newPages.push(this.pageNew(def));
         } else {
            this.emit(
               "warning",
               `App[${this.id}] is referenceing an unknown Page[${id}]`,
               {
                  appID: this.id,
                  pageID: id,
               }
            );
            // console.error(
            //    `App[${this.id}] is referenceing an unknown Page[${id}]`
            // );
         }
      });
      this._pages = newPages;
      // {array} ._pages
      // an array of all the {ABViewPages} this ABApplication offers as
      // interfaces for working with our Data.
      // ABViewPages operate within the confines of an ABApplication so
      // they are created/stored/accessed from within an ABApplication

      (attributes.json.processIDs || []).forEach((pID) => {
         var p = this.AB.processByID(pID);
         if (!p) {
            this.emit(
               "warning",
               `Application is referencing an unknown process.`,
               { appID: this.id, processID: pID }
            );
         }
      });

      this.processIDs = attributes.json.processIDs || [];
      // {array} .processIDs
      // an array of all the {ABProcess.id}s referenced by this Application.

      // Object List Settings
      attributes.json.objectListSettings =
         attributes.json.objectListSettings || {};
      this.objectListSettings = this.objectListSettings || {};
      this.objectListSettings.isOpen = JSON.parse(
         attributes.json.objectListSettings.isOpen || false
      );
      this.objectListSettings.searchText =
         attributes.json.objectListSettings.searchText || "";
      this.objectListSettings.sortDirection =
         attributes.json.objectListSettings.sortDirection || "asc";
      this.objectListSettings.isGroup = JSON.parse(
         attributes.json.objectListSettings.isGroup || false
      );

      // let the MLClass now process the translations:
      // transition issues:
      attributes.translations =
         attributes.translations || attributes.json.translations;

      super.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   get ViewManager() {
      return _platform_ABViewManager__WEBPACK_IMPORTED_MODULE_0__["default"];
   }

   /// ABApplication data methods
   /**
    * @method isAccessibleForRoles()
    * return true/false if this ABApplication is accessible for one of the
    * passed in ABRoles.
    * @param {array[ABRole]} roles
    *        an array of {ABRole} instances.
    * @return {bool}
    */
   isAccessibleForRoles(roles) {
      var foundRole = false;

      // if we are on the basic Role assignments:
      if (!this.isAccessManaged) {
         (roles || []).forEach((r) => {
            if (this.roleAccess.indexOf(r.uuid || r) > -1) {
               foundRole = true;
            }
         });
         return foundRole;
      }

      // isAccessManaged has been set, so 2 kinds of ppl can
      // see this App
      // 1) an AccessManager
      if (parseInt(this.accessManagers.useRole)) {
         (roles || []).forEach((r) => {
            if (this.accessManagers.role.indexOf(r.uuid || r) > -1) {
               foundRole = true;
            }
         });
      }

      // stop here if found.
      if (foundRole) return foundRole;

      // 2) someone who has a role that can see one of it's pages.
      // scan each Page of this Application
      (this.pages() || []).forEach((p) => {
         // check to see if that page.isAccessibleForRoles()
         if (p.isAccessibleForRoles(roles)) {
            foundRole = true;
         }
      });
      return foundRole;
   }

   get isWebApp() {
      return this.appType == "web";
   }

   get isMobile() {
      return this.appType == "mobile";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // MLClass translation
      let versionData = this.json.versionData;

      this.json = super.toObj();

      this.json.name = this.name;

      this.json.versionData = versionData;

      this.json.objectIDs = this.objectIDs;

      this.json.objectListSettings = this.objectListSettings;

      this.json.hintIDs = this.hintIDs;

      this.json.queryIDs = this.queryIDs;

      this.json.datacollectionIDs = this.datacollectionIDs;

      this.json.pageIDs = (this._pages || []).map((p) => p.id);

      this.json.processIDs = this.processIDs || [];

      // // for each MobileApp: compile to json
      // var currApps = [];
      // this._mobileApps.forEach((app) => {
      //    currApps.push(app.toObj())
      // })
      // this.json.mobileApps = currApps;

      return {
         id: this.id,
         type: this.type || "application",
         appType: this.appType || "web",
         name: this.name,
         icon: this.icon,
         isSystemObject: this.isSystemObject,
         json: this.json,
         roleAccess: this.roleAccess,
         translations: this.json.translations,
         isAccessManaged: this.isAccessManaged,
         isTranslationManaged: this.isTranslationManaged,
         isTutorialManaged: this.isTutorialManaged,
         accessManagers: this.accessManagers,
         translationManagers: this.translationManagers,
         tutorialManagers: this.tutorialManagers,
      };
   }

   ///
   /// Mobile Apps
   ///

   ///
   /// Datacollections
   ///

   // datacollectionNew(values) {
   //    return new ABDataCollectionCore(values, this);
   // }

   datacollectionsExcluded(filter = () => true) {
      return this.AB.datacollections((o) => {
         return this.datacollectionIDs.indexOf(o.id) == -1;
      }).filter(filter);
   }

   datacollectionsIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.datacollections((o) => {
         return this.datacollectionIDs.indexOf(o.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   ///
   /// Objects
   ///

   objectsExcluded(filter = () => true) {
      return this.AB.objects((o) => {
         return this.objectIDs.indexOf(o.id) == -1;
      }).filter(filter);
   }

   objectsIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.objects((o) => {
         return this.objectIDs.indexOf(o.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   ///
   /// Hints
   ///

   hintsExcluded(filter = () => true) {
      return this.AB.hints((h) => {
         return this.hintIDs.indexOf(h.id) == -1;
      }).filter(filter);
   }

   hintsIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.hints((h) => {
         return this.hintIDs.indexOf(h.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   /**
    * @method connectedObjects()
    *
    * return an array of all the connected ABObjects for a given ABObject.
    *
    * @param {string} id
    *        an ID of an ABObject
    * @return {array}   array of options for webix select
    *         [ {id, value}, ... ]
    */
   connectedObjects(id) {
      console.error(
         "ABApplicationCore.connectedObjects(): who is calling this?"
      );

      if (id == "") return [];

      // Determine the object from the ID
      var myObj = this.AB.objectByID(id);

      // Get all the connected Fields for that object
      var connectedFields = myObj.connectFields();
      // Store the related fields associatively inside their related Objects ID
      var connectedObj = {};
      connectedFields.forEach((f) => {
         connectedObj[f.settings.linkObject] = this.AB.objectByID(
            f.settings.linkObject
         );
      });
      // Look up the objects by their ID and push them in an options array
      var linkedObjects = [];
      Object.keys(connectedObj).forEach(function (key /*, index */) {
         linkedObjects.push({
            id: this[key].id,
            value: this[key].label,
         });
      }, connectedObj /* = this. inside fn */);

      return linkedObjects;
   }

   /**
    * @method connectedFields()
    * return an array of all the connected ABFields for a given ABObject
    * @param {string} currObjID
    *        an ID of the current ABObject
    * @param {string} linkedObjectID
    *        an ID of the linked ABObject
    * @return {array}
    *        array of options for webix select
    */
   connectedFields(currObjID, linkedObjectID) {
      console.error("!!! Who is calling this?");

      // Determine the object from the currObjID
      var myObj = this.AB.objectByID(currObjID);

      // Get all the connected Fields for our object that match the linkedObjectID
      var connectedFields = myObj.connectFields(
         (f) => f.settings.linkObject == linkedObjectID
      );
      // Build an arry of options for the webix select
      var linkedFields = [];
      connectedFields.forEach((f) => {
         linkedFields.push({ id: f.columnName, value: f.label });
      });

      return linkedFields;
   }

   ///
   /// Pages
   ///

   /**
    * @method pages()
    * return an array of all the ABViewPages for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABViewPages that this fn
    *        returns true for.
    * @param {boolean} deep
    *        flag to search in sub pages
    * @return {array}
    *        array of ABViewPages
    */
   pages(filter = () => true, deep = false) {
      var result = [];

      if (!this._pages || this._pages.length < 1) return result;

      // find into sub-pages recursively
      if (filter && deep) {
         // function searchDeep(curr) {
         //    let resultsCurr = curr._pages.filter(filter);

         //    for (let p of curr._pages) {
         //       let resultsP = searchDeep(p);
         //       if (resultsP.length) {
         //          resultsCurr = resultsCurr.concat(resultsP);
         //       }
         //    }
         //    // if we get here, end
         //    return resultsCurr;
         // }

         // result = searchDeep(this);
         result = this._searchDeep(this, "_pages", filter);
      }
      // find root pages
      else {
         result = (this._pages || []).filter(filter);
      }

      return result;
   }

   /**
    * @method _searchDeep()
    * search each node of a tree and return all matches that pass the provided
    * filter.
    * @param {AB*} curr
    *        An object that contains a tree structure.
    * @param {string} key
    *        The curr[key] reference of the array of items to search
    * @param {function} filter
    *        The curr[key].filter(filter) that returns true/false if a node is
    *        to be included in the result.
    * @return {array}
    */
   _searchDeep(curr, key, filter) {
      let items = curr[key] ?? [];
      let resultsCurr = items.filter?.(filter) ?? [];

      for (let p of items) {
         let resultsP = this._searchDeep(p, key, filter);
         if (resultsP.length) {
            resultsCurr = resultsCurr.concat(resultsP);
         }
      }

      return resultsCurr;
   }

   ///
   /// Processes
   ///

   /**
    * @method processes()
    * return an array of all the ABProcesses for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABProcesses that
    *        this fn returns true for.
    * @return {array}
    *        array of ABProcesses
    */
   processes(filter = () => true) {
      return this.AB.processes((p) => {
         return this.processIDs.indexOf(p.id) > -1;
      }).filter(filter);
   }

   hasProcess(process) {
      if (process && process.id) {
         return this.processIDs.indexOf(process.id) > -1;
      } else {
         return false;
      }
   }

   ///
   /// Views
   ///

   /**
    * @method views()
    * return an array of all the Views for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of Views that this fn
    *        returns true for.
    * @return {array}
    *        array of Views
    */
   views(filter) {
      var result = [];
      var views = [];
      var pages = [];

      if (
         (!this._pages || this._pages.length < 1) &&
         (!this._views || this._views.length < 1)
      )
         return result;

      function lookDeep(view) {
         if (view._pages && view._pages.length) {
            view._pages.forEach((p) => {
               // check the page views recusively
               var pageViews = p.views(filter, true);
               // if there was a match store it
               if (pageViews && pageViews.length > 0) {
                  result = pageViews;
               }
               // if no match move on to the subpages
               if (result.length < 1) {
                  // loop through each subpage recursively
                  var subPages = p.pages(filter, true);
                  // if there was a match store it
                  if (subPages && subPages.length > 0) {
                     result = subPages;
                  }
                  if (result.length < 1) {
                     lookDeep(p);
                  }
               }
            });
         }
      }

      // look at views recursively
      if (filter) {
         // look at views recursively (views can have subviews and so on)
         if (this._views) {
            views = this._views.filter(filter);

            if (views.length < 1) {
               this._views.forEach((v) => {
                  var subViews = v.views(filter, true);
                  if (subViews && subViews.length > 0) {
                     views = subViews;
                  }
               });
            }
         }

         // if no views of the root page match now look at the sub pages and their views
         if (views.length) {
            result = views;
         } else {
            // check the first level subpages
            result = this._pages.filter(filter);

            // if no match check each pages views and subpages
            if (result.length < 1) {
               // looping through pages
               lookDeep(this);
            }
         }
      }
      // find all views
      else {
         // recusively gather all views on this view
         if (this._views) {
            views = this._views;
            if (views.length) {
               views.forEach((v) => {
                  var subViews = v.views(() => true, true);
                  if (subViews && subViews.length) {
                     views = views.concat(subViews);
                  }
               });
            }
         }

         // recursively gather all pages and their views
         if (this._pages) {
            pages = this._pages;
            if (pages.length) {
               pages.forEach((p) => {
                  // grab all views on this page
                  var pageViews = p.views(() => true, true);
                  if (pageViews && pageViews.length) {
                     views = views.concat(pageViews);
                  }
                  // grab all subpages on this page
                  var subPages = p.pages(() => true, true);
                  if (subPages && subPages.length) {
                     pages = pages.concat(subPages);
                     subPages.forEach((sub) => {
                        var subViews = sub.views(() => true, true);
                        if (subViews && subViews.length) {
                           views = views.concat(subViews);
                        }
                     });
                  }
               });
            }
         }

         result = result.concat(pages, views);
      }

      return result;
   }

   /**
    * @method viewAll()
    * return a list of all the {ABViewxxx} classes available.
    * @return {array} of ABView objects
    */
   viewAll(fn = () => true) {
      return this.ViewManager.allViews(fn);
   }

   ///
   /// Queries
   ///

   /**
    * queriesExcluded()
    * return a list of ABObjectQuery(s) that are not included in this
    * ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which queries to return.
    * @return {array}
    */
   queriesExcluded(filter = () => true) {
      return this.AB.queries((q) => {
         return this.queryIDs.indexOf(q.id) == -1;
      }).filter(filter);
   }

   /**
    * queriesIncluded()
    * return a list of ABObjectQuery(s) that are included in this
    * ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which queries to return.
    * @param {fn} [sort] function to sort by, default is .label
    * @return {array}
    */
   queriesIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.queries((q) => {
         return this.queryIDs.indexOf(q.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   ///
   /// Roles
   ///

   /**
    * @method roles()
    * return an array of all the ABRole for this ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which roles to return.
    * @return {array}   array of ABRole
    */
   // roles(filter = () => true) {
   //    return (this.role || []).filter(filter);
   // }

   /**
    * @method urlResolve()
    * given an object pointer, return the specific object referenced.
    * pointer must start with a '#', use '/' as delimiters, and either
    * reference an object's .id, or an object's .property.
    * for example:
    * #/_objects   : resolves to the array of ._objects pointed to by this
    *               application.
    * #/_objects/[object.id] : reolved to a specific object
    * #/_objects/[object.id]/_fields/[field.id] : resolves to a specific data field
    *               refereced by object.id.
    *
    * @param {string} pointer : the string url referencing the object you want
    *                       to retrieve.
    * @return {obj}
    */
   urlResolve(pointer) {
      var parts = pointer.split("/");

      var parseStep = (obj, steps) => {
         // we're done.  obj is what we are looking for:
         if (steps.length == 0) {
            return obj;
         }

         // pull the next step key:
         var key = steps.shift();

         // special case, "#" makes sure we are talking about the
         // Application object
         if (key == "#") {
            return parseStep(this, steps);
         }

         // if obj is an [], then key should be an .id reference to
         // lookup:
         if (Array.isArray(obj)) {
            obj = obj.filter(function (o) {
               return o.id == key;
            })[0];
            return parseStep(obj, steps);
         }

         // otherwise obj should be an {} and key a property:
         if (obj && obj[key]) {
            return parseStep(obj[key], steps);
         }

         if (key == "_objects") {
            console.error(new Error("REFACTOR: old objectBy url reference:"));

            // This can be gotten from our AB
            var id = steps.shift();
            return parseStep(this.AB.objectByID(id), steps);
         }

         // if we got here, there is an error!
         // console.error('!!! failed to lookup url:'+pointer);
         console.error("!!! failed to lookup url:" + pointer);
         return null;
      };

      return parseStep(this, parts);
   }

   /**
    * @method urlPointer()
    * return the url pointer for this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      // NOTE: if we need to expand this to search across
      // applications, then add in this application.id here:
      if (acrossApp) return "#/" + this.id + "/";
      else return "#/";
   }

   /**
    * @method urlObject()
    * return the url pointer for objects in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlObject(acrossApp) {
      return this.urlPointer(acrossApp) + "_objects/";
   }

   /**
    * @method urlView()
    * return the url pointer for pages in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPage(acrossApp) {
      return this.urlPointer(acrossApp) + "_pages/";
   }

   /**
    * @method urlQuery()
    * return the url pointer for queries in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlQuery(acrossApp) {
      return this.urlPointer(acrossApp) + "_queries/";
   }

   /**
    * @method version()
    * return the current version of this Application.
    * Version information is in format "{Major}.{Minor}.{patch}"
    * @return {string}
    */
   get version() {
      return this.json?.versionData?.versionNumber ?? "0.0.0";
   }

   ///
   ///   Object List Settings
   ///
   get objectlistIsOpen() {
      return this.objectListSettings.isOpen;
   }

   set objectlistIsOpen(isOpen) {
      this.objectListSettings.isOpen = isOpen;
   }

   get objectlistSearchText() {
      return this.objectListSettings.searchText;
   }

   set objectlistSearchText(searchText) {
      this.objectListSettings.searchText = searchText;
   }

   get objectlistSortDirection() {
      return this.objectListSettings.sortDirection;
   }

   set objectlistSortDirection(sortDirection) {
      this.objectListSettings.sortDirection = sortDirection;
   }

   get objectlistIsGroup() {
      return this.objectListSettings.isGroup;
   }

   set objectlistIsGroup(isGroup) {
      this.objectListSettings.isGroup = isGroup;
   }

   ///
   /// Instance generators
   ///

   /**
    * @method pageNew()
    *
    * return an instance of a new (unsaved) ABViewPage that is tied to this
    * ABApplication.
    *
    * NOTE: this new page is not included in our this.pages until a .save()
    * is performed on the page.
    *
    * @return {ABViewPage}
    */
   pageNew(values) {
      // make sure this is an ABViewPage description
      // values.key = ABViewPageCore.common().key;
      values.key = "page";

      return this.ViewManager.newView(values, this, null);
   }

   /**
    * @method pageByID()
    * return pages from the given {id}
    * @param {string} id
    *        the uuid of the page to return.
    * @param {bool} deep
    *        should this search deep (through all our children's children)
    * @return {ABViewPage}
    */
   pageByID(id, deep = true) {
      return this.pages((f) => f.id == id, deep)[0];
   }

   get urlCurrentVersion() {
      return `/mobile/version/${this.id}`;
   }

   get version() {
      return this.json.versionData?.versionNumber || "0.0.0";
   }

   /**
    * @method viewNew()
    *
    * return an instance of a new (unsaved) ABView.
    *
    * @return {ABView}
    */
   viewNew(values, application, parent) {
      return this.ViewManager.newView(values, application, parent);
   }

   ///
   /// Utilities
   ///

   cloneDeep(/* object */) {
      var errorDepreciated = new Error(
         "ABApplicationCore.cloneDeep(): Depreciated!  Use AB.cloneDeep() instead."
      );
      throw errorDepreciated;

      // return JSON.parse(JSON.stringify(object));
   }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 39807:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/core/ABApplicationMobileCore.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABApplicationMobileCore)
/* harmony export */ });
/* harmony import */ var _platform_ABViewManagerMobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABViewManagerMobile */ 15656);
/* harmony import */ var _platform_ABApplication__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/ABApplication */ 10285);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_platform_ABApplication__WEBPACK_IMPORTED_MODULE_1__]);
_platform_ABApplication__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
/**
 * ABApplicationMobileCore
 *
 * This is the core ABApplicationMobile class that manages the common operations
 * of a Mobile PWA ABApplication.
 */

// webpack can handle 'require()' statements, but node can't handle import
// so let's use require():



class ABApplicationMobileCore extends _platform_ABApplication__WEBPACK_IMPORTED_MODULE_1__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);
      this.appType = "mobile"; // Just making sure.
      this.networkType = attributes.networkType;

      this.pageDefault = attributes.pageDefault;
      // {uuid}
      // the {ABMobilePage}.uuid of the page that is our default Page.
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   get ViewManager() {
      return _platform_ABViewManagerMobile__WEBPACK_IMPORTED_MODULE_0__["default"];
   }

   pageNew(def) {
      console.error("TODO: pageNew for ApplicationMobile");
      return null;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var json = super.toObj();
      json.appType = "mobile";
      json.networkType = this.networkType;

      json.pageDefault = this.pageDefault;

      return json;
   }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 47621:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/core/ABDataCollectionCore.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABDataCollectionCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
/*
 * ABDataCollection
 * Defines a set of data that other parts of the Application can work with.
 * it can point to either an ABObject, or ABObjectQuery, and can have an
 * filter, and sorts defined.
 *
 *
 *
 */
// const ABEmitter = require("../platform/ABEmitter");


// const ABObject = require("../platform/ABObject");
// const ABObjectQuery = require("../platform/ABObjectQuery");
// const RowFilter = require("../platform/RowFilter");

var DefaultValues = {
   id: "uuid",
   label: "", // label
   object: {}, // json of ABObject
   query: {}, // json of ABObjectQuery
   settings: {
      datasourceID: "", // id of ABObject or ABObjectQuery
      linkDatacollectionID: "", // id of ABDatacollection
      linkFieldID: "", // id of ABField
      followDatacollectionID: "", // id of ABDatacollection
      objectWorkspace: {
         filterConditions: {
            // array of filters to apply to the data table
            glue: "and",
            rules: [],
         },
         sortFields: [], // array of columns with their sort configurations
      },
      loadAll: false,
      // preventPopulate: false, depreciating in favour of populate
      populate: true, // true/false or array of columns to populate.
      isQuery: false, // if true it is a query, otherwise it is a object.

      fixSelect: "", // _CurrentUser, _FirstRecord, _FirstRecordDefault or row id

      syncType: 1, // 1 (Server), 2 (Client)
   },
};

const QueuedOperations = [];
// {array} of operations that we want to perform but allow some space
// between operations.
var _queueTimer = null;

function runQueue() {
   // if (!_queueTimer) {
   //    _queueTimer = setInterval(() => {
   //       runQueue();
   //    }, 20);
   // }
   if (QueuedOperations.length == 0) {
      // stop
      // clearInterval(_queueTimer);
      _queueTimer = null;
      return;
   }
   var op = QueuedOperations.shift();
   op.fn();
   _queueTimer = setTimeout(runQueue, op.timeout);
}
function queueOperation(fn, timeout = 20) {
   QueuedOperations.push({ fn, timeout });
   if (!_queueTimer) {
      runQueue();
   }
}

class ABDataCollectionCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(["label"], AB);

      attributes = attributes || {};

      // this.application = application;

      this.fromValues(attributes);

      this.__dataCollection = this._dataCollectionNew([]);
      // {DataCollection}
      // This is a working instance of a DataCollection, not an {ABDatacCollection}
      // On web/mobile this is a webix component.  So keep the creation as part of
      // the platform/ABDataCollection implementation.

      // Set filter value
      this.refreshFilterConditions();

      this.__bindComponentIds = [];
      this.__flexComponentIds = [];

      // refresh a data collection
      // this.init();

      // mark data status does not be initialized
      this._dataStatus = this.dataStatusFlag.notInitial;

      this.__filterCond = null;
      // {QueryCondition}
      // A passed in Query Condition for filtering our DataCollection.
      // This value is ANDed with our normal filter conditions.

      this.__model = null;
      // {ABModel}
      // An instance of the ABModel used for this DataCollection to
      // access data on the server.
   }

   /**
    * contextKey()
    *
    * return a unique key that represents data from/for this type of object.
    *
    * used when creating Network jobs and needing to be notified when a job
    * is complete.  We send a contextKey() to the Network job and then listen
    * for it to know when it is complete.
    * @return {string}
    */
   static contextKey() {
      return "datacollection";
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      this.id = values.id;
      // {string} .id
      // the uuid of this ABDataCollection Definition.

      this.name = values.name || null;
      // {string} .name
      // the unchanging name of this ABDataCollection

      this.type = values.type || "datacollection";
      // {string} .type
      // the type of ABDefinition this is.

      values.settings = values.settings || {};
      this.settings = this.settings || {};
      // {obj} .settings
      // the specific operation values for this ABDataCollection

      this.settings.linkDatacollectionID =
         values.settings.linkDatacollectionID ||
         DefaultValues.settings.linkDatacollectionID;
      // {string} .settings.linkDatacollectionID
      // the uuid of another ABDataCollection that provides the link/trigger
      // for filtering the values of this ABDataCollection.

      this.settings.linkFieldID =
         values.settings.linkFieldID || DefaultValues.settings.linkFieldID;
      // {string} .settings.linkFieldID
      // this.fieldLink is intended to be the way to connect to the column in
      // the datacollectionLink that we are following.  However this field
      // is the field in this.datasource that connects to the field in
      // datacollectionLink that has the value we are linked to.
      // So, If this DC(ObjB), and our datacollectionLink (ObjA)
      // then this.fieldLink = ObjB->FieldB
      // To find the corresponding field in ObjA, we do:
      // this.fieldLink.fieldLink  (ObjA->FieldA)

      this.settings.followDatacollectionID =
         values.settings.followDatacollectionID ||
         DefaultValues.settings.followDatacollectionID;
      // {string} .settings.followDatacollectionID
      // the uuid of another ABDataCollection that provides the follow cursor data collection

      this.settings.objectWorkspace = values.settings.objectWorkspace || {
         filterConditions:
            DefaultValues.settings.objectWorkspace.filterConditions,
         sortFields: DefaultValues.settings.objectWorkspace.sortFields,
      };
      // {obj} .settings.objectWorkspace
      // the default settings for what is shown in the AppBuilder's
      // DataCollection workspace

      this.settings.fixSelect = values.settings.fixSelect;

      // Convert to boolean
      this.settings.loadAll = JSON.parse(
         values.settings.loadAll || DefaultValues.settings.loadAll
      );
      // {bool} .settings.loadAll
      // do we load all the data at one time? false == load by pages.

      this.settings.isQuery = JSON.parse(
         values.settings.isQuery || DefaultValues.settings.isQuery
      );
      // {bool} .settings.isQuery
      // is the data source for this ABDataCollection based upon an
      // ABObjectQuery?

      this.settings.populate = (() => {
         // First check .populate
         if (values.settings.populate != undefined) {
            return values.settings.populate;
            // Then check legacy .preventPopulate
         } else if (
            values.settings.preventPopulate == true ||
            values.settings.preventPopulate == "1"
         ) {
            return false;
         } else return DefaultValues.settings.populate;
      })();
      // {bool | array} populate
      // Control whcih related connections to populate. Default, true, populates
      // all connections. False loads no connnections. Also accepts an array of
      // column names to load specefic connections.

      // Convert to number
      this.settings.syncType = parseInt(
         values.settings.syncType || DefaultValues.settings.syncType
      );
      // {int} .settings.syncType
      // how is the data between this ABDataCollection and it's
      // .datasource synced?

      this.__datasource = null;
      // {obj} .__datasource
      // the reference to the ABObject/ABObjectQuery that this ABDataCollection
      // is based off of.

      this.settings.datasourceID =
         values.settings.datasourceID || DefaultValues.settings.datasourceID;
      // {string} .settings.datasourceID
      // the uuid of the .__datasource object to use

      // now lookup and reference the proper datasource
      if (this.settings.datasourceID) {
         // check for an ABObject
         var obj = this.AB.objectByID(this.settings.datasourceID);
         if (!obj) {
            // this must be an ABObjectQuery then ...
            obj = this.AB.queryByID(this.settings.datasourceID);
         }

         if (obj) {
            this.__datasource = obj;
            this.settings.isQuery = obj.type === "query";
            if (this.settings.isQuery) {
               if (this.__datasource.isGroup) {
                  if (!this.__treeCollection)
                     this.__treeCollection = this._treeCollectionNew();
                  // {TreeCollection}
                  // This is a webix TreeCollection (or similar)
                  // keep it's implementation as part of the platform

                  this.__isGroup = true;
               }
            }
         } else {
            console.error(
               `ABDataCollection[${this.name}][${this.id}] unable to find datasource [${this.settings.datasourceID}]`
            );
         }
      }

      // // Populate data source: ABObject or ABObjectQuery
      // if (values.query && values.query[0]) {
      //    this.__datasource = new ABObjectQuery(
      //       values.query[0],
      //       this.application
      //    );
      //    this.settings.isQuery = true;

      //    if (this.__datasource.isGroup) {
      //       if (!this.__treeCollection)
      //          this.__treeCollection = this._treeCollectionNew();

      //       this.__isGroup = true;
      //    }
      // } else if (values.object && values.object[0]) {
      //    this.__datasource = new ABObject(values.object[0], this.application);
      //    this.settings.isQuery = false;
      // }

      // let the MLClass now process the translations:
      super.fromValues(values);
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj(); // untranslate the object

      return {
         id: this.id,
         name: this.name || this.label,
         type: this.type || "datacollection",
         settings: this.AB.cloneDeep(this.settings || {}),
         translations: obj.translations,
      };
   }

   /**
    * @method save()
    *
    * persist this instance of ABDatacollection with it's parent
    *
    *
    * @return {Promise}
    *      .resolve( {this} )
    */
   async save() {
      if (!this.id) {
         this.label = this.label || this.name;
      }
      await super.save();
      return this;
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABDatacollection
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy() {
      var removeFromApplications = () => {
         return new Promise((next, err) => {
            // this.AB.applications().then((apps) => {

            const apps = this.AB.applications();
            // NOTE: apps is a webix datacollection

            var allRemoves = [];

            var appsWithObject = apps.filter((a) => {
               return a.datacollectionsIncluded((o) => o.id == this.id);
            });
            appsWithObject.forEach((app) => {
               allRemoves.push(app.datacollectionRemove(this));
            });

            return Promise.all(allRemoves).then(next).catch(err);
            // });
         });
      };

      return Promise.resolve()
         .then(() => {
            return removeFromApplications();
         })
         .then(() => {
            return super.destroy();
         })
         .then(() => {
            this.emit("destroyed");
         });
   }

   /**
    * @property $dc
    * return the underlying webix datacollection
    * @return {webix.datacollection}
    */
   get $dc() {
      return this.__dataCollection;
   }

   /**
    * @property datasource
    * return a object of this component.
    *
    * @return {ABObject|ABObjectQuery}
    */
   get datasource() {
      if (!this.__datasource) {
         if (this.id && this.name) {
            // occassionally we have blank DCs (without .id or .name)
            // and I don't want to see errors for those
            var err = new Error(
               `DataCollection[${this.name}][${this.id}] missing reference datasource`
            );
            this.AB.notify("builder", err, { datacollection: this.toObj() });
         }
         return null;
      }
      var obj = this.AB.objectByID(this.__datasource.id);
      if (!obj) {
         obj = this.AB.queryByID(this.__datasource.id);
      }
      return obj;
   }

   /**
    * @property datasource
    * set a object to data collection
    *
    * @param {ABObject|ABObjectQuery} object
    */
   set datasource(object) {
      this.__datasource = object;

      this.refreshFilterConditions();
   }

   /**
    * @property sourceType
    * return type of source.
    *
    * @return {string} - 'object' or 'query'
    */
   get sourceType() {
      return this.settings.isQuery ? "query" : "object";
   }

   /**
    * @method datacollectionLink
    * return a ABDatacollection that link of this.
    *
    * @return {ABDatacollection}
    */
   get datacollectionLink() {
      if (!this.AB) return null;

      return this.AB.datacollectionByID(this.settings.linkDatacollectionID);
   }

   /**
    * @property fieldLink
    * return a ABFieldConnect field that link of this.
    *
    * @return {ABFieldConnect}
    */
   get fieldLink() {
      let object = this.datasource;
      if (!object) return null;

      return object.fieldByID(this.settings.linkFieldID);
   }

   /**
    * @property model
    * return a source model
    *
    * @return ABModel
    */
   get model() {
      if (!this.__model) {
         let object = this.datasource; // already notified

         this.__model = object ? object.model() : null;
      }
      return this.__model;
   }

   get dataStatusFlag() {
      return {
         notInitial: 0,
         initializing: 1,
         initialized: 2,
      };
   }

   get dataStatus() {
      return this._dataStatus;
   }

   get isDataInitialized() {
      return this.dataStatus == this.dataStatusFlag.initialized;
   }

   dataInitialized() {
      this._dataStatus = this.dataStatusFlag.initialized;
   }

   ///
   /// Cursor
   ///

   setCursor(itemId) {
      // If the static cursor is set, then this DC could not set cursor to other rows
      if (
         this.settings.fixSelect &&
         (this.settings.fixSelect != "_FirstRecordDefault" ||
            this.settings.fixSelect == itemId)
      )
         return;

      if (this.__treeCollection) {
         // set cursor of tree collection
         this.setCursorTree(itemId);

         // pull current row id
         let currTreeId = this.__treeCollection.getCursor();
         if (currTreeId) {
            let currTreeItem = this.__treeCollection.getItem(currTreeId);
            if (currTreeItem) itemId = currTreeItem._itemId;
         }
      }

      let dc = this.__dataCollection;
      if (dc) {
         // Store the old cursor id
         this.__previousCursorId = dc.getCursor();

         // clear cursor
         if (itemId == null) {
            dc.setCursor(null);
         }
         // If set rowId equal current cursor, it will not trigger .onAfterCursorChange event
         else if (dc.getCursor() == itemId) {
            this.emit("changeCursor", this.getCursor());
         }
         // set new cursor
         else if (dc.exists(itemId)) {
            dc.setCursor(itemId);
         }
      }
   }

   /**
    *
    * @param {string|number} itemId - Id of item or Id of row data
    */
   setCursorTree(itemId) {
      let tc = this.__treeCollection;
      if (tc && tc.getCursor() != itemId) {
         // If it is id of tree collection, then find row id of data
         let treeCursor = tc.find({ id: itemId }, true);
         if (treeCursor) {
            tc.setCursor(itemId);
         }
         // If it is not id of tree collection, then find/set root of data
         else {
            let treeItem = tc.find({ _itemId: itemId, $parent: 0 }, true);
            if (treeItem) tc.setCursor(treeItem.id);
            else tc.setCursor(null);
         }
      }
   }

   getCursor(treeCursor = false) {
      // Cursor of tree collection
      if (treeCursor && this.__treeCollection) {
         let currId = this.__treeCollection.getCursor();
         if (currId) {
            let currItem = this.__treeCollection.getItem(currId);

            // filter current id for serialize
            this.__treeCollection.filter(
               (item) => item._itemId == currItem._itemId
            );

            // pull item with child items
            let currItemAndChilds =
               this.__treeCollection.serialize()[0] || null;

            // refresh filter
            this.refreshLinkCursor();

            return currItemAndChilds;
         }
      }

      let dc = this.__dataCollection;
      if (dc == null) return null;

      let currId = dc.getCursor();
      let currItem = dc.getItem(currId);

      return currItem;
   }

   getFirstRecord() {
      var dc = this.__dataCollection;
      if (dc == null) return null;

      var currId = dc.getFirstId();
      var currItem = dc.getItem(currId);

      return currItem;
   }

   getNextRecord(record) {
      var dc = this.__dataCollection;
      if (dc == null) return null;

      var currId = dc.getNextId(record.id);
      var currItem = dc.getItem(currId);

      return currItem;
   }

   /**
    * @method refreshLinkCursor
    *    If the data collection is bound to another and it is the child connection
    *    it finds it's parents current set cursor and then filters its data
    *    based off of the cursor.
    *
    *    In cases where a DC has set .loadAll, our job is to filter existing data
    *    that is already loaded in the internal __dataCollection.
    *
    *    Otherwise this is not the place to trigger a data refresh.  We depend
    *    on other mechanisms (.reloadData(), datacollection .select()) to trigger
    *    an update.
    */
   refreshLinkCursor(force = false) {
      // our filter conditions need to know there was an updated cursor.
      // some of our filters are based upon our linked data.
      this.refreshFilterConditions();

      // NOTE: If DC does not set load all data, then it does not need to filter by the parent DC.
      // because it fetch data when the cursor of the parent DC changes.
      if (!this.settings.loadAll && !force) return;

      // do not set the filter unless this dc is initialized "dataStatusFlag==2"
      // if (this.dataStatus != this.dataStatusFlag.initialized) return;

      // filter the data in the data collection
      // using its parents current cursor because all the data in this child
      // data collection has been loaded and the frontend can decide what is
      // seen or not seen
      let linkCursor;
      let dvLink = this.datacollectionLink;
      if (dvLink) {
         linkCursor = dvLink.getCursor();
      }

      let filterData = (rowData) => {
         // This row is not loaded yet. It will be loaded when scrolling.
         if (rowData == null) return true;

         // if link dc cursor is null:
         // ... if there's no parent show all data
         // ... if we have a parent hide all data - address cases where user see
         //     unexpected data (ns_app#318) - should this be a DC setting?
         if (!linkCursor) return dvLink ? false : true;
         else return this.isParentFilterValid(rowData);
      };

      if (this.__dataCollection) this.__dataCollection.filter(filterData);
      if (this.__treeCollection) this.__treeCollection.filter(filterData);
   }

   setStaticCursor() {
      if (this.settings.fixSelect) {
         // set cursor to the current user
         if (this.settings.fixSelect == "_CurrentUser") {
            var username = this.currentUserUsername();
            var userFields = this.datasource.fields((f) => f.key == "user");

            // find a row that contains the current user
            var row = this.__dataCollection.find((r) => {
               var found = false;

               userFields.forEach((f) => {
                  if (found || r[f.columnName] == null) return;

                  if (r[f.columnName].filter) {
                     // Array - isMultiple
                     found =
                        r[f.columnName].filter((data) => data.id == username)
                           .length > 0;
                  } else if (r[f.columnName] == username) {
                     found = true;
                  }
               });

               return found;
            }, true);

            // set a first row of current user to cursor
            if (row) {
               this.__dataCollection.setCursor(row.id);

               this.setCursorTree(row.id);
            }
         } else if (
            this.settings.fixSelect == "_FirstRecord" ||
            this.settings.fixSelect == "_FirstRecordDefault"
         ) {
            // // find a row that contains the current user
            // var row = this.__dataCollection.find((r) => {

            //  var found = false;
            //  if (!found) {
            //    found = true;
            //    return true; // just give us the first record
            //  }

            // }, true);

            // // set a first row of current user to cursor
            // if (row)
            //  this.__dataCollection.setCursor(row.id);

            let currRowId = this.__dataCollection.getCursor();
            if (
               !currRowId ||
               (currRowId && !this.__dataCollection.exists(currRowId))
            ) {
               // If current cursor is filtered by parent DC, then select new cursor

               // set a first row to cursor
               let rowId = this.__dataCollection.getFirstId();
               // if (rowId) {
               this.__dataCollection.setCursor(rowId || null);

               // NOTE: differnece between ab_platform_web and ab_platform_pwa
               if (
                  this.__dataCollection.data?.count?.() == 0 ||
                  this.__dataCollection.data?.length == 0
               ) {
                  this.emit("collectionEmpty", {});
               }

               this.setCursorTree(rowId);
               // }
            }
         } else {
            this.__dataCollection.setCursor(this.settings.fixSelect);

            this.setCursorTree(this.settings.fixSelect);
         }
      }

      // Set the cursor to the first row
      if (this.isCursorFollow) {
         const rowId = this.__dataCollection.getFirstId();
         this.setCursor(rowId || null);
         this.setCursorTree(rowId || null);

         // If no data but the parent DC set cursor, then this should be reload data.
         const dcFollow = this.datacollectionFollow;
         if (!rowId && dcFollow?.getCursor()) {
            this.loadData();
         }
      }
   }

   ///
   /// Data
   ///

   /**
    * @method filterCondition()
    * Provide a temporary filter condition to modify the data we are returning.
    * Used by User search criterias.
    * @param {json} cond
    *        A valid QueryCondition to filter the response.
    */
   filterCondition(cond = null) {
      this.__filterCond = cond;
   }

   init() {
      // prevent initialize many times
      if (this.initialized) return;
      this.initialized = true;

      if (!this.__dataCollection.___AD.onAfterCursorChange) {
         this.__dataCollection.___AD.onAfterCursorChange =
            this.__dataCollection.attachEvent("onAfterCursorChange", () => {
               // debugger;
               var currData = this.getCursor();

               this.emit("changeCursor", currData);
            });
      }

      // relate data functions
      let isRelated = (relateData, rowId, PK = "id") => {
         if (Array.isArray(relateData)) {
            return relateData.filter((v) => (v[PK] || v) == rowId).length > 0;
         } else {
            return relateData && (relateData[PK] || relateData) == rowId;
         }
      };

      // events
      this.on("ab.datacollection.create", (data) => {
         // NOTE: UPDATing this process to add another check.
         // .isCursorFollow only invalidates the 1st half of the routine.
         // .isCursorFollow STILL needs to follow the 2nd half of the routine
         // // If this DC is following cursor for other DC, then it should not add the new item to their list.
         // if (this.isCursorFollow) return;

         let obj = this.datasource;
         if (!obj) return;

         if (!data || !data.data) return;

         let needAdd = false;
         let updatedVals = [];

         // Don't do First Step if .isCursorFollow
         if (!this.isCursorFollow) {
            // First Step
            // Does this new entry need to be part of the data we are currently
            // tracking?  If so, add it.
            Promise.resolve()
               .then(() => {
                  return new Promise((next, bad) => {
                     // Query
                     if (obj instanceof this.AB.Class.ABObjectQuery) {
                        let objList =
                           obj.objects((o) => o.id == data.objectId) || [];

                        needAdd = objList.length > 0;

                        if (!needAdd) return next();

                        let where = {
                           glue: "or",
                           rules: [],
                        };

                        objList.forEach((o) => {
                           let newDataId = data.data[`${o.PK()}`];
                           if (!newDataId) return;

                           where.rules.push({
                              key: `${
                                 o.alias || obj.objectAlias(o.id)
                              }.${o.PK()}`,
                              rule: "equals",
                              value: newDataId,
                           });
                        });

                        obj.model()
                           .findAll({
                              where: where,
                           })
                           .then((newQueryData) => {
                              updatedVals = newQueryData.data || [];
                              updatedVals.forEach((v) => {
                                 delete v.id;
                              });

                              next();
                           })
                           .catch(bad);
                     }
                     // Object
                     else {
                        needAdd = obj.id == data.objectId;
                        updatedVals = [data.data];
                        next();
                     }
                  });
               })
               .then(() => {
                  if (needAdd) {
                     (updatedVals || []).forEach((updatedV) => {
                        // If this DC uses a query, it pulls refreshed data from the server in the previous step,
                        // so there is no need to recheck the query's filter.
                        const skipDatasourceFilter =
                           obj instanceof this.AB.Class.ABObjectQuery;

                        // filter condition before add
                        if (!this.isValidData(updatedV, skipDatasourceFilter))
                           return;

                        // filter the cursor of parent DC
                        const dcLink = this.datacollectionLink;
                        if (dcLink && !this.isParentFilterValid(updatedV))
                           return;

                        // check to see if item already exisits in data collection
                        // and check to see that we are not loading the data serverside from cursor
                        if (
                           !this.__dataCollection.exists(
                              updatedV[`${obj.PK()}`]
                           ) &&
                           !this.__reloadWheres
                        ) {
                           this.__dataCollection.add(updatedV, 0);
                           this.emit("create", updatedV);
                           // this.__dataCollection.setCursor(rowData.id);
                        } else if (
                           !this.__dataCollection.exists(
                              updatedV[`${obj.PK()}`]
                           ) &&
                           this.__reloadWheres
                        ) {
                           // debugger;
                           if (this.isParentFilterValid(updatedV)) {
                              // we track bound components and flexlayout components
                              var attachedComponents =
                                 this.__bindComponentIds.concat(
                                    this.__flexComponentIds
                                 );
                              attachedComponents.forEach((bcids) => {
                                 // if the reload button already exisits move on
                                 if ($$(bcids + "_reloadView")) {
                                    return false;
                                 }

                                 // find the position of the data view
                                 var pos = 0;
                                 var parent = $$(bcids).getParentView();
                                 if ($$(bcids).getParentView().index) {
                                    pos = $$(bcids)
                                       .getParentView()
                                       .index($$(bcids));
                                 } else if (
                                    $$(bcids).getParentView().getParentView()
                                       .index
                                 ) {
                                    // this is a data view and it is inside a
                                    // scroll view that is inside an accodion
                                    // so we need to go deeper to add the button
                                    parent = $$(bcids)
                                       .getParentView()
                                       .getParentView();
                                    pos = $$(bcids)
                                       .getParentView()
                                       .getParentView()
                                       .index($$(bcids).getParentView());
                                 }

                                 // store the datacollection so we can pass it to the button later
                                 var DC = this;
                                 // add a button that reloads the view when clicked
                                 if (parent.addView) {
                                    var L = this.AB.Label();
                                    parent.addView(
                                       {
                                          id: bcids + "_reloadView",
                                          view: "button",
                                          value: L(
                                             "New data available. Click to reload."
                                          ),
                                          css: "webix_primary webix_warn",
                                          click: function (id, event) {
                                             DC.reloadData();
                                             $$(id)
                                                .getParentView()
                                                .removeView(id);
                                          },
                                       },
                                       pos
                                    );
                                 }
                              });
                              // this.emit("create", updatedV);
                           }
                        }
                     });

                     if (
                        this.__treeCollection // && this.__treeCollection.exists(updatedVals.id)
                     ) {
                        this.parseTreeCollection({
                           data: updatedVals,
                        });
                     }
                  }

                  // ABObject only
                  if (!(obj instanceof this.AB.Class.ABObjectQuery)) {
                     // if it is a linked object
                     let connectedFields = this.datasource.connectFields(
                        (f) =>
                           f.datasourceLink &&
                           f.datasourceLink.id == data.objectId
                     );

                     // It should always be only one item for ABObject
                     updatedVals = updatedVals[0];

                     // update relation data
                     if (
                        updatedVals &&
                        connectedFields &&
                        connectedFields.length > 0
                     ) {
                        // various PK name
                        let PK = connectedFields[0].object.PK();
                        if (!updatedVals.id && PK != "id")
                           updatedVals.id = updatedVals[PK];

                        this.__dataCollection.find({}).forEach((d) => {
                           let updateItemData = {};

                           connectedFields.forEach((f) => {
                              var updateRelateVal = {};
                              if (f && f.fieldLink) {
                                 updateRelateVal =
                                    updatedVals[f.fieldLink.relationName()] ||
                                    {};
                              }

                              let rowRelateVal = d[f.relationName()] || {};

                              let valIsRelated = isRelated(
                                 updateRelateVal,
                                 d.id,
                                 PK
                              );

                              // Relate data
                              if (
                                 Array.isArray(rowRelateVal) &&
                                 rowRelateVal.filter(
                                    (v) =>
                                       v == updatedVals.id ||
                                       v.id == updatedVals.id ||
                                       v[PK] == updatedVals.id
                                 ).length < 1 &&
                                 valIsRelated
                              ) {
                                 rowRelateVal.push(updatedVals);

                                 updateItemData[f.relationName()] =
                                    rowRelateVal;
                                 updateItemData[f.columnName] = updateItemData[
                                    f.relationName()
                                 ].map((v) => v.id || v[PK] || v);
                              } else if (
                                 !Array.isArray(rowRelateVal) &&
                                 (rowRelateVal != updatedVals.id ||
                                    rowRelateVal.id != updatedVals.id ||
                                    rowRelateVal[PK] != updatedVals.id) &&
                                 valIsRelated
                              ) {
                                 updateItemData[f.relationName()] = updatedVals;
                                 updateItemData[f.columnName] =
                                    updatedVals.id || updatedVals;
                              }
                           });

                           // If this item needs to update
                           if (Object.keys(updateItemData).length > 0) {
                              this.__dataCollection.updateItem(
                                 d.id,
                                 updateItemData
                              );

                              if (this.__treeCollection)
                                 this.__treeCollection.updateItem(
                                    d.id,
                                    updateItemData
                                 );

                              this.emit(
                                 "update",
                                 this.__dataCollection.getItem(d.id)
                              );
                           }
                        });
                     }
                  }

                  this.updateRelationalDataFromLinkDC(data.objectId, data.data);
                  // filter link data collection's cursor
                  this.refreshLinkCursor();
                  this.setStaticCursor();
               });
         }

         // SECOND Step:
         // Try to detect if this newly created entry connects to one of the
         // values this DC is currently managing.  If so, than add this value
         // to the connection.

         let incomingObj = this.AB.objectByID(data.objectId);
         if (!incomingObj) return;

         // find any of incomingObj connections that are tied to my object:
         let connectedFields = incomingObj
            .connectFields((f) => f.datasourceLink?.id == obj.id)
            .filter((f) => f); // <-- safety check, no undefined or nulls
         if (connectedFields.length == 0) return;

         let iPK = incomingObj.PK();
         let PK = obj.PK();
         let newData = this.AB.cloneDeep(data.data);

         let currCursor = this.getCursor();
         let needsRefresh = false;

         connectedFields.forEach((f) => {
            // pull the values in this connected fields
            let values = data.data[f.columnName]; // just need the PK

            if (!Array.isArray(values))
               values = [values].filter((v) => !this.AB.isNil(v));

            values.forEach((v) => {
               v = v[PK] || v; // just in case this was an {} and not the {uuid}

               // if this is one of the items we are managing
               if (this.__dataCollection.exists(v)) {
                  let localField = f.fieldLink;
                  if (localField) {
                     let row = this.__dataCollection.getItem(v);
                     let colName = localField.columnName;
                     let relName = localField.relationName();

                     if (localField.linkType() == "many") {
                        if (!Array.isArray(row[colName])) {
                           row[colName] = [row[colName]].filter(
                              (r) => !this.AB.isNil(r)
                           );
                        }
                        // if it isn't already in the array, add it
                        let rval = localField.getRelationValue(newData);
                        if (row[colName].indexOf(rval) == -1) {
                           row[colName].push(rval);
                        }

                        if (!Array.isArray(row[relName])) {
                           row[relName] = [row[relName]].filter(
                              (r) => !this.AB.isNil(r)
                           );
                        }
                        if (
                           row[relName].filter((r) => r[iPK] == newData[iPK])
                              .length == 0
                        ) {
                           row[relName].push(newData);
                        }
                     } else {
                        row[colName] = localField.getRelationValue(newData);
                        row[relName] = newData;
                     }

                     // pass updated data back into DC:
                     this.__dataCollection.updateItem(v, row);

                     if (this.__treeCollection)
                        this.__treeCollection.updateItem(v, row);

                     this.emit("update", this.__dataCollection.getItem(v));

                     // if we just updated our Current Cursor, we need to
                     // let our connected DC's know to refresh.
                     if (currCursor?.id == v) {
                        needsRefresh = true;
                     }
                  }
               }
            });
         });

         if (needsRefresh) {
            this.emit("cursorStale", null);
         }
      });

      this.on("ab.datacollection.connection-added", (data) => {
         // This event notifies us of a specific relation being created between
         // two records. In this case the source object that was originally
         // operated on, is sent along in data.data.
         //
         // eg: if this was a `create` operation, the newly created value is
         //     included in data.data.
         // eg: if this was an `update` operation, the row that was modified
         //     is included.
         //
         // {json} data
         // incoming socket payload:
         // data.objectID {string}
         //      the ABObject this connection is being added to
         // data.fieldID  {string}
         //      which connect Field in this ABObject the value is added to
         // data.rowID    {string}
         //      which specific row/entry this is being added to
         // data.data     {json}
         //      The value being added.
         //

         let obj = this.datasource;
         if (!obj) return;

         if (!data.rowID) return;

         // ABObject only
         if (!(obj instanceof this.AB.Class.ABObjectQuery)) {
            // if this is the object we are managing
            if (obj.id === data.objectID) {
               let field = obj.fieldByID(data.fieldID);
               if (field) {
                  // figure out if we actually have the value that was changed:
                  let isExists = this.__dataCollection.exists(data.rowID);
                  if (isExists) {
                     let newData = this.AB.cloneDeep(data.data);
                     let row = this.__dataCollection.getItem(data.rowID);

                     let colName = field.columnName;
                     let relName = field.relationName();

                     if (field.linkType() == "many") {
                        if (!Array.isArray(row[colName])) {
                           // in case row[col]:{obj} this will make sure it
                           // is included as an [ {obj} ], but will also prevent
                           // [ undefined ] if row[col] isn't set:
                           row[colName] = [row[colName]].filter(
                              (r) => !this.AB.isNil(r)
                           );
                        }
                        row[colName].push(field.getRelationValue(newData));

                        if (!Array.isArray(row[relName])) {
                           row[relName] = [row[relName]].filter(
                              (r) => !this.AB.isNil(r)
                           );
                        }
                        row[relName].push(newData);
                     } else {
                        row[colName] = field.getRelationValue(newData);
                        row[relName] = newData;
                     }

                     // pass updated data back into DC:
                     this.__dataCollection.updateItem(data.rowID, row);

                     if (this.__treeCollection)
                        this.__treeCollection.updateItem(data.rowID, row);

                     this.emit(
                        "update",
                        this.__dataCollection.getItem(data.rowID)
                     );
                  }
               }
            }
         } else if (obj instanceof this.AB.Class.ABObjectQuery) {
            // ABQuery

            // NOTE: that in this case, if this change is about one of the
            // objects we track, we will most likely have to reload the data
            // to make sure we are displaying proper data.

            // This will follow the same logic as in "ab.datacollection.create"
            // so instead of repeating that here, let's call our "create"
            // handler instead:

            ///// LEFT OFF HERE:
            // need to pull out the data in data.data that represents the
            // connection to data.objectId

            //// WAIT!!!!!!
            //// Instead, of this "connection-added", lets add the logic in
            //// a "created" handler to detect if we should add the new entry
            //// into A value we currently track.
            //// ===> This way we only have to send out "Created" messages
            ////

            let newPacket = {
               objectId: data.objectId,
               data: this.AB.cloneDeep(data.data),
            };
            this.emit("ab.datacollection.create", newPacket);
         }
      });

      this.on("ab.datacollection.update", (data) => {
         // {json} data
         // incoming socket payload:
         // data.objectId {string} uuid of the ABObject that was updated
         // data.data {json} the new updated value of that row entry.

         let obj = this.datasource;
         if (!obj) return;

         // updated values
         let values = data.data;
         if (!values) return;

         // #Johnny: removing this check.  A DC that is following another cursor
         // still has a value that might need updating.
         // DC who is following cursor should update only current cursor.
         // if (
         //    this.isCursorFollow &&
         //    this.getCursor()?.id != (values[obj.PK()] ?? values.id)
         // ) {
         //    return;
         // }

         let needUpdate = false;
         let skipDatasourceFilter = false;
         let isExists = false;
         let updatedIds = [];
         // {array}
         // an array of the row indexs in our DataCollection that have values
         // that need to be updated.

         let updatedTreeIds = [];
         let updatedVals = {};

         //
         // Case 1: This DC contains the value that was updated
         // In this case, we want to replace our current entry with
         // the new one passed in.
         // EX: This is a DC of Users, and the incoming Entry is a User
         // that we are already displaying.
         //

         // Query
         if (obj instanceof this.AB.Class.ABObjectQuery) {
            let objList = obj.objects((o) => o.id == data.objectId) || [];
            needUpdate = objList.length > 0;
            if (needUpdate) {
               // NOTE: Data needs to be updated in the query even if it doesn't match the filter conditions.
               skipDatasourceFilter =
                  obj instanceof this.AB.Class.ABObjectQuery;

               (objList || []).forEach((o) => {
                  updatedIds = updatedIds.concat(
                     this.__dataCollection
                        .find((item) => {
                           return (
                              item[
                                 `${this.datasource.objectAlias(
                                    o.id
                                 )}.${o.PK()}`
                              ] == (values[o.PK()] || values.id)
                           );
                        })
                        .map((o) => o.id) || []
                  );

                  // grouped queries
                  if (this.__treeCollection) {
                     updatedTreeIds = updatedTreeIds.concat(
                        this.__treeCollection
                           .find((item) => {
                              return (
                                 item[
                                    `${this.datasource.objectAlias(
                                       o.id
                                    )}.${o.PK()}`
                                 ] == (values[o.PK()] || values.id)
                              );
                           })
                           .map((o) => o.id) || []
                     );
                  }
               });

               isExists = updatedIds.length > 0;

               updatedVals = this._queryUpdateData(objList, values);
            }
         }
         // Object
         else {
            needUpdate = obj.id == data.objectId;
            if (needUpdate) {
               // various PK name
               if (!values.id && obj.PK() != "id") values.id = values[obj.PK()];

               updatedIds.push(values.id);

               isExists = this.__dataCollection.exists(values.id);
               updatedVals = values;
            }
         }

         // if it is the source object
         if (needUpdate) {
            if (isExists) {
               if (this.isValidData(updatedVals, skipDatasourceFilter)) {
                  // only spread around cloned copies because some objects (I'm
                  // looking at you ABFieldUser) will modify some data for local
                  // usage.
                  updatedVals = this.AB.cloneDeep(updatedVals);
                  if (this.__dataCollection) {
                     updatedIds = this.AB.uniq(updatedIds);
                     updatedIds.forEach((itemId) => {
                        this.__dataCollection.updateItem(itemId, updatedVals);
                     });
                  }

                  if (this.__treeCollection) {
                     // update data in tree
                     updatedTreeIds = this.AB.uniq(updatedTreeIds);
                     updatedTreeIds.forEach((itemId) => {
                        this.__treeCollection.updateItem(itemId, updatedVals);
                     });
                  }

                  this.emit("update", updatedVals);

                  // If the update item is current cursor, then should tell components to update.
                  let currData = this.getCursor();
                  if (currData?.id == updatedVals.id) {
                     this.emit("cursorStale", currData);
                  }
               } else {
                  // Johnny: Here we are simply removing the DataCollection Entries that are
                  // no longer valid.
                  // Just cycle through the collected updatedIds and remove them.
                  let currData = this.getCursor();
                  updatedIds.forEach((id) => {
                     // If the item is current cursor, then the current cursor should be cleared.

                     if (currData?.id == id) this.emit("cursorStale", null);

                     this.__dataCollection.remove(id);
                     this.__totalCount--;

                     // TODO: update tree list
                     // if (this.__treeCollection) {
                     //  this.__treeCollection.remove(id);
                     // }

                     this.emit("delete", id);
                  });
               }
            }
            // filter before add new record
            else if (this.isValidData(updatedVals)) {
               // OK we have a value, that COULD be in our DC
               // before we add it, let's make sure we are not limited in our selection of items:
               if (!this.isCursorFollow && !this.settings.fixSelect) {
                  // this means the updated record was not loaded yet so we are adding it to the top of the grid
                  // the placement will probably change on the next load of the data
                  this.__dataCollection.add(updatedVals, 0);

                  if (this.__treeCollection)
                     this.parseTreeCollection({
                        data: [updatedVals],
                     });

                  this.emit("create", updatedVals);
               }
            }
         }

         //
         // Case 2: This DC has entries that CONNECT to the updated value.
         // We need to make sure our connections, properly reflect the
         // current state of the incoming data.
         //
         // EG: This DC is a list of Roles that connect to User, and an updated
         // User is passed in.

         let currCursor = this.getCursor();
         let updateCursor = null;

         // if it is a linked object
         // look for connected fields that link to the incoming objectId
         let connectedFields = obj.connectFields(
            (f) => f.datasourceLink && f.datasourceLink.id == data.objectId
         );

         // update relation data
         if (
            obj instanceof this.AB.Class.ABObject &&
            connectedFields?.length > 0
         ) {
            // various PK name
            // webix datacollections require an .id value, so make sure
            // this incoming value has an .id set
            let PK = obj.PK();
            if (!values.id && PK != "id") values.id = values[PK];

            if (this.__dataCollection.count() > 0) {
               this.__dataCollection.find({}).forEach((d) => {
                  let updateItemData = {
                     id: d.id,
                  };

                  connectedFields.forEach((f) => {
                     if (!f) return;

                     let updateRelateVal = {};
                     let rowRelateVal = d[f.relationName()] || {};

                     if (f.fieldLink)
                        updateRelateVal =
                           values[f.fieldLink.relationName()] || {};

                     // check to see if we are supposed to be related to this
                     let valIsRelated = isRelated(updateRelateVal, d.id, PK);

                     // If NO, then make sure we Unrelate data
                     // if this is an array -> filter out the entry
                     if (
                        Array.isArray(rowRelateVal) &&
                        rowRelateVal.filter(
                           (v) =>
                              v == values.id ||
                              v.id == values.id ||
                              v[PK] == values.id
                        ).length > 0 &&
                        !valIsRelated
                     ) {
                        updateItemData[f.relationName()] = rowRelateVal.filter(
                           // NOTE: Special case: the incoming value.id will be .uuid
                           // however in case of User Fields, v.id == username and not .uuid
                           // so we put our default check to be v[PK] here to play nice
                           (v) => (v[PK] || v.id || v) != values.id
                        );
                        updateItemData[f.columnName] = updateItemData[
                           f.relationName()
                        ].map((v) => v.id || v[PK] || v);
                     } else if (
                        // this is not an array so set link to null
                        !Array.isArray(rowRelateVal) &&
                        (rowRelateVal == values.id ||
                           rowRelateVal.id == values.id ||
                           rowRelateVal[PK] == values.id) &&
                        !valIsRelated
                     ) {
                        updateItemData[f.relationName()] = null;
                        updateItemData[f.columnName] = null;
                     }

                     // However, if we are supposed to be related => make sure we are
                     // If this is an array, then add to list
                     // AND YES: make sure it is cloned
                     if (valIsRelated) {
                        values = this.AB.cloneDeep(values);
                     }
                     if (Array.isArray(rowRelateVal) && valIsRelated) {
                        // update relate data
                        if (
                           rowRelateVal.filter(
                              (v) =>
                                 v == values.id ||
                                 v.id == values.id ||
                                 v[PK] == values.id
                           ).length > 0
                        ) {
                           // just update the one entry in my array with the new
                           // value
                           rowRelateVal.forEach((v, index) => {
                              if (
                                 v == values.id ||
                                 v.id == values.id ||
                                 v[PK] == values.id
                              )
                                 rowRelateVal[index] = values;
                           });
                        }
                        // add new relate
                        else {
                           rowRelateVal.push(values);
                        }

                        updateItemData[f.relationName()] = rowRelateVal;
                        updateItemData[f.columnName] = updateItemData[
                           f.relationName()
                        ].map(
                           (v) => f.getRelationValue(v) /*v.id || v[PK] || v*/
                        );
                     } else if (
                        !Array.isArray(rowRelateVal) &&
                        (rowRelateVal != values.id ||
                           rowRelateVal.id != values.id ||
                           rowRelateVal[PK] != values.id) &&
                        valIsRelated
                     ) {
                        updateItemData[f.relationName()] = values;
                        // make ConnectedField use .getRelationValue() here!
                        updateItemData[f.columnName] =
                           f.getRelationValue(values);
                     }
                  });

                  // If this item needs to update
                  // meaning there is > 1 key in the object (we always have .id)
                  if (Object.keys(updateItemData).length > 1) {
                     // normalize data before add to data collection
                     // UPDATE: this should already have happened in NetworkRestSocket
                     // when the initial data is received.

                     // NOTE: We could not normalize relational data because they are not full data
                     // Merge update data to exists data instead

                     if (this.__treeCollection?.exists(d.id)) {
                        const treeItem = Object.assign(
                           this.__treeCollection.getItem(d.id),
                           updateItemData
                        );
                        this.__treeCollection.updateItem(d.id, treeItem);
                     }

                     if (this.__dataCollection?.exists(d.id)) {
                        const dcItem = Object.assign(
                           this.__dataCollection.getItem(d.id),
                           updateItemData
                        );
                        this.__dataCollection.updateItem(d.id, dcItem);
                        this.emit(
                           "update",
                           this.__dataCollection.getItem(d.id)
                        );
                        if (currCursor?.id == dcItem.id) {
                           updateCursor = dcItem;
                        }
                     }
                  }
               });
            }
         }

         //
         // Case 3: Our DC is linked to a DC that was effected by this update.
         //
         // We will approach it from another direction, if the current DC made
         // an update to it's current Cursor, then we will emit a "cursorStale"
         // event, so our linked DCs will update themselves with the new value:
         if (updateCursor) {
            this.emit("cursorStale", null);
         }
         // this.updateRelationalDataFromLinkDC(data.objectId, values);
         this.refreshLinkCursor();

         this.setStaticCursor();
      });

      // We are subscribing to notifications from the server that an item may be stale and needs updating
      // We will improve this later and verify that it needs updating before attempting the update on the client side
      this.on("ab.datacollection.stale", (data) => {
         // debugger;
         // if we don't have a datasource or model, there is nothing we can do here:
         // Verify the datasource has the object we are listening for if not just stop here
         if (
            !this.datasource ||
            !this.model ||
            this.datasource.id != data.objectId
         ) {
            return;
         }

         // updated values
         var values = data.data;

         if (!values) return;

         // use the Object's defined Primary Key:
         var PK = this.model.object.PK();
         if (!values[PK]) {
            PK = "id";
         }

         // DC who is following cursor should update only current cursor.
         if (
            this.isCursorFollow &&
            this.getCursor()?.[PK] != (values[PK] ?? values?.id)
         ) {
            return;
         }

         if (values) {
            if (this.__dataCollection.exists(values[PK])) {
               var cond = { where: {} };
               cond.where[PK] = values[PK];
               // this data collection has the record so we need to query the server to find out what it's latest data is so we can update all instances
               this.model.staleRefresh(cond).then((res) => {
                  // check to make sure there is data to work with
                  if (Array.isArray(res.data) && res.data.length) {
                     // debugger;
                     let obj = this.datasource;
                     if (!obj) return;
                     // normalize data before add to data collection

                     // UPDATE: this should already have happened in NetworkRestSocket
                     // when the initial data is received.
                     //var model = obj.model();
                     // model.normalizeData(res.data[0]);

                     // tell the webix data collection to update using their API with the row id (values.id) and content (res.data[0])
                     if (this.__dataCollection.exists(values[PK])) {
                        this.__dataCollection.updateItem(
                           values[PK],
                           res.data[0]
                        );
                     }

                     // If the update item is current cursor, then should tell components to update.
                     var currData = this.getCursor();
                     if (currData?.[PK] == values[PK]) {
                        this.emit("cursorStale", currData);
                     }
                  } else {
                     // If there is no data in the object then it was deleted...lets clean things up
                     // If the deleted item is current cursor, then the current cursor should be cleared.
                     var currId = this.getCursor();
                     if (currId == values[PK]) this.emit("cursorStale", null);

                     this.__dataCollection.remove(values[PK]);
                     this.__totalCount--;
                     this.emit("delete", values[PK]);
                  }
               });
            }
         }

         // filter link data collection's cursor
         this.refreshLinkCursor();
         this.setStaticCursor();
      });

      this.on("ab.datacollection.delete", (data) => {
         // debugger;
         let obj = this.datasource;
         if (!obj) return;

         let deleteId = data.data;
         let needDelete = false;
         let deletedIds = [];
         let deletedTreeIds = [];

         // Query
         if (obj instanceof this.AB.Class.ABObjectQuery) {
            let objList = obj.objects((o) => o.id == data.objectId) || [];
            needDelete = objList.length > 0;
            if (needDelete) {
               (objList || []).forEach((o) => {
                  deletedIds =
                     this.__dataCollection
                        .find((item) => {
                           return item[`${o.alias}.${o.PK()}`] == deleteId;
                        })
                        .map((o) => o.id) || [];

                  // grouped queries
                  if (this.__treeCollection) {
                     deletedTreeIds =
                        this.__treeCollection
                           .find((item) => {
                              return item[`${o.alias}.${o.PK()}`] == deleteId;
                           })
                           .map((o) => o.id) || [];
                  }
               });
            }
         }
         // Object
         else {
            needDelete = obj.id == data.objectId;
            if (needDelete) {
               deletedIds.push(deleteId);
            }
         }

         // if it is the source object
         if (needDelete) {
            // If the deleted item is current cursor, then the current cursor should be cleared.
            var currData = this.getCursor();

            deletedIds.forEach((delId) => {
               if (currData?.[obj.PK()] == delId)
                  this.emit("cursorStale", null);

               if (this.__dataCollection.exists(delId))
                  this.__dataCollection.remove(delId);
               this.__totalCount--;
            });

            if (this.__treeCollection) {
               deletedTreeIds.forEach((delId) => {
                  if (this.__treeCollection.exists(delId))
                     this.__treeCollection.remove(delId);
                  this.__totalCount--;
               });
            }

            if (deletedIds[0]) this.emit("delete", deletedIds[0]);
         }

         // if it is a linked object
         let connectedFields = obj.connectFields(
            (f) => f.datasourceLink && f.datasourceLink.id == data.objectId
         );

         // update relation data
         if (
            obj instanceof this.AB.Class.ABObject &&
            connectedFields &&
            connectedFields.length > 0
         ) {
            // various PK name
            let PK = connectedFields[0].object.PK();

            this.__dataCollection.find({}).forEach((d) => {
               let updateRelateVals = {};

               connectedFields.forEach((f) => {
                  let relateVal = d[f.relationName()];
                  if (relateVal == null) return;

                  if (
                     Array.isArray(relateVal)
                     // JOHNNY: for speed improvements, don't make this check:
                     // just do it and that will reduce 1x through the array.
                     // &&
                     // relateVal.filter(
                     //    (v) =>
                     //       v == deleteId ||
                     //       v.id == deleteId ||
                     //       v[PK] == deleteId
                     // ).length > 0
                  ) {
                     updateRelateVals[f.relationName()] = relateVal.filter(
                        (v) => (v.id || v[PK] || v) != deleteId
                     );
                     updateRelateVals[f.columnName] = updateRelateVals[
                        f.relationName()
                     ].map((v) => v.id || v[PK] || v);
                  } else if (
                     relateVal == deleteId ||
                     relateVal.id == deleteId ||
                     relateVal[PK] == deleteId
                  ) {
                     updateRelateVals[f.relationName()] = null;
                     updateRelateVals[f.columnName] = null;
                  }
               });

               // If this item needs to update
               if (Object.keys(updateRelateVals).length > 0) {
                  // normalize data before add to data collection

                  // var model = obj.model();
                  // model.normalizeData(updateRelateVals);

                  this.__dataCollection.updateItem(d.id, updateRelateVals);

                  if (this.__treeCollection)
                     this.__treeCollection.updateItem(d.id, updateRelateVals);

                  this.emit("update", this.__dataCollection.getItem(d.id));
               }
            });
         }
      });

      // add listeners when cursor of link data collection is changed
      const linkDC = this.datacollectionLink;
      // if (linkDC && this.settings.loadAll) {
      if (linkDC) {
         this.eventAdd({
            emitter: linkDC,
            eventName: "changeCursor",
            listener: (currentCursor) => {
               // NOTE: we can clear data here to update UI display, then data will be fetched when webix.dataFeed event
               if (
                  !this.settings?.loadAll &&
                  currentCursor?.id != linkDC.previousCursorId
               )
                  this.clearAll();

               this.refreshLinkCursor();
               this.setStaticCursor();
            },
         });

         this.eventAdd({
            emitter: linkDC,
            eventName: "cursorStale",
            listener: (currentCursor) => {
               // cursorStale : the current cursor hasn't CHANGED, but the data
               // of that value has changed.
               // This is triggered by one of our socket updates that detects
               // changes to the cursor data.

               // if don't have .loadAll set,  we'll need to update our data:
               if (!this.settings?.loadAll) {
                  // What I do here depends on what my linked DC has set for
                  // it's .loadConnections (shouldPopulate) value
                  let dvLink = this.datacollectionLink;
                  let isMyDataThere = dvLink.shouldPopulate;
                  if (Array.isArray(isMyDataThere)) {
                     // if this was an array: it should be an array of columnNames
                     // of the dvLink that are being populated.

                     // the column I'm interested in:
                     let colName = this.fieldLink.fieldLink.columnName;

                     // is it there?
                     isMyDataThere = isMyDataThere.indexOf(colName) > -1;
                  }
                  if (!isMyDataThere) {
                     // If it didn't populate it's data, then I can't be
                     // efficient about how to update my data.
                     // we'll just have to reload:

                     // find out how many entries we have already loaded and try to
                     // load at least that many again.:
                     let count = 20;
                     if (this.__dataCollection.count() > count)
                        count = this.__dataCollection.count();
                     if (this.__treeCollection?.count() > count)
                        count = this.__treeCollection.count();

                     let currCursor = this.__dataCollection.getCursor();
                     this.clearAll();
                     this.reloadData(0, count).then(() => {
                        this.__dataCollection.setCursor(currCursor);
                        this.emit("cursorSelect", currCursor);
                     });
                  } else {
                     // if the linked DC does have my data populated:

                     // the values I currently contain can fall into 1 of 3 categories:
                     // 1) A value I currently have that I need to Keep
                     // 2) A value I currently have that I need to remove
                     // 3) A value I don't have, but need to Add

                     // the current value of the cursor should have the ID references
                     // to what SHOULD be in my display

                     // get the current cursor of our linked DC
                     let linkCursor;

                     if (dvLink) {
                        linkCursor = dvLink.getCursor();
                     }
                     if (!linkCursor) {
                        // if linkCursor is no longer set, then we should clear()
                        this.clearAll();
                        return;
                     }

                     let PK = this.datasource.PK();

                     // lets start by assuming all the current values in cursor are #3
                     // -> all the values into valuesToAdd:

                     let colName = this.fieldLink?.fieldLink?.relationName?.();
                     let valuesToAdd = {};
                     let valuesIn = colName ? linkCursor[colName] || [] : [];
                     if (!Array.isArray(valuesIn)) valuesIn = [valuesIn];
                     valuesIn = valuesIn.filter((v) => v);
                     valuesIn.forEach((v) => {
                        valuesToAdd[v[PK]] = v;
                     });

                     let valuesToRemove = [];
                     // step through all the values I currently have
                     let currValues = this.__dataCollection.find(() => true);
                     currValues.forEach((value) => {
                        // if value is in valuesToAdd
                        if (valuesToAdd[value[PK]]) {
                           // we already have it so turns out we don't need to add
                           // it after all
                           delete valuesToAdd[value[PK]];
                        } else {
                           // the current state of the Link Cursor value doesn't have
                           // this value, so we need to remove it:
                           valuesToRemove.push(value[PK]);
                        }
                     });

                     // now remove the items we don't want:
                     this.__dataCollection.remove(valuesToRemove);

                     // then we have to ask for the values we need to add:
                     valuesToAdd = Object.keys(valuesToAdd); // convert to []
                     // NOTE: .staleRefresh() is designed to handle a single requst
                     // that will be compiled with other requests to be more efficient
                     // so we need to make 1 .staleRefresh() at a time and then
                     // compile those results into our data collection.
                     let prmsAllRefreshes = [];
                     let allAdds = [];
                     (valuesToAdd || []).forEach((v) => {
                        let cond = { where: {} };
                        cond.where[PK] = v;
                        // NOTE: we are using the abbreviated condition syntax here.

                        // NOTE: staleRefresh() has some buffering capabilities
                        // that combine multiple calls into 1 more efficient call:
                        prmsAllRefreshes.push(
                           this.model.staleRefresh(cond).then((res) => {
                              // check to make sure there is data to work with
                              if (Array.isArray(res.data) && res.data.length) {
                                 res.data.forEach((d) => {
                                    allAdds.push(d);
                                 });
                              } else {
                                 if (res.data) {
                                    allAdds.push(res.data);
                                 }
                              }
                           })
                        );
                     });
                     Promise.all(prmsAllRefreshes).then(() => {
                        allAdds.forEach((d) => {
                           if (this.isValidData(d)) {
                              if (!this.__dataCollection.exists(d[PK])) {
                                 this.__dataCollection.add(d);
                              }
                           }
                        });
                     });
                  }

                  return;
               }

               // Otherwise, we need to refilter our data:
               this.refreshLinkCursor();
               this.setStaticCursor();
            },
         });
      }

      // add listeners when cursor of the followed data collection is changed
      const followDC = this.datacollectionFollow;
      if (followDC) {
         this.eventAdd({
            emitter: followDC,
            eventName: "changeCursor",
            listener: () => {
               const followCursor = followDC.getCursor();
               const currentCursor = this.getCursor();

               // If the cursor is not the new, then it should not reload.
               if (
                  followCursor?.[followDC.datasource.PK()] ==
                  currentCursor?.[this.datasource.PK()]
               )
                  return;

               this.clearAll();
               this.loadData();
            },
         });

         this.eventAdd({
            emitter: followDC,
            eventName: "cursorStale",
            listener: () => {
               // cursorStale : the current cursor hasn't CHANGED, but the data
               // of that value has changed.
               // This is triggered by one of our socket updates that detects
               // changes to the cursor data.

               this.clearAll();
               this.loadData();
            },
         });
      }
   }

   /*
    * waitForDataCollectionToInitialize()
    * there are certain situations where this datacollection shouldn't
    * load until another one has loaded.  In those cases, the fn()
    * will wait for the required datacollection to emit "initializedData"
    * before continuing on.
    * @param {ABViewDataCollection} DC
    *      the DC this datacollection depends on.
    * @returns {Promise}
    */
   async waitForDataCollectionToInitialize(DC, msg) {
      DC.init();

      return new Promise((resolve, reject) => {
         /* eslint-disable no-fallthrough */
         switch (DC.dataStatus) {
            // if that DC hasn't started initializing yet, start it!
            case DC.dataStatusFlag.notInitial:
               DC.loadData().catch(reject);
            // no break;

            // once in the process of initializing

            case DC.dataStatusFlag.initializing:
               /* eslint-enable no-fallthrough*/
               // listen for "initializedData" event from the DC
               // then we can continue.
               this.eventRemove("initializedData", DC);
               this.eventAdd({
                  emitter: DC,
                  eventName: "initializedData",
                  listener: () => {
                     // go next
                     resolve();
                  },
               });
               break;

            // if it is already initialized, we can continue:
            case DC.dataStatusFlag.initialized:
               resolve();
               break;

            // just in case, if the status is not known, just continue
            default:
               resolve();
               break;
         }
         /* eslint-enable no-fallthrough */
      });
   }

   // /**
   //  * @method whereCleanUp()
   //  * Parse through the current where condition and remove any null or
   //  * empty logical blocks.
   //  * @param {obj} curr
   //  *        1) The current where condition in ABQuery Format:
   //  *        {
   //  *           glue: [AND, OR],
   //  *           rules: [ {rule} ]
   //  *        }
   //  *        or 2) The current {rule} to validate
   //  *        {
   //  *          key:{string},
   //  *          rule:{string},
   //  *          vlaue:{mixed}
   //  *        }
   //  * @return {ABQuery.where} / { Rule }
   //  */
   // whereCleanUp(curr) {
   //    if (curr) {
   //       if (curr.glue && curr.rules) {
   //          // this is a logical Block (AND, OR)
   //          // we need to filter the children
   //          let newValue = { glue: curr.glue, rules: [] };
   //          curr.rules.forEach((r) => {
   //             let cleanRule = this.whereCleanUp(r);
   //             // don't add values that didn't pass
   //             if (cleanRule) {
   //                newValue.rules.push(cleanRule);
   //             }
   //          });

   //          // if we have a non empty block, then return it:
   //          if (newValue.rules.length > 0) {
   //             return newValue;
   //          }

   //          // this isn't really a valid conditional, so null
   //          return null;
   //       }

   //       // This is a specific rule, that isn't null so:
   //       return curr;
   //    }
   //    return null;
   // }

   /**
    * @method getWhereClause()
    * Return the current where condition for the datacollection.
    * The where condition might change depending if we are following
    * another datacollection or not.
    *
    * NOTE: start and limit might be effected by some of our settings
    * so we include them here and then return those values as well.
    *
    * @param {int} start
    * @param {int} limit
    * @returns [ wheres, start, limit ]
    */
   getWhereClause(start, limit) {
      // pull filter conditions
      let wheres = this.AB.cloneDeep(
         this.settings.objectWorkspace.filterConditions ?? {}
      );
      // if we pass new wheres with a reload use them instead
      if (this.__reloadWheres) {
         wheres = this.__reloadWheres;
      }
      wheres.glue = wheres.glue || "and";
      wheres.rules = wheres.rules || [];

      const __additionalWheres = {
         glue: "and",
         rules: [],
      };

      // add the filterCond if there are rules to add
      if (this.__filterCond?.rules?.length > 0) {
         __additionalWheres.rules.push(this.__filterCond);
      }

      // Filter by a selected cursor of a link DC
      let linkRule = this.ruleLinkedData();
      if (!this.settings.loadAll && linkRule) {
         __additionalWheres.rules.push(linkRule);
      }
      // pull data rows following the follow data collection
      else if (this.datacollectionFollow) {
         const followCursor = this.datacollectionFollow.getCursor();
         // store the PK as a variable
         let PK = this.datasource.PK();
         // if the datacollection we are following is a query
         // add "BASE_OBJECT." to the PK so we can select the
         // right value to report the cursor change to
         if (this.datacollectionFollow.settings.isQuery) {
            PK = "BASE_OBJECT." + PK;
         }
         if (followCursor) {
            start = 0;
            limit = null;
            wheres = {
               glue: "and",
               rules: [
                  {
                     key: this.datasource.PK(),
                     rule: "equals",
                     value: followCursor[PK],
                  },
               ],
            };
         }
         // Set no return rows
         else {
            wheres = {
               glue: "and",
               rules: [
                  {
                     key: this.datasource.PK(),
                     rule: "equals",
                     value: "NO RESULT ROW",
                  },
               ],
            };
         }
      }

      // Combine setting & program filters
      if (__additionalWheres.rules.length) {
         if (wheres.rules.length) {
            __additionalWheres.rules.unshift(wheres);
         }
         wheres = __additionalWheres;
      }

      // remove any null in the .rules
      // if (wheres?.rules?.filter) wheres.rules = wheres.rules.filter((r) => r);
      wheres = this.datasource.whereCleanUp(wheres);

      return [wheres, start, limit];
   }

   async loadData(start, limit) {
      // mark data status is initializing
      if (this._dataStatus == this.dataStatusFlag.notInitial) {
         this._dataStatus = this.dataStatusFlag.initializing;
         this.emit("initializingData", {});
      }

      var obj = this.datasource;
      if (obj == null) {
         this.dataInitialized();
         return Promise.resolve([]);
      }

      var model = obj.model();
      if (model == null) {
         this.dataInitialized();
         return Promise.resolve([]);
      }

      // pull the defined sort values
      var sorts = this.settings.objectWorkspace.sortFields || [];

      let [wheres, s2, l2] = this.getWhereClause(start, limit);
      start = s2;
      limit = l2;

      // // pull filter conditions
      // let wheres = this.AB.cloneDeep(
      //    this.settings.objectWorkspace.filterConditions ?? {}
      // );
      // // if we pass new wheres with a reload use them instead
      // if (this.__reloadWheres) {
      //    wheres = this.__reloadWheres;
      // }
      // wheres.glue = wheres.glue || "and";
      // wheres.rules = wheres.rules || [];

      // const __additionalWheres = {
      //    glue: "and",
      //    rules: [],
      // };

      // // add the filterCond if there are rules to add
      // if (this.__filterCond?.rules?.length > 0) {
      //    __additionalWheres.rules.push(this.__filterCond);
      // }

      // // Filter by a selected cursor of a link DC
      // let linkRule = this.ruleLinkedData();
      // if (!this.settings.loadAll && linkRule) {
      //    __additionalWheres.rules.push(linkRule);
      // }
      // // pull data rows following the follow data collection
      // else if (this.datacollectionFollow) {
      //    const followCursor = this.datacollectionFollow.getCursor();
      //    // store the PK as a variable
      //    let PK = this.datasource.PK();
      //    // if the datacollection we are following is a query
      //    // add "BASE_OBJECT." to the PK so we can select the
      //    // right value to report the cursor change to
      //    if (this.datacollectionFollow.settings.isQuery) {
      //       PK = "BASE_OBJECT." + PK;
      //    }
      //    if (followCursor) {
      //       start = 0;
      //       limit = null;
      //       wheres = {
      //          glue: "and",
      //          rules: [
      //             {
      //                key: this.datasource.PK(),
      //                rule: "equals",
      //                value: followCursor[PK],
      //             },
      //          ],
      //       };
      //    }
      //    // Set no return rows
      //    else {
      //       wheres = {
      //          glue: "and",
      //          rules: [
      //             {
      //                key: this.datasource.PK(),
      //                rule: "equals",
      //                value: "NO RESULT ROW",
      //             },
      //          ],
      //       };
      //    }
      // }

      // // Combine setting & program filters
      // if (__additionalWheres.rules.length) {
      //    if (wheres.rules.length) {
      //       __additionalWheres.rules.unshift(wheres);
      //    }
      //    wheres = __additionalWheres;
      // }

      // // remove any null in the .rules
      // // if (wheres?.rules?.filter) wheres.rules = wheres.rules.filter((r) => r);
      // wheres = obj.whereCleanUp(wheres);

      // set query condition
      var cond = {
         where: wheres || {},
         // limit: limit || 20,
         skip: start || 0,
         sort: sorts,
         populate: this.shouldPopulate,
      };

      //// NOTE: we no longer set a default limit on loadData() but
      //// require the platform.loadData() to pass in a default limit.
      if (limit != null) {
         cond.limit = limit;
      }

      // if settings specify loadAll, then remove the limit
      if (this.settings.loadAll && !this.isCursorFollow) {
         delete cond.limit;
      }

      //
      // Step 1: make sure any DataCollections we are linked to are
      // initialized first.  Then proceed with our initialization.
      //
      const parentDc = this.datacollectionLink ?? this.datacollectionFollow;
      // If we are linked to another datacollection then wait for it
      if (parentDc) {
         await this.waitForDataCollectionToInitialize(parentDc);
      }

      //
      // Step 2: if we have any filter rules that depend on other DataCollections,
      // then wait for them to be initialized first.
      // eg: "(not_)in_data_collection" rule filters
      if (wheres?.rules?.length) {
         const dcFilters = [];

         wheres.rules.forEach((rule) => {
            // if this collection is filtered by data collections we need to load them in case we need to validate from them later
            if (
               rule.rule == "in_data_collection" ||
               rule.rule == "not_in_data_collection"
            ) {
               const dv = this.AB.datacollectionByID(rule.value);
               if (dv) {
                  dcFilters.push(this.waitForDataCollectionToInitialize(dv));
               }
            }
         });

         await Promise.all(dcFilters);
      }

      //
      // Step 3: pull data to data collection
      // we will keep track of the resolve, reject for this
      // operation.
      // the actual resolve() should happen in the
      // .processIncomingData() after the  data is processed.
      return new Promise((resolve, reject) => {
         this._pendingLoadDataResolve = {
            resolve: resolve,
            reject: reject,
         };

         this.platformFind(model, cond).catch((err) => {
            reject(err);
         });
      });
   }

   platformFind(model, cond) {
      //// Core Migration Note:
      //// the ABViewDataCollectionCore now manages data in a different way:
      //// local data  vs  Remote Data
      //// this will need to be updated to reflect that management:
      //// (and also explains why we refactored things into .processIncomingData())
      return model.findAll(cond).then((data) => {
         console.error("TODO: parse returned data and figure out paging");
         console.error(data);
         // parse out the total and figure out if we need to track loading more:
         return this.processIncomingData(data);
      });
   }

   /**
    * @method shouldPopulate()
    * Return our populate status. We now want to query this info outside this
    * object.
    * @return {bool|Array}
    *         true/false,  or an array of columnNames that are being populated.
    */
   get shouldPopulate() {
      return (
         this.settings.populate ??
         (this.settings.preventPopulate ? false : true)
      );
   }

   /**
    * @method queuedParse()
    * This is an attempt at loading very large datasets into a Webix DC without locking up
    * the display.
    * @param {array} data
    *        The data to load into the __dataCollection
    * @param {callback} cb
    *        A callback to call when the data has been fully loaded.
    */
   async queuedParse(incomingData, cb) {
      const data = incomingData?.data || incomingData;
      if (!data?.length) {
         cb?.();
         return Promise.resolve();
      }

      const total_count = incomingData.total_count;

      let nextData;
      if (data.length > 250) {
         // let pos = this.__dataCollection.count();
         let pos = this.__dataCollection.find({}).length;
         let remain = data.splice(250);
         nextData = {
            data: remain,
            pos: pos + data.length,
            total_count,
         };
      }

      const parsedData = {
         data,
         pos: incomingData.pos,
         total_count,
      };
      this.__dataCollection.parse(parsedData);

      return new Promise((resolve) => {
         setTimeout(async () => {
            await this.queuedParse(nextData);

            // Introduce a delay to ensure the UI has fully rendered the list before proceeding
            setTimeout(async () => {
               cb?.();
               resolve();
            }, 50);
         }, 15);
      });
   }

   /**
    * processIncomingData()
    * is called from loadData() once the data is returned.  This method
    * allows the platform to make adjustments to the data based upon any
    * platform defined criteria.
    * @param {obj} data  the data as it was returned from the Server
    *        which should be in following format:
    *        {
    *          status: "success", // or "error"
    *          data:[ {ABObjectData}, {ABObjectData}, ...]
    *        }
    */
   processIncomingData(data) {
      return Promise.resolve().then(() => {
         // store total count
         this.__totalCount = data.total_count;

         // Need to .parse it the first time
         if (!this.__dataCollection?.find({}).length) {
            this.__dataCollection?.clearAll();
            // this.__dataCollection?.parse(data);
         }

         if (this.__throttleIncoming) clearTimeout(this.__throttleIncoming);
         this.__throttleIncoming = setTimeout(async () => {
            // using queuedParse() to responsively handle large datasets.
            await this.queuedParse(data);

            // In order to get the total_count updated I had to use .load()
            this.__dataCollection.load(async () => {
               setTimeout(() => {
                  this.refreshLinkCursor();
               }, 250);

               return {
                  // NOTE: return a empty array to prevent render items in DataTable twice. (Items are rendered in .queuedParse function)
                  data: [],
                  pos: data.pos,
                  total_count: data.total_count,
               };
            });

            // this does nothing???
            this.parseTreeCollection(data);

            // if we are linked, then refresh our cursor
            var linkDv = this.datacollectionLink;
            if (linkDv) {
               // filter data by match link data collection
               this.refreshLinkCursor();
               this.setStaticCursor();
            } else {
               // set static cursor
               this.setStaticCursor();
            }

            // now we close out our .loadData() promise.resolve() :
            if (this._pendingLoadDataResolve) {
               this._pendingLoadDataResolve.resolve();

               // after we call .resolve() stop tracking this:
               this._pendingLoadDataResolve = null;
            }

            // If dc set load all, then it will not trigger .loadData in dc at
            // .onAfterLoad event
            if (this.settings.loadAll) {
               this.emit("loadData", {});
            }

            // mark initialized data
            if (this._dataStatus != this.dataStatusFlag.initialized) {
               this.dataInitialized();
               this.emit("initializedData", {});
            }
         }, 100);
      });
   }

   /**
    * @method reloadData()
    * Trigger the DataCollection to reload its data from the server.
    * @param {int} start
    *        Start position of where we want the data to load.
    * @param {int} limit
    *        How many entries to load at a time.
    * @return {Promise}
    */
   reloadData(start, limit) {
      // var waitForDataCollectionToInitialize = (DC) => {
      //    return new Promise((resolve, reject) => {
      //       switch (DC.dataStatus) {
      //          // if that DC hasn't started initializing yet, start it!
      //          case DC.dataStatusFlag.notInitial:
      //             DC.loadData().catch(reject);
      //          // no break;

      //          // once in the process of initializing
      //          /* eslint-disable no-fallthrough*/
      //          case DC.dataStatusFlag.initializing:
      //             /* eslint-enable no-fallthrough*/
      //             // listen for "initializedData" event from the DC
      //             // then we can continue.
      //             this.eventAdd({
      //                emitter: DC,
      //                eventName: "initializedData",
      //                listener: () => {
      //                   // go next
      //                   resolve();
      //                },
      //             });
      //             break;

      //          // if it is already initialized, we can continue:
      //          case DC.dataStatusFlag.initialized:
      //             resolve();
      //             break;

      //          // just in case, if the status is not known, just continue
      //          default:
      //             resolve();
      //             break;
      //       }
      //    });
      // };

      return Promise.resolve().then(() => {
         // check if we are currently waiting for more data requests on this datacollection before continuing
         if (this.reloadTimer) {
            // if we are already waiting delete the current timer
            clearTimeout(this.reloadTimer);
            delete this.reloadTimer;
         }

         // return a promise
         if (!this.reloadPromise) {
            this.reloadPromise = new Promise((resolve, reject) => {
               this.reloadPromise__resolve = resolve;
               this.reloadPromise__reject = reject;
            });
         }

         // then create a new timeout to delete current timeout, clear data
         // and load new
         this.reloadTimer = setTimeout(() => {
            // clear the data from the dataCollection,
            this.clearAll();
            // then loads new data from the server
            return this.loadData(start, limit)
               .then(() => {
                  if (this.reloadPromise) {
                     this.reloadPromise__resolve();
                     delete this.reloadPromise;
                     delete this.reloadPromise__resolve;
                     delete this.reloadPromise__reject;
                  }

                  // delete the current setTimeout
                  clearTimeout(this.reloadTimer);
                  delete this.reloadTimer;
               })
               .catch((err) => {
                  if (this.reloadPromise) {
                     this.reloadPromise__reject(err);
                     delete this.reloadPromise;
                     delete this.reloadPromise__resolve;
                     delete this.reloadPromise__reject;
                  }
                  // delete the current setTimeout
                  clearTimeout(this.reloadTimer);
                  delete this.reloadTimer;
               });
         }, 50);
         // setting to 50ms because right now we do not see many
         // concurrent calls,  we need to increase this if we begin to

         return this.reloadPromise;
      });
   }

   /**
    * reloadWheres()
    * stores the child data collections filters for subsequent loads.
    * It is called from bindParentDc() when child data collections that are not
    * marked to load all data are initializing. To do this we use webix
    * server side binding by setting the param of "dataFeed".
    * @param {obj} wheres  the new filters for the data collection
    *        This is a combination of any exisiting filters the data collection
    *        alreay had as well as the filter for the current cursor set by the
    *        master data collection. We store this in __reloadWheres for when
    *        the data needs to be updated.
    *        The format of the wheres is our Query Builder Format
    *        ex: {
    *              "glue": "and",
    *              "rules": [{
    *                "key": "33ba8957-6b9c-4ddb-9533-c46b13878ae1",
    *                "rule": "contains",
    *                "value": "1594176994894"
    *              }]
    *            }
    */
   reloadWheres(wheres) {
      this.__reloadWheres = wheres;
   }

   getData(filter) {
      var dc = this.__dataCollection;
      if (dc) {
         return dc.find((row) => {
            let isValid = true;

            // data collection filter
            // isValid = this.isValidData(row);

            // NOTE: data are filtered from the server side (webix.dataFeed)
            // parent dc filter
            let linkDv = this.datacollectionLink;
            if (linkDv && this.settings.loadAll && isValid) {
               isValid = this.isParentFilterValid(row);
            }

            // addition filter
            if (isValid && filter) {
               isValid = filter(row);
            }

            return isValid;
         });
      } else {
         return [];
      }
   }

   isParentFilterValid(rowData) {
      // data is empty
      if (rowData == null) return false;

      var linkDv = this.datacollectionLink;
      if (linkDv == null) return true;

      const linkObj = linkDv.datasource;
      if (linkObj == null) return true;

      var fieldLink = this.fieldLink;
      if (fieldLink == null) return true;

      // if the parent's cursor is not set we have not filted this collection
      // yet so the data that comes back should be valid
      var linkCursor = linkDv.getCursor();
      if (linkCursor == null) {
         return true;
      }

      var linkVal = rowData[fieldLink.relationName()];
      if (linkVal == null) {
         // try to get relation value(id) again
         if (rowData[fieldLink.columnName]) {
            linkVal = rowData[fieldLink.columnName];
         } else {
            return false;
         }
      }

      let PK = fieldLink.object.PK();

      // array - 1:M , M:N
      if (linkVal.filter) {
         return (
            linkVal.filter(
               (val) =>
                  (val[PK] || val.id || val) ==
                  (linkCursor[linkObj.PK()] || linkCursor.id || linkCursor)
            ).length > 0
         );
      } else {
         return (
            (linkVal[PK] || linkVal.id || linkVal) ==
            (linkCursor[linkObj.PK()] || linkCursor.id || linkCursor)
         );
      }
   }

   clearAll() {
      if (this.__dataCollection) this.__dataCollection.clearAll();

      if (this.__treeCollection) this.__treeCollection.clearAll();

      this._dataStatus = this.dataStatusFlag.notInitial;
   }

   get totalCount() {
      return this.__totalCount || 0;
   }

   ///
   /// Components
   ///

   /**
    * @method bind
    * @param {Object} component - a webix element instance
    */
   bind(/* component */) {
      console.error("Platform.ABDataCollection.bind() Not implemented");
   }

   unbind(/* component */) {
      console.error("Platform.ABDataCollection.unbind() Not implemented");
   }

   removeComponent(comId) {
      // get index
      let index = this.__bindComponentIds.indexOf(comId);

      // delete
      this.__bindComponentIds.splice(index, 1);
   }

   /**
    * @method ruleLinkedData()
    * return a QueryFilter rule that also checks that incoming data is linked
    * to our .datacollectionLink (if it exists).
    * @return {obj} {QueryFilterRule}
    */
   ruleLinkedData() {
      let rule = null;
      const dataCollectionLink = this.datacollectionLink;
      const fieldLink = this.fieldLink;
      if (dataCollectionLink && fieldLink) {
         const linkCursorId = dataCollectionLink?.getCursor()?.id;
         if (linkCursorId) {
            const linkType = `${fieldLink.linkType()}:${fieldLink.linkViaType()}`;

            let filterRule;
            // NOTE: If object is query, then use "contains" because ABOBjectQuery return JSON
            if (fieldLink.alias) {
               filterRule = "contains";
            }
            // M:1
            else if (linkType == "many:one") {
               filterRule = "have_relation";
            }
            // 1:M
            else {
               filterRule = "equals";
            }

            rule = {
               alias: fieldLink.alias, // ABObjectQuery
               key: fieldLink.id,
               rule: filterRule,
               value: fieldLink.getRelationValue(
                  dataCollectionLink.__dataCollection.getItem(linkCursorId)
               ),
            };
         }
      }
      return rule;
   }

   /**
    * @method refreshFilterConditions()
    * This is called in two primary cases:
    *    - on initialization of a DC to setup our filters.
    *    - in the operation of the ABDesigner when using a DC to display data
    *      in the Work_object_grid and the datacollection_work(?)
    * In the case of the ABDesigner, new temporary where conditions are provided
    * from the possible filters we can set, and those need to effect the data
    * we display.
    * @param {ABRowFilter.where} wheres
    *        The filter condition from the ABRowFilter values we are storing.
    */
   refreshFilterConditions(wheres = null) {
      // There are 3 Filters that help us know if our data is Valid:
      // 1) A filter for any ABObjectQuery we are managing.
      // 2) A filter for our own filter condition
      // 3) A filter that represents what our scopes allows

      // Set filter of ABObject
      if (this.__filterDatasource == null)
         this.__filterDatasource = this.AB.filterComplexNew(
            `${this.id}_filterDatasource`
         );

      if (this.datasource) {
         // this.__filterDatasource.applicationLoad(this.datasource.application);
         this.__filterDatasource.fieldsLoad(this.datasource.fields());

         let filterConditions;

         // Query
         if (this.datasource instanceof this.AB.Class.ABObjectQuery) {
            filterConditions = this.datasource.where;
         }
         // Apr 29, 2021 Removed this because we do not want Object filters to
         // effect validation of DataCollections
         // Object

         // else if (this.datasource instanceof ABObject) {
         //    let currentView = this.datasource.currentView();
         //    if (currentView && currentView.filterConditions)
         //       filterConditions = currentView.filterConditions;
         // }

         if (filterConditions)
            this.__filterDatasource.setValue(filterConditions);
         else this.__filterDatasource.setValue({});
      } else {
         this.__filterDatasource.fieldsLoad([]);
         this.__filterDatasource.setValue(
            DefaultValues.settings.objectWorkspace.filterConditions
         );
      }

      // Set filter of data view
      // Apr 29, 2021 Added this code back to validate with DataCollection Filters
      if (this.__filterDatacollection == null)
         this.__filterDatacollection = this.AB.filterComplexNew(
            `${this.id}_filterDatacollection`
         );

      // this.__filterDatacollection.applicationLoad(
      //    this.datasource ? this.datasource.application : null
      // );
      this.__filterDatacollection.fieldsLoad(
         this.datasource ? this.datasource.fields() : []
      );

      // if we pass in wheres, then Save that value to our internal .filterConditions
      if (wheres) this.settings.objectWorkspace.filterConditions = wheres;

      let filter = this.AB.cloneDeep(
         this.settings.objectWorkspace?.filterConditions ?? {
            glue: "and",
            rules: [],
         }
      );
      // sanity checks:
      // I've learned not to trust: this.settings.objectWorkspace
      filter.glue = filter.glue || "and";
      filter.rules = filter.rules || [];

      // if there is a linkRule, add it to filter
      let linkRule = this.ruleLinkedData(); // returns a rule if we are linked
      if (linkRule) {
         // NOTE: linkRule was originally designed to produce a rule for the
         // loadData() routine.  In SQL, our linkRule might have an "equals"
         // rule, to match.  But in this context if our linktype is "many"
         // we need to change the rule to "contains":
         // QUESTION: If this is still required, consider moving it into the `ruleLinkedData` function for maintainability. ??
         // if (this.fieldLink?.linkType() == "many") {
         //    linkRule.rule = "contains";
         // }

         // if linkRule not already IN filter:
         let isAlreadyThere = false;
         let keys = Object.keys(linkRule);
         (filter.rules || []).forEach((r) => {
            if (isAlreadyThere) return;
            let allMatch = true;
            keys.forEach((k) => {
               if (r[k] != linkRule[k]) {
                  allMatch = false;
               }
            });
            isAlreadyThere = allMatch;
         });
         if (!isAlreadyThere) {
            // link Rule needs to be ANDed to our current Rules:
            if (filter.glue == "and") {
               filter.rules.push(linkRule);
            } else {
               filter = { glue: "and", rules: [filter, linkRule] };
            }
         }
      }

      if ((filter.rules || []).length > 0 && !this.isCursorFollow) {
         this.__filterDatacollection.setValue(filter);
      } else {
         this.__filterDatacollection.setValue(
            DefaultValues.settings.objectWorkspace.filterConditions
         );
      }

      // Set filter of user's scope
      if (this.__filterScope == null)
         this.__filterScope = this.AB.filterComplexNew(
            `${this.id}_filterScope`
         );

      if (this.datasource) {
         let scopeList = (this.userScopes || []).filter(
            (s) =>
               !s.allowAll &&
               (s.objectIds || []).indexOf(this.datasource.id) > -1
         );
         if (scopeList && scopeList.length > 0) {
            // this.__filterScope.applicationLoad(this.datasource.application);
            this.__filterScope.fieldsLoad(this.datasource.fields() || []);

            // concat all rules of scopes
            let scopeRules = [];
            scopeList
               .filter(
                  (s) => s.filter && s.filter.rules && s.filter.rules.length
               )
               .forEach((s) => {
                  let sRules = (s.filter.rules || []).filter(
                     (r) =>
                        this.datasource.fields((f) => f.id == r.key).length > 0
                  );

                  scopeRules = scopeRules.concat(sRules);
               });

            let scopeWhere = {
               glue: "or",
               rules: scopeRules,
            };
            this.__filterScope.setValue(scopeWhere);
         }
      }
   }

   get isGroup() {
      return this.__isGroup || false;
   }

   ///
   /// Sync type
   ///

   get syncTypeFlag() {
      return {
         server: 1,
         client: 2,
      };
   }

   get syncType() {
      return this.settings.syncType || DefaultValues.syncType;
   }

   /** Private methods */

   /**
    * @method _dataCollectionNew
    * Get webix.DataCollection
    *
    * @return {webix.DataCollection}
    *
    * @param {Array} data - initial data
    */
   _dataCollectionNew(/*data*/) {
      var error = new Error(
         "the platform.ABDataCollection._dataCollectionNew() is expected to return a proper DataCollection!"
      );
      console.error(error);
      return null;
   }

   /**
    * @method _treeCollectionNew
    * Get webix.TreeCollection
    *
    * @return {webix.TreeCollection}
    *
    */
   _treeCollectionNew() {
      console.error(
         "the platform.ABDataCollection._treeCollectionNew() is expected to return a proper TreeCollection!"
      );
      return null;
   }

   parseTreeCollection(data = {}) {
      // TODO all this does is log "is missing?"
      // if (false) {
      //    console.log(
      //       "Platform.ABDataCollection.parseTreeCollection() missing!"
      //    );
      // }
   }
   // parseTreeCollection(data = {}) {

   //  if (!(this.__datasource instanceof ABObjectQuery) ||
   //    !this.__datasource.isGroup ||
   //    !this.__treeCollection)
   //    return;

   //  let addRowToTree = (join = {}, parentAlias = null) => {

   //    let alias = join.alias;

   //    (data.data || []).forEach(row => {

   //      let dataId = row[`${alias}.uuid`] || row[`${alias}.id`];
   //      if (!dataId) return;

   //      // find parent nodes
   //      let parentItemIds = [];
   //      let parentId = row[`${parentAlias}.uuid`] || row[`${parentAlias}.id`];
   //      if (parentId) {
   //        parentItemIds = this.__treeCollection
   //          .find(item => item._alias == parentAlias && item._dataId == parentId)
   //          .map(item => item.id);
   //      }

   //      // check exists
   //      let exists = this.__treeCollection.find(item => {
   //        return item._alias == alias &&
   //          item._dataId == dataId &&
   //          (parentItemIds.length == 0 || parentItemIds.indexOf(item.$parent) > -1);
   //      }, true);
   //      if (exists) return;

   //      let treeNode = {};
   //      treeNode._alias = alias;
   //      treeNode._dataId = dataId;
   //      treeNode._itemId = row.id; // Keep row id for set cursor to data collection

   //      Object.keys(row).forEach(propName => {

   //        // Pull value from alias
   //        if (propName.indexOf(`${alias}.`) == 0) {
   //          treeNode[propName] = row[propName];
   //        }

   //      });

   //      if (row.translations)
   //        treeNode.translations = row.translations;

   //      // child nodes
   //      if (parentItemIds.length > 0)
   //        parentItemIds.forEach(parentItemId => {
   //          this.__treeCollection.add(treeNode, null, parentItemId);
   //        });
   //      // root node
   //      else
   //        this.__treeCollection.add(treeNode, null);

   //    });

   //    // Sub-joins
   //    (join.links || []).forEach(link => {
   //      addRowToTree(link, alias);
   //    });

   //  };

   //  // Show loading cursor
   //  (this.__bindComponentIds || []).forEach(comId => {

   //    let boundComp = $$(comId);
   //    if (boundComp &&
   //      boundComp.showProgress)
   //      boundComp.showProgress({ type: "icon" });

   //  });

   //  addRowToTree(this.__datasource.joins());

   //  // Hide loading cursor
   //  (this.__bindComponentIds || []).forEach(comId => {

   //    let boundComp = $$(comId);
   //    if (boundComp &&
   //      boundComp.hideProgress)
   //      boundComp.hideProgress();

   //  })
   // }

   /**
    * @method _queryUpdateData
    *
    * @param {Array} objList - List of ABObject
    * @param {Object} values
    */
   _queryUpdateData(objList, values) {
      let updatedVals = {};

      // Add alias to properties of update data
      Object.keys(values).forEach((key) => {
         objList.forEach((oItem) => {
            let alias = this.datasource.objectAlias(oItem.id);

            updatedVals[`${alias}.${key}`] = values[key];

            // Add alias to properties of .translations
            if (
               key == "translations" &&
               values["translations"] &&
               values["translations"].length
            ) {
               updatedVals.translations = [];

               values["translations"].forEach((tran) => {
                  let updatedTran = {};

                  Object.keys(tran).forEach((tranKey) => {
                     if (tranKey == "language_code")
                        updatedTran["language_code"] = tran["language_code"];
                     else updatedTran[`${alias}.${tranKey}`] = tran[tranKey];
                  });

                  updatedVals.translations.push(updatedTran);
               });
            }
         });
      });

      return updatedVals;
   }

   isValidData(rowData, skipDatasourceFilter = false) {
      let result = true;

      // NOTE: should we use filter of the current view of object to filter
      //        if yes, update .wheres condition in .loadData too
      if (this.__filterDatasource && !skipDatasourceFilter)
         result = result && this.__filterDatasource.isValid(rowData);

      if (this.__filterDatacollection)
         result = result && this.__filterDatacollection.isValid(rowData);

      if (result && this.__filterScope)
         result = result && this.__filterScope.isValid(rowData);

      return result;
   }

   updateRelationalDataFromLinkDC(objectId, rowData) {
      const dcLink = this.datacollectionLink;
      const cursorLink = dcLink?.getCursor();

      // Add the new data that just relate to the Link DC
      if (
         dcLink?.datasource.id == objectId &&
         cursorLink &&
         cursorLink.id == rowData?.id
      ) {
         const obj = this.datasource;
         const linkedField = this.fieldLink;
         let relatedData = rowData[linkedField.fieldLink.relationName()];
         if (relatedData && !Array.isArray(relatedData))
            relatedData = [relatedData];

         (relatedData ?? []).forEach((item) => {
            if (item == null) return;

            if (!this.__dataCollection.exists(item[obj.PK()])) {
               // QUESTION: Should we .find to get fully info here ?
               const newItem = this.AB.cloneDeep(item);
               newItem[linkedField.relationName()] = [rowData];
               this.__dataCollection.add(newItem);
            }
         });

         // trigger to components to know there are updated data.
         this.emit("warnRefresh");
      }
   }

   // Clone

   clone(settings) {
      settings = settings || this.toObj();
      var clonedDatacollection = new this.constructor(settings, this.AB);
      clonedDatacollection.__datasource = this.__datasource;
      clonedDatacollection._dataStatus = this._dataStatus;

      // clonedDatacollection.__dataCollection = this.__dataCollection.copy();
      clonedDatacollection.__filterDatacollection.setValue(
         settings.settings.objectWorkspace.filterConditions
      );

      var parseMe = () => {
         if (clonedDatacollection.__dataCollection) {
            clonedDatacollection.__dataCollection.parse(
               this.__dataCollection
                  .find({})
                  .filter((row) =>
                     clonedDatacollection.__filterDatacollection.isValid(row)
                  )
            );
         }
         if (clonedDatacollection.__treeCollection) {
            clonedDatacollection.__treeCollection.parse(
               this.__treeCollection
                  .find({})
                  .filter((row) =>
                     clonedDatacollection.__filterDatacollection.isValid(row)
                  )
            );
         }
      };

      parseMe();

      // return new Promise((resolve, reject) => {
      //    // load the data
      //    clonedDatacollection
      //       .loadData()
      //       .then(() => {

      // set the cursor
      clonedDatacollection.setStaticCursor();

      var cursorID = this.getCursor();
      if (cursorID) {
         // NOTE: webix documentation issue: .getCursor() is supposed to return
         // the .id of the item.  However it seems to be returning the {obj}
         if (cursorID.id) cursorID = cursorID.id;

         clonedDatacollection.setCursor(cursorID);
      }

      return clonedDatacollection;

      // resolve(clonedDatacollection);
      //       })
      //       .catch(reject);
      // });
   }

   filteredClone(filters) {
      var obj = this.toObj();

      // check to see that filters are set (this is sometimes helpful to select the first record without doing so at the data collection level)
      if (filters?.rules?.length) {
         if (obj.settings.objectWorkspace.filterConditions?.rules?.length) {
            obj.settings.objectWorkspace.filterConditions.rules =
               obj.settings.objectWorkspace.filterConditions.rules.concat(
                  filters.rules
               );
         } else {
            obj.settings.objectWorkspace.filterConditions = filters;
         }
      }
      let clonedDC = this.clone(obj);
      return clonedDC; // new ABViewDataCollection(settings, this.application, this.parent);
   }

   //
   // Event handles
   //

   /**
    * @method eventAdd()
    *
    *
    *
    * @param {object} evt - {
    *              emitter: object,
    *              eventName: string,
    *              listener: function
    *            }
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      this.__events = this.__events || [];

      let exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventClear()
    * unsubscribe all events.
    * should do it before destroy a component
    *
    */
   eventClear() {
      if (this.__events && this.__events.length > 0) {
         this.__events.forEach((e) => {
            e.emitter.removeListener(e.eventName, e.listener);
         });
      }
   }

   /**
    * @method eventRemove()
    * unsubscribe a event.
    *
    * @param {string} eventName - Name of the event
    * @param {object} emitter - Emitter object
    */
   eventRemove(eventName, emitter = null) {
      if (this.__events?.length > 0 && eventName) {
         this.__events.forEach((e) => {
            if (eventName == e.eventName && (!emitter || emitter == e.emitter))
               e.emitter.removeListener(e.eventName, e.listener);
         });

         this.__events = this.__events.filter((e) => e.eventName != eventName);
      }
   }

   get userScopes() {
      return [];
   }

   get isCursorFollow() {
      return (
         this.settings.followDatacollectionID &&
         (!this.settings.linkDatacollectionID || !this.settings.linkFieldID)
      );
   }

   get datacollectionFollow() {
      if (!this.isCursorFollow) return null;

      return (this.AB ?? AB).datacollectionByID(
         this.settings.followDatacollectionID
      );
   }

   get previousCursorId() {
      return this.__previousCursorId;
   }

   waitReady() {
      // if (this.dataStatus == this.dataStatusFlag.initialized) {
      //    return Promise.resolve();
      // }
      // console.log(`DC[${this.label}] waiting for initializedData.`);
      // return new Promise((resolve /*, reject */) => {
      //    this.once("initializedData", ()=>{
      //       resolve();
      //    })

      // })

      return this.waitForDataCollectionToInitialize(this);
   }
}


/***/ }),

/***/ 17953:
/*!****************************************************!*\
  !*** ./src/js/AppBuilder/core/ABDefinitionCore.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABDefinitionCore)
/* harmony export */ });
// import ABApplication from "./ABApplication"

class ABDefinitionCore {
   constructor(attributes, AB) {
      this.AB = AB;
      this.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
		{
			id: uuid(),
			name: 'name',
			type: 'xxxxx',
			json: "{json}"
		}
		*/
      if (attributes.id) {
         this.id = attributes.id;
      }
      this.name =
         attributes?.name ||
         attributes?.json?.name ||
         attributes?.json?.label ||
         attributes?.json?.translations?.[0]?.label ||
         "";
      if (!this.name) {
         this.AB.notify.builder(
            new Error("Attributes for definition had no 'name'"),
            {
               context: "ABDefinitionCore.fromValues()",
               attributes,
            }
         );
      }
      this.type = attributes.type || attributes?.json?.type || "";
      this.json = attributes.json || null;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      return {
         id: this.id,
         name: this.name,
         type: this.type,
         json: this.json,
      };
   }

   /**
    * @method destroy()
    * destroy the current instance of ABDefinition
    * Also remove it from our parent application
    * @return {Promise}
    */
   destroy() {
      return this.AB.definitionDestroy(this.id);
   }

   /**
    * @method save()
    * persist this instance of ABObject with it's parent ABApplication
    * @return {Promise}
    *         .resolve( {this} )
    */
   async save() {
      if (this.id) {
         return this.AB.definitionUpdate(this.id, this.toObj());
      } else {
         return this.AB.definitionCreate(this.toObj());
      }
   }
}


/***/ }),

/***/ 45800:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/core/ABFactoryCore.js ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABApplication */ 10285);
/* harmony import */ var _platform_ABApplicationMobile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/ABApplicationMobile */ 38094);
/* harmony import */ var _platform_ABDefinition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/ABDefinition */ 34802);
/* harmony import */ var _platform_ABComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../platform/ABComponent */ 64971);
/* harmony import */ var _ABFieldManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ABFieldManager */ 96408);
/* harmony import */ var _platform_ABIndex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/ABIndex */ 32711);
/* harmony import */ var _platform_ABObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/ABObject */ 83311);
/* harmony import */ var _platform_ABObjectExternal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../platform/ABObjectExternal */ 18700);
/* harmony import */ var _platform_ABObjectImport__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../platform/ABObjectImport */ 94910);
/* harmony import */ var _platform_ABObjectApi__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform/ABObjectApi */ 9611);
/* harmony import */ var _platform_ABObjectApiNetsuite__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../platform/ABObjectApiNetsuite */ 65506);
/* harmony import */ var _platform_ABDataCollection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../platform/ABDataCollection */ 98383);
/* harmony import */ var _platform_ABObjectQuery__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../platform/ABObjectQuery */ 59545);
/* harmony import */ var _platform_ABHint__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../platform/ABHint */ 5701);
/* harmony import */ var _platform_ABProcess__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../platform/ABProcess */ 33046);
/* harmony import */ var _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../platform/process/ABProcessParticipant */ 74843);
/* harmony import */ var _platform_process_ABProcessLane__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../platform/process/ABProcessLane */ 23479);
/* harmony import */ var _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./process/ABProcessTaskManager */ 83316);
/* harmony import */ var _platform_ABStep__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../platform/ABStep */ 81410);
/* harmony import */ var _platform_views_ABViewDetailItem__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../platform/views/ABViewDetailItem */ 48172);
/* harmony import */ var _platform_views_ABViewFormItem__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../platform/views/ABViewFormItem */ 9247);
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../platform/mobile/ABMobileViewFormItem */ 3199);
/* harmony import */ var _platform_RowFilter__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../platform/RowFilter */ 84470);
/* harmony import */ var _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../platform/FilterComplex */ 10758);
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
/* harmony import */ var _platform_ABEmitter__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../platform/ABEmitter */ 4025);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__, _platform_ABApplicationMobile__WEBPACK_IMPORTED_MODULE_1__, _ABFieldManager__WEBPACK_IMPORTED_MODULE_4__, _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_17__]);
([_platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__, _platform_ABApplicationMobile__WEBPACK_IMPORTED_MODULE_1__, _ABFieldManager__WEBPACK_IMPORTED_MODULE_4__, _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_17__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/*
 * ABFactoryCore
 * an object that contains the definitions and references for a single tenant.
 * It is expected that an instance of this should be returned from an
 * ABBootstrap.init(req).then((AB)=>{}) call.
 */

// const _ = require("lodash");
// const uuidv4 = require("uuid");

// const ABApplication = require("../platform/ABApplication");




// const ABDefinition = require("../platform/ABDefinition");


// const ABComponent = require("../platform/ABComponent");


// const ABFieldManager = require("./ABFieldManager");


// const ABIndex = require("../platform/ABIndex");


// const ABObject = require("../platform/ABObject");


// const ABObjectExternal = require("../platform/ABObjectExternal");


// const ABObjectImport = require("../platform/ABObjectImport");


// const ABObjectApi = require("../platform/ABObjectApi");




// const ABDataCollection = require("../platform/ABDataCollection");


// const ABObjectQuery = require("../platform/ABObjectQuery");


// const ABHint = require("../platform/ABHint");


// const ABProcess = require("../platform/ABProcess");


// const ABProcessParticipant = require("../platform/process/ABProcessParticipant");


// const ABProcessLane = require("../platform/process/ABProcessLane");


// const ABProcessTaskManager = require("./process/ABProcessTaskManager");


// const ABStep = require("../platform/ABStep");


// const ABViewDetailItem = require("../platform/views/ABViewDetailItem");


// const ABViewFormItem = require("../platform/views/ABViewFormItem");


// const ABMobileViewFormItem = require("../platform/mobile/ABMobileViewFormItem");


// const ABObjectWorkspaceViewGrid = require("../platform/workspaceViews/ABObjectWorkspaceViewGrid");
// const ABObjectWorkspaceViewKanban = require("../platform/workspaceViews/ABObjectWorkspaceViewKanban");
// const ABObjectWorkspaceViewGantt = require("../platform/workspaceViews/ABObjectWorkspaceViewGantt");

// const RowFilter = require("../platform/RowFilter");


// const FilterComplex = require("../platform/FilterComplex");


// const ABMLClass = require("../platform/ABMLClass");


// const EventEmitter = require("../platform/ABEmitter");


class ABFactory extends _platform_ABEmitter__WEBPACK_IMPORTED_MODULE_25__["default"] {
   constructor(definitions) {
      /**
       * @param {hash} definitions
       *        { ABDefinition.id : {ABDefinition} }
       *        of all the definitions defined for the current Tenant
       */

      super();
      this.setMaxListeners(0);

      this._definitions = definitions || {};
      // {hash}  { ABDefinition.id : {ABDefinition} }
      // ensure ._definitions is a HASH{ ID : {ABDefinition}}
      if (Array.isArray(definitions)) {
         var hash = {};
         definitions.forEach((d) => {
            hash[d.id] = d;
         });
         this._definitions = hash;
      }

      //
      //
      // Manage our working objects
      //

      this._allApplications = [];
      // {array} of all the ABApplication(s) in our site.

      this._allObjects = [];
      // {array} of all the ABObject(s) in our site.

      this._allHints = [];
      // {array} of all the ABHint(s) in our site.

      this._allProcesses = [];
      // {array} of all the ABProcess(s) in our site.

      this._allQueries = [];
      // {array} of all the ABObjectQuery(s) in our site.

      this._allSteps = [];
      // {array} of all the ABStep(s) in our site.

      this._allDatacollections = [];
      // {array} of all the ABDataCollection(s) in our site.

      //
      // Class References
      //
      this.Class = {
         ABApplication: _platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__["default"],
         ABComponent: _platform_ABComponent__WEBPACK_IMPORTED_MODULE_3__["default"],
         ABDefinition: _platform_ABDefinition__WEBPACK_IMPORTED_MODULE_2__["default"],
         ABFieldManager: _ABFieldManager__WEBPACK_IMPORTED_MODULE_4__["default"],
         ABIndex: _platform_ABIndex__WEBPACK_IMPORTED_MODULE_5__["default"],
         ABMLClass: _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_24__["default"],
         ABObject: _platform_ABObject__WEBPACK_IMPORTED_MODULE_6__["default"],
         ABObjectExternal: _platform_ABObjectExternal__WEBPACK_IMPORTED_MODULE_7__["default"],
         ABObjectImport: _platform_ABObjectImport__WEBPACK_IMPORTED_MODULE_8__["default"],
         ABObjectApi: _platform_ABObjectApi__WEBPACK_IMPORTED_MODULE_9__["default"],
         ABObjectApiNetsuite: _platform_ABObjectApiNetsuite__WEBPACK_IMPORTED_MODULE_10__["default"],
         ABObjectQuery: _platform_ABObjectQuery__WEBPACK_IMPORTED_MODULE_12__["default"],
         ABProcessParticipant: _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_15__["default"],
         // ABRole      // Do we need this anymore?

         // ABObjectWorkspaceViewGrid,
         // ABObjectWorkspaceViewKanban,
         // ABObjectWorkspaceViewGantt,

         ABProcessTaskManager: _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_17__["default"],

         ABViewDetailItem: _platform_views_ABViewDetailItem__WEBPACK_IMPORTED_MODULE_19__["default"],
         ABViewFormItem: _platform_views_ABViewFormItem__WEBPACK_IMPORTED_MODULE_20__["default"],
         ABMobileViewFormItem: _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_21__["default"],
      };

      //
      // Rules
      // These are a common set of "rules" for all platforms.
      //
      this.rules = {
         /**
          * @method AB.rules.isUUID
          * evaluate a given value to see if it matches the format of a uuid
          * @param {string} key
          * @return {boolean}
          */
         isUUID: function (key) {
            var checker = RegExp(
               "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
               "i"
            );
            return checker.test(key);
         },

         /**
          * @method AB.rules.nameFilter()
          * return a properly formatted name for an AppBuilder object.
          * @param {string} name
          *        The name of the object we are conditioning.
          * @return {string}
          */
         nameFilter: function (name) {
            return String(name).replace(/[^a-z0-9_.]/gi, "");
         },

         /**
          * @method AB.rules.toApplicationNameFormat()
          * return a properly formatted Application Name
          * @param {string} name
          *        The name of the Application we are conditioning.
          * @return {string}
          */
         toApplicationNameFormat: function (name) {
            return "AB_" + this.nameFilter(name);
         },

         /**
          * @method AB.rules.toFieldRelationFormat()
          * This function uses for define relation name of Knex Objection
          * return a relation name of column
          * @param {string} colName
          *        The name of the Column
          * @return {string}
          */
         toFieldRelationFormat: function (colName) {
            return this.nameFilter(colName) + "__relation";
         },

         /**
          * @method AB.rules.toJunctionTableFK()
          * return foriegnkey (FK) column name for a junction table name
          * @param {string} objectName
          *        The name of the Object with a connection
          * @param {string} columnName
          *        The name of the connection columnName.
          * @return {string}
          */
         toJunctionTableFK: function (objectName, columnName) {
            var fkName = objectName + "_" + columnName;

            if (fkName.length > 64) fkName = fkName.substring(0, 64);

            return fkName;
         },

         /**
          * @method AB.rules.toJunctionTableNameFormat()
          * return many-to-many junction table name
          * @param {string} appName
          *        The name of the Application for this object
          * @param {string} sourceTableName
          *        The name of the source object we are conditioning.
          * @param {string} targetTableName
          *        The name of the target object we are conditioning.
          * @param {string} colName
          * @return {string}
          */
         toJunctionTableNameFormat: function (
            appName,
            sourceTableName,
            targetTableName,
            colName
         ) {
            // The maximum length of a table name in MySql is 64 characters
            appName = this.toApplicationNameFormat(appName);
            if (appName.length > 17) appName = appName.substring(0, 17);

            if (sourceTableName.length > 15)
               sourceTableName = sourceTableName.substring(0, 15);

            if (targetTableName.length > 15)
               targetTableName = targetTableName.substring(0, 15);

            colName = this.nameFilter(colName);
            if (colName.length > 14) colName = colName.substring(0, 14);

            return "{appName}_{sourceName}_{targetName}_{colName}"
               .replace("{appName}", appName)
               .replace("{sourceName}", sourceTableName)
               .replace("{targetName}", targetTableName)
               .replace("{colName}", colName);
         },

         /**
          * @method AB.rules.toObjectNameFormat
          * return a properly formatted Object/Table Name
          * @param {string} objectName
          *        The {ABObject}.name of the Object we are conditioning.
          * @return {string}
          */
         toObjectNameFormat: function (objectName) {
            return `AB_${this.nameFilter(objectName)}`;
         },
      };

      // Notify Helpers
      this.notify.builder = (...params) => {
         this.notify("builder", ...params);
      };

      this.notify.developer = (...params) => {
         this.notify("developer", ...params);
      };
   }

   /**
    * @method definitionClean()
    * make sure the provided ABDefinition values are properly formatted
    * @param {ABDefinition} d
    *        The json settings of an ABDefinition object.
    */
   definitionClean(d) {
      if (typeof d.json == "string") {
         try {
            d.json = JSON.parse(d.json);
         } catch (e) {
            console.log(e);
            console.error(` Error on definition id[${d.id}]`);
         }
      }
   }

   init() {
      let allDefinitions = Object.keys(this._definitions).map(
         (k) => this._definitions[k]
      );
      // {array} all our definitions in an Array format.

      // make sure our definitions.json field is an {} and not string
      allDefinitions.forEach((d) => {
         this.definitionClean(d);
      });

      // perform these in order:
      [
         "object",
         "query",
         "datacollection",
         "process",
         "hint",
         "step",
         "application",
      ].forEach((type) => {
         var objTypes = allDefinitions.filter((d) => d.type == type);
         objTypes.forEach((def) => {
            let { keyList, keyFn } = this.objectKeysByDef(def);
            if (keyList) {
               this[keyList].push(this[keyFn](def.json));
            }
         });
      });

      this.emit("init.objects_ready");
      return Promise.resolve();
   }

   /**
    * @method objectKeysByDef()
    * Analyze the provided ABDefinition json and return which set of list and
    * functions are used to create a new instance of this definition.
    * @param {json} def
    *        the ABDefinition json of the definition we are evaluating
    * @return { keyList, keyFn }
    *        keyList: {string}  which of our internal lists to store this new
    *                 object.
    *        keyFn: {string} which of our methods to call with the def.json
    *               as the param that will create the new object.
    *
    *        ex:  this[keyList].push( this[keyFn](def.json));
    *
    *        if this def is not one of the types we track,
    *        keyList = keyFn = null;
    */
   objectKeysByDef(def) {
      switch (def.type) {
         case "application":
            return { keyList: "_allApplications", keyFn: "applicationNew" };

         case "datacollection":
            return {
               keyList: "_allDatacollections",
               keyFn: "datacollectionNew",
            };

         case "hint":
            return { keyList: "_allHints", keyFn: "hintNew" };

         case "steps":
            return { keyList: "_allSteps", keyFn: "stepNew" };

         case "object":
            return { keyList: "_allObjects", keyFn: "objectNew" };

         case "process":
            return { keyList: "_allProcesses", keyFn: "processNew" };

         case "query":
            return { keyList: "_allQueries", keyFn: "queryNew" };

         default:
            // we don't manage any other
            return { keyList: null, keyFn: null };
      }
   }

   //
   // Definitions
   //

   /**
    * definitionByID(id)
    * return an ABDefinition.json value ready for our objects to use.
    * @param {string} id
    *        the uuid of the ABDefinition to delete
    * @param {bool} isRaw
    *        indicates if we want the full ABDefinition, or the .json param
    *        true : returns full ABDefinition value.
    *        false: returns the .json parameter used by most ABObjects.
    * @return {Promise}
    */
   definitionByID(id, isRaw = false) {
      if (this._definitions[id]) {
         if (isRaw) {
            return this._definitions[id];
         } else {
            return this._definitions[id].json;
         }
      }
      return null;
   }

   /**
    * definitionNew(values)
    * return an ABDefinition object tied to this Tenant.
    * @param {obj} values
    *        The value hash of the ABDefinition object to create.
    * @return {ABDefinition}
    */
   definitionNew(values) {
      return new _platform_ABDefinition__WEBPACK_IMPORTED_MODULE_2__["default"](values, this);
   }

   /**
    * definitionsParse()
    * include the incoming definitions into our ABFactory. These new
    * definitions will replace any existing ones with the same .id.
    * @param {array[ABDefinitioin]} defs
    *     the incoming array of ABDefinitions to parse.
    * @return {Promise}
    */
   definitionsParse(defs = []) {
      if (!Array.isArray(defs)) {
         defs = [defs];
      }

      // store/replace the incoming definitions
      // 1st: insert ALL our definitions internally
      defs.forEach((d) => {
         this.definitionClean(d);
         this._definitions[d.id] = d;
      });
      // 2nd: Now we can then go through and signal the "updates"
      // and the related objects can find their dependent definitions.
      defs.forEach((d) => {
         this.definitionSync("updated", d.id, d);
      });

      return Promise.resolve();
   }

   /**
    * definitionSync()
    * Synchronize an individual definition into our repository of definitions.
    * @param {string} op
    *        the type of synchronization this is
    *        [ "created", "updated", "destroyed"]
    * @param {uuid} id
    *        the definition.id of the definition we are synchronizing
    * @param {json} def
    *        the ABDefinition attributes we are storing.
    */
   definitionSync(op, id, def) {
      var { keyList, keyFn } = this.objectKeysByDef(def);
      if (keyList) {
         var curr;
         switch (op) {
            case "created":
               this[keyList].push(this[keyFn](def.json));
               this.emit("definition.created", def.json);
               break;

            case "updated":
               // get the current object
               curr = this[keyList].find((d) => d.id == id);

               // remove from list
               this[keyList] = this[keyList].filter((d) => d.id != id);
               // add new one:
               this[keyList].push(this[keyFn](def.json));

               // signal this object needs to be updated:
               // NOTE: if this is one of the objects we are tracking,
               // we don't need to this.emit() the message.
               if (curr) {
                  curr.emit("definition.updated", def.json);
               } else {
                  this.emit("definition.updated", def.json);
               }
               break;

            case "destroyed":
               // get the current object
               curr = this[keyList].find((d) => d.id == id);
               if (curr) {
                  // remove from list
                  this[keyList] = this[keyList].filter((d) => d.id != id);

                  // signal this object needs to be updated:
                  curr.emit("definition.deleted", def.json);

                  this.emit("definition.deleted", def.json);
               }
               break;
         }
      }
   }

   //
   // ABObjects
   //
   /**
    * @method applications()
    * return all the ABApplications that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABApplications.
    *        Must return true to include the entry.
    * @return {array}
    */
   applications(fn = () => true) {
      return (this._allApplications || []).filter(fn);
   }

   /**
    * @method applicationByID()
    * returns a single ABApplication that matches the given ID.
    * @param {string} ID
    *        the .id/.name/.label of the ABApplication we are searching
    *        for.
    * @return {ABApplication}
    *        the matching ABApplication object if found
    *        {null} if not found.
    */
   applicationByID(ID) {
      return this.applications((a) => a.id == ID)[0];
   }

   /**
    * @method applicationNew()
    * Return a new instance of an ABApplication object.
    * @param {json} values
    *        the ABDefinition.json of the ABApplication object we are
    *        creating.
    * @return {ABApplication}
    */
   applicationNew(values) {
      // just in case we got here by mistake:
      if (values.appType == "mobile") {
         return this.applicationMobileNew(values);
      }

      return new _platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__["default"](values, this);
   }

   /**
    * @method applicationMobileNew()
    * Return a new instance of an ABApplicationMobile object.
    * @param {json} values
    *        the ABDefinition.json of the ABApplicationMobile object we are
    *        creating.
    * @return {ABApplicationMobile}
    */
   applicationMobileNew(values) {
      return new _platform_ABApplicationMobile__WEBPACK_IMPORTED_MODULE_1__["default"](values, this);
   }

   /**
    * @method datacollections()
    * return an array of all the ABDataCollection for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABDataCollection that
    *        this fn returns true for.
    * @return {array}
    *        array of ABDataCollection
    */
   datacollections(filter = () => true) {
      return (this._allDatacollections || []).filter(filter);
   }

   /**
    * @method datacollectionByID()
    * returns a single ABDatacollection that matches the given ID.
    * @param {string} ID
    *        the .id/.name/.label of the ABDatacollection we are searching
    *        for.
    * @return {ABDatacollection}
    *        the matching ABDatacollection object if found
    *        {null} if not found.
    */
   datacollectionByID(ID) {
      // an undefined or null ID should not match any DC.
      if (!ID) return null;

      return this.datacollections((dc) => {
         return dc.id == ID || dc.name == ID || dc.label == ID;
      })[0];
   }

   /**
    * @method datacollectionNew()
    * create a new instance of ABDataCollection
    * @param {obj} values
    *        the initial values for the DC
    * @return {ABDatacollection}
    */
   datacollectionNew(values) {
      var dc = new _platform_ABDataCollection__WEBPACK_IMPORTED_MODULE_11__["default"](values, this);
      dc.on("destroyed", () => {
         // make sure it is no longer in our internal list
         this._allDatacollections = this._allDatacollections.filter(
            (d) => d.id != dc.id
         );
      });
      return dc;
   }

   /**
    * @method fieldNew()
    * return an instance of a new (unsaved) ABField that is tied to a given
    * ABObject.
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    * @param {obj} values  the initial values for this field.
    *                - { key:'{string}'} is required
    * @param {ABObject} object  the parent object this field belongs to.
    * @return {ABField}
    */
   fieldNew(values, object) {
      // NOTE: ABFieldManager returns the proper ABFieldXXXX instance.
      return _ABFieldManager__WEBPACK_IMPORTED_MODULE_4__["default"].newField(values, object);
   }

   /**
    * @method indexNew()
    * return an instance of a new (unsaved) ABIndex.
    * @return {ABIndex}
    */
   indexNew(values, object) {
      return new _platform_ABIndex__WEBPACK_IMPORTED_MODULE_5__["default"](values, object);
   }

   /**
    * @method Label()
    * a simple label factory.
    * It is expected to be called like this:
    * @codestart
    *    var L = AB.Label();
    *    var outputText = L("Hello World");
    *    var o2 = L("I'm {0} years old", [5]);
    * @codeend
    * @return {fn}
    */
   Label() {
      return (key, altText, values = []) => {
         var label = key;
         if (altText) {
            if (Array.isArray(altText)) {
               values = altText;
            } else {
               label = altText;
            }
         }

         values.forEach((v, i) => {
            var sub = `{${i}}`;
            label = label.replaceAll(sub, v);
         });

         return label;
      };
   }

   /**
    * @method objects()
    * return an array of all the ABObjects for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABObjects that this fn
    *        returns true for.
    * @return {array}
    *        array of ABObject
    */
   objects(filter = () => true) {
      return (this._allObjects || []).filter(filter);
   }

   /**
    * @method objectByID()
    * return the specific object requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   objectByID(ID) {
      return this.objects((o) => {
         return o.id == ID || o.name == ID || o.label == ID;
      })[0];
   }

   /**
    * @method objectNew()
    * return an instance of a new (unsaved) ABObject that is tied to this
    * ABApplication.
    * NOTE: this new object is not included in our this.objects until a .save()
    * is performed on the object.
    * @return {ABObject}
    */
   objectNew(values) {
      var newObj = null;

      if (values.isExternal == true)
         newObj = new _platform_ABObjectExternal__WEBPACK_IMPORTED_MODULE_7__["default"](values, this);
      else if (values.isImported == true)
         newObj = new _platform_ABObjectImport__WEBPACK_IMPORTED_MODULE_8__["default"](values, this);
      else if (values.isNetsuite == true)
         newObj = new _platform_ABObjectApiNetsuite__WEBPACK_IMPORTED_MODULE_10__["default"](values, this);
      else if (values.isAPI == true) newObj = new _platform_ABObjectApi__WEBPACK_IMPORTED_MODULE_9__["default"](values, this);
      else newObj = new _platform_ABObject__WEBPACK_IMPORTED_MODULE_6__["default"](values, this);

      /*
      // IS THIS CORRECT?
      newObj.on("destroyed", () => {
         // make sure it is no longer in our internal list
         this._allObjects = this._allObjects.filter((o) => o.id != newObj.id);
      });
      */

      return newObj;
   }

   objectFile() {
      return this.objectByID("4a9d89c9-f4eb-41af-91e4-909eff389f3e");
   }

   objectLanguage() {
      return this.objectByID("d84cd351-d96c-490f-9afb-2a0b880ca0ec");
   }

   objectProcessDefinition() {
      return this.objectByID("af91fc75-fb73-4d71-af14-e22832eb5915");
   }

   objectProcessForm() {
      return this.objectByID("d36ae4c8-edef-48d8-bd9c-79a0edcaa067");
   }

   objectProcessInstance() {
      return this.objectByID("2ba85be0-78db-4eda-ba43-c2c4e3831849");
   }

   objectRole() {
      return this.objectByID("c33692f3-26b7-4af3-a02e-139fb519296d");
   }

   objectScope() {
      return this.objectByID("af10e37c-9b3a-4dc6-a52a-85d52320b659");
   }

   objectToken() {
      return this.objectByID("08826ac7-4b33-4745-a3d7-f7831ca4ff59");
   }

   objectUser() {
      return this.objectByID("228e3d91-5e42-49ec-b37c-59323ae433a1");
   }

   objectKey() {
      return this.objectByID("d734fe8c-b615-446c-8a5f-793ddece19f9");
   }

   objectSecret() {
      return this.objectByID("db5b3b26-5300-4c92-bc73-8ce4f4696992");
   }

   //
   // Hints
   //
   /**
    * @method hints()
    * return all the ABHints that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABHints.
    *        Must return true to include the entry.
    * @return {array}
    */
   hints(filter = () => true) {
      return (this._allHints || []).filter(filter);
   }

   /**
    * @method hintByID()
    * return the specific hint requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   hintID(ID) {
      return this.hints((h) => {
         return h.id == ID || h.name == ID || h.label == ID;
      })[0];
   }

   /**
    * @method hintNew()
    * return an instance of a new (unsaved) ABHint that is tied to this
    * ABApplication.
    * NOTE: this new hint is not included in our this.hints until a .save()
    * is performed on the object.
    * @return {ABHint}
    */
   hintNew(values) {
      var newHint = new _platform_ABHint__WEBPACK_IMPORTED_MODULE_13__["default"](values, this);

      return newHint;
   }

   //
   // Steps
   //
   /**
    * @method steps()
    * return all the ABSteps that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABSteps.
    *        Must return true to include the entry.
    * @return {array}
    */
   steps(filter = () => true) {
      return (this._allSteps || []).filter(filter);
   }

   /**
    * @method stepByID()
    * return the specific step requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   stepID(ID) {
      return this.steps((s) => {
         return s.id == ID || s.name == ID || s.label == ID;
      })[0];
   }

   /**
    * @method stepNew()
    * return an instance of a new (unsaved) ABStep that is tied to this
    * ABApplication.
    * NOTE: this new step is not included in our this.steps until a .save()
    * is performed on the object.
    * @return {ABHint}
    */
   stepNew(id, hintID) {
      var stepDef = this.definitionByID(id);
      if (stepDef) {
         var getStep = new _platform_ABStep__WEBPACK_IMPORTED_MODULE_18__["default"](stepDef, this);
         return getStep;
      } else {
         var params = {
            settings: {
               hint: hintID,
            },
         };
         var newStep = new _platform_ABStep__WEBPACK_IMPORTED_MODULE_18__["default"](params, this);
         return newStep;
      }

      // return null;
   }

   //
   // Processes
   //
   /**
    * @method processes()
    * return all the ABProcess that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABProcess.
    *        Must return true to include the entry.
    * @return {array}
    */
   processes(filter = () => true) {
      return (this._allProcesses || []).filter(filter);
   }

   /**
    * @method processByID()
    * return the specific process requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   processByID(ID) {
      return this.processes((p) => {
         return p.id == ID || p.name == ID || p.label == ID;
      })[0];
   }

   /**
    * @method processNew()
    * Return a new instance of an ABProcess object.
    * @param {json} values
    *        the ABDefinition.json of the ABProcess object we are
    *        creating.
    * @return {ABProcess}
    */
   processNew(values) {
      return new _platform_ABProcess__WEBPACK_IMPORTED_MODULE_14__["default"](values, this);
   }

   /**
    * @method processElementNew(id)
    * return an instance of a new ABProcessOBJ that is tied to a given
    * ABProcess.
    * @param {string} id
    *        the ABDefinition.id of the element we are creating
    * @param {ABProcess} process
    *        the process this task is a part of.
    * @return {ABProcessTask}
    */
   processElementNew(id, process) {
      var taskDef = this.definitionByID(id);
      if (taskDef) {
         switch (taskDef.type) {
            case _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_15__["default"].defaults().type:
               return new _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_15__["default"](taskDef, process, this);
            // break;

            case _platform_process_ABProcessLane__WEBPACK_IMPORTED_MODULE_16__["default"].defaults().type:
               return new _platform_process_ABProcessLane__WEBPACK_IMPORTED_MODULE_16__["default"](taskDef, process, this);
            // break;

            default:
               // default to a Task
               return _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_17__["default"].newTask(taskDef, process, this);
            // break;
         }
      }
      return null;
   }

   /**
    * @method processElementNewForModelDefinition(def)
    *
    * return an instance of a new ABProcess[OBJ] that is tied to the given
    * BPMI:Element definition.
    *
    * @param {BPMI:Element} element the element definition from our BPMI
    *              modler.
    * @return {ABProcess[OBJ]}
    */
   processElementNewForModelDefinition(element, process) {
      var newElement = null;

      switch (element.type) {
         case "bpmn:Participant":
            newElement = new _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_15__["default"]({}, process, this);
            break;

         case "bpmn:Lane":
            newElement = new _platform_process_ABProcessLane__WEBPACK_IMPORTED_MODULE_16__["default"]({}, process, this);
            break;

         default:
            var defaultDef = _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_17__["default"].definitionForElement(element);
            if (defaultDef) {
               newElement = _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_17__["default"].newTask(
                  defaultDef,
                  process,
                  this
               );
            }
            break;
      }

      // now make sure this new Obj pulls any relevant info from the
      // diagram element
      if (newElement) {
         newElement.fromElement(element);
      }
      return newElement;
   }

   /**
    * @method queries()
    * return an array of all the ABObjectQuery(s).
    * @param {fn} filter
    *        a filter fn to return a set of ABObjectQuery(s) that this fn
    *        returns true for.
    * @return {array}
    *        array of ABObjectQuery
    */
   queries(filter = () => true) {
      return (this._allQueries || []).filter(filter);
   }
   // queriesAll() {
   //    console.error(
   //       "ABFactory.queriesAll() Depreciated! Use .queries() instead. "
   //    );
   //    return this.queries();
   // }

   /**
    * @method queryByID()
    * return the specific query requested by the provided id.
    * NOTE: this method has been extended to allow .name and .label
    * as possible lookup values.
    * @param {string} ID
    * @return {ABObjectQuery}
    */
   queryByID(ID) {
      return this.queries((q) => {
         return q.id == ID || q.name == ID || q.label == ID;
      })[0];
   }

   /**
    * @method queryNew()
    * return an instance of a new (unsaved) ABObjectQuery that is tied to this
    * ABFactory.
    * @return {ABObjectQuery}
    */
   queryNew(values) {
      return new _platform_ABObjectQuery__WEBPACK_IMPORTED_MODULE_12__["default"](values, this);
   }

   /**
    * @method rowfilterNew()
    * return an instance of a new RowFilter that is tied to this
    * ABFactory.
    * @return {RowFilter}
    */
   rowfilterNew(App, idBase) {
      if (App) {
         console.error("!! Who is calling this with an App?");
      }
      return new _platform_RowFilter__WEBPACK_IMPORTED_MODULE_22__["default"](App || this._App, idBase, this);
   }

   /**
    * @method filterComplexNew()
    * return an instance of a new FilterComplex that is tied to this
    * ABFactory.
    * @return {FilterComplex}
    */
   filterComplexNew(idBase, options = {}) {
      return new _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_23__["default"](idBase, this, options);
   }

   /**
    * @method viewNewDetatched()
    * Return an instance of a View that is NOT attached to an ABApplication.
    * @return {ABViewXXX}
    */
   viewNewDetatched(values) {
      if (!this._mockApp) {
         this._mockApp = this.applicationNew({});
      }
      return this._mockApp.viewNew(values, this._mockApp);
   }

   //
   // Utilities
   //

   /**
    * notify()
    * will send alerts to a group of people. These alerts are usually about
    * configuration errors, or software problems.
    * @param {string} domain
    *     which group of people we are sending a notification to.
    * @param {Error} error
    *     An error object generated at the point of issue.
    * @param {json} info
    *     Additional related information concerning the issue.
    */
   notify(/* ...params */) {
      console.error(
         "ABFactory.notify() is expected to be overwritten by the platform!"
      );
   }

   /**
    * notifyInfo()
    * a common routine to parse the info parameter provided to .notify() into
    * a more detailed set of data.
    * @param {json} info
    * @return {json}
    */
   _notifyInfo(info) {
      var moreInfo = {};

      if (info) {
         Object.keys(info).forEach((k) => {
            switch (k) {
               case "field":
                  moreInfo.objectID = info[k].object?.id;
                  moreInfo.objectName = info[k].object?.name;
                  moreInfo.fieldID = info[k].id;
                  moreInfo.fieldName = info[k].label || info[k].name;
                  break;

               case "object":
                  moreInfo.objectID = info[k].id;
                  moreInfo.objectName = info[k].name;
                  break;

               case "datacollection":
                  moreInfo.datacollectionID = info[k].id;
                  moreInfo.datacollectionName = info[k].label || info[k].name;
                  var ds = info[k].datasource;
                  if (ds) {
                     moreInfo.datacollectionDSID = ds.id;
                     moreInfo.datacollectionDSName = ds.name;
                  }
                  break;

               case "process":
                  moreInfo.processID = info[k].id;
                  moreInfo.processName = info[k].label || info[k].name;
                  break;

               case "req":
                  moreInfo.req = {
                     jobID: info[k].jobID,
                     tenantID: info[k]._tenantID,
                     user: info[k]._user,
                  };
                  break;

               case "task":
                  if (info[k].process) {
                     moreInfo.processID = info[k].process.id;
                     moreInfo.processName =
                        info[k].process.label || info[k].process.name;
                  }
                  moreInfo.taskID = info[k].id;
                  moreInfo.taskName = info[k].label || info[k].name;
                  break;

               case "view":
                  if (info[k].application) {
                     moreInfo.applicationID = info[k].application.id;
                     moreInfo.applicationName =
                        info[k].application.label || info[k].application.name;
                  }
                  moreInfo.viewID = info[k].id;
                  moreInfo.viewName = info[k].label || info[k].name;
                  moreInfo.viewKey = info[k].key;
                  break;
               default:
                  moreInfo[k] = info[k];
                  break;
            }
         });
      }

      return moreInfo;
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABFactory);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 96408:
/*!**************************************************!*\
  !*** ./src/js/AppBuilder/core/ABFieldManager.js ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldManager)
/* harmony export */ });
/*
 * ABFieldManager
 *
 * An interface for managing the different ABFields available in our AppBuilder.
 *
 */

/*
 * Fields
 * A name => ABField  hash of the different ABFields available.
 */
var Fields = {};

var AllFieldClasses = [
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldString */ 56675)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldLongText */ 33482)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldNumber */ 66242)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldDate */ 42405)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldDateTime */ 68246)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldBoolean */ 23126)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldList */ 23122)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldTree */ 32001)),
   await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldEmail */ 19387)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldFile */ 5833)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldImage */ 34688)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldUser */ 21391)),
   await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldConnect */ 30289)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldCalculate */ 15308)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldTextFormula */ 62817)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldFormula */ 54953)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldAutoIndex */ 99341)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldJson */ 7101)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldCombine */ 71331)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldSelectivity */ 55522)),
];

AllFieldClasses.forEach((FIELD) => {
   FIELD = FIELD.default;
   Fields[FIELD.defaults().key] = FIELD;
});

class ABFieldManager {
   /*
    * @function allFields
    * return all the currently defined ABFields in an array.
    * @return [{ABField},...]
    */
   static allFields() {
      var fields = [];
      for (var f in Fields) {
         fields.push(Fields[f]);
      }
      return fields;
   }

   /**
    * @function fieldByKey()
    * Return a specific ABField that matches the given key
    * @param {string} key
    *        The ABField.key value we are looking for.
    * @return {ABFieldXXX || undefined}
    */
   static fieldByKey(key) {
      return Fields[key];
   }

   /*
    * @function newField
    * return an instance of an ABField based upon the values.key value.
    * @return {ABField}
    */
   static newField(values, object) {
      if (values.key) {
         try {
            return new Fields[values.key](values, object);
         } catch (err) {
            console.log("Error", err);
            console.log("Available fields", Fields);
            console.log("Requested field", values.key);
         }
      } else {
         console.log("-------");
         console.log("values:");
         console.error(values);
         console.log();
         console.error("object:");
         console.error(object);
         console.log("-------");
         throw new Error(
            `ABFieldManager.newField(): Unknown Field Key [${values.name}][${values.key}] for object[${object.name}]`
         );
         //// TODO: what to do here?
      }
   }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 36717:
/*!**********************************************!*\
  !*** ./src/js/AppBuilder/core/ABHintCore.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABHintCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
// import ABApplication from "./ABApplication"


// const _concat = require("lodash/concat");

class ABHintCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(["name", "description"], AB);

      this.fromValues(attributes);

      // indicate we are ready.
      // this.elements().forEach((e) => {
      //    e.onProcessReady();
      // });
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
    {
      id: uuid(),
      name: 'name',
      description: 'description',
      type: 'hint',
      settings: {
         active: {boolean},
         view: uuid
      }
    }
    */

      let active = attributes?.settings?.active ?? "1";

      this.id = attributes?.id || "";
      this.name = attributes?.name || "New Tutorial";
      this.description = attributes?.description || "";
      this.type = attributes?.type || "hint";
      this.settings = {};
      this.settings.active = active;
      this.settings.transition = attributes?.settings?.transition;
      this.settings.showIntroStep = attributes?.settings?.showIntroStep;
      this.settings.view = attributes?.settings?.view || "";
      this.stepIDs = attributes?.stepIDs || [];

      let currSteps = this?._steps || {};
      this._steps = {};
      (attributes?.stepIDs || []).forEach((sID) => {
         if (!sID) return;
         var ele = this.AB.stepNew(sID, this.id);
         if (ele) {
            this._steps[sID] = ele;
         }
      });
      if (attributes) super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this ABProcess instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label) {
         this.label = this.name;
      }

      // OP.Multilingual.unTranslate(this, this, ["label"]);
      var data = super.toObj();

      var fieldsToSave = ["type", "settings", "stepIDs", "id", "name"];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   /**
    * steps()
    * return an array of steps that match the given filter (or all steps
    * if no filter is provided).
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return {[ABStep]}
    */
   steps(fn = () => true) {
      var allSteps = Object.keys(this._steps).map((e) => {
         return this._steps[e];
      });
      return allSteps.filter(fn);
   }

   /**
    * stepAdd()
    * insert a step to be added to this hint.
    * @param {ABStep} element
    *        the full instance of an ABStep to track.
    */
   stepAdd(step) {
      this._steps[step.id] = step;
   }

   /**
    * stepByID()
    * return the {ABStep} that has the given .id
    * @param {string} id
    * @return {ABStep[OBJ]}
    */
   stepByID(id) {
      return this._steps[id] ?? null;
   }

   /**
    * stepRemove()
    * remove a step from being displayed by this hint.
    * @param {id} ABStep ID
    *        an ID of a step
    *        to remove.
    */
   stepRemove(id) {
      // remove from stepIDs array
      let stepIndex = this.stepIDs.indexOf(id);
      if (stepIndex > -1) {
         this.stepIDs.splice(stepIndex, 1);
      }
      // remove from _steps definitions
      delete this._steps[id];
   }
}


/***/ }),

/***/ 59815:
/*!***********************************************!*\
  !*** ./src/js/AppBuilder/core/ABIndexCore.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABIndexCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);


class ABIndexCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, object) {
      super(["label"], object.AB);
      this.object = object;

      this.fromValues(attributes);
   }

   fromValues(attributes) {
      /*
      {
        id: uuid(),
        name: 'name',
        fields:[
            {ABDataField.id}
        ],
        unique: {boolean}
      }
      */
      this.id = attributes.id;
      this.type = "index";
      this.name = attributes.name;
      this.unique = JSON.parse(attributes.unique || false);

      // Convert to an array
      if (attributes.fieldIDs && !Array.isArray(attributes.fieldIDs)) {
         attributes.fieldIDs = [attributes.fieldIDs];
      }

      this._unknownFieldIDs = [];
      this.fields = (attributes.fieldIDs || [])
         .map((f) => {
            let field = this.object.fieldByID(f);
            if (!field) {
               this._unknownFieldIDs.push(f);
               let err = new Error(
                  `Index[${this.name}][${this.id}] is referencing an unknown field[${f}]`
               );
               this.AB.notify.developer(err, {
                  index: this.id,
                  field: f,
               });
            }
            return field;
         })
         .filter((fId) => fId);

      if (this.fields.length == 0) {
         let err = new Error(
            `Index[${this.name}][${this.id}] is not referencing any fields`
         );
         this.AB.notify.developer(err, {
            index: this.id,
            attributeFieldIDs: attributes.fieldIDs || [],
         });
      }

      // let the MLClass process the Translations
      super.fromValues(attributes);
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      let result = super.toObj();

      result.id = this.id;
      result.type = "index";
      result.name = this.name;
      result.unique = this.unique;

      // Convert to an array
      if (this.fields && !Array.isArray(this.fields)) {
         this.fields = [this.fields];
      }

      result.fieldIDs = (this.fields || [])
         .map((f) => {
            // Convert to the id of field
            return f.id || f;
         })
         .filter((fId) => fId);

      // carry along the unknown Field IDs so a
      // developer/builder can come along and trace
      // what happened.
      this._unknownFieldIDs.forEach((f) => {
         result.fieldIDs.push(f);
      });

      return result;
   }

   get indexName() {
      let tableName = this.object.dbTableName();

      // Maximum 64 characters long
      return `${tableName}_${this.name}`.replace(/ /g, "").substring(0, 64);
   }

   get uniqueName() {
      let indexName = this.indexName.substring(0, 57);

      return `${indexName}_unique`;
   }
}


/***/ }),

/***/ 90477:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/core/ABMLClassCore.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMLClassCore)
/* harmony export */ });
/* harmony import */ var _platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABEmitter */ 4025);
/**
 * ABMLClassCore
 * manage the multilingual information of an instance of a AB Defined Class.
 *
 * these classes have certain fields ("label", "description"), that can be
 * represented in different language options as defined by our platform.
 *
 * This core ABMLClass will internally track the multilingual fields
 * (this.mlFields) and auto
 */

class ABMLClassCore extends _platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(fieldList, AB) {
      super();
      this.mlFields = fieldList || ["label"];
      // {array}
      // field names of values that are multilingual

      this.AB = AB;
      // {ABFactory}
      // our common source of references for other AB objects
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   /**
    * @method fromValues
    * called during the .fromValues() work chain.  Should be called
    * AFTER all the current data is already populated.
    */
   fromValues(attributes) {
      this.translations = attributes.translations;

      // if translations were provided
      if (this.translations) {
         // multilingual fields: label, description
         this.translate();
      } else {
         // maybe this came from a form that has ML values in the attributes, but
         // no .translations[] yet:
         // check for mlFields in attributes and record them here:
         (this.mlFields || []).forEach((field) => {
            if (attributes[field]) {
               this[field] = attributes[field];
            }
         });
      }
   }

   /**
    * @function defaultTranslations()
    * return an initial .translations entry to initialize the
    * translations values of a given translateable object.
    * @param {array} fields  the multilingual fields this obj manages.
    * @param {json}  values  a default set of values for this object.
    * @return {array}  of translation entries.
    */
   defaultTranslations(fields, values) {
      values = values || {};

      var entry = {
         // Question: should this be this.AB.Multilingual.currentLanguage() || "en"
         // currently since the defaults are sent in programattically, we are
         // expecting the labels to be in "en"
         language_code: "en",
      };

      fields.forEach((f) => {
         entry[f] = values[f] || f;
      });

      return [entry];
   }

   /**
    * @method languageDefault
    * return a default language code.
    * @return {string}
    */
   languageDefault() {
      return "en";
   }

   /**
    * @method toObj()
    * called during the .toObj() work chain.  Should be called
    * BEFORE the current data is populated.
    */
   toObj() {
      this.unTranslate();

      return {
         translations: this.translations,
      };
   }

   /**
    * @method toDefinition()
    * convert this instance into an ABDefinition object.
    * @return {ABDefinition}
    */
   toDefinition() {
      return this.AB.definitionNew({
         id: this.id,
         name: this.name,
         type: this.type,
         json: this.toObj(),
      });
   }

   /**
    * @method translate
    * Given a set of json data, pull out any multilingual translations
    * and flatten those values to the base object.
    * @param {obj} obj  The instance of the object being translated
    * @param {json} json The json data being used for translation.
    *                      There should be json.translations = [ {transEntry}, ...]
    *                      where transEntry = {
    *                          language_code:'en',
    *                          field1:'value',
    *                          ...
    *                      }
    * @param {array} fields an Array of multilingual fields to pull to
    *                       the obj[field] value.
    */
   translate(obj, json, fields, languageCode = null) {
      if (!obj) obj = this;
      if (!json) json = this;
      if (!fields) fields = this.mlFields || [];

      if (!json.translations) {
         json.translations = [];
      }

      if (typeof json.translations == "string") {
         json.translations = JSON.parse(json.translations);
      }

      var currLanguage = languageCode || this.languageDefault();

      if (fields && fields.length > 0) {
         // [fix] if no matching translation is in our json.translations
         //       object, then just use the 1st one.
         var first = null; // the first translation entry encountered
         var found = false; // did we find a matching translation?

         json.translations.forEach(function (t) {
            if (!first) first = t;

            // find the translation for the current language code
            if (t.language_code == currLanguage) {
               found = true;

               // copy each field to the root object
               fields.forEach(function (f) {
                  if (t[f] != null) obj[f] = t[f];

                  obj[f] = t[f] || ""; // default to '' if not found.
               });
            }
         });

         // if !found, then use the 1st entry we did find.  prepend desired
         // [language_code] to each of the fields.
         if (!found && first) {
            // copy each field to the root object
            fields.forEach(function (f) {
               if (first[f] != null && first[f] != "")
                  obj[f] = `[${currLanguage}]${first[f]}`;
               else obj[f] = ""; // default to '' if not found.
            });
         }
      }
   }

   /**
    * @method unTranslate
    * Take the multilingual information in the base obj, and push that
    * down into the json.translations data.
    * @param {obj} obj  The instance of the object with the translation
    * @param {json} json The json data being used for translation.
    *                      There should be json.translations = [ {transEntry}, ...]
    *                      where transEntry = {
    *                          language_code:'en',
    *                          field1:'value',
    *                          ...
    *                      }
    * @param {array} fields an Array of multilingual fields to pull from
    *                       the obj[field] value.
    */
   unTranslate(obj, json, fields) {
      if (!obj) obj = this;
      if (!json) json = this;
      if (!fields) fields = this.mlFields || [];

      if (!json.translations) {
         json.translations = [];
      }

      var currLanguage = this.languageDefault();

      if (fields && fields.length > 0) {
         var foundOne = false;

         json.translations.forEach(function (t) {
            // find the translation for the current language code
            if (t.language_code == currLanguage) {
               // copy each field to the root object
               fields.forEach(function (f) {
                  // verify obj[f] is defined
                  // --> DONT erase the existing translation
                  if (obj[f] != null) {
                     t[f] = obj[f];
                  }
               });

               foundOne = true;
            }
         });

         // if we didn't update an existing translation
         if (!foundOne) {
            // create a translation entry:
            var trans = {};

            // assume current languageCode:
            trans.language_code = currLanguage;

            fields.forEach(function (field) {
               if (obj[field] != null) {
                  trans[field] = obj[field];
               }
            });

            json.translations.push(trans);
         }
      }
   }
}


/***/ }),

/***/ 312:
/*!***********************************************!*\
  !*** ./src/js/AppBuilder/core/ABModelCore.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABModelCore)
/* harmony export */ });
//
// ABModelCore
//
// Represents the Data interface for an ABObject data.
//
// to use an ABModel to load a DataTable:
// Method 1:
//  gather all the data externally and send to the DataTable
//    Model.findAll()
//    .then((data)=>{
//      DataTable.parse(data);
//    })
//

class ABModelCore {
   constructor(object) {
      // link me to my ABObject
      this.object = object;
      this.AB = object.AB;

      this._where = null;
      this._sort = null;
      this._skip = null;
      this._limit = null;

      this.staleRefreshInProcess = false;
      this.staleRefreshMap = {
         /* id : Promise */
      };
      this.staleRefreshPending = [];
      this.staleRefreshTimerID = null;

      // include this
      this.responseContext = { key: "--", context: {} };
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   contextKey(key) {
      this.responseContext.key = key || "--";
   }

   contextValues(values) {
      this.responseContext.context = values || {};
   }

   // Prepare multilingual fields to be untranslated
   // Before untranslating we need to ensure that values.translations is set.
   prepareMultilingualData(values) {
      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();
      // if mlFields are inside of the values saved we want to translate otherwise do not because it will reset the translation field and you may loose unchanged translations
      var shouldTranslate = false;
      if (mlFields.length) {
         mlFields.forEach(function (field) {
            if (values[field] != null) {
               shouldTranslate = true;
            }
         });
      }
      if (shouldTranslate) {
         if (
            values.translations == null ||
            typeof values.translations == "undefined" ||
            values.translations == ""
         ) {
            values.translations = [];
         }
         this.object.unTranslate(values, values, mlFields);
      }
   }

   request(/* method, params */) {
      console.error(
         "!!! ABModelCore.request() should be overridden by platform."
      );
      return Promise.resolve();
   }

   // /**
   //  * @method create
   //  * update model values on the server.
   //  */
   // create(values) {

   //   this.prepareMultilingualData(values);

   //   var params = {
   //     url: this.object.urlRest(),
   //     params: values
   //   }
   //   return this.request('post', params)
   //     .then((data) => {

   //       this.normalizeData(data);

   //       return data;

   //       // FIX: now with sockets, the triggers are fired from socket updates.
   //       // trigger a create event
   //       // triggerEvent('create', this.object, data);

   //     })
   //     .catch(reject);

   // }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer} id  the .id of the instance to remove.
    * @return {Promise}
    */
   // delete(id) {

   //   var params = {
   //     url: this.object.urlRestItem(id)
   //   }
   //   return this.request('delete', params)
   //     .then((data) => {

   //       return data;

   //       // FIX: now with sockets, the triggers are fired from socket updates.
   //       // trigger a delete event
   //       // triggerEvent('delete', this.object, id);

   //     })
   // }

   /**
    * @method findAll
    * performs a data find with the provided condition.
    */
   //   findAll(cond) {

   //     cond = cond || {};

   //     var params = {
   //       url: this.object.urlRest(),
   //       params: cond
   //     }
   //     return this.request('get', params)
   //       .then((data) => {

   //         this.normalizeData(data.data);

   //         resolve(data);
   //       })
   //       .catch((err) => {
   // /// TODO: this should be done in platform/ABModel:
   //         // if (err && err.code) {
   //         //  switch(err.code) {
   //         //    case "ER_PARSE_ERROR":
   //         //      OP.Error.log('AppBuilder:ABModel:findAll(): Parse Error with provided condition', { error: err, condition:cond })
   //         //      break;

   //         //    default:
   //         //      OP.Error.log('AppBuilder:ABModel:findAll(): Unknown Error with provided condition', { error: err, condition:cond })
   //         //      break;
   //         //  }

   //         // }
   // console.error(err);
   //       })

   //   }

   urlParamsCreate(values) {
      return {
         url: this.object.urlRest(),
         params: values,
      };
   }

   urlParamsDelete(id) {
      return {
         url: this.object.urlRestItem(id),
      };
   }

   urlParamsFind(cond) {
      return {
         url: this.object.urlRest(),
         params: cond || {},
      };
   }

   urlParamsUpdate(id, values) {
      return {
         url: this.object.urlRestItem(id),
         params: values,
      };
   }

   /**
    * @method count
    * count a data find with the provided condition.
    */
   count(cond) {
      cond = cond || {};

      var params = {
         url: this.object.urlRestCount(),
         params: cond,
      };
      return this.request("get", params)
         .then((numberOfRows) => {
            // resolve(numberOfRows);
            return numberOfRows;
         })
         .catch((err) => {
            // TODO: this should be done in platform/ABModel

            // OP.Error.log('AppBuilder:ABModel:count(): Parse Error with provided condition', { error: err, condition:cond })

            // reject(err);
            console.error(err);
         });
   }

   /**
    * @method staleRefresh
    * Process a request to refresh the data for a given entry.
    * This method is called from a ABDataview when it receives
    * a 'ab.datacollection.stale' message.
    * This method will try to queue similar reqeusts and then issue 1 large
    * request, rather than numerous individual ones.
    * @param {obj} cond  the condition of the entry we are requesting.
    * @return {Promise}
    */
   staleRefresh(cond) {
      // cond should be { where:{ id: X } } format.
      var PK = this.object.PK();

      var currID = cond[PK]; // just in case we get a { id: X }
      if (cond.where) {
         currID = cond.where[PK];
      }

      return new Promise((resolve, reject) => {
         if (!currID) {
            var Err = new Error(
               "Model.staleRefresh(): could not resolve ." + PK
            );
            Err.cond = cond;
            reject(Err);
            return;
         }

         // convert to PK : Promise object:
         var entry = {
            resolve: resolve,
            reject: reject,
         };
         entry[PK] = currID;

         // queue up refresh condition
         this.staleRefreshPending.push(entry);

         // if ! staleRefreshInProcess
         if (!this.staleRefreshInProcess) {
            // set timeout to another 200ms wait after LAST staleRefresh()
            if (this.staleRefreshTimerID) {
               clearTimeout(this.staleRefreshTimerID);
            }
            this.staleRefreshTimerID = setTimeout(() => {
               this.staleRefreshProcess();
            }, 200);
         }
      });
   }

   /**
    * @method staleRefreshProcess
    * Actually process the current pending requests.
    */
   staleRefreshProcess() {
      this.staleRefreshInProcess = true;
      var currentEntries = this.staleRefreshPending;
      this.staleRefreshPending = [];
      var PK = this.object.PK();

      var responseHash = {
         /* id : [{entry}] */
      };
      var cond = { where: {}, populate: true };
      cond.where[PK] = [];

      console.log(
         "Model.staleRefreshProcess(): buffered " +
            currentEntries.length +
            " requests"
      );
      currentEntries.forEach((e) => {
         responseHash[e[PK]] = responseHash[e[PK]] || [];
         responseHash[e[PK]].push(e);
      });

      cond.where[PK] = Object.keys(responseHash);

      this.findAll(cond).then((res) => {
         // for each entry we got back
         if (Array.isArray(res.data) && res.data.length) {
            res.data.forEach((data) => {
               // find it's matching request:
               if (responseHash[data[PK]]) {
                  // respond to the pending promise
                  // and remove these entries from responseHash
                  var entries = responseHash[data[PK]];
                  entries.forEach((entry) => {
                     var resolve = entry.resolve;
                     resolve({ data: [data] });
                  });

                  delete responseHash[data[PK]];
               } else {
                  console.error(
                     "Model.staleRefreshProcess(): returned entry was not in our responseHash:",
                     data,
                     responseHash
                  );
               }
            });
         }

         // now if there are any entries left in responseHash,
         // respond with an empty entry:
         var allKeys = Object.keys(responseHash);
         if (allKeys.length > 0) {
            console.warn(
               "Model.staleRefreshProcess(): " +
                  allKeys.length +
                  " entries with no responses. "
            );
         }
         allKeys.forEach((key) => {
            let entry = responseHash[key];
            let resolve;
            if (Array.isArray(entry)) {
               resolve = entry[0].resolve;
            } else {
               resolve = entry.resolve;
            }
            resolve({ data: [] });
            delete responseHash[key];
         });

         // now check to see if there are any more pending requests:
         if (this.staleRefreshPending.length > 0) {
            // process them:
            this.staleRefreshProcess();
         } else {
            // mark we are no longer processing stale requests.
            this.staleRefreshInProcess = false;
         }
      });
   }

   /**
     * @method findConnected
     * return the connected data associated with an instance of this model.
     *
     * to limit the result to only a single connected column:
     *    model.findConnected( 'col1', {data})
     *    then ((data) => {
     *      // data = [{obj1}, {obj2}, ... {objN}]
     *    })
     *
     * To find >1 connected field data:
     *    model.findConnected( ['col1', 'col2'], {data} )
     *    .then((data) =>{
     *    
     *      // data = {
     *      //     col1 : [{obj1}, {obj2}, ... {objN}],
     *      //     col2 : [{obj1}, {obj2}, ... {objN}]
     *      // }
     *    })
     *
     * To find all connected field data:
     *    model.findConnected( {data} )
     *    .then((data) =>{
     *    
     *      // data = {
     *      //     connectedColName1 : [{obj1}, {obj2}, ... {objN}],
     *      //     connectedColName2 : [{obj1}, {obj2}, ... {objN}],
     *      //    ...
     *      //     connectedColNameN : [{obj1}, {obj2}, ... {objN}]
     *      // }
     *    })

     * @param {string/array} fields  [optional] an array of connected fields you want to return.
     * @param {obj} data  the current object instance (data) to lookup
     * @return {Promise}
     */
   findConnected(fields, data) {
      if (typeof data == "undefined") {
         if (!Array.isArray(fields) && typeof fields == "object") {
            data = fields;
            fields = []; // return all fields
         }
      }

      if (typeof fields == "string") {
         fields = [fields]; // convert to an array of values
      }

      return new Promise((resolve, reject) => {
         // sanity checking:
         if (!data.id) {
            // I can't find any connected items, if I can't find this one:
            resolve(null);
            return;
         }

         let cond = {};
         cond[this.object.PK()] = data.id;
         this.findAll({ where: cond, populate: true })
            .then((results) => {
               if (
                  !results.data ||
                  !Array.isArray(results.data) ||
                  results.data.length == 0
               ) {
                  resolve([]); // no data to return.
                  return;
               }

               // work with the first object.
               var myObj = results.data[0];

               // if only 1 field requested, then return that
               if (fields.length == 1) {
                  let data =
                     myObj[
                        fields[0].replace(/[^a-z0-9.]/gi, "") + "__relation"
                     ];
                  if (!data) return resolve([]);

                  if (!Array.isArray(data)) data = [data];

                  resolve(data);
                  return;
               }

               // if no fields requested, return them all:
               if (fields.length == 0) {
                  var allFields = this.object.fields((f) => {
                     return f.settings.linkType;
                  });
                  allFields.forEach((f) => {
                     fields.push(f.columnName);
                  });
               }

               var returnData = {};
               fields.forEach((colName) => {
                  returnData[colName] =
                     myObj[colName.replace(/[^a-z0-9.]/gi, "") + "__relation"];
               });

               resolve(returnData);
            })
            .catch((err) => {
               console.error("!!! error with findConnected() attempt:", err);
               reject(err);
            });
      });
   }

   // /**
   //  * @method loadInto
   //  * loads the current values into the provided Webix DataTable
   //  * @param {DataTable} DT  A Webix component that can dynamically load data.
   //  */
   // loadInto(DT) {

   //   // if a limit was applied, then this component should be loading dynamically
   //   if (this._limit) {

   //     DT.define('datafetch', this._limit);
   //     DT.define('datathrottle', 250);  // 250ms???

   //     // catch the event where data is requested:
   //     // here we will do our own findAll() so we can persist
   //     // the provided .where condition.

   //     // oh yeah, and make sure to remove any existing event handler when we
   //     // perform a new .loadInto()
   //     DT.___AD = DT.___AD || {};
   //     if (DT.___AD.onDataRequestEvent) {
   //       DT.detachEvent(DT.___AD.onDataRequestEvent);
   //     }
   //     DT.___AD.onDataRequestEvent = DT.attachEvent("onDataRequest", (start, count) => {

   //       var cond = {
   //         where: this._where,
   //         sort: this._sort,
   //         limit: count,
   //         skip: start
   //       }

   //       if (DT.showProgress)
   //         DT.showProgress({ type: "icon" });

   //       this.findAll(cond)
   //         .then((data) => {
   //           data.data.forEach((item) => {
   //             if (item.properties != null && item.properties.height != "undefined" && parseInt(item.properties.height) > 0) {
   //               item.$height = parseInt(item.properties.height);
   //             } else if (parseInt(this._where.height) > 0) {
   //               item.$height = parseInt(this._where.height)
   //             }
   //           });
   //           DT.parse(data);

   //           if (DT.hideProgress)
   //             DT.hideProgress();

   //         })

   //       return false; // <-- prevent the default "onDataRequest"
   //     });

   //     DT.refresh();
   //   }

   //   // else just load it all at once:
   //   var cond = {};
   //   if (this._where) cond.where = this._where;
   //   if (this._sort) cond.sort = this._sort;
   //   if (this._limit != null) cond.limit = this._limit;
   //   if (this._skip != null) cond.skip = this._skip;

   //   if (DT.showProgress)
   //     DT.showProgress({ type: "icon" });

   //   this.findAll(cond)
   //     .then((data) => {
   //       data.data.forEach((item) => {
   //         if (item.properties != null && item.properties.height != "undefined" && parseInt(item.properties.height) > 0) {
   //           item.$height = parseInt(item.properties.height);
   //         } else if (parseInt(this._where.height) > 0) {
   //           item.$height = parseInt(this._where.height)
   //         }
   //       });
   //       DT.parse(data);

   //       if (DT.hideProgress)
   //         DT.hideProgress();

   //     })
   //     .catch((err) => {
   //       console.error('!!!!!', err);
   //     })

   // }

   // /**
   //  * @method limit
   //  * set the limit value for this set of data
   //  * @param {integer} limit  the number or elements to return in this call
   //  * @return {ABModel} this object that is chainable.
   //  */
   // limit(limit) {
   //   this._limit = limit;
   //   return this;
   // }

   // /**
   //  * @method skip
   //  * set the skip value for this set of data
   //  * @param {integer} skip  the number or elements to skip
   //  * @return {ABModel} this object that is chainable.
   //  */
   // skip(skip) {
   //   this._skip = skip;
   //   return this;
   // }

   //   /**
   //    * @method update
   //    * update model values on the server.
   //    */
   //   update(id, values) {

   //     this.prepareMultilingualData(values);

   //     // remove empty properties
   //     for (var key in values) {
   //       if (values[key] == null)
   //         delete values[key];
   //     }

   //     var params = {
   //       url: this.object.urlRestItem(id),
   //       params: values
   //     }
   //     return this.request('put', params)
   //       .then((data) => {

   //         // .data is an empty object ??

   //         this.normalizeData(data);

   //         return data;

   //         // FIX: now with sockets, the triggers are fired from socket updates.
   //         // trigger a update event
   //         // triggerEvent('update', this.object, data);

   //       })
   //       .catch((err)=>{
   // console.error(err);
   //       });

   //   }

   /**
    * @method upsert
    * upsert model values on the server.
    */
   upsert(values) {
      this.prepareMultilingualData(values);

      // remove empty properties
      for (var key in values) {
         if (values[key] == null) delete values[key];
      }

      var params = {
         url: this.object.urlRest(),
         params: values,
      };
      return this.request("put", params)
         .then((data) => {
            // .data is an empty object ??

            this.normalizeData(data);

            return data;

            // FIX: now with sockets, the triggers are fired from socket updates.
            // trigger a update event
            // triggerEvent('update', this.object, data);
         })
         .catch((err) => {
            console.error(err);
         });
   }

   /**
    * @method where
    * set the where condition for the data being loaded.
    * @param {json} cond  the json condition statement.
    * @return {ABModel} this object that is chainable.
    */
   where(cond) {
      this._where = cond;
      return this;
   }

   /**
    * @method where
    * set the sort condition for the data being loaded.
    * @param {json} cond  the json condition statement.
    * @return {ABModel} this object that is chainable.
    */
   sort(cond) {
      this._sort = cond;
      return this;
   }

   /**
    * @method refresh
    * refresh model definition on the server.
    */
   refresh() {
      console.error("!!! Depreciated: where is this being called from?");
      return Promise.resolve();

      // var params = {
      //    url: this.object.urlRestRefresh(),
      // };
      // return this.request("put", params);
   }

   /**
    * @method isCsvPacked
    * check if the data is packed in a csv format
    * @param {json} data  the json condition statement.
    * @return {boolean} true if the data is packed in a csv format
    *                   false if the data is not packed in a csv format
    */
   isCsvPacked(data) {
      if (data.csv_packed) {
         return true;
      }
      return false;
   }

   /**
    * @method csvPack
    * pack the data into a csv format
    * @param {json} data
    *               The original data format.
    *              {
    *                data: [{obj1}, {obj2}, ... {objN}],
    *                total_bytes:xx,
    *              }
    * @return {json} the csv packed data
    *                {
    *                  csv_packed:{
    *                    data: "<csv data>",
    *                    relations: {
    *                      {connectionID}: "<csv data>",
    *                      {connectionID}: "<csv data>",
    *                      ...
    *                    },
    *                  },
    *                  total_bytes:xx,
    *                }
    */
   csvPack(data) {
      // data should be the original json data packet we want to send
      // {
      //   data: [{obj1}, {obj2}, ... {objN}],
      //   total_bytes:xx,
      // }
      // we want to convert this to:
      // {
      //   csv_packed:{
      //     data: "csv data",
      //     relations: {
      //       {connectionID}: "csv data", // each entry has entry._csvID, that is the lookup
      //       {connectionID}: "csv data",
      //       ...
      //   }
      //   total_bytes:xx,
      // }
      let packedData = { data: "", relations: {} };
      let myObject = this.object;

      let content = data.data;
      let returnType = "array";
      if (!Array.isArray(content)) {
         returnType = "single";
         content = [content];
      }
      content = content.filter((row) => !this.AB.isNil(row));

      // stringify any potential json data
      // starting with List data
      let keys = ["list", "json"];
      let stringifyFields = myObject.fields((f) => keys.indexOf(f.key) > -1);
      stringifyFields.forEach((f) => {
         for (let I = 0; I < content.length; I++) {
            let row = content[I];
            if (row[f.columnName]) {
               row[f.columnName] = JSON.stringify(row[f.columnName]);
            }
         }
      });

      // break out and compact the connected data
      let connections = myObject.connectFields();
      connections.forEach((connField) => {
         let connHash = {};
         let relationName = connField.relationName();
         let connPK = connField.datasourceLink.PK();

         // gather all the connected data for this field
         for (let I = 0; I < content.length; I++) {
            let row = content[I];
            if (row[relationName]) {
               if (Array.isArray(row[relationName])) {
                  row[relationName].forEach((r) => {
                     if (!connHash[r.id]) {
                        connHash[r.id] = r;
                     }
                  });
               } else {
                  let r = row[relationName];
                  if (!connHash[r.id]) {
                     connHash[r.id] = r;
                  }
               }
            }
         }

         // assign a smaller id value
         Object.keys(connHash).forEach((id, indx) => {
            connHash[id]._csvID = indx;
         });

         // now reencode the connection data to reference the new _csvID
         for (let I = 0; I < content.length; I++) {
            let row = content[I];
            let ids = [];
            let hasRelationData = false;
            if (row[relationName]) {
               hasRelationData = true;
               if (Array.isArray(row[relationName])) {
                  row[relationName].forEach((r) => {
                     ids.push(connHash[r.id]._csvID);
                  });
               } else {
                  let r = row[relationName];
                  ids.push(connHash[r.id]._csvID);
               }
            }
            // only make an update if it did have relation data
            if (hasRelationData) {
               row[connField.columnName] = JSON.stringify(ids);
               delete row[relationName];
            }
         }

         let connData = Object.values(connHash);
         connData.forEach((c) => {
            if (c.id == c[connPK]) {
               delete c.id;
            }

            // if translations are present return them to an object
            if (c.translations) {
               c.translations = JSON.stringify(c.translations);
            }
         });
         let connDataCsv = this.AB.jsonToCsv(connData);
         packedData.relations[connField.id] = connDataCsv;
      });

      // final data preparations for csv encoding
      for (let I = 0; I < content.length; I++) {
         let row = content[I];
         // client side .normalizeData() should repopulate .id
         delete row.id;

         // we don't use .properties anymore, right?
         delete row.properties;

         // make sure embedded translations are stringified.
         if (row.translations) {
            row.translations = JSON.stringify(row.translations);
         }

         // special case for relations that are empty
         connections.forEach((connField) => {
            let relationName = connField.relationName();
            if (row[relationName] === null) {
               delete row[relationName];
            }
         });
      }

      // now convert the data to CSV
      packedData.data = this.AB.jsonToCsv(content);
      packedData.type = returnType; // single or array

      let newData = {};
      Object.keys(data).forEach((key) => {
         if (key != "data") {
            newData[key] = data[key];
         }
      });
      newData.csv_packed = packedData;
      return newData;
   }

   /**
    * @method csvUnpack
    * unpack the data from our csv format
    * @param {json} data
    *              The csv packed data format.
    * @return {json} the unpacked data
    */
   csvUnpack(data) {
      // data should be a data packet returned from the server
      // {
      //   csv_packed:{
      //     data: "csv data",
      //     relations: {
      //       {connectionID}: "csv data", // each entry has entry._csvID, that is the lookup
      //       {connectionID}: "csv data",
      //       ...
      //   }
      //   total_bytes:xx,
      // }
      // we want to convert this to:
      // {
      //   data: [{obj1}, {obj2}, ... {objN}],
      //   total_bytes:xx,
      // }

      let myObject = this.object;
      let parseResult = this.AB.csvToJson(data.csv_packed.data);
      // parseResult = { data: [], errors:[], meta:{}}

      let returnType = data.csv_packed.type;

      if (parseResult.errors?.length) {
         // ignore common error when .data is ""
         if (data.csv_packed.data !== "") {
            console.error("Error parsing CSV data:", parseResult.errors);
            console.error("Original CSV data:");
            console.error(data.csv_packed.data);
            console.error("result:");
            console.error(parseResult.data);
         }
      }
      let jsonData = parseResult.data;

      let keyFields = ["list", "boolean", "number", "json"];
      let parseFields = myObject.fields((f) => keyFields.indexOf(f.key) > -1);
      jsonData.forEach((row) => {
         // unstringify any list,bool,number fields
         parseFields.forEach((f) => {
            let val = row[f.columnName];
            if (val && typeof val == "string") {
               try {
                  row[f.columnName] = JSON.parse(val);
               } catch (e) {
                  console.error(
                     "Error parsing JSON data for column: " + f.columnName,
                     val,
                     e
                  );
               }
            }
         });

         // if translations are present return them to an object
         if (row.translations) {
            row.translations = JSON.parse(row.translations);
         }
      });

      let connections = myObject.connectFields();
      connections.forEach((connField) => {
         let relationName = connField.relationName();

         if (data.csv_packed.relations[connField.id]) {
            let connDataParseResult = this.AB.csvToJson(
               data.csv_packed.relations[connField.id]
            );
            let connData = connDataParseResult.data;

            let connHash = {};
            let connPK = connField.datasourceLink.PK();
            connData.forEach((c) => {
               if (!c.id) {
                  c.id = c[connPK];
               }
               connHash[c._csvID] = c;
            });

            jsonData.forEach((row) => {
               let ids = [];
               let populatedData = [];
               let entries = [];
               try {
                  // ok, we know this is a possibility, so just skip it
                  if (row[connField.columnName] !== "") {
                     entries = JSON.parse(row[connField.columnName]);
                  }
               } catch (e) {
                  if (row[connField.columnName] == "") {
                     // not a problem, just no data
                  } else {
                     // this might be a situation on the server where
                     // row[columnName] has a value, but row[relationName] is empty.
                     if (typeof row[relationName] == "undefined") {
                        row[relationName] = null;
                     }
                     // console.error(
                     //    "Error parsing JSON data for column: " +
                     //       connField.columnName,
                     //    e
                     // );
                  }
               }
               if (!Array.isArray(entries)) {
                  entries = [entries];
               }
               entries.forEach((id) => {
                  if (connHash[id]) {
                     let connEntry = connHash[id];
                     ids.push(connField.getRelationValue(connEntry));
                     // Alternatively, we could remove the row[columnName] and let
                     // normalizeData() repopulate it.
                     populatedData.push(connEntry);
                  }
               });
               if (connField.linkType() == "many") {
                  row[connField.columnName] = ids;
                  row[connField.relationName()] = populatedData;
               } else {
                  row[connField.columnName] = ids[0];
                  row[connField.relationName()] = populatedData[0];
               }
            });

            // now clear the ._csvID from the data
            Object.keys(connHash).forEach((id) => {
               delete connHash[id]._csvID;
            });
         }
      });

      // final pass to clear up stringified relation data
      jsonData.forEach((row) => {
         connections.forEach((connField) => {
            // many connections must be an array, not "[]"
            if (connField.linkType() == "many") {
               let val = row[connField.columnName];
               if (val && typeof val == "string") {
                  row[connField.columnName] = JSON.parse(val);
               }
            }
         });
      });

      let returnData = {};
      Object.keys(data).forEach((key) => {
         if (key != "csv_packed") {
            returnData[key] = data[key];
         }
      });
      returnData.data = jsonData;

      if (returnType == "single" && Array.isArray(returnData.data)) {
         returnData.data = returnData.data[0];
      }
      return returnData;
   }

   normalizeData(data) {
      // convert to array
      if (!(data instanceof Array)) data = [data];

      // find all connected fields
      var connectedFields = this.object.connectFields();

      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();

      // if this object has some date fields, convert the data to date object:
      var dateFields =
         this.object.fields(function (f) {
            return f.key == "date" || f.key == "datetime";
         }) || [];

      // calculate fields
      var calculatedFields = this.object.fields((f) => f.key == "calculate");

      data.forEach((d) => {
         if (d == null) return;

         // various PK name
         if (!d.id && this.object.PK() != "id") d.id = d[this.object.PK()];

         // loop through data's connected fields
         connectedFields.forEach((c) => {
            // get the relation name so we can change the original object
            var relationName = c.relationName();

            // if (d[c.columnName] == null)
            //  d[c.columnName] = '';

            // Our client side tools need to know that this value is null if it
            // isn't provided:
            if (
               typeof d[relationName] == "undefined" &&
               typeof d[c.columnName] == "undefined"
            ) {
               d[relationName] = null;
               d[c.columnName] = null;
               return;
            }

            // if there is no data we can exit now
            if (d[relationName] == null) return;

            // if relation data is still a string and isn't empty
            if (
               typeof d[relationName] == "string" &&
               d[relationName].length > 0
            ) {
               // parse the string into an object
               d[relationName] = JSON.parse(d[relationName]);
            }

            // if the data is an array we need to loop through it
            if (Array.isArray(d[relationName])) {
               d[relationName].forEach((r) => {
                  // if translations are present and they are still a string
                  if (r.translations && typeof r.translations == "string") {
                     // parse the string into an object
                     r.translations = JSON.parse(r.translations);
                  }
               });
               // if the data is not an array it is a single item...check that has translations and it is a string
            } else if (
               d[relationName].translations &&
               typeof d[relationName].translations == "string"
            ) {
               // if so parse the string into an object
               d[relationName].translations = JSON.parse(
                  d[relationName].translations
               );
            }

            // set .id to relation columns
            let objectLink = c.datasourceLink;

            // if we didn't get the linked object, just return.
            if (!objectLink) return;

            let olPK = objectLink.PK();
            var relatedMlFields = objectLink.multilingualFields();

            if (Array.isArray(d[relationName])) {
               d[relationName].forEach((subData) => {
                  // update .id values
                  // if (olPK != "id" && subData[olPK]) subData.id = subData[olPK];
                  const relationValue = c.getRelationValue(subData);
                  if (olPK != "id") subData.id = relationValue;

                  // perform Translation
                  if (relatedMlFields.length) {
                     objectLink.translate(subData, subData, relatedMlFields);
                  }
               });
            } else {
               // update .id value
               // if (d[relationName][olPK]) {
               //    d[relationName].id = d[relationName][olPK];
               // }
               const relationValue = c.getRelationValue(d[relationName]);
               if (relationValue) {
                  d[relationName].id = relationValue;
               }

               // perform Translation
               if (relatedMlFields.length) {
                  objectLink.translate(
                     d[relationName],
                     d[relationName],
                     relatedMlFields
                  );
               }
            }

            // if (
            //    objectLink &&
            //    olPK != "id" &&
            //    d[relationName] &&
            //    !d[relationName].id
            // ) {
            //    // is array
            //    if (d[relationName].forEach) {
            //       d[relationName].forEach((subData) => {
            //          if (subData[olPK]) subData.id = subData[olPK];
            //       });
            //    } else if (d[relationName][olPK]) {
            //       d[relationName].id = d[relationName][olPK];
            //    }
            // }

            // if (relatedMlFields.length) {
            //    d[relationName];
            //    objectLink.translate(
            //       d[relationName],
            //       d[relationName],
            //       relatedMlFields
            //    );
            // }

            // Change property name of connected field
            if (!d[c.columnName]) {
               if (c.linkType() == "one") {
                  if (d[relationName]) {
                     // d[c.columnName] = d[relationName][olPK];
                     d[c.columnName] = c.getRelationValue(d[relationName]);
                  } else {
                     d[c.columnName] = null;
                  }
               } else {
                  if (d[relationName]) {
                     if (Array.isArray(d[relationName])) {
                        try {
                           d[c.columnName] = (d[relationName] || []).map(
                              // (i) => i[olPK]
                              (i) => c.getRelationValue(i)
                           );
                        } catch (e) {
                           console.log("+++++++++++++++");
                           console.log(`ID:[${c.id}]`);
                           console.log(`ColumnName:[${c.label}]`);
                           console.log(`relationName:[${relationName}]`);
                           console.log(`linkType:[${c.linkType()}]`);
                           console.log("data:");
                           console.log(JSON.stringify(d[relationName]));
                           console.log("+++++++++++++++");
                        }
                     } else {
                        // this is strange: supposed to be "many" but coming in
                        // as "one"
                        console.log("+++++++++++++++");
                        console.log(`ID:[${c.id}]`);
                        console.log(`ColumnName:[${c.label}]`);
                        console.log(`relationName:[${relationName}]`);
                        console.log(`linkType:[${c.linkType()}]`);
                        console.log("data:");
                        console.log(JSON.stringify(d[relationName]));
                        console.log("+++++++++++++++");
                        // d[c.columnName] = [d[relationName][olPK]];
                        d[c.columnName] = [c.getRelationValue(d[relationName])];
                     }
                  } else {
                     d[c.columnName] = [];
                  }
               }
            }
         });

         if (mlFields.length) {
            this.object.translate(d, d, mlFields);
         }

         // convert the data to date object
         dateFields.forEach((date) => {
            if (d && d[date.columnName] != null) {
               // check to see if data has already been converted to a date object
               if (typeof d[date.columnName] == "string") {
                  if (date.key == "date") {
                     // if we are ignoring the time it means we ignore timezone as well
                     // so lets trim that off when creating the date so it can be a simple date
                     d[date.columnName] = this.AB.rules.toDate(
                        d[date.columnName],
                        {
                           format: "MM/DD/YYYY",
                           ignoreTime: true,
                        }
                     );
                  } else {
                     // Convert UTC to Date
                     d[date.columnName] = this.AB.rules.toDate(
                        d[date.columnName]
                     );
                     // d[date.columnName] = new Date(moment(d[date.columnName]));
                  }
               }
            }
         });

         calculatedFields.forEach((calField) => {
            d[calField.columnName] = calField.format(d);
         });
      });
   }
}


/***/ }),

/***/ 31549:
/*!***************************************************!*\
  !*** ./src/js/AppBuilder/core/ABObjectApiCore.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectApiCore)
/* harmony export */ });
/* harmony import */ var _platform_ABObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABObject */ 83311);
/* harmony import */ var _platform_ABModelApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/ABModelApi */ 70558);



class ABObjectApiCore extends _platform_ABObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      this.isAPI = true;

      this.fromValues(attributes);
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   fromValues(attributes) {
      super.fromValues(attributes);

      this.readonly = parseInt(attributes.readonly) || 0;
      this.apiType = attributes.apiType || "Read";
      this.request = attributes.request ?? {};
      this.request.headers = attributes.request?.headers ?? [];
      this.response = attributes.response ?? {};
      this.response.fields = attributes.response?.fields ?? [];
      this.isFetched = attributes.isFetched ?? false;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABObjectQuery instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      const result = super.toObj();

      result.isAPI = this.isAPI;
      result.readonly = this.readonly;
      result.apiType = this.apiType;
      result.request = this.request ?? {};
      result.request.headers = this.request?.headers ?? [];
      result.response = this.response ?? {};
      result.response.fields = this.response?.fields ?? [];
      result.isFetched = this.isFetched;

      return result;
   }

   /**
    * @method model
    * return a Model object that will allow you to interact with the data for
    * this ABObjectQuery.
    */
   model() {
      var model = new _platform_ABModelApi__WEBPACK_IMPORTED_MODULE_1__["default"](this);

      // default the context of this model's operations to this object
      model.contextKey(this.constructor.contextKey());
      model.contextValues({ id: this.id }); // the datacollection.id

      return model;
   }

   /**
    * @function getPagingValues()
    *
    * @return {Object} - {
    *                       start: "Property name of the API for start index",
    *                       limit: "Property name of the API for limit return the item number"
    *                     }
    */
   getPagingValues({ skip, limit }) {
      const result = {};
      const pagingSettings = this.request?.paging ?? {};

      if (pagingSettings.start && skip != null) {
         result[pagingSettings.start] = skip;
      }
      if (pagingSettings.limit && limit != null) {
         result[pagingSettings.limit] = limit;
      }

      return result;
   }

   dataFromKey(data) {
      let result = [];

      if (!Array.isArray(data)) data = [data];

      data.forEach((item) => {
         // Clone item
         let itemResult = { ...item };

         // Pull data from `Data key` of the API object
         // FORMAT: "Property.Name.Value"
         (this.response.dataKey ?? "").split(".").forEach((key) => {
            if (key == "" || key == null) return;
            itemResult = itemResult?.[key];
         });

         if (Array.isArray(itemResult)) {
            result = result.concat(itemResult);
         } else if (itemResult) {
            result.push(itemResult);
         }
      });

      return result;
   }

   get headers() {
      const headers = {};

      (this.request.headers ?? []).forEach((header) => {
         if (header?.value == null) return;

         headers[header.key] = header.value;
      });

      return headers;
   }
}


/***/ }),

/***/ 55336:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/core/ABObjectApiNetsuiteCore.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectApiNetsuiteCore)
/* harmony export */ });
/* harmony import */ var _platform_ABObjectApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABObjectApi */ 9611);
/* harmony import */ var _platform_ABModelApiNetsuite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/ABModelApiNetsuite */ 19901);



class ABObjectApiNetsuiteCore extends _platform_ABObjectApi__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      this.isNetsuite = true;

      this.fromValues(attributes);
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   fromValues(attributes) {
      super.fromValues(attributes);

      this.credentials = attributes.credentials ?? {};
      this.columnRef = attributes.columnRef ?? {};
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABObjectQuery instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      const result = super.toObj();

      result.isNetsuite = true;
      result.credentials = this.credentials;
      result.columnRef = this.columnRef;

      return result;
   }

   /**
    * @method model
    * return a Model object that will allow you to interact with the data for
    * this ABObjectQuery.
    */
   model() {
      var model = new _platform_ABModelApiNetsuite__WEBPACK_IMPORTED_MODULE_1__["default"](this);

      // default the context of this model's operations to this object
      model.contextKey(this.constructor.contextKey());
      model.contextValues({ id: this.id }); // the datacollection.id

      return model;
   }

   /**
    * @function getPagingValues()
    *
    * @return {Object} - {
    *                       start: "Property name of the API for start index",
    *                       limit: "Property name of the API for limit return the item number"
    *                     }
    */
   /*
   getPagingValues({ skip, limit }) {
      const result = {};
      const pagingSettings = this.request?.paging ?? {};

      if (pagingSettings.start && skip != null) {
         result[pagingSettings.start] = skip;
      }
      if (pagingSettings.limit && limit != null) {
         result[pagingSettings.limit] = limit;
      }

      return result;
   }

   dataFromKey(data) {
      let result = [];

      if (!Array.isArray(data)) data = [data];

      data.forEach((item) => {
         // Clone item
         let itemResult = { ...item };

         // Pull data from `Data key` of the API object
         // FORMAT: "Property.Name.Value"
         (this.response.dataKey ?? "").split(".").forEach((key) => {
            if (key == "" || key == null) return;
            itemResult = itemResult?.[key];
         });

         if (Array.isArray(itemResult)) {
            result = result.concat(itemResult);
         } else if (itemResult) {
            result.push(itemResult);
         }
      });

      return result;
   }

   get headers() {
      const headers = {};

      (this.request.headers ?? []).forEach((header) => {
         if (header?.value == null) return;

         headers[header.key] = header.value;
      });

      return headers;
   }

   */
}


/***/ }),

/***/ 92741:
/*!************************************************!*\
  !*** ./src/js/AppBuilder/core/ABObjectCore.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectCore)
/* harmony export */ });
/* harmony import */ var _platform_ABModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABModel */ 41637);
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
/**
 * ABObjectCore
 *
 * Manage the loading of specific ABObject data into useable objects
 * that can instantiate themselves and provide field and model resources.
 */




class ABObjectCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_1__["default"] {
   constructor(attributes, AB) {
      super(["label"], AB);

      /*
{
	id: uuid(),
	connName: 'string', // Sails DB connection name: 'appdev_default', 'legacy_hris', etc. Default is 'appBuilder'.
	name: 'name',
	labelFormat: 'xxxxx',
	labelSettings: Object,
	isImported: 1/0,
	isExternal: 1/0,
	tableName:'string',  // NOTE: store table name of import object to ignore async
	primaryColumnName: 'string', // NOTE: store column name of PK
	transColumnName: 'string', // NOTE: store column name of translations table
	urlPath:'string',
	importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
								// to get other object:	 ABApplication.objectFromRef(obj.importFromObject);
	translations:[
		{}
	],
	fields:[
		{ABDataField}
   ],
   indexes: [
      {ABIndex}
   ]
}
*/

      this.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object. These methods are not dependent
   /// on the instance values of the Application.
   ///

   static contextKey() {
      return "object";
   }

   ///
   /// Instance Methods
   ///

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            connName: 'string', // Sails DB connection name: 'appdev_default', 'legacy_hris', etc. Default is 'appBuilder'.
            name: 'name',
            labelFormat: 'xxxxx',
            labelSettings: Object,
            isImported: 1/0,
            isExternal: 1/0,
            tableName:'string',  // NOTE: store table name of import object to ignore async
            primaryColumnName: 'string', // NOTE: store column name of PK
            transColumnName: 'string', // NOTE: store column name of translations table
            urlPath:'string',
            importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
                                        // to get other object:  ABApplication.objectFromRef(obj.importFromObject);
            translations:[
                {}
            ],
            fields:[
                {ABDataField}
            ],
            indexes: [
               {ABIndex}
            ]
        }
        */

      this.id = attributes.id;
      // {string} .id
      // the uuid of this ABObject Definition.

      this.type = attributes.type || "object";
      // {string} .type
      // the type of ABDefinition this is.

      this.connName = attributes.connName || undefined; // undefined == 'appBuilder'
      // {string} .connName
      // the sails.config.connections[connName] configuration reference.
      // if not set ({undefined}), then our default "appBuilder" config is used

      this.name = attributes.name || "";
      // {string} .name
      // A name reference for this ABObject. This is a reference that isn't
      // translateable and will be used for lookups across languages.

      this.labelFormat = attributes.labelFormat || "";
      // {string} .labelFormat
      // A string template for how to display an entry for this ABObject in
      // common UI elements like grids, lists, etc...

      this.labelSettings = attributes.labelSettings || {};
      // {Object} .labelSettings

      this.labelSettings.isNoLabelDisplay = parseInt(
         this.labelSettings.isNoLabelDisplay || 0
      );
      // {bool} .isNoLabelDisplay

      this.isImported = parseInt(attributes.isImported || 0);
      // {depreciated}
      // {bool} .isImported
      // previously used to mark ABObjects that were created in other
      // ABApplicaitons.  No longer relevant with Global ABObjects

      this.isExternal = parseInt(attributes.isExternal || 0);
      // {bool} .isExternal
      // Marks this ABObject as referencing a pre-existing table in the DB that
      // we are treating as an ABObject.
      // These objects are not allowed to create/update/destroy the db table
      // nor can we add/remove fields.
      // However we are able to customize the Field definitions to change the
      // column names, hidden attributes, Object label, etc...
      // We can update our Defintion attributes, but not any actual DB changes.

      this.tableName = attributes.tableName || ""; // NOTE: store table name of import object to ignore async
      // {string} .tableName
      // the `{database}.{tableName}` of the db table that this ABObject's data
      // is stored in.
      // knex does not like .(dot) in table and column names
      // https://github.com/knex/knex/issues/2762
      this.tableName = this.tableName.replace(/[^a-zA-Z0-9_ ]/gi, "");

      this.primaryColumnName = attributes.primaryColumnName || ""; // NOTE: store column name of PK
      // {string} .primaryColumnName
      // is the col_name of which key is the primary key.  By default it is
      // "uuid", but in some external objects this might be something else
      // ("id", "ren_id", etc...).

      this.transColumnName = attributes.transColumnName || ""; // NOTE: store column name of translations table
      // {string} .transColumnName
      // this is a workaround to include hris_ren_data and hris_ren_trans data

      this.urlPath = attributes.urlPath || "";

      // this.importFromObject = attributes.importFromObject || "";

      this.isSystemObject = attributes.isSystemObject;
      // {bool} .isSystemObject
      // We are now storing some of our System Required Data as ABObjects as well.
      // These Objects should not be allowed to be modified by typical AppBuilder
      // designer.  However we can enable a mode for AB Designer to then expand these
      // ABObjects, and eventually we can use the AppBuilder to Create the AppBuilder.
      if (
         typeof this.isSystemObject == "undefined" ||
         this.isSystemObject == "false"
      ) {
         this.isSystemObject = false;
      }

      this.createdInAppID = attributes.createdInAppID;
      // {string} .createdInAppID
      // the .id of the ABApplication that originally created this ABObject.

      // if attributes.objectWorkspace DOES exist, make sure it is fully
      // populated.
      if (typeof attributes.objectWorkspace != "undefined") {
         if (typeof attributes.objectWorkspace.sortFields == "undefined")
            attributes.objectWorkspace.sortFields = [];
         if (typeof attributes.objectWorkspace.filterConditions == "undefined")
            attributes.objectWorkspace.filterConditions = [];
         if (typeof attributes.objectWorkspace.frozenColumnID == "undefined")
            attributes.objectWorkspace.frozenColumnID = "";
         if (typeof attributes.objectWorkspace.hiddenFields == "undefined")
            attributes.objectWorkspace.hiddenFields = [];
      }
      this.objectWorkspace = attributes.objectWorkspace || {
         sortFields: [], // array of columns with their sort configurations
         filterConditions: [], // array of filters to apply to the data table
         frozenColumnID: "", // id of column you want to stop freezing
         hiddenFields: [], // array of [ids] to add hidden:true to
      };
      // {obj} .objectWorkspace
      // When in the ABObject editor in the AppBuilder Designer, different
      // views of the information can be created.  These views are stored here
      // and are avaiable to other users in the Designer.

      // pull in field definitions:
      var fields = [];
      this.fieldIDs = attributes.fieldIDs || [];
      // {array}  [ ABField.id, ... ]
      // this is a collection of ALL the ABFields this object references.
      // This will include ABFields that were directly created for this object
      // and will include ABFields that were imported.

      this.importedFieldIDs = attributes.importedFieldIDs || [];
      // {array} [ ABField.id, ... ]
      // this is a collection of the ABFields in our .fieldIDs that were
      // IMPORTED.

      this._unknownFieldIDs = [];
      this.fieldIDs.forEach((id) => {
         if (!id) return;

         var def = this.AB.definitionByID(id);
         if (def) {
            fields.push(this.AB.fieldNew(def, this));
         } else {
            this._unknownFieldIDs.push(id);
            let err = new Error(
               `O[${this.name}] is referenceing an unknown field id[${id}]`
            );
            this.AB.notify.builder(err, {
               field: { id, object: { id: this.id, name: this.name } },
            });
         }
      });
      this._fields = fields;

      // pull in index definitions:
      this.importIndexes(attributes.indexIDs);

      // let the MLClass now process the translations:
      super.fromValues(attributes);
   }

   /**
    * @method importIndexes
    * instantiate a set of indexes from the given ids.
    * @param {array} indexIDs The different ABDefinition IDs for each index
    *        [ "uuid11", "uuid2", ... "uuidN" ]
    */
   importIndexes(indexIDs) {
      this._unknownIndex = [];
      var indexes = [];
      (indexIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            indexes.push(this.AB.indexNew(def, this));
         } else {
            this._unknownIndex.push(id);
            let err = new Error(
               `O[${this.name}] is referenceing an unknown index id[${id}]`
            );
            this.AB.notify.builder(err, {
               field: { id, object: { id: this.id, name: this.name } },
            });
         }
      });
      this._indexes = indexes;
   }

   /**
    * @method exportFields
    * convert our array of fields into a settings object for saving to disk.
    * @return {array}
    */
   // exportFields() {
   //     var currFields = [];
   //     this._fields.forEach((obj) => {
   //         currFields.push(obj.toObj());
   //     });
   //     return currFields;
   // }

   // /**
   //  * @method exportFields
   //  * convert our array of fields into a settings object for saving to disk.
   //  * @return {array}
   //  */
   // exportIndexes() {
   //    var currIndexes = [];
   //    this._indexes.forEach((idx) => {
   //       currIndexes.push(idx.toObj());
   //    });
   //    return currIndexes;
   // }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // MLClass translation
      var obj = super.toObj();

      // track the field .ids of our fields
      var fieldIDs = this.fields().map((f) => f.id);
      (this._unknownFieldIDs || []).forEach((id) => {
         fieldIDs.push(id);
      });
      // NOTE: we keep the ._unknownFieldIDs so a developer/builder
      // can come back and track down what happened to the missing
      // ids.

      // track the index .ids of our indexes
      var indexIDs = this.indexes().map((f) => f.id);
      (this._unknownIndex || []).forEach((id) => {
         indexIDs.push(id);
      });

      return {
         id: this.id,
         type: this.type || "object",
         connName: this.connName,
         name: this.name,
         labelFormat: this.labelFormat,
         labelSettings: this.labelSettings || {},
         isImported: this.isImported,
         isExternal: this.isExternal,
         tableName: this.tableName,
         // NOTE: store table name of import object to ignore async
         primaryColumnName: this.primaryColumnName,
         // NOTE: store column name of PK
         transColumnName: this.transColumnName,
         // NOTE: store column name of translations table
         urlPath: this.urlPath,
         // importFromObject: this.importFromObject,
         objectWorkspace: this.objectWorkspace,
         isSystemObject: this.isSystemObject,

         translations: obj.translations,
         fieldIDs: fieldIDs,
         importedFieldIDs: this.importedFieldIDs,
         indexIDs: indexIDs,
         createdInAppID: this.createdInAppID,
      };
   }

   ///
   /// Objects
   ///

   /**
    * @method objectLinks()
    *
    *  return an array of ABObject that's connected.
    *
    * @param {object} filter
    * @return {array} - An array of ABObject
    */
   objectLinks(/* filter */) {
      var connectFields = this.connectFields();

      return connectFields.map((f) => f.datasourceLink);
   }

   ///
   /// Fields
   ///

   /**
    * @method fields()
    * return an array of all the ABFields for this ABObject.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array[ABFieldxxx]}
    */
   fields(fn = () => true) {
      return this._fields.filter(fn);
   }

   /**
    * @method fieldByID()
    * return the object's field from the given {ABField.id}
    * @param {string} id
    *        the uuid of the field to return.
    * @return {ABFieldxxx}
    */
   fieldByID(id) {
      return this.fields((f) => f?.id == id)[0];
   }

   /**
    * @method connectFields()
    *
    * return an array of the ABFieldConnect that is connect object fields.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array}
    */
   connectFields(fn = () => true) {
      return this.fields((f) => f && f.isConnection).filter(fn);
   }

   /**
    * @method fieldImport
    * register the given ABField.id as an imported field for this ABObject.
    * The ABField definition should be available before making this call.
    * After this call, the ABField is included in the ABObject, but the ABObject
    * has NOT been saved.
    * @param {ABField} fieldID The ABDefinition.id for a field that is imported
    *        into this object.
    */
   fieldImport(id) {
      if (!id) return;

      if (this.importedFieldIDs.indexOf(id) == -1) {
         this.importedFieldIDs.push(id);
      }

      // just to be safe:
      var isThere = this._fields.find((f) => f.id == id);
      if (!isThere) {
         var def = this.AB.definitionByID(id);
         if (def) {
            this._fields.push(this.AB.fieldNew(def, this));
         } else {
            this._unknownFieldIDs = this._unknownFieldIDs || [];
            this._unknownFieldIDs.push(id);
            let err = new Error(
               `O[${this.name}] is importing an unknown field id[${id}]`
            );
            this.AB.notify.builder(err, {
               field: { id, object: { id: this.id, name: this.name } },
            });
         }
      }
   }

   /**
    * @method fieldNew()
    *
    * return an instance of a new (unsaved) ABField that is tied to this
    * ABObject.
    *
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    *
    * @return {ABField}
    */
   fieldNew(values) {
      return this.AB.fieldNew(values, this);
   }

   /**
    * @method fieldRemove()
    *
    * remove the given ABField from our ._fields array and persist the current
    * values.
    *
    * @param {ABField} field The instance of the field to remove.
    * @return {Promise}
    */
   fieldRemove(field) {
      var origLen = this._fields.length;
      this._fields = this.fields(function (o) {
         return o.id != field.id;
      });

      // be sure to remove this from our imported ids if it was
      // listed there.
      this.importedFieldIDs = this.importedFieldIDs.filter(
         (fid) => fid != field.id
      );

      if (this._fields.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
      return Promise.resolve();
   }

   /**
    * @method fieldReorder()
    *
    * reorder the fields in our object
    *
    * @param {ABField} field The instance of the field to remove.
    * @return {Promise}
    */
   fieldReorder(sourceId, targetId) {
      // We know what was moved and what item it has replaced/pushed forward
      // so first we want to splice the item moved out of the array of fields
      // and store it so we can put it somewhere else
      let itemMoved = null;
      let oPos = 0; // original position
      for (var i = 0; i < this._fields.length; i++) {
         if (this._fields[i].columnName == sourceId) {
            itemMoved = this._fields[i];
            this._fields.splice(i, 1);
            oPos = i;
            break;
         }
      }
      // once we have removed/stored it we can find where its new position
      // will be by looping back through the array and finding the item it
      // is going to push forward
      for (var j = 0; j < this._fields.length; j++) {
         if (this._fields[j].columnName == targetId) {
            // if the original position was before the new position we will
            // follow webix's logic that the drop should go after the item
            // it was placed on
            if (oPos <= j) {
               j++;
            }
            this._fields.splice(j, 0, itemMoved);
            break;
         }
      }

      return this.save();
   }

   /**
    * @method fieldSave()
    *
    * save the given ABField in our ._fields array and persist the current
    * values.
    *
    * @param {ABField} field The instance of the field to save.
    * @return {Promise}
    */
   fieldSave(field) {
      var isIncluded = this.fieldByID(field.id);
      if (!isIncluded) {
         this._fields.push(field);
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method fieldAdd()
    *
    * save the given ABField in our ._fields array and persist the current
    * values if they changed.
    *
    * @param {ABField} field The instance of the field to save.
    * @return {Promise}
    */
   fieldAdd(field) {
      var isIncluded = this.fieldByID(field.id);
      if (!isIncluded) {
         // if not already included, then add and save the Obj definition:
         this._fields.push(field);
         return this.save();
      }

      // Nothing was required so return
      return Promise.resolve();
   }

   /**
    * @method imageFields()
    *
    * return an array of the ABFieldImage fields this object has.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array}
    */
   imageFields(fn = () => true) {
      return this.fields((f) => f && f.key == "image").filter(fn);
   }

   /**
    * @method multilingualFields()
    *
    * return an array of columnnames that are multilingual.
    *
    * @return {array}
    */
   multilingualFields() {
      return this.fields((f) => f && f.isMultilingual).map((f) => f.columnName);
   }

   /**
    * @method indexes()
    *
    * return an array of all the ABIndex for this ABObject.
    *
    * @param filter {Object}
    *
    * @return {array}
    */
   indexes(filter = () => true) {
      return this._indexes.filter(filter);
   }

   /**
    * @method indexByID()
    * return the object's index from the given {ABIndex.id}
    * @param {string} id
    *        the id of the ABIndex to return.
    * @return {ABIndex}
    */
   indexByID(id) {
      return this.indexes((f) => f.id == id)[0];
   }

   /**
    * @method indexRemove()
    * remove the given ABIndex from our ._indexes array and persist the current
    * values.
    * @param {ABIndex} index
    * @return {Promise}
    */
   indexRemove(index) {
      var origLen = this._indexes.length;
      this._indexes = this.indexes(function (idx) {
         return idx.id != index.id;
      });

      // persist our changes if something changed.
      if (origLen != this._indexes.length) {
         return this.save();
      }

      // nothing was removed, so continue on.
      return Promise.resolve();
   }

   /**
    * @method indexSave()
    * save the given ABIndex in our ._indexes array and persist the current
    * values.
    * @param {ABIndex} index
    * @return {Promise}
    */
   indexSave(index) {
      var isIncluded = this.indexByID(index.id);
      if (!isIncluded) {
         this._indexes.push(index);
         return this.save();
      }

      return Promise.resolve();
   }

   ///
   /// Working with data from server
   ///

   /**
    * @method model
    * return a Model object that will allow you to interact with the data for
    * this ABObject.
    */
   model() {
      var model = new _platform_ABModel__WEBPACK_IMPORTED_MODULE_0__["default"](this);

      // default the context of this model's operations to this object
      model.contextKey(ABObjectCore.contextKey());
      model.contextValues({ id: this.id });

      return model;
   }

   ///
   /// URL
   ///

   /**
    * @method urlRest
    * return the url to access the data for this object.
    * @return {string}
    */
   urlRest() {
      return `/app_builder/model/${this.id}`;
   }

   /**
    * @method urlRestBatch
    * return the url to use for batch creates for this object
    * @return {string}
    */
   urlRestBatch() {
      return `/app_builder/batch/model/${this.id}`;
   }

   /**
    * @method urlRestItem
    * return the url to access the data for an instance of this object.
    * @return {string}
    */
   urlRestItem(id) {
      return `/app_builder/model/${this.id}/${id}`;
   }

   /**
    * @method urlRestLog
    * return the url to access the logs for this ABObject.
    * @return {string}
    */
   urlRestLog() {
      return `/app_builder/object/${this.id}/track`;
   }

   /**
    * @method urlRestRefresh
    * return the url to signal a refresh for this object.
    * @return {string}
    */
   urlRestRefresh() {
      return `/app_builder/model/refreshobject/${this.id}`;
   }

   /**
    * @method urlCount
    * return the url to count of data for this object.
    * @return {string}
    */
   urlRestCount() {
      return `/app_builder/model/${this.id}/count`;
   }

   ///
   ///	Object Workspace Settings
   ///
   get workspaceSortFields() {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) return currView.sortFields;
         else return null;
      }
      // old version
      else {
         return this.objectWorkspace.sortFields;
      }
   }

   set workspaceSortFields(fields) {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) currView.sortFields = fields;
      }
      // old version
      else {
         this.objectWorkspace.sortFields = fields;
      }
   }

   get workspaceFilterConditions() {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) return currView.filterConditions;
         else return null;
      }
      // old version
      else {
         return this.objectWorkspace.filterConditions;
      }
   }

   set workspaceFilterConditions(filterConditions) {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) currView.filterConditions = filterConditions;
      }
      // old version
      else {
         this.objectWorkspace.filterConditions = filterConditions;
      }
   }

   get workspaceFrozenColumnID() {
      return this.objectWorkspace.frozenColumnID;
   }

   set workspaceFrozenColumnID(id) {
      this.objectWorkspace.frozenColumnID = id;
   }

   get workspaceHiddenFields() {
      return this.objectWorkspace.hiddenFields || [];
   }

   set workspaceHiddenFields(fields) {
      this.objectWorkspace.hiddenFields = fields;
   }

   /**
    * @method isReadOnly
    *
    * @return {boolean}
    */
   get isReadOnly() {
      return this.isImported || this.isExternal || this.readonly;
   }

   /**
    * @method defaultValues
    * Collect a hash of key=>value pairs that represent the default values
    * from each of our fields.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   defaultValues() {
      var values = {};
      this.fields().forEach((f) => {
         f.defaultValue(values);
      });

      return values;
   }

   /**
    * @method isValidData
    * Parse through the given data and return an array of any invalid
    * value errors.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   isValidData(/* data */) {
      // NOTE: the platform needs to define a way to verify the data
      console.warn("Platform.ABObject.isValidData() missing");
      return true;
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this object. This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this object.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      console.error("Who is calling this?");

      if (this.application == null) return null;

      return this.application.urlObject(acrossApp) + this.id;
   }

   /**
    * @method urlField
    * return a string pointer to this object's fields
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlField(acrossApp) {
      console.error("Who is calling this?");

      return this.urlPointer(acrossApp) + "/_fields/";
   }

   /**
    * @method PK
    * return a string of the primary column name
    *
    * @return {string}
    */
   PK() {
      return this.primaryColumnName || "uuid";
   }

   remoteCreate(data) {
      console.log(
         "object[" + this.name + "] received a remoteCreate() with data:",
         data
      );
   }

   /**
    * @method clone
    * return a clone of ABObject
    *
    * @return {ABObjectBase}
    */
   clone() {
      // ignore properties who're spend much performance
      // NOTE: do not clone them. Just copy reference
      let ignoreProps = ["application", "_fields"];

      let cloneOne = JSON.parse(JSON.stringify(this));

      ignoreProps.forEach((prop) => {
         cloneOne[prop] = this[prop];
      });

      return cloneOne;
   }

   /**
    * @method minRelationData()
    * return an array of ABField.columnNames that make up
    * the minimum fields required to display this objects __RELATION
    * data in our UI widgets.
    */
   minRelationData() {
      var fields = [this.PK()];

      if (this.multilingualFields().length > 0) {
         fields.push("translations");
      }

      var labelData = this.labelFormat || "";

      // get column ids in {colId} template
      // ['{colId1}', ..., '{colIdN}']
      var colIds = labelData.match(/\{[^}]+\}/g);

      if (colIds && colIds.forEach) {
         colIds.forEach((colId) => {
            var colIdNoBracket = colId.replace("{", "").replace("}", "");

            var field = this.fieldByID(colIdNoBracket);
            if (field == null) return;

            fields.push(field.columnName);
         });
      }
      // Default defining label
      else {
         const defaultFld = this.fields((f) => f.fieldUseAsLabel())[0];
         if (defaultFld) fields.push(defaultFld.columnName);
      }

      // System requires to include number field values
      // because they are used on Formula/Calculate fields on client side
      fields = fields.concat(
         this.fields((f) => f.key == "number").map((f) => f.columnName)
      );

      return fields;
   }

   // Display data with label format of object
   displayData(rowData) {
      let L = this.AB.Label();
      if (rowData == null) return "";

      // translate multilingual
      //// TODO: isn't this a MLObject??  use this.translate()
      var mlFields = this.multilingualFields();
      this.translate(rowData, rowData, mlFields);

      var labelData = this.labelFormat || "";

      // default label
      if (!labelData && this.fields().length > 0) {
         var defaultField = this.fields((f) => f.fieldUseAsLabel())[0];
         if (defaultField) labelData = "{" + defaultField.id + "}";
         else {
            // if label is empty, then show .id
            if (!labelData.trim()) {
               let labelSettings = this.labelSettings || {};
               if (labelSettings && labelSettings.isNoLabelDisplay) {
                  labelData = L(labelSettings.noLabelText || "[No Label]");
               } else {
                  // show id of row
                  labelData = `${
                     this.AB.rules.isUUID(rowData.id) ? "ID: " : ""
                  }${rowData.id}`;
               }
            }
         }
      }

      // get column ids in {colId} template
      // ['{colId1}', ..., '{colIdN}']
      var colIds = labelData.match(/\{[^}]+\}/g);

      // Using rawString to catch actual values we are pulling out.
      // the label data might have additional characters "-" and such that will
      // remain, and doing a .trim() on that wont catch that the label data
      // is actually empty.
      let rawString = "";
      if (colIds && colIds.forEach) {
         colIds.forEach((colId) => {
            var colIdNoBracket = colId.replace("{", "").replace("}", "");

            var field = this.fieldByID(colIdNoBracket);
            if (field == null) return;

            let valField = field.format(rowData) || "";
            labelData = labelData.replace(colId, valField);
            rawString = `${rawString}${valField}`;
         });
      }

      // if label is empty, then show .id
      if (!rawString.trim()) {
         let labelSettings = this.labelSettings || {};
         if (labelSettings && labelSettings.isNoLabelDisplay) {
            labelData = L(labelSettings.noLabelText || "[No Label]");
         } else {
            // show id of row
            labelData = `${this.AB.rules.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`;
         }
      }

      return labelData;
   }

   /**
    * @method whereCleanUp()
    * Parse through the current where condition and remove any null or
    * empty logical blocks.
    * @param {obj} curr
    *        1) The current where condition in ABQuery Format:
    *        {
    *           glue: [AND, OR],
    *           rules: [ {rule} ]
    *        }
    *        or 2) The current {rule} to validate
    *        {
    *          key:{string},
    *          rule:{string},
    *          vlaue:{mixed}
    *        }
    * @return {ABQuery.where} / { Rule }
    */
   whereCleanUp(curr) {
      if (curr) {
         if (curr.glue && curr.rules) {
            // SENTRY Error AB-APPBUILDER-4H
            // "curr.rules.forEach is not a function"
            // curr.rules is supposed to be an array. If we are not
            // getting that, then let's send an alert to figure out what
            // is happening here:
            if (!Array.isArray(curr.rules)) {
               // what is this entry?
               let err = new Error(
                  `ABObjectCore.whereCleanUP(): Sentry Error: AB-APPBUILDER-4H: current rule is not properly formed: ${JSON.stringify(
                     curr
                  )}`
               );
               this.AB.notify.developer(err, { curr });
            }

            // this is a logical Block (AND, OR)
            // we need to filter the children
            let newValue = { glue: curr.glue, rules: [] };
            curr.rules.forEach((r) => {
               let cleanRule = this.whereCleanUp(r);
               // don't add values that didn't pass
               if (cleanRule) {
                  newValue.rules.push(cleanRule);
               }
            });

            // if we have a non empty block, then return it:
            if (newValue.rules.length > 0) {
               return newValue;
            }

            // this isn't really a valid conditional, so null
            return null;
         }

         // This is a specific rule, that isn't null so:
         // if it isn't {}, then return it
         if (Object.keys(curr).length > 0) return curr;

         // otherwise we skip this as well
         return null;
      }
      return null;
   }
}


/***/ }),

/***/ 20391:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/core/ABObjectQueryCore.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectQueryCore)
/* harmony export */ });
/* harmony import */ var _platform_ABObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABObject */ 83311);
/* harmony import */ var _platform_ABModelQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/ABModelQuery */ 56972);
//
// ABObjectQuery
//
// A type of Object in our system that is based upon a complex relationship of multiple
// existing Objects.
//
// In the QueryBuilder section of App Builder, a new Query Object can be created.
// An initial Object can be chosen from our current list of Objects. After that, additional Objects
// and a specified join type can be specified.
//
// A list of fields from each specified Object can also be included as the data to be returned.
//
// A where statement is also part of the definition.
//




class ABObjectQueryCore extends _platform_ABObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);
      /*
{
	id: uuid(),
	name: 'name',
	labelFormat: 'xxxxx',
	isImported: 1/0,
	urlPath:'string',
	importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
								// to get other object:  ABApplication.objectFromRef(obj.importFromObject);
	translations:[
		{}
	],



	// ABOBjectQuery Specific Changes
	// we store a list of fields by their urls:
	fields:[
		{
			alias: "",
			fieldURL:'#/url/to/field',
		}
	],


	// we store a list of joins:
	joins:{
		alias: "",							// the alias name of table - use in SQL command
		objectURL:"#/...",					// the base object of the join
		links: [
			{
				alias: "",							// the alias name of table - use in SQL command
				fieldID: "uuid",					// the connection field of the object we are joining with.
				type:[left, right, inner, outer]	// join type: these should match the names of the knex methods
						=> innerJoin, leftJoin, leftOuterJoin, rightJoin, rightOuterJoin, fullOuterJoin
				links: [
					...
				]
			}
		]

	},


	where: { QBWhere }
}
*/
      this.isQuery = true;
      // {bool}
      // a property to mark the difference between an ABObject and ABObjectQuery.

      this.__missingObject = this.__missingObject ?? [];
      // {array} fieldInfo
      // the field info that defined an object we can't find.

      this.__missingFields = this.__missingFields ?? [];
      // {array} [ { objID, fieldID }, ... ]
      // a list of field definitions that we are unable to resolve.

      this.__cantFilter = [];
      // {array} [ {field, fieldInfo}, ... ]
      // a list of field that were assigned but can't be used for filtering.

      this.__duplicateFields = [];
      // {array} [ {fieldInfo}, ... ]
      // a list of duplicate field definitions.

      this.__linkProblems = [];
      // {array} [ { message, data }, ...]
      // a list of warning messages related to link objects
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   /**
    * contextKey()
    * returns a unique key that represents a query in
    * our networking job resolutions.
    * @return {string}
    */
   static contextKey() {
      return "query";
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   fromValues(attributes) {
      super.fromValues(attributes);

      this.type = "query";

      // populate connection objects
      // this._objects = {};
      // this.obj2Alias = attributes.obj2Alias || {};

      this.alias2Obj = {}; // this gets built in the .importJoins()
      // { "alias" : object.id }
      // this is a lookup hash of a referenced alias to the Object it
      // references.

      this.objectIDs = [];
      // {array}  of ABObject.id s that are referenced by this query.
      // this is how we limit our searches on objects.
      // this gets built in the .importJoins();

      this.viewName = attributes.viewName || "";
      // {string}
      // this is the SQL tablename of where our Query will store it's
      // view data.

      // import all our ABObjects
      this.importJoins(attributes.joins || {});

      // import fields after joins are imported
      this._fields = null;
      this.importFields(attributes.fields || []);
      // {array} [ { alias, field}, {},... ]
      // an array of field definition structures that mark what fields this
      // query is interested in pulling data from.
      //    .alias : {string} matches the alias of the ABObject that the field
      //             is from
      //    .field : {ABFieldXXX} the link to the actual ABField instance

      // Import our Where condition
      this.where = attributes.where || {}; // .workspaceFilterConditions
      // Fix default where.glue value
      if (
         this.where &&
         !this.where.glue &&
         this.where.rules &&
         this.where.rules.length > 0
      )
         this.where.glue = "and";

      this._objectWorkspaceViews = attributes.objectWorkspaceViews || {};

      this.settings = this.settings || {};

      if (attributes && attributes.settings) {
         // convert from "0" => true/false
         this.settings.grouping = JSON.parse(
            attributes.settings.grouping || false
         );
         this.settings.hidePrefix = JSON.parse(
            attributes.settings.hidePrefix || false
         );
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABObjectQuery instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      var result = super.toObj();

      result.viewName = this.viewName;

      result.joins = this.exportJoins();
      result.fields = this.exportFields();
      result.where = this.where; // .workspaceFilterConditions

      result.settings = this.settings;

      return result;
   }

   ///
   /// Fields
   ///

   /**
    * @method importFields
    * instantiate a set of fields from the given attributes.
    * Our attributes are a set of field URLs That should already be created in their respective
    * ABObjects.
    * @param {array} fieldSettings The different field urls for each field
    */
   importFields(fieldSettings) {
      var newFields = [];
      (fieldSettings || []).forEach((fieldInfo) => {
         if (fieldInfo == null) return;

         // pull object by alias name
         let object = this.objectByAlias(fieldInfo.alias);

         // Pull object from .AB
         if (!object && this.AB) {
            object = this.AB.objectByID(fieldInfo.objectID);

            // keep
            if (object) {
               this._objects = this._objects || {};
               this._objects[fieldInfo.alias] = object;
            }
         }

         if (!object) {
            this.__missingObject = this.__missingObject ?? [];
            this.__missingObject.push(fieldInfo);
            return;
         }

         let field = object.fieldByID(fieldInfo.fieldID);
         if (!field) {
            this.__missingFields = this.__missingFields ?? [];
            this.__missingFields.push({
               objID: object.id,
               fieldID: fieldInfo.fieldID,
               fieldInfo,
            });
            return;
         }

         if (!this.canFilterField(field)) {
            this.__cantFilter = this.__cantFilter ?? [];
            this.__cantFilter.push({ field, fieldInfo });
         }

         // check duplicate
         let isNew =
            newFields.filter(
               (f) =>
                  f.alias == fieldInfo.alias && f.field.id == fieldInfo.fieldID
            ).length < 1;

         if (!isNew) {
            this.__duplicateFields = this.__duplicateFields ?? [];
            this.__duplicateFields.push({ fieldInfo });
         }

         // should be a field of base/join objects
         if (field && this.canFilterField(field) && isNew) {
            // add alias to field
            // create new instance of this field:
            var def = field.toObj();
            let clonedField = new field.constructor(def, field.object);

            clonedField.alias = fieldInfo.alias;

            let alias = fieldInfo.alias;
            if (Array.isArray(this.joins())) {
               // NOTE: query v1
               alias = field.object.name;
            }

            newFields.push({
               alias: alias,
               field: clonedField,
            });
         }
      });
      this._fields = newFields;
   }

   /**
    * @method exportFields
    * convert our array of fields into a settings object for saving to disk.
    * @return {array}
    */
   exportFields() {
      var currFields = [];
      this._fields.forEach((fieldInfo) => {
         currFields.push({
            alias: fieldInfo.alias,
            objectID: fieldInfo.field.object.id,
            fieldID: fieldInfo.field.id,
         });
      });

      // let's persist the faulty settings so a developer or builder can
      // review and fix it by hand.
      (this.__missingObject || []).forEach((f) => {
         currFields.push(f);
      });

      (this.__cantFilter || []).forEach((f) => {
         currFields.push(f.fieldInfo);
      });

      return currFields;
   }

   /**
    * @method fields()
    *
    * Support the ABObject api by returning a list of fields relevant
    * to this ABObjectQuery.
    *
    * @return {array}
    */
   fields(fn = () => true) {
      if (!fn) fn = () => true;
      return this._fields.map((f) => f.field).filter(fn);
   }

   ///
   /// Joins & Objects
   ///

   /**
    * @method joins()
    *
    * return an object of joins for this Query.
    *
    * @return {Object}
    */
   joins() {
      return this._joins || {};
   }

   /**
    * @method objects()
    *
    * return an array of all the relevant ABObjects for this Query.
    *
    * @return {array}
    */
   objects(fn = () => true) {
      // FOR proper expected operation, this fn must only return object
      // matches for which this ABQuery is managing objects:

      return this.AB.objects((o) => this.objectIDs.indexOf(o.id) > -1).filter(
         fn
      );
   }

   /**
    * @method objectAlias()
    *
    * return alias of of ABObjects.
    *
    * @return {string}
    */
   objectAlias(objectId) {
      let result = null;

      Object.keys(this.alias2Obj || {}).forEach((alias) => {
         if (!result && this.alias2Obj[alias] == objectId) {
            result = alias;
         }
      });

      return result;
   }

   /**
    * @method objectBase
    * return the origin object
    *
    * @return {ABObject}
    */
   objectBase() {
      if (!this._joins.objectID) return null;

      return this.AB.objectByID(this._joins.objectID) || null;
   }

   /**
    * @method objectByAlias()
    * return ABObject search by alias name
    *
    * @param {string} - alias name
    * @return {ABClassObject}
    */
   objectByAlias(alias) {
      var objID = this.alias2Obj[alias];
      if (objID) {
         return this.objects((o) => o.id == objID)[0];
      }
      return null;
   }

   /**
    * @method objectByID()
    * return ABObject search by ID
    * @param {string} objID
    *        The requested {ABObject}.id of the object to return.
    * @return {ABObject} | null
    */
   objectByID(objID) {
      if (objID) {
         return this.objects((o) => o.id == objID)[0];
      }
      return null;
   }

   /**
    * @method links()
    *
    * return an array of links for this Query.
    *
    * @return {array}
    */
   links(filter = () => true) {
      return (this._links || []).filter(filter);
   }

   /**
    * @method importJoins
    * instantiate a set of joins from the given attributes.
    * Our joins contain a set of ABObject URLs that should already be created in our Application.
    * @param {Object} settings The different field urls for each field
    *					{ }
    */
   importJoins(settings) {
      // copy join settings
      this._joins = this.AB.cloneDeep(settings);

      var uniqueObjectIDs = {};
      // { obj.id : obj.id }
      // a hash of object.ids for all the relevant ABObjects necessary for this
      // ABObjectQuery

      var newLinks = [];
      // {array} of link definitions
      // build the operating values for this._links

      let storeObject = (object, alias) => {
         if (!object) return;

         // var inThere = newObjects.filter(obj => obj.id == object.id && obj.alias == alias ).length > 0;
         // if (!inThere) {
         // newObjects[alias] = object;
         // this.obj2Alias[object.id] = alias;
         this.alias2Obj[alias] = object.id;
         uniqueObjectIDs[object.id] = object.id;
         // newObjects.push({
         // 	alias: alias,
         // 	object: object
         // });
         // }
      };

      let storeLinks = (links) => {
         (links || []).forEach((link) => {
            // var inThere = newLinks.filter(l => l.fieldID == link.fieldID).length > 0;
            // if (!inThere) {
            newLinks.push(link);
            // }
         });
      };

      this.__linkProblems = this.__linkProblems ?? [];

      let processJoin = (baseObject, joins) => {
         if (!baseObject) return;

         (joins || []).forEach((link) => {
            // Convert our saved settings:
            //	{
            //		alias: "",							// the alias name of table - use in SQL command
            //		objectID: "uuid",					// id of the connection object
            //		links: [
            //			{
            //				alias: "",							// the alias name of table - use in SQL command
            //				fieldID: "uuid",					// uhe connection field of the object we are joining with.
            //				type:[left, right, inner, outer]	// join type: these should match the names of the knex methods
            //						=> innerJoin, leftJoin, leftOuterJoin, rightJoin, rightOuterJoin, fullOuterJoin
            //				links: [
            //					...
            //				]
            //			}
            //		]
            //	},

            var linkField = baseObject.fieldByID(link.fieldID);
            if (!linkField) {
               this.__linkProblems.push({
                  message: `could not resolve our linkField[${link.fieldID}]`,
                  data: {
                     link,
                  },
               });
               return;
            }

            // track our linked object
            var linkObject = this.AB.objectByID(linkField.settings.linkObject);
            if (!linkObject) {
               this.__linkProblems.push({
                  message: `could not resolve our linked field -> linkObject[${linkField.settings.linkObject}]`,
                  data: {
                     link,
                  },
               });
               return;
            }

            storeObject(linkObject, link.alias);

            storeLinks(link.links);

            processJoin(linkObject, link.links);
         });
      };

      // if (!this._joins.objectURL)
      // 	// TODO: this is old query version
      // 	return;

      // store the root object
      var rootObject = this.objectBase();
      if (!rootObject) {
         // this._objects = newObjects;
         this.__linkProblems.push({
            message: "could not resolve our base object",
            data: {
               objectID: this._joins?.objectID,
            },
         });
         return;
      }

      storeObject(rootObject, "BASE_OBJECT");

      storeLinks(settings.links);

      processJoin(rootObject, settings.links);

      // this._objects = newObjects;
      this._links = newLinks;
      this.objectIDs = Object.keys(uniqueObjectIDs);
   }

   /**
    * @method exportJoins
    * save our list of objects into our format for persisting on the server
    * @param {array} settings
    */
   exportJoins() {
      return this.AB.cloneDeep(this._joins || {});
   }

   ///
   /// Working with Client Components:
   ///

   /**
    * @method model
    * return a Model object that will allow you to interact with the data for
    * this ABObjectQuery.
    */
   model() {
      var model = new _platform_ABModelQuery__WEBPACK_IMPORTED_MODULE_1__["default"](this);

      // default the context of this model's operations to this object
      model.contextKey(this.constructor.contextKey());
      model.contextValues({ id: this.id }); // the datacollection.id

      return model;
   }

   /**
    * @method canFilterObject
    * evaluate the provided object to see if it can directly be filtered by this
    * query.
    * @param {ABObject} object
    * @return {bool}
    */
   canFilterObject(object) {
      if (!object) return false;

      // I can filter this object if it is one of the objects in my joins
      return (
         this.objects((obj) => {
            return obj.id == object.id;
         }).length > 0
      );
   }

   /**
    * @method canFilterField
    * evaluate the provided field to see if it can be filtered by this
    * query.
    * @param {ABObject} object
    * @return {bool}
    */
   canFilterField(field) {
      if (!field) return false;

      // I can filter a field if it's object OR the object it links to can be filtered:
      let object = field.object;
      // Transition:
      // let linkedObject = this.objects(
      //    (obj) => obj.id == field.settings.linkObject
      // )[0];
      var linkedObject = field.datasourceLink;

      return this.canFilterObject(object) || this.canFilterObject(linkedObject);
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this object. This url pointer
    * should be able to be used by this.AB.urlResolve() to return
    * this object.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      console.error(
         "ABQueryCore.urlPointer(): Depreciated: Where is this being called?"
      );
      return this.application.urlQuery(acrossApp) + this.id;
   }

   /**
    * @method isGroup
    *
    * @return {boolean}
    */
   get isGroup() {
      return this.settings.grouping || false;
   }

   /**
    * @method isReadOnly
    *
    * @return {boolean}
    */
   get isReadOnly() {
      return true;
   }

   /**
    * @method isDisabled()
    * check this contains removed objects or fields
    *
    * @return {boolean}
    */
   isDisabled() {
      return this.disabled || false;
   }

   get workspaceFilterConditions() {
      let filterConditions = super.workspaceFilterConditions;
      if (
         filterConditions == null ||
         filterConditions.rules == null ||
         !filterConditions.rules.length
      ) {
         filterConditions = this.where;
      }

      return filterConditions;
   }
}


/***/ }),

/***/ 44166:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/core/ABProcessCore.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ 96486);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _platform_process_tasks_ABProcessTaskSubProcess__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/process/tasks/ABProcessTaskSubProcess */ 75175);
// import ABApplication from "./ABApplication"



// const _concat = require("lodash/concat");
const _concat = lodash__WEBPACK_IMPORTED_MODULE_1__.concat;



class ABProcessCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(["label"], AB);

      this.fromValues(attributes);

      // indicate we are ready.
      this.elements().forEach((e) => {
         e.onProcessReady();
      });
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
    {
      id: uuid(),
      name: 'name',
      type: 'xxxxx',
      json: "{json}"
    }
    */
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || "process";
      this.xmlDefinition = attributes.xmlDefinition || null;

      // this.json = attributes.json || null;
      let currElements = this._elements || {};
      this._elements = {};
      (attributes.elementIDs || []).forEach((eID) => {
         var ele = this.AB.processElementNew(eID, this);
         if (ele) {
            this._elements[eID] = ele;
         } else {
            // current eID isn't one of our definitions yet, so might be
            // a temporary .diagramID from an unsaved task:
            if (currElements[eID]) {
               this._elements[eID] = currElements[eID];
            } else {
               this.emit(
                  "warning",
                  `P[${this.name}] is referencing an unknown process element id[${eID}]`,
                  { process: this.id, eID }
               );
            }
         }
      });

      this._connections = attributes.connections || {};

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this ABProcess instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label) {
         this.label = this.name;
      }

      // OP.Multilingual.unTranslate(this, this, ["label"]);
      var data = super.toObj();

      var fieldsToSave = ["id", "name", "xmlDefinition"];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      data.elementIDs = [];
      for (var e in this._elements) {
         // NOTE: when a task is initially created, it doesn't have an .id
         // so we need to reference it by it's .diagramID
         data.elementIDs.push(
            this._elements[e].id ?? this._elements[e].diagramID
         );
      }

      data.connections = this._connections;

      // data.participantIDs = [];
      // for (var p in this._participants) {
      //     data.participantIDs.push(this._participants[p].id);
      // }

      return data;
   }

   //
   // XML Model
   //

   /**
    * modelDefinition()
    * return the current xml definition for this process
    * @return {string}
    */
   modelDefinition() {
      return this.xmlDefinition;
   }

   /**
    * modelNew()
    * initialze our xml definition to a new state.
    * @return {string}
    */
   modelNew() {
      this.xmlDefinition = `<?xml version="1.0" encoding="UTF-8"?>
<bpmn2:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn2="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:di="http://www.omg.org/spec/DD/20100524/DI" xsi:schemaLocation="http://www.omg.org/spec/BPMN/20100524/MODEL BPMN20.xsd" id="process-def-${this.id}" targetNamespace="http://bpmn.io/schema/bpmn">
  <bpmn2:process id="Process_1" isExecutable="true">
    <bpmn2:startEvent id="StartEvent_1"/>
  </bpmn2:process>
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">
      <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">
        <dc:Bounds height="36.0" width="36.0" x="412.0" y="240.0"/>
      </bpmndi:BPMNShape>
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>
</bpmn2:definitions>`;

      //// TODO: create a default Start Task here??
   }

   /**
    * modelUpdate()
    * update our xml definition from the provided description.
    * @param {string} xml  bpmn2 xml definition from our modeler.
    * @return {string}
    */
   modelUpdate(xml) {
      this.xmlDefinition = xml;
   }

   //
   // Diagram Elements
   //

   /**
    * connections()
    * return an array of connections that describe the relationships between
    * our process elements.
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return [{SimpleConnectionObj}]
    */
   connections(fn = () => true) {
      var allConnections = Object.keys(this._connections).map((e) => {
         return this._connections[e];
      });

      // If parent, merge connections
      if (this.process && this.key === "SubProcess") {
         allConnections = allConnections.concat(this.process.connections());
      }

      return allConnections.filter(fn);
   }

   /**
    * connectionForDiagramID()
    * return the connection for the given diagram id
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionForDiagramID(dID) {
      return this.connections((t) => {
         return t.id == dID;
      })[0];
   }

   /**
    * connectionsIncoming()
    * return the connections that are entering this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsIncoming(dID) {
      return this.connections((c) => {
         return c.to == dID;
      });
   }

   /**
    * connectionsOutgoing()
    * return the connections that are leaving this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsOutgoing(dID) {
      return this.connections((c) => {
         return c.from == dID;
      });
   }

   /**
    * connectionRemove()
    * remove the connection info for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionRemove(element) {
      delete this._connections[element.id];
   }

   /**
    * connectionSimplyElement()
    * given a BPMN diagram element, return a simplified object that describes
    * the connection between two elements.
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    * @return {SimpleConnectionObj}
    *        .id : {string} diagram id of the connection element
    *        .type : {string} the type of connection
    *        .from : {string} the diagram id of the source element
    *        .to : {string} the diagram id of the dest element
    */
   connectionSimplyElement(element) {
      var bo = element.businessObject;
      var from = null;
      if (bo.sourceRef) {
         from = bo.sourceRef.id;
      }

      var to = null;
      if (bo.targetRef) {
         to = bo.targetRef.id;
      }

      var connection = {
         id: element.id,
         type: element.type,
         from: from,
         to: to,
      };
      return connection;
   }

   /**
    * connectionUpsert()
    * add or update the connection information for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionUpsert(element) {
      var simpleConn = this.connectionSimplyElement(element);
      if (simpleConn.from && simpleConn.to && element.parent) {
         this._connections[simpleConn.id] = simpleConn;
      } else {
         // this connection is no longer connecting anything thing.
         // it is being removed.
         this.connectionRemove(element);
      }
   }

   /**
    * elements()
    * return an array of elements that match the given filter (or all elements
    * if no filter is provided).
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return {[ABProcessTask, ABProcessParticipant, etc...]}
    */
   elements(fn = () => true) {
      var allElements = Object.keys(this._elements).map((e) => {
         return this._elements[e];
      });
      return allElements.filter(fn);
   }

   /**
    * elementAdd()
    * insert an element to be tracked by this process.
    * @param {ABProcessElement} element
    *        the full instance of an ABProcessElement to track.
    */
   elementAdd(element) {
      this._elements[element.id || element.diagramID] = element;
   }

   /**
    * elementByID()
    * return the {ABProcessElement} that has the given .id
    * @param {string} id
    * @return {ABProcess[OBJ]}
    */
   elementByID(id) {
      return this._elements[id] ?? null;
   }

   /**
    * elementForDiagramID()
    * return the object that is tied to the given xml diagram ID.
    * @param {string} dID the diagram ID
    * @return {ABProcess[OBJ]}
    */
   elementForDiagramID(dID) {
      return this.elements((t) => {
         return t.diagramID == dID;
      })[0];
   }

   /**
    * elementRemove()
    * remove an element from being tracked by this process.
    * @param {obj|ABProcessElement} def
    *        a definition of, or full Object instance of the ABProcessElement
    *        to remove.
    */
   elementRemove(def) {
      delete this._elements[def.id || def.diagramID];
   }

   /**
    * isTriggeredBy()
    * scan our tasks and see if we have a "trigger" task that responds to
    * the provided key.
    * @param {string} key the trigger key
    * @return {bool}
    */
   isTriggeredBy(key) {
      return this.taskForTriggerKey(key) != null;
   }

   /**
    * connectionNextTask()
    * return the ABProcessElement(s) that are after the given Element
    * (eg connects to) this element.
    * @param {ABProcessElement} currElement
    * @return {array}
    */
   connectionNextTask(currElement) {
      var elements = [];
      var nextConnections = this.connections((c) => {
         return c.from == currElement.diagramID;
      });
      nextConnections.forEach((c) => {
         var element = this.elements((e) => {
            return e.diagramID == c.to;
         })[0];
         if (element) {
            elements.push(element);
         }
      });
      return elements;
   }

   /**
    * connectionPreviousTask()
    * return the ABProcessElement(s) that was a previous Element
    * (eg connects to) this element.
    * @param {ABProcessElement} currElement
    * @return {array}
    */
   connectionPreviousTask(currElement) {
      var elements = [];
      var prevConnections = this.connections((c) => {
         return c.to == currElement.diagramID;
      });
      prevConnections.forEach((c) => {
         var element = this.elements((e) => {
            return e.diagramID == c.from;
         })[0];
         if (element) {
            elements.push(element);
         }
      });
      return elements;
   }

   /**
    * processData()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processData(currElement, params) {
      // var tasksToAsk = this.connectionPreviousTask(currElement);
      // var values = queryPreviousTasks(tasksToAsk, "processData", params, this);
      // return values.length > 0
      //    ? values.length > 1
      //       ? values
      //       : values[0]
      //    : null;

      var tasksToAsk = this.allPreviousTasks(currElement);
      var values = queryPreviousTasks(tasksToAsk, "processData", params, this);
      return values.length > 0
         ? values.length > 1
            ? values
            : values[0]
         : null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can request from other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataFields(currElement) {
      var tasksToAsk = this.allPreviousTasks(currElement);
      // var tasksToAsk = this.connectionPreviousTask(currElement);
      var fields = queryPreviousTasks(
         tasksToAsk,
         "processDataFields",
         null,
         this
      );
      // Include data from the main process as well
      if (this.key === "SubProcess") {
         const parentFields = this.process.processDataFields(this);
         if (parentFields) {
            fields.push(...parentFields);
         }
      }
      return fields.length > 0 ? fields : null;
   }

   /**
    * allPreviousConnections()
    * walk through the current graph and return all the previous connections
    * leading up to the given {ProcessElement}
    * @param {Connection} conn
    * @param {hash} hashConn
    *        { connection.id : connection }
    * @return {array}
    */
   allPreviousConnectionsForConnection(conn, hashConn) {
      var prevConnections = this.connections((c) => {
         return c.to == conn.from;
      });

      prevConnections.forEach((c) => {
         if (!hashConn[c.id]) {
            hashConn[c.id] = c;
            this.allPreviousConnectionsForConnection(c, hashConn);
         }
      });
   }
   allPreviousConnectionsForElement(currElement) {
      var prevConnections = this.connections((c) => {
         return c.to == currElement.diagramID;
      });
      var hashConn = {
         /* connection.id : connection */
      };
      // hashConn will contains the final collection of connections.

      prevConnections.forEach((c) => {
         hashConn[c.id] = c;
         this.allPreviousConnectionsForConnection(c, hashConn);
      });

      // TODO: detect circle backs and remove connections that
      // resolve back to currElement

      // convert our hash into an array
      return Object.keys(hashConn).map((k) => hashConn[k]);
   }

   allPreviousTasks(currElement) {
      var prevTasks = {}; /* task.id : task */
      var allPreviousConnections =
         this.allPreviousConnectionsForElement(currElement);
      var task;
      allPreviousConnections.forEach((conn) => {
         // each conn has a .to and a .from => grab both tasks
         task = this.elementForDiagramID(conn.to);
         if (task) prevTasks[task.id] = task;

         task = this.elementForDiagramID(conn.from);
         if (task) prevTasks[task.id] = task;
      });

      var tasksToAsk = Object.keys(prevTasks)
         .map((k) => prevTasks[k])
         .filter((t) => t.id != currElement.id);

      return tasksToAsk;
   }

   /**
    * processDataObjects()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataObjects(currElement) {
      var tasksToAsk = this.connectionPreviousTask(currElement);
      var fields = queryPreviousTasks(
         tasksToAsk,
         "processDataObjects",
         null,
         this
      );
      return fields.length > 0 ? fields : null;
   }

   /**
    * taskForTriggerKey()
    * return one or more tasks that respond to the given trigger key
    * @param {string} key a trigger key
    * @return {[ABProcessTask,...]}
    */
   taskForTriggerKey(key) {
      var trigger = this.elements((t) => {
         return t.triggerKey == key;
      })[0];
      if (trigger) {
         return trigger;
      } else {
         return null;
      }
   }

   //
   // Participants
   //

   // /**
   //  * participants()
   //  * return an array of participants that match the given filter (or all tasks
   //  * if no filter is provided).
   //  * @param {fn} fn an iterator that returns true if the provided participants
   //  *                should be returned.
   //  * @return {[ABProcessParticipant,...]}
   //  */
   // participants(fn) {
   //     if (!fn)
   //         fn = () => {
   //             return true;
   //         };
   //     var all = Object.keys(this._participants).map((p) => {
   //         return this._participants[p];
   //     });
   //     return all.filter(fn);
   // }

   // /**
   //  * participantsForDiagramID()
   //  * return the participant(s) that are tied to the given xml diagram ID.
   //  * @param {string} dID the diagram ID
   //  * @return {[ABProcessParticipant,...]}
   //  */
   // participantsForDiagramID(dID) {
   //     return this.participants((p) => {
   //         return p.diagramID == dID;
   //     });
   // }
}

var queryPreviousTasks = (
   list,
   method,
   param,
   process,
   responses,
   processedIDs
) => {
   // recursive fn() to step through our graph and compile
   // results.
   if (typeof responses == "undefined") {
      responses = [];
   }
   if (typeof processedIDs == "undefined") {
      processedIDs = [];
   }
   if (list.length == 0) {
      return responses;
   } else {
      // get next task
      const task = list.shift();

      // if we haven't already done task:
      if (processedIDs.indexOf(task.diagramID) == -1) {
         // mark this task as having been processed
         processedIDs.push(task.diagramID);

         let value = null;

         // get any field's it provides
         if (!(task instanceof _platform_process_tasks_ABProcessTaskSubProcess__WEBPACK_IMPORTED_MODULE_2__["default"]))
            value = task[method].apply(task, param);

         // value = task[method].apply(task, param);

         if (value === null) value = [];
         responses = _concat(responses, value);

         // add any previous tasks to our list
         list = _concat(list, process.connectionPreviousTask(task));
      }

      // process next Task
      return queryPreviousTasks(
         list,
         method,
         param,
         process,
         responses,
         processedIDs
      );
   }
};


/***/ }),

/***/ 53618:
/*!**********************************************!*\
  !*** ./src/js/AppBuilder/core/ABStepCore.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABStepCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
// import ABApplication from "./ABApplication"



class ABStepCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(["name", "text"], AB);

      this.fromValues(attributes);

      // indicate we are ready.
      // this.elements().forEach((e) => {
      //    e.onProcessReady();
      // });
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
    {
      id: uuid(),
      name: 'name',
      type: 'xxxxx',
      json: "{json}"
    }
    */
      this.id = attributes.id;
      this.name = attributes.name || "New Step";
      this.type = attributes.type || "step";
      this.text = attributes.text || "";
      this.settings = attributes.settings || {};
      this.settings.event = attributes?.settings?.event || "click";
      this.settings.el = attributes?.settings?.el || "";
      // this.xmlDefinition = attributes.xmlDefinition || null;

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this ABProcess instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      // debugger;
      // default label value
      if (!this.label) {
         this.label = this.name;
      }

      // OP.Multilingual.unTranslate(this, this, ["label"]);
      var data = super.toObj();

      var fieldsToSave = ["id", "name", "settings", "type"];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   // /**
   //  * steps()
   //  * return an array of steps that match the given filter (or all steps
   //  * if no filter is provided).
   //  * @param {fn} fn an iterator that returns true if the provided element
   //  *                should be returned.
   //  * @return {[ABStep]}
   //  */
   // steps(fn = () => true) {
   //    var allSteps = Object.keys(this._steps).map((e) => {
   //       return this._steps[e];
   //    });
   //    return allSteps.filter(fn);
   // }

   // /**
   //  * stepAdd()
   //  * insert a step to be added to this hint.
   //  * @param {ABStep} element
   //  *        the full instance of an ABStep to track.
   //  */
   // stepAdd(step) {
   //    this._steps[step.id] = step;
   // }

   // /**
   //  * stepByID()
   //  * return the {ABStep} that has the given .id
   //  * @param {string} id
   //  * @return {ABStep[OBJ]}
   //  */
   // stepByID(id) {
   //    return this._step[id] ?? null;
   // }

   // /**
   //  * stepRemove()
   //  * remove a step from being displayed by this hint.
   //  * @param {obj|ABStep} def
   //  *        a definition of, or full Object instance of the ABStep
   //  *        to remove.
   //  */
   // stepRemove(def) {
   //    delete this._steps[def.id];
   // }
}


/***/ }),

/***/ 85642:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/core/ABViewManagerCore.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewManagerCore)
/* harmony export */ });
/*
 * ABViewManager
 *
 * An interface for managing the different ABViews available in our AppBuilder.
 *
 */

var AllViews = [
   // require("../platform/views/ABView"),
   await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/views/ABView */ 69459)),
   // require("../platform/views/ABViewCarousel"),
   // require("../platform/views/ABViewChart"),
   // require("../platform/views/ABViewChartArea"),
   // require("../platform/views/ABViewChartBar"),
   // require("../platform/views/ABViewChartLine"),
   // require("../platform/views/ABViewChartPie"),
   // require("../platform/views/ABViewComment"),
   // require("../platform/views/ABViewConditionalContainer"),
   // require("../platform/views/ABViewConnectDataFilter"),
   // require("../platform/views/ABViewContainer"),
   // require("../platform/views/ABViewCSVExporter"),
   // require("../platform/views/ABViewCSVImporter"),
   // require("../platform/views/ABViewDataFilter"),
   // require("../platform/views/ABViewDataSelect"),
   // require("../platform/views/ABViewDataview"),
   // require("../platform/views/ABViewDocxBuilder"),
   // require("../platform/views/ABViewGrid"),
   // require("../platform/views/ABViewImage"),
   // require("../platform/views/ABViewLabel"),
   // require("../platform/views/ABViewLayout"),
   // require("../platform/views/ABViewList"),
   // require("../platform/views/ABViewMenu"),
   // require("../platform/views/ABViewOrgChart"),
   // require("../platform/views/ABViewPage"),
   // require("../platform/views/ABViewPDFImporter"),
   // require("../platform/views/ABViewPivot"),
   // require("../platform/views/ABViewTab"),
   // require("../platform/views/ABViewText"),

   // //
   // // Special Editors
   // //
   // require("../platform/views/ABViewGantt"),
   // require("../platform/views/ABViewKanban"),
   // require("../platform/views/ABViewReportsManager"),
   // require("../platform/views/ABViewScheduler"),

   // //
   // // Detail Components
   // //
   // require("../platform/views/ABViewDetail"),
   // require("../platform/views/ABViewDetailCheckbox"),
   // require("../platform/views/ABViewDetailConnect"),
   // require("../platform/views/ABViewDetailCustom"),
   // require("../platform/views/ABViewDetailImage"),
   // // require("../platform/views/ABViewDetailSelectivity"),
   // require("../platform/views/ABViewDetailText"),
   // require("../platform/views/ABViewDetailTree"),

   // //
   // // Form Components
   // //
   // require("../platform/views/ABViewForm"),
   // require("../platform/views/ABViewFormButton"),
   // require("../platform/views/ABViewFormCheckbox"),
   // require("../platform/views/ABViewFormConnect"),
   // require("../platform/views/ABViewFormCustom"),
   // require("../platform/views/ABViewFormDatepicker"),
   // require("../platform/views/ABViewFormJson"),
   // require("../platform/views/ABViewFormNumber"),
   // require("../platform/views/ABViewFormReadonly"),
   // require("../platform/views/ABViewFormSelectMultiple"),
   // require("../platform/views/ABViewFormSelectSingle"),
   // require("../platform/views/ABViewFormTextbox"),
   // require("../platform/views/ABViewFormTree"),
];

/*
 * Views
 * A name => ABView  hash of the different ABViews available.
 */
var Views = {};
AllViews.forEach((v) => {
   if (v.default?.common) {
      v = v.default;
   }
   Views[v.common().key] = v;
});

class ABViewManagerCore {
   /**
    * @function allViews
    * return all the currently defined ABViews in an array.
    * @return [{ABView},...]
    */
   static allViews(fn = () => true) {
      var views = [];
      for (var v in Views) {
         var V = Views[v];
         if (fn(V)) {
            views.push(V);
         }
      }
      return views;
   }

   /**
    * @function newView
    * return an instance of an ABView based upon the values.key value.
    * @return {ABView}
    */
   static newView(values, application, parent) {
      parent = parent || null;

      if (values.key == "detailselectivity") {
         values.key = "detailconnect";
      }

      //		if ((values.key) && (Views[values.key])) {
      if (values.key) {
         if (!Views[values.key]) {
            if (!isPlugin(values.key)) {
               console.error(
                  "!! View[" +
                     values.key +
                     "] not yet defined.  Have an ABView instead:"
               );
            }
            return new Views["view"](values, application, parent);
         }

         return new Views[values.key](values, application, parent);
      } else {
         var err = new Error(`Unknown view key [${values.key}]`);
         console.error(err); // show the stack.
         console.error({
            error: err,
            values: values,
            application: application,
         });
         return null;
      }
   }

   static viewClass(key) {
      if (Views[key]) {
         return Views[key];
      }
      console.error(`Unknown View Key[${key}]`);
      return;
   }

   static addViewClass(View) {
      Views[View.common().key] = View;
   }
}

/**
 * Check if the key starts with plugin_
 */
function isPlugin(key) {
   return key.split("_")[0] === "plugin";
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 40080:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/core/ABViewManagerMobileCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewManagerMobile
 *
 * An interface for managing the different ABViews available in our AppBuilder.
 *
 */

/*
 * Views
 * A name => ABView  hash of the different ABViews available.
 */
var Views = {};
[
   __webpack_require__(/*! ../platform/mobile/ABMobilePage */ 77831),
   __webpack_require__(/*! ../platform/mobile/ABMobileView */ 53349),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewCustom */ 95609),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewForm */ 55805),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormButton */ 50037),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormCheckbox */ 92092),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormConnect */ 2493),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormDate */ 37272),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormDatetime */ 43717),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormEmail */ 46722),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormFile */ 94298),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormFormula */ 92696),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormImage */ 14241),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormNumber */ 95729),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormReadonly */ 95620),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormSelectMultiple */ 77614),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormSelectSingle */ 88001),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormTextbox */ 36959),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewLabel */ 84205),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewList */ 78261),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewTimeline */ 15103),
].forEach((v) => {
   if (v.default?.common) {
      v = v.default;
   }
   Views[v.common().key] = v;
});

module.exports = class ABViewManagerCore {
   /**
    * @function allViews
    * return all the currently defined ABViews in an array.
    * @return [{ABView},...]
    */
   static allViews(fn = () => true) {
      var views = [];
      for (var v in Views) {
         var V = Views[v];
         if (fn(V)) {
            views.push(V);
         }
      }
      return views;
   }

   /**
    * @function newView
    * return an instance of an ABView based upon the values.key value.
    * @return {ABView}
    */
   static newView(values, application, parent) {
      parent = parent || null;

      if (values.key == "detailselectivity") {
         values.key = "detailconnect";
      }

      //		if ((values.key) && (Views[values.key])) {
      if (values.key) {
         if (!Views[values.key]) {
            console.error(
               "!! View[" +
                  values.key +
                  "] not yet defined.  Have an ABView instead:"
            );
            return new Views["mobile-view"](values, application, parent);
         }

         return new Views[values.key](values, application, parent);
      } else {
         var err = new Error(`Unknown view key [${values.key}]`);
         console.error(err); // show the stack.
         console.error({
            error: err,
            values: values,
            application: application,
         });
         return null;
      }
   }

   static viewClass(key) {
      if (Views[key]) {
         return Views[key];
      }
      console.error(`Unknown View Key[${key}]`);
      return;
   }
};


/***/ }),

/***/ 89391:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/core/FilterComplexCore.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FilterComplexCore)
/* harmony export */ });
/* harmony import */ var _platform_ABComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABComponent */ 64971);

// const ABObjectQuery = require("../platform/ABObjectQuery");

/**
 *  support get data from objects and queries
 */
function getFieldVal(rowData, field) {
   if (!field) return null;
   if (!field.columnName) return null;
   const columnName = field.columnName;

   let value = null;

   if (columnName.indexOf(".") > -1) {
      let colName = columnName.split(".")[1];
      value = rowData[columnName] || rowData[colName];
   } else {
      value = rowData[columnName];
   }

   // pull relation data
   if (value == null && field.relationName) {
      const relationName = field.relationName();
      const pureRelationName = relationName.split(".")[1]; // support [BASE_OBJECT.columnName] field name of ABQuery
      value = rowData[relationName] || rowData[pureRelationName];
   }

   if (value != null && !isNaN(value)) {
      return value;
   }

   // otherwise, this might be a process check where the rowData keys have
   // '[diagramID].[field.id]'
   for (const k in rowData) {
      const key = k.split(".")[1];
      if (key && key == field.id) {
         value = rowData[k];
      }
   }

   if (
      (value == null || (typeof value == "number" && isNaN(value))) &&
      field.format
   )
      value = field.format(rowData);

   return value;
}

function getConnectFieldValue(rowData, field) {
   let connectedVal = "";

   const extractVal = (itemData) => {
      let val;
      const relationName = field.relationName();
      if (itemData[relationName]) {
         val =
            (field.indexField
               ? itemData[relationName][field.indexField.columnName]
               : null) ?? // custom index
            (field.indexField2
               ? itemData[relationName][field.indexField2.columnName]
               : null) ?? // custom index 2
            itemData[relationName].id ??
            itemData[relationName];
      } else {
         let fieldVal = getFieldVal(itemData, field);
         if (fieldVal != null) {
            val = fieldVal;
         }
      }
      return val;
   };

   if (Array.isArray(rowData)) {
      connectedVal = rowData.map((data) => extractVal(data));
   } else if (rowData) {
      connectedVal = extractVal(rowData);
   }
   return connectedVal;
}

class FilterComplexCore extends _platform_ABComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(idBase, AB) {
      idBase = idBase || "ab_filter_complex";

      if (typeof AB === "undefined") {
         console.error("FilterComplexCore(): being called without an AB!");
      }

      super(null, idBase, AB);

      this.Account = { username: "??" };
      this._settings = {};
      this.condition = {};
      // const batchName; // we need to revert to this default when switching away from a in/by query field

      this._QueryFields = [];
      this._Fields;

      // internal business logic
      const _logic = (this._logic = {
         callbacks: {
            onChange: () => {},
         },

         removeHtmlTags: function (text) {
            let result = "";
            try {
               let div = document.createElement("div");
               div.innerHTML = text;

               result = div.textContent || div.innerText || "";
            } catch (err) {
               result = (text || "").replace(/(<([^>]+)>)/gi, "");
            }

            return result;
         },
      });

      // Interface methods for parent component:
      // this.objectLoad = _logic.objectLoad;
      // this.viewLoad = _logic.viewLoad;
      // this.setValue = _logic.setValue;
      // this.isValid = _logic.isValid;
   }

   init(options = {}) {
      this._settings = options;
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    * @param condition {Object} - [Optional] {
    *                                           glue: "and" | "or",
    *                                           rules: []
    *                                        }
    */
   isValid(rowData, condition = this.condition) {
      // If conditions but no data return false
      if (condition?.rules?.length && rowData == null) return false;

      // If no conditions, then return true
      if (!condition?.rules?.length || rowData == null) return true;

      let result = condition.glue === "and" ? true : false;

      condition.rules.forEach((filter) => {
         // Nested filters
         if (filter?.rules?.length) {
            if (condition.glue === "or")
               result = result || this.isValid(rowData, filter);
            else result = result && this.isValid(rowData, filter);
            return;
         }
         // Skip incomplete filter condition
         else if (!filter || !filter.key || !filter.rule) return;

         const fieldInfo = (this._Fields || []).filter(
            (f) => f.id == filter.key || f.columnName == filter.key
         )[0];

         if (!fieldInfo) return;

         let condResult = null;

         // Filters that have "this_object" don't have a fieldInfo.key, so in that case,
         // define a special .key == "this_object"
         let ruleFieldType = fieldInfo.key;

         if (typeof fieldInfo.key == "undefined") {
            if (fieldInfo.id != "this_object") {
               fieldInfo.key = "connectField"; // if you are looking at the parent object it won't have a key to analyze
               ruleFieldType = fieldInfo.key;
            } else ruleFieldType = "this_object";
         }

         let value = null;

         if (fieldInfo.relationName) {
            value = getConnectFieldValue(rowData, fieldInfo);
         } else {
            value = getFieldVal(rowData, fieldInfo);
         }

         switch (ruleFieldType) {
            case "string":
            case "LongText":
            case "email":
               if (value == null) value = "";

               condResult = this.textValid(value, filter.rule, filter.value);
               break;
            case "date":
            case "datetime":
               condResult = this.dateValid(value, filter.rule, filter.value);
               break;
            case "number":
            case "calculate":
            case "formula":
               condResult = this.numberValid(value, filter.rule, filter.value);
               break;
            case "list":
               condResult = this.listValid(value, filter.rule, filter.value);
               break;
            case "boolean":
               condResult = this.booleanValid(value, filter.rule, filter.value);
               break;
            case "user":
               condResult = this.userValid(value, filter.rule, filter.value);
               break;
            case "connectField":
            case "connectObject":
               condResult = this.connectFieldValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "this_object":
               condResult = this.thisObjectValid(
                  rowData,
                  filter.rule,
                  filter.value
               );
               break;
         }

         if (condition.glue === "and") {
            result = result && condResult;
         } else {
            result = result || condResult;
         }
      });

      return result;
   }

   textValid(value, rule, compareValue) {
      let result = false;

      value = value.trim().toLowerCase();
      value = this._logic.removeHtmlTags(value); // remove html tags - rich text editor

      compareValue = compareValue.trim().toLowerCase().replace(/  +/g, " ");

      // support "john smith" => "john" OR/AND "smith"
      const compareArray = compareValue.split(" ");

      switch (rule) {
         case "contains":
            compareArray.forEach((val) => {
               if (result == false)
                  // OR
                  result = value.indexOf(val) > -1;
            });
            break;
         case "not_contains":
            result = true;
            compareArray.forEach((val) => {
               if (result == true)
                  // AND
                  result = value.indexOf(val) < 0;
            });
            break;
         case "equals":
            compareArray.forEach((val) => {
               if (result == false)
                  // OR
                  result = value == val;
            });
            break;
         case "not_equal":
            result = true;
            compareArray.forEach((val) => {
               if (result == true)
                  // AND
                  result = value != val;
            });
            break;
         case "is_empty":
            result = value == "" || value == null;
            break;
         case "is_not_empty":
            result = value != "" && value != null;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   dateValid(value, rule, compareValue) {
      let result = false;

      if (!(value instanceof Date)) value = new Date(value);

      if (!(compareValue instanceof Date))
         compareValue = new Date(compareValue);
      switch (rule) {
         case "less":
            result = value < compareValue;
            break;
         case "greater":
            result = value > compareValue;
            break;
         case "less_or_equal":
            result = value <= compareValue;
            break;
         case "greater_or_equal":
            result = value >= compareValue;
            break;
         case "is_current_date":
            result =
               value.setHours(0, 0, 0, 0) == compareValue.setHours(0, 0, 0, 0);
            break;
         case "is_empty":
            result = !value;
            break;
         case "is_not_empty":
            result = !!value;
            break;
         case "is_null":
            result = value == null;
            break;
         case "is_not_null":
            result = value != null;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }
      return result;
   }

   numberValid(value, rule, compareValue) {
      let result = false;

      value = Number(value);
      compareValue = Number(compareValue);

      switch (rule) {
         case "equal":
         case "equals":
            result = value == compareValue;
            break;
         case "not_equal":
            result = value != compareValue;
            break;
         case "less":
            result = value < compareValue;
            break;
         case "greater":
            result = value > compareValue;
            break;
         case "less_or_equal":
            result = value <= compareValue;
            break;
         case "greater_or_equal":
            result = value >= compareValue;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   listValid(value, rule, compareValue) {
      let result = false;

      // compareValue = compareValue.toLowerCase();

      if (!Array.isArray(compareValue)) compareValue = [compareValue];

      switch (rule) {
         case "equals":
            if (value) result = compareValue.indexOf(value) > -1;
            break;
         case "not_equal":
            if (value) result = compareValue.indexOf(value) < 0;
            else result = true;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   booleanValid(value, rule, compareValue) {
      let result = false;

      switch (rule) {
         case "checked":
            result = value == true || value > 0 || value == "true";
            break;
         case "unchecked":
            result =
               value == false ||
               value <= 0 ||
               value == "false" ||
               value == null;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   userValid(value, rule, compareValue) {
      if (!value || !value?.length) return false;
      let result = false;

      if (!Array.isArray(value)) value = [value];

      /* eslint-disable no-fallthrough */
      switch (rule) {
         case "is_current_user":
            result =
               value.filter((v) => (v?.username || v) == this.Account.username)
                  .length > 0;
            break;
         case "is_not_current_user":
            result =
               value.filter((v) => (v?.username || v) != this.Account.username)
                  .length > 0;
            break;
         case "contain_current_user":
            compareValue = this.Account.username;
         // break;  <-- NO BREAK HERE: fall through to "equals"

         case "equals":
            result =
               value.filter((v) => (v?.username || v) == compareValue).length >
               0;
            break;
         case "not_contain_current_user":
            compareValue = this.Account.username;
         // break;  <-- NO BREAK HERE: fall through to "not_equals"

         case "not_equal":
            result =
               value.filter((v) => (v?.username || v) == compareValue).length <
               1;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }
      /* eslint-enable no-fallthrough */

      return result;
   }

   queryFieldValid(rowData, rule, compareValue) {
      let result = false;

      if (!compareValue) return result;

      // queryId:fieldId
      const queryId = compareValue.split(":")[0],
         fieldId = compareValue.split(":")[1];

      // if no query
      const query = this.AB.queries((q) => q.id == queryId)[0];
      if (!query) return result;

      // if no field
      const field = query.fields((f) => f.id == fieldId)[0];
      if (!field) return result;

      let qIdBase = "{idBase}-query-field-{id}"
            .replace("{idBase}", this.idBase)
            .replace("{id}", query.id),
         inQueryFieldFilter = new this.constructor(qIdBase, this.AB);
      inQueryFieldFilter.Account = this.Account;
      inQueryFieldFilter.fieldsLoad(query.fields());
      inQueryFieldFilter.setValue(query.workspaceFilterConditions);

      switch (rule) {
         case "in_query_field":
            result = inQueryFieldFilter.isValid(rowData);
            break;
         case "not_in_query_field":
            result = !inQueryFieldFilter.isValid(rowData);
            break;
      }

      return result;
   }

   inQueryValid(rowData, rule, compareValue) {
      let result = false;

      if (!compareValue || !this.AB) return result;

      // if no query
      let query = this.AB.queries((q) => q.id == compareValue)[0];
      if (!query) return result;

      let qIdBase = "{idBase}-query-{id}"
            .replace("{idBase}", this.idBase)
            .replace("{id}", query.id),
         inQueryFilter = new this.constructor(qIdBase, this.AB);
      inQueryFilter.Account = this.Account;
      inQueryFilter.fieldsLoad(query.fields());
      inQueryFilter.setValue(query.workspaceFilterConditions);

      switch (rule) {
         case "in_query":
            result = inQueryFilter.isValid(rowData);
            break;
         case "not_in_query":
            result = !inQueryFilter.isValid(rowData);
            break;
      }

      return result;
   }

   dataCollectionValid(value, rule, compareValue) {
      let result = false;

      if (!compareValue) return result;

      let dc = this.AB.datacollections((d) => d.id == compareValue)[0];

      switch (rule) {
         case "in_data_collection":
            if (!dc) return false;

            result = dc.getData((d) => d.id == value.id).length > 0;
            break;
         case "not_in_data_collection":
            if (!dc) return true;

            result = dc.getData((d) => d.id == value.id).length < 1;
            break;
      }

      return result;
   }

   connectFieldValid(rowData, field, rule, compareValue) {
      let relationName = field.relationName();

      let connectedVal = "";

      let linkType = field.linkType();

      if (rowData) {
         if (rowData[relationName]) {
            if (linkType == "many") {
               // lets get an array of connected ids => stringified()
               connectedVal = JSON.stringify(
                  getConnectFieldValue(rowData, field).map((i) => i.id || i)
               );
            } else {
               // connectedVal = (
               //    (field.indexField
               //       ? rowData[relationName][field.indexField.columnName]
               //       : null) ?? // custom index
               //    (field.indexField2
               //       ? rowData[relationName][field.indexField2.columnName]
               //       : null) ?? // custom index 2
               //    rowData[relationName].id ??
               //    rowData[relationName]
               // )
               connectedVal = getConnectFieldValue(rowData, field)
                  .toString()
                  .toLowerCase();
            }
         } else {
            let fieldVal = getFieldVal(rowData, field);
            if (fieldVal != null) {
               connectedVal = fieldVal;
            }
         }
      }

      // If value will be the connected object, then pull value (string)
      if (typeof connectedVal == "object") {
         connectedVal =
            (field.indexField
               ? connectedVal[field.indexField.columnName]
               : null) ??
            (field.indexField2
               ? connectedVal[field.indexField2.columnName]
               : null) ??
            connectedVal[field.columnName] ??
            connectedVal.id ??
            connectedVal;
      }

      // Compare value isn't always a string?
      // https://appdev-designs.sentry.io/issues/5056850389/
      let compareValueLowercase =
         typeof compareValue === "string"
            ? compareValue.toLowerCase?.()
            : compareValue;

      // NOTE: if linkType == many, and rule is equals/not_equal,
      // these will be interpreted as "contains/not_contains"
      let ruleSafe = rule;
      if (linkType == "many") {
         switch (rule) {
            case "equals":
               ruleSafe = "contains";
               break;
            case "not_equal":
               ruleSafe = "not_contains";
               break;
         }
      }

      switch (ruleSafe) {
         case "contains":
            return connectedVal.toString().indexOf(compareValueLowercase) > -1;
         case "not_contains":
            return connectedVal.toString().indexOf(compareValueLowercase) == -1;
         case "equals":
            return connectedVal == compareValueLowercase;
         case "not_equal":
            return connectedVal != compareValueLowercase;
         case "in_query":
         case "not_in_query":
            return this.inQueryValid(rowData[relationName], rule, compareValue);
         case "is_current_user":
         case "is_not_current_user":
         case "contain_current_user":
         case "not_contain_current_user":
            return this.userValid(connectedVal, rule, compareValue);
         case "is_empty":
            return (
               rowData[relationName] == null ||
               rowData[relationName].length < 1 ||
               rowData[relationName] == ""
            );
         case "is_not_empty":
            return (
               rowData[relationName] != null &&
               ((Array.isArray(rowData[relationName]) &&
                  rowData[relationName].length > 0) ||
                  rowData[relationName] != "")
            );
         case "in_data_collection":
         case "not_in_data_collection":
            return this.dataCollectionValid(connectedVal, rule, compareValue);
      }
   }

   thisObjectValid(rowData, rule, compareValue) {
      let result = false;
      let query = null;
      let listThisObjects = null;
      let alias = null;
      let newRowData = null;

      switch (rule) {
         // if in_query condition
         case "in_query":
         case "not_in_query":
            if (!this._Object) return result;

            // if > 1 copy of this object in query ==> Error!
            query = this.AB.queries((q) => q.id == compareValue)[0];

            if (!query) return result;

            listThisObjects = query.objects((o) => {
               return o.id == this._Object.id;
            });

            if (listThisObjects.length > 1) {
               // Alternative: choose the 1st instance of this object in the query, and make the compare on that.
               // Be sure to warn the developer of the limitiations of an "this_object" "in_query"  when query has > 1 copy of
               // this object as part of the query.

               console.error(
                  "HEY!  Can't compare this_object to a query that has > 1 copy of that object!"
               );

               return true;
            }

            // get this object's alias from the query
            alias = query.objectAlias(this._Object.id);

            // make sure all my columns in rowData are prefixed by "alias".columnName
            newRowData = {};

            Object.keys(rowData).forEach((key) => {
               newRowData[`${alias}.${key}`] = rowData[key];
            });

            // then pass this on to the _logic.queryValid();
            return this.inQueryValid(newRowData, rule, compareValue);

         // if in_datacollection condition
         case "in_data_collection":
         case "not_in_data_collection":
            // send rowData, null to datacollectionValid()
            return this.dataCollectionValid(rowData, rule, compareValue);
      }
   }

   processFieldsLoad(processFields = []) {
      if (processFields && !Array.isArray(processFields)) {
         processFields = [processFields];
      }
      this._ProcessFields = processFields;

      this.uiInit();
   }

   /**
    * @method fieldsLoad
    * set fields
    *
    * @param array {ABField}
    * @param object {ABObject} [optional]
    */
   fieldsLoad(fields = [], object = null) {
      this._Fields = fields.filter(
         (f) => f && f.fieldIsFilterable && f.fieldIsFilterable()
      );
      this._QueryFields = this._Fields
         ? this._Fields.filter((f) => f && f.isConnection && f.key != "user")
         : [];

      // insert our 'this object' entry if an Object was given.
      if (object) {
         this._Object = object;

         // insert our uuid in addition to the rest of our fields
         let thisObjOption = {
            id: "this_object",
            label: object.label,
            key: "uuid",
         };

         // If object is query ,then should define default alias: "BASE_OBJECT"
         // NOTE: Could not reference ABObjectQuery because recursive looping reference
         // if (object instanceof ABObjectQuery) {
         if (object.viewName) {
            thisObjOption.alias = "BASE_OBJECT";
         }

         this._Fields.unshift(thisObjOption);
      } else {
         delete this._Object;
      }
   }

   fieldsToQB() {
      /*
      let mapTypes = {
         LongText: "string",
         email: "string",
         datetime: "date",
         connectField: "connectObject"
      };

      const fields = this._Fields.map((f) => {
         // Label
         let label = f.label;
         if (this._settings.showObjectName && f.object && f.object.label)
            label = `${f.object.label}.${f.label}`;

         // Type
         let type = f.key || f.type;
         if (mapTypes[type]) type = mapTypes[type];

         // the format for webix querybuilder:
         // { id  value:"label" type }
         //      type: {string} the type of value it is.
         //            since we want to tailor value selectors per field,
         //            we will make a unique type for each field. and then
         //            add value selectors for that specific .type
         return { id: f.columnName, value: label, type: type };
      });
      return fields;
      */

      let fields = (this._Fields || []).map((f) => {
         let label = f.label;
         if (this._settings.showObjectName && f.object && f.object.label)
            label = `${f.object.label}.${f.label}`;

         let type = "text"; // "text", "number", "date"
         let conditions = [];
         let processFieldKeys = [];
         let hasQueryField = true;

         if (!this._settings.isProcessParticipant)
            switch (f.key) {
               case "boolean":
                  conditions = conditions.concat(
                     this.fieldsAddFiltersBoolean(f)
                  );
                  processFieldKeys = ["boolean"];

                  break;

               case "connectObject":
                  conditions = this.fieldsAddFiltersConnectObject(f);

                  // Add filter options to Custom index
                  if (
                     // 1:M
                     (f.settings.linkType == "one" &&
                        f.settings.linkViaType == "many") ||
                     // 1:1 isSource = true
                     (f.settings.linkType == "one" &&
                        f.settings.linkViaType == "one" &&
                        f.settings.isSource)
                  ) {
                     const stringResults = this.fieldsAddFiltersString(
                        f
                     ).filter(
                        (opt) =>
                           f.settings.isCustomFK ||
                           // If this connect field does not use custom FK, then allow just `is empty` and `is not empty` filter options
                           opt.id == "is_empty" ||
                           opt.id == "is_not_empty"
                     );
                     conditions = stringResults.concat(conditions);

                     // By Query Field
                     conditions = conditions.concat(
                        this.fieldsAddFiltersQuery(f, true)
                     );
                  }

                  hasQueryField = false;
                  processFieldKeys = ["connectObject"];

                  break;

               case "date":
               case "datetime":
                  type = "date";
                  conditions = conditions.concat(this.fieldsAddFiltersDate(f));
                  processFieldKeys = ["date", "datetime"];

                  break;

               case "calculate":
               case "formula":
               case "number":
                  type = "number";
                  conditions = conditions.concat(
                     this.fieldsAddFiltersNumber(f)
                  );
                  processFieldKeys = ["calculate", "formula", "number"];

                  break;

               case "string":
               case "LongText":
               case "email":
               case "AutoIndex":
                  conditions = conditions.concat(
                     this.fieldsAddFiltersString(f)
                  );
                  processFieldKeys = [
                     "string",
                     "LongText",
                     "email",
                     "AutoIndex",
                  ];

                  break;

               case "list":
                  conditions = conditions.concat(this.fieldsAddFiltersList(f));

                  break;

               case "user":
                  conditions = conditions.concat(this.fieldsAddFiltersUser(f));
                  processFieldKeys = ["user"];

                  break;

               case "uuid":
                  conditions = conditions.concat(
                     this.fieldsAddFiltersThisObject(f)
                  );
                  hasQueryField = false;

                  break;
               default:
                  break;
            }
         else
            switch (f.key) {
               case "connectObject":
               case "uuid":
                  hasQueryField = false;

                  break;
            }

         conditions = conditions.concat(
            this.fieldsAddFiltersQuery(f, hasQueryField)
         );

         if (this._settings.isRecordRule) {
            conditions = conditions.concat(this.fieldsAddFiltersRecordRule(f));
         }

         let isProcessField =
            (this._ProcessFields || []).filter((processField) => {
               if (!processField) return false;

               if (processField.field) {
                  return processFieldKeys.includes(processField.field.key);
               } else if (processField.key) {
                  // uuid
                  let processFieldId = processField.key.split(".").pop();
                  return processFieldId == f.id || processFieldId == f.key;
               }
            }).length > 0;

         if (isProcessField) {
            conditions = conditions.concat(this.fieldsAddFiltersContext(f));
         }

         conditions = conditions.concat(this.fieldsAddFiltersCustom(f));

         // let type = f.id; // the default unique identifier for our filter types
         // if (f.id == "this_object") {
         //    // if this happens to be our special "this_object" field, then our
         //    // type needs to be the "uuid" type in the definition:
         //    type = f.type;
         // }

         // the format for webix querybuilder:
         // { id  value:"label" type }
         //      type: {string} the type of value it is.
         //            since we want to tailor value selectors per field,
         //            we will make a unique type for each field. and then
         //            add value selectors for that specific .type
         return {
            id: f.id,
            value: label,
            type: type,
            conditions: conditions,
            // format: () => {},
         };
      });

      // !!! Process Fields of ABProcess
      // https://github.com/digi-serve/appbuilder_class_core/blob/master/FilterComplexCore.js#L636
      // https://github.com/digi-serve/appbuilder_class_core/blob/master/FilterComplexCore.js#L564
      // (this._ProcessFields || [])
      //    // if there is no .field, it is probably an embedded special field
      //    .filter((pField) => pField.field == null)
      //    .forEach((pField) => {
      //       // like: .uuid
      //       let key = pField.key.split(".").pop();
      //       if (key == "uuid" && this._Object) {
      //          fields.unshift({
      //             id: pField.key,
      //             value: this._Object.label,
      //             type: "text",
      //             conditions: this.fieldsAddFiltersContext(),
      //          });
      //       }
      //    });

      return fields;
   }

   fieldsAddFiltersDate(field) {
      let dateConditions = {
         less: this.labels.component.beforeCondition,
         greater: this.labels.component.afterCondition,
         less_or_equal: this.labels.component.onOrBeforeCondition,
         greater_or_equal: this.labels.component.onOrAfterCondition,
         is_current_date: this.labels.component.isCurrentDateCondition,
         less_current: this.labels.component.beforeCurrentCondition,
         greater_current: this.labels.component.afterCurrentCondition,
         less_or_equal_current:
            this.labels.component.onOrBeforeCurrentCondition,
         greater_or_equal_current:
            this.labels.component.onOrAfterCurrentCondition,
         last_days: this.labels.component.onLastDaysCondition,
         next_days: this.labels.component.onNextDaysCondition,
         is_empty: this.labels.component.isEmpty,
         is_not_empty: this.labels.component.isNotEmpty,
      };

      let result = [];

      for (let condKey in dateConditions)
         switch (condKey) {
            case "is_current_date":
            case "less_current":
            case "greater_current":
            case "less_or_equal_current":
            case "greater_or_equal_current":
            case "is_empty":
            case "is_not_empty":
               result.push({
                  id: condKey,
                  value: dateConditions[condKey],
                  batch: "none",
                  handler: (a, b) => this.dateValid(a, condKey, b),
               });
               break;
            case "last_days":
               result.push({
                  id: condKey,
                  value: dateConditions[condKey],
                  batch: "text",
                  handler: (a, b) => this.dateValid(a, condKey, b),
               });
               break;
            default:
               result.push({
                  id: condKey,
                  value: dateConditions[condKey],
                  batch: "datepicker",
                  handler: (a, b) => this.dateValid(a, condKey, b),
               });
               break;
         }
      return result;
   }

   fieldsAddFiltersString(field) {
      let stringConditions = {
         contains: {
            batch: "text",
            label: this.labels.component.containsCondition,
         },
         not_contains: {
            batch: "text",
            label: this.labels.component.notContainsCondition,
         },
         equals: {
            batch: "text",
            label: this.labels.component.isCondition,
         },
         not_equal: {
            batch: "text",
            label: this.labels.component.isNotCondition,
         },
         is_empty: {
            batch: "none",
            label: this.labels.component.isEmpty,
         },
         is_not_empty: {
            batch: "none",
            label: this.labels.component.isNotEmpty,
         },
      };

      let result = [];

      for (let condKey in stringConditions) {
         result.push({
            id: condKey,
            value: stringConditions[condKey].label,
            batch: stringConditions[condKey].batch,
            handler: (a, b) => this.textValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersNumber(field) {
      let numberConditions = {
         equals: this.labels.component.equalCondition,
         not_equal: this.labels.component.notEqualCondition,
         less: this.labels.component.lessThanCondition,
         greater: this.labels.component.moreThanCondition,
         less_or_equal: this.labels.component.lessThanOrEqualCondition,
         greater_or_equal: this.labels.component.moreThanOrEqualCondition,
      };

      let result = [];

      for (let condKey in numberConditions) {
         result.push({
            id: condKey,
            value: numberConditions[condKey],
            batch: "text",
            handler: (a, b) => this.numberValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersList(field) {
      let listConditions = {
         equals: this.labels.component.equalListCondition,
         not_equal: this.labels.component.notEqualListCondition,
      };

      let result = [];

      for (let condKey in listConditions) {
         result.push({
            id: condKey,
            value: listConditions[condKey],
            batch: "list",
            handler: (a, b) => this.listValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersBoolean(field) {
      let booleanConditions = {
         checked: this.labels.component.checkedCondition,
         unchecked: this.labels.component.notCheckedCondition,
      };

      let result = [];

      for (let condKey in booleanConditions) {
         result.push({
            id: condKey,
            value: booleanConditions[condKey],
            batch: "none",
            handler: (a, b) => this.booleanValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersUser(field) {
      let userConditions = {
         is_current_user: {
            batch: "none",
            label: this.labels.component.isCurrentUserCondition,
         },
         is_not_current_user: {
            batch: "none",
            label: this.labels.component.isNotCurrentUserCondition,
         },
         contain_current_user: {
            batch: "none",
            label: this.labels.component.containsCurrentUserCondition,
         },
         not_contain_current_user: {
            batch: "none",
            label: this.labels.component.notContainsCurrentUserCondition,
         },
         equals: {
            batch: "user",
            label: this.labels.component.equalListCondition,
         },
         not_equal: {
            batch: "user",
            label: this.labels.component.notEqualListCondition,
         },
      };

      let result = [];

      for (let condKey in userConditions) {
         result.push({
            id: condKey,
            value: userConditions[condKey].label,
            batch: userConditions[condKey].batch,
            handler: (a, b) => this.userValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersConnectObject(field) {
      const connectConditions = {
         same_as_user: {
            batch: "user",
            label: this.labels.component.sameAsUser,
            handler: (a, b) => this.userValid(a, "same_as_user", b),
         },
         not_same_as_user: {
            batch: "user",
            label: this.labels.component.notSameAsUser,
            handler: (a, b) => this.userValid(a, "not_same_as_user", b),
         },
         in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.inDataCollection,
            handler: (a, b) =>
               this.dataCollectionValid(a, "in_data_collection", b),
         },
         not_in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.notInDataCollection,
            handler: (a, b) =>
               this.dataCollectionValid(a, "not_in_data_collection", b),
         },
         // TODO
         // contains: this.labels.component.containsCondition,
         // not_contains: this.labels.component.notContainCondition,
         // equals: this.labels.component.isCondition,
         // not_equal: this.labels.component.isNotCondition
      };

      const result = [];

      for (let condKey in connectConditions) {
         result.push({
            id: condKey,
            value: connectConditions[condKey].label,
            batch: connectConditions[condKey].batch,
            handler: connectConditions[condKey].handler,
         });
      }

      return result;
   }

   fieldsAddFiltersQuery(field, hasQueryField = false) {
      const queryConditions = hasQueryField
         ? {
              in_query_field: {
                 label: this.labels.component.inQueryField,
                 batch: "queryField",
              },
              not_in_query_field: {
                 label: this.labels.component.notInQueryField,
                 batch: "queryField",
              },
           }
         : {
              in_query: {
                 label: this.labels.component.inQuery,
                 batch: "query",
              },
              not_in_query: {
                 label: this.labels.component.notInQuery,
                 batch: "query",
              },
           };

      const result = [];

      for (const condKey in queryConditions) {
         result.push({
            id: condKey,
            value: queryConditions[condKey].label,
            batch: queryConditions[condKey].batch,
            handler: (a, b) => this.queryFieldValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersThisObject(field) {
      let thisObjectConditions = {
         in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.inDataCollection,
         },
         not_in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.notInDataCollection,
         },
      };

      let result = [];

      for (let condKey in thisObjectConditions) {
         result.push({
            id: condKey,
            value: thisObjectConditions[condKey].label,
            batch: thisObjectConditions[condKey].batch,
            handler: (a, b) => this.thisObjectValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersRecordRule(field) {
      let recordRuleConditions = {
         same_as_field: this.labels.component.sameAsField,
         not_same_as_field: this.labels.component.notSameAsField,
      };

      let result = [];

      for (let condKey in recordRuleConditions) {
         result.push({
            id: condKey,
            value: recordRuleConditions[condKey],
            batch: "recordRule",
            handler: (a, b) => true, // TODO: record rule validation
         });
      }

      return result;
   }

   fieldsAddFiltersContext(field) {
      let contextConditions = {
         context_equals: {
            batch: "context",
            label: this.labels.component.equalsProcessValue,
            handler: (a, b) => a == b,
         },
         context_not_equal: {
            batch: "context",
            label: this.labels.component.notEqualsProcessValueCondition,
            handler: (a, b) => a != b,
         },
         context_in: {
            batch: "context",
            label: this.labels.component.inProcessValueCondition,
            handler: (a, b) => a.indexOf(b) > -1,
         },
         context_not_in: {
            batch: "context",
            label: this.labels.component.notInProcessValueCondition,
            handler: (a, b) => a.indexOf(b) == -1,
         },
      };

      let result = [];

      for (let condKey in contextConditions) {
         result.push({
            id: condKey,
            value: contextConditions[condKey].label,
            batch: contextConditions[condKey].batch,
            handler: contextConditions[condKey].handler,
         });
      }

      return result;
   }

   fieldsAddFiltersCustom(field) {
      const customOptions = this._customOptions ?? {};
      const options = customOptions[field.id || field] ?? {};
      return options.conditions ?? [];
   }

   queriesLoad(queries = []) {
      this._Queries = queries;
   }

   /**
    * @method queries()
    *
    * return an array of all the ABObjectQuery.
    *
    * @param filter {Object}
    *
    * @return {array}
    */
   queries(filter = () => true) {
      const queryList = this._Queries ?? this.AB?.queries?.() ?? [];

      return queryList.filter((q) => filter(q));
   }

   setValue(settings) {
      this.condition = settings || {};

      this.condition.rules = this.condition.rules || [];
   }

   /**
    * @method getValue
    * return the current condition of the filter.
    * @return {JSON} -
    * {
    * 	glue: '', // 'and', 'or'
    *		rules: [
    *			{
    *				key:	'uuid',
    *				rule:	'rule',
    *				value:	'value'
    *			}
    *		]
    * }
    */
   getValue() {
      // When asked for a value before a condition is set, default the
      // unset glue to "and";
      if (typeof this.condition.glue == "undefined") {
         this.condition.glue = "and";
      }
      return this.condition;
   }

   isComplete() {
      let result = true;

      const noValueRules = [
         "is_current_user",
         "is_not_current_user",
         "contain_current_user",
         "not_contain_current_user",
         "same_as_user",
         "not_same_as_user",
         "is_empty",
         "is_not_empty",
         "checked",
         "unchecked",
         "is_current_date",
      ];

      const isCompleteRules = (rules = []) => {
         if (result == false) return;

         rules.forEach((r) => {
            if (r?.rules && Array.isArray(r?.rules)) {
               isCompleteRules(r?.rules);
            } else {
               result =
                  result &&
                  r?.key != null &&
                  r?.key != "" &&
                  r?.rule != null &&
                  r?.rule != "" &&
                  ((r?.value != null && r?.value != "") ||
                     noValueRules.indexOf(r?.rule) > -1);
            }
         });
      };

      isCompleteRules(this.condition?.rules);

      return result;
   }
}


/***/ }),

/***/ 51509:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/core/RowFilterCore.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RowFilterCore)
/* harmony export */ });
/* harmony import */ var _platform_ABComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABComponent */ 64971);


/**
 *  support get data from objects and queries
 */
function getFieldVal(rowData, field, returnSingular = true) {
   if (!field) return null;
   if (!field.columnName) return null;
   // if rowData is an array, then pull the first element to get value
   if (rowData && rowData[0]) rowData = rowData[0];

   let columnId = field.id;
   let columnName = field.columnName;

   let value = null;
   if (columnName.indexOf(".") > -1) {
      let colName = columnName.split(".")[1];
      value = rowData[columnName] || rowData[colName] || rowData[columnId];
   } else {
      value = rowData[columnName] || rowData[columnId];
   }

   if (value) {
      return value;
   }

   // otherwise, this might be a process check where the rowData keys have
   // '[diagramID].[field.id]'
   for (var k in rowData) {
      var key = k.split(".")[1];
      if (key && (key == columnId || key == columnName)) {
         value = rowData[k];
      }
   }

   // if value is an array, filter empty item
   if (value && Array.isArray(value)) {
      value = value.filter((v) => v != null);
      if (returnSingular) value = value[0];
   }

   return value;
}

class RowFilterCore extends _platform_ABComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(App, idBase, AB) {
      idBase = idBase || "ab_row_filter";

      super(App, idBase, AB);

      this.Account = { username: "??" };
      this._settings = {};
      this.config_settings = {};
      // var batchName; // we need to revert to this default when switching away from a in/by query field

      this._QueryFields = [];
      this._Fields;

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onChange: () => {},
         },

         /**
          * @method getValue
          *
          * @return {JSON} -
          * {
          * 		glue: '', // 'and', 'or'
          *		rules: [
          *			{
          *				key:	'column name',
          *				rule:	'rule',
          *				value:	'value'
          *			}
          *		]
          * }
          */
         getValue: () => {
            return this.config_settings;
         },

         removeHtmlTags: function (text) {
            let result = "";
            try {
               let div = document.createElement("div");
               div.innerHTML = text;

               result = div.textContent || div.innerText || "";
            } catch (err) {
               result = (text || "").replace(/(<([^>]+)>)/gi, "");
            }

            return result;
         },

         textValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (value == null) value = "";

            value = value.toString().trim().toLowerCase();
            value = _logic.removeHtmlTags(value); // remove html tags - rich text editor

            compareValue = compareValue
               .toString()
               .trim()
               .toLowerCase()
               .replace(/  +/g, " ");

            // support "john smith" => "john" OR/AND "smith"
            var compareArray = compareValue.split(" ");

            switch (rule) {
               case "contains":
                  compareArray.forEach((val) => {
                     if (result == false)
                        // OR
                        result = value.indexOf(val) > -1;
                  });
                  break;
               case "not_contains":
                  result = true;
                  compareArray.forEach((val) => {
                     if (result == true)
                        // AND
                        result = value.indexOf(val) < 0;
                  });
                  break;
               case "equals":
                  compareArray.forEach((val) => {
                     if (result == false)
                        // OR
                        result = value == val;
                  });
                  break;
               case "not_equal":
                  result = true;
                  compareArray.forEach((val) => {
                     if (result == true)
                        // AND
                        result = value != val;
                  });
                  break;
               case "is_empty":
                  result = value == null || value == "";
                  break;
               case "is_not_empty":
                  result = value != null && value != "";
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         dateValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (!(value instanceof Date)) value = new Date(value);

            if (!(compareValue instanceof Date))
               compareValue = new Date(compareValue);

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               case "less":
                  result = value < compareValue;
                  break;
               case "greater":
                  result = value > compareValue;
                  break;
               case "less_or_equal":
                  result = value <= compareValue;
                  break;
               case "greater_or_equal":
                  result = value >= compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         numberValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            value = Number(value);
            compareValue = Number(compareValue);

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               case "less":
                  result = value < compareValue;
                  break;
               case "greater":
                  result = value > compareValue;
                  break;
               case "less_or_equal":
                  result = value <= compareValue;
                  break;
               case "greater_or_equal":
                  result = value >= compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         listValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (value && value.toLowerCase) value = value.toLowerCase();

            compareValue = compareValue.toLowerCase();

            if (!Array.isArray(compareValue)) compareValue = [compareValue];

            switch (rule) {
               case "equals":
                  if (value) result = compareValue.indexOf(value) > -1;
                  break;
               case "not_equal":
                  if (value) result = compareValue.indexOf(value) < 0;
                  else result = true;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         booleanValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);

            // default value should be false
            if (value == null) value = false;

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         userValid: (rowData, field, rule, compareValue) => {
            var result = false;

            var value = getFieldVal(rowData, field);

            // if (Array.isArray(value)) value = [value];

            switch (rule) {
               case "is_current_user":
                  result = value == this.Account.username;
                  break;
               case "is_not_current_user":
                  result = value != this.Account.username;
                  break;
               case "contain_current_user":
                  if (!value) {
                     result = false;
                     break;
                  }
                  if (!Array.isArray(value)) value = [value];

                  result =
                     (value || []).filter((v) => {
                        if (v) {
                           return (
                              (v.username || v.id || v.text || v) ==
                              this.Account.username
                           );
                        } else {
                           return false;
                        }
                     }).length > 0;
                  break;
               case "not_contain_current_user":
                  if (!value) {
                     result = false;
                     break;
                  }
                  if (!Array.isArray(value)) value = [value];

                  result =
                     (value || []).filter((v) => {
                        if (v) {
                           return (
                              (v.username || v.id || v.text || v) ==
                              this.Account.username
                           );
                        } else {
                           return false;
                        }
                     }).length == 0;
                  break;
               case "equals":
                  result = value.indexOf(compareValue) > -1;
                  break;
               case "not_equal":
                  result = value.indexOf(compareValue) < 0;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         queryValid: (rowData, rule, compareValue) => {
            var result = false;

            if (!this.AB || !compareValue) return result;

            // queryId:fieldId
            var queryId = compareValue.split(":")[0],
               fieldId = compareValue.split(":")[1];

            // if no query
            var query = this.queries((q) => q.id == queryId)[0];
            if (!query) return result;

            // if no field
            var field = query.fields((f) => f.id == fieldId)[0];
            if (!field) return result;

            let qIdBase = "{idBase}-query-field-{id}"
                  .replace("{idBase}", idBase)
                  .replace("{id}", query.id),
               inQueryFieldFilter = new this.constructor(this.App, qIdBase);
            inQueryFieldFilter.Account = this.Account;
            // inQueryFieldFilter.applicationLoad(this._Application);
            inQueryFieldFilter.fieldsLoad(query.fields());
            inQueryFieldFilter.setValue(query.workspaceFilterConditions);

            switch (rule) {
               case "in_query_field":
                  result = inQueryFieldFilter.isValid(rowData);
                  break;
               case "not_in_query_field":
                  result = !inQueryFieldFilter.isValid(rowData);
                  break;
            }

            return result;
         },

         inQueryValid: (rowData, columnName, rule, compareValue) => {
            let result = false;

            if (columnName) {
               rowData = rowData[columnName] || {};
            }

            if (!compareValue || !this.AB) return result;

            // if no query
            let query = this.queries((q) => q.id == compareValue)[0];
            if (!query) return result;

            let qIdBase = "{idBase}-query-{id}"
                  .replace("{idBase}", idBase)
                  .replace("{id}", query.id),
               inQueryFilter = new this.constructor(this.App, qIdBase);
            inQueryFilter.Account = this.Account;
            // inQueryFilter.applicationLoad(this._Application);
            inQueryFilter.fieldsLoad(query.fields());
            inQueryFilter.setValue(query.workspaceFilterConditions);

            switch (rule) {
               case "in_query":
                  result = inQueryFilter.isValid(rowData);
                  break;
               case "not_in_query":
                  result = !inQueryFilter.isValid(rowData);
                  break;
            }

            return result;
         },

         dataCollectionValid: (rowData, columnName, rule, compareValue) => {
            var result = false;

            if (!compareValue || !this.AB) return result;

            if (columnName) {
               rowData = rowData[columnName] || {};
            }

            let dc = this.AB.datacollectionByID(compareValue);

            switch (rule) {
               case "in_data_collection":
                  if (!dc) return false;

                  result =
                     dc.getData(
                        (d) => (d.id || d.uuid) == (rowData.id || rowData.uuid)
                     ).length > 0;
                  break;
               case "not_in_data_collection":
                  if (!dc) return true;

                  result =
                     dc.getData(
                        (d) => (d.id || d.uuid) == (rowData.id || rowData.uuid)
                     ).length < 1;
                  break;
            }

            return result;
         },

         connectFieldValid: function (rowData, field, rule, compareValue) {
            let relationName = field.relationName();

            let connectedVal = "";

            if (rowData) {
               if (rowData[relationName]) {
                  connectedVal = (
                     (field.indexField
                        ? rowData[relationName][field.indexField.columnName]
                        : false) || // custom index
                     (field.indexField2
                        ? rowData[relationName][field.indexField2.columnName]
                        : false) || // custom index 2
                     rowData[relationName].id ||
                     rowData[relationName]
                  )
                     .toString()
                     .toLowerCase();
               } else {
                  let fieldVal = getFieldVal(rowData, field);
                  if (fieldVal != null) {
                     connectedVal = fieldVal;

                     // an Object to a String
                     if (typeof connectedVal == "object") {
                        connectedVal =
                           field.datasourceLink.displayData(connectedVal);
                     }
                  }
               }
            }

            let compareValueLowercase = (compareValue || "").toLowerCase();

            switch (rule) {
               case "contains":
                  return (
                     connectedVal.toString().indexOf(compareValueLowercase) > -1
                  );
               case "not_contains":
                  return (
                     connectedVal.toString().indexOf(compareValueLowercase) ==
                     -1
                  );
               case "equals":
                  return connectedVal == compareValueLowercase;
               case "not_equal":
                  return connectedVal != compareValueLowercase;
               case "in_query":
               case "not_in_query":
                  return _logic.inQueryValid(
                     rowData,
                     relationName,
                     rule,
                     compareValue
                  );
               case "is_current_user":
               case "is_not_current_user":
               case "contain_current_user":
               case "not_contain_current_user":
                  return _logic.userValid(rowData, field, rule, compareValue);
               case "is_empty":
                  return (
                     rowData[relationName] == null ||
                     rowData[relationName].length < 1 ||
                     rowData[relationName] == ""
                  );
               case "is_not_empty":
                  return (
                     rowData[relationName] != null &&
                     ((Array.isArray(rowData[relationName]) &&
                        rowData[relationName].length > 0) ||
                        rowData[relationName] != "")
                  );
               case "in_data_collection":
               case "not_in_data_collection":
                  return _logic.dataCollectionValid(
                     rowData,
                     relationName,
                     rule,
                     compareValue
                  );
            }
         },

         thisObjectValid: (rowData, rule, compareValue) => {
            let result = false;

            switch (rule) {
               // if in_query condition
               case "in_query":
               case "not_in_query":
                  if (!this.AB || !this._Object) return result;

                  // if > 1 copy of this object in query ==> Error!
                  var query = this.queries((q) => q.id == compareValue)[0];
                  if (!query) return result;

                  var listThisObjects = query.objects((o) => {
                     return o.id == this._Object.id;
                  });
                  if (listThisObjects.length > 1) {
                     // Alternative: choose the 1st instance of this object in the query, and make the compare on that.
                     // Be sure to warn the developer of the limitiations of an "this_object" "in_query"  when query has > 1 copy of
                     // this object as part of the query.

                     console.error(
                        "HEY!  Can't compare this_object to a query that has > 1 copy of that object!"
                     );
                     return true;
                  }

                  // get this object's alias from the query
                  var alias = query.objectAlias(this._Object.id);

                  // make sure all my columns in rowData are prefixed by "alias".columnName
                  var newRowData = {};
                  Object.keys(rowData).forEach((key) => {
                     newRowData[`${alias}.${key}`] = rowData[key];
                  });

                  // then pass this on to the _logic.queryValid();
                  return _logic.inQueryValid(
                     newRowData,
                     null,
                     rule,
                     compareValue
                  );
               // break; /* eslint no-unreachable */

               // if in_datacollection condition
               case "in_data_collection":
               case "not_in_data_collection":
                  // send rowData, null to datacollectionValid()
                  return _logic.dataCollectionValid(
                     rowData,
                     null,
                     rule,
                     compareValue
                  );
               // break; /* eslint no-unreachable */
            }
         },
      });

      // Interface methods for parent component:
      // this.objectLoad = _logic.objectLoad;
      // this.viewLoad = _logic.viewLoad;
      this.getValue = _logic.getValue;
      // this.setValue = _logic.setValue;
      // this.isValid = _logic.isValid;
   }

   init(options) {
      if (options.showObjectName) {
         this._settings.showObjectName = options.showObjectName;
      }
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    */
   isValid(rowData) {
      var config_settings = this.config_settings;
      var _logic = this._logic;

      // If no conditions, then return true
      if (
         config_settings == null ||
         config_settings.rules == null ||
         config_settings.rules.length == 0
      )
         return true;

      if (rowData == null) return false;

      var result = config_settings.glue === "and" ? true : false;

      config_settings.rules.forEach((filter) => {
         if (!filter?.key || !filter?.rule) return;

         var fieldInfo = this._Fields.filter((f) => f.id == filter.key)[0];
         if (!fieldInfo) return;

         var condResult;

         // Filters that have "this_object" don't have a fieldInfo.key, so in that case,
         // define a special .key == "this_object"
         var ruleFieldType = fieldInfo.key;
         if (typeof fieldInfo.key == "undefined") {
            if (fieldInfo.id != "this_object") {
               fieldInfo.key = "connectField"; // if you are looking at the parent object it won't have a key to analyze
               ruleFieldType = fieldInfo.key;
            } else ruleFieldType = "this_object";
         }

         switch (ruleFieldType) {
            case "string":
            case "LongText":
            case "email":
               condResult = _logic.textValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "date":
            case "datetime":
               condResult = _logic.dateValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "number":
            case "formula":
               condResult = _logic.numberValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "list":
               condResult = _logic.listValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "boolean":
               condResult = _logic.booleanValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "user":
               condResult = _logic.userValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "connectField":
            case "connectObject":
               condResult = _logic.connectFieldValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "this_object":
               condResult = _logic.thisObjectValid(
                  rowData,
                  filter.rule,
                  filter.value
               );
               break;
         }

         if (config_settings.glue === "and") {
            result = result && condResult;
         } else {
            result = result || condResult;
         }
      });

      return result;
   }

   /**
    * @method applicationLoad
    * set application
    *
    * @param application {ABApplication}
    */
   // applicationLoad(application) {
   //    this._Application = application;
   // }

   /**
    * @method fieldsLoad
    * set fields
    *
    * @param {array} fields
    *        an array of fields used in this Query
    * @param {ABObject} object [optional]
    *        (optional) ABObject reference if this Filter should support
    *        the "this object" conditions.
    */
   fieldsLoad(fields = [], object = null) {
      this._Fields = fields.filter((f) => f?.fieldIsFilterable?.());
      // NOTE: User fields are now Connections, but we want to treat them
      // differently.
      this._QueryFields = this._Fields
         ? this._Fields.filter((f) => f && f.isConnection && f.key != "user")
         : [];

      // insert our 'this object' entry if an Object was given.
      if (object) {
         this._Object = object;

         let thisObjOption = {
            id: "this_object",
            label: object.label,
         };

         // If object is query ,then should define default alias: "BASE_OBJECT"
         if (object.viewName) {
            thisObjOption.alias = "BASE_OBJECT";
         }

         this._Fields.unshift(thisObjOption);
      } else {
         delete this._Object;
      }
   }

   queriesLoad(queries = []) {
      this._Queries = queries;
   }

   /**
    * @method queries()
    * return an array of all the ABObjectQuery.
    * @param {fn} filter
    * @return {array}
    */
   queries(filter = () => true) {
      let result = [];

      if (this.AB) {
         result = result.concat(this.AB.queries(filter));
      }

      if (this._Queries) {
         result = result.concat(
            (this._Queries || []).filter(
               (q) => filter(q) && result.filter((r) => r.id == q.id).length < 1
            )
         );
      }

      return result;
   }

   setValue(settings) {
      this.config_settings = settings || {};
      this.config_settings.rules = this.config_settings.rules || [];
   }
}


/***/ }),

/***/ 97177:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldAutoIndexCore.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldAutoIndexCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldAutoIndex
 *
 * An ABFieldAutoIndex defines a AutoIndex field type.
 *
 */



const ABFieldAutoIndexDefaults = {
   key: "AutoIndex",
   // unique key to reference this specific DataField

   description: "Auto Increment Value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "key",
   // font-awesome icon reference.  (without the 'fa-').  so 'key'  to
   // reference 'fa-key'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Auto Index",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["tinyint", "smallint", "mediumint", "int", "integer"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   prefix: "",
   delimiter: "none",
   displayLength: 4,
   previewText: "0000",
};

class ABFieldAutoIndexCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldAutoIndexDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldAutoIndexDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   static getDelimiterSign(text) {
      const delimiterItem = this.delimiterList().filter((item) => {
         return item.id == text;
      })[0];

      return delimiterItem ? delimiterItem.sign : "";
   }

   static delimiterList() {
      let L = this.AB.Label();
      return [
         { id: "none", value: L("None"), sign: "" },
         { id: "comma", value: L("Comma"), sign: ", " },
         { id: "slash", value: L("Slash"), sign: "/" },
         { id: "space", value: L("Space"), sign: " " },
         { id: "dash", value: L("Dash"), sign: "-" },
         { id: "colon", value: L("Colon"), sign: ":" },
      ];
   }

   static setValueToIndex(prefix, delimiter, displayLength, displayNumber) {
      const resultIndex =
         prefix +
         this.getDelimiterSign(delimiter) +
         ("0000000000" + displayNumber).slice(-parseInt(displayLength));

      return resultIndex;
   }

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.displayLength = parseInt(this.settings.displayLength);
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // Remove every values, then we will use AUTO_INCREMENT of MySQL
      delete values[this.columnName];
   }

   format(rowData) {
      if (!rowData?.[this.columnName]) return "";

      try {
         const resultAutoIndex = this.constructor.setValueToIndex(
            this.settings.prefix,
            this.settings.delimiter,
            this.settings.displayLength,
            rowData[this.columnName]
         );

         return resultAutoIndex;
      } catch (err) {
         return "";
      }
   }
}


/***/ }),

/***/ 96108:
/*!*****************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldBooleanCore.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldBooleanCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldBoolean
 *
 * An ABFieldBoolean defines a boolean field type.
 *
 */



const ABFieldBooleanDefaults = {
   key: "boolean",
   // unique key to reference this specific DataField

   description: "A single checkbox that can be checked or unchecked.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "check-square-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'check-square-o'  to
   // reference 'fa-check-square-o'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Checkbox",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["boolean"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["bool", "boolean"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   default: 0,
};

class ABFieldBooleanCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldBooleanDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldBooleanDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      if (this.settings.default != null)
         this.settings.default = parseInt(this.settings.default);
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] == null && this.settings.default != null) {
         values[this.columnName] = this.settings.default;
      }
   }
}


/***/ }),

/***/ 69813:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldCalculateCore.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldCalculateCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldCalculate
 *
 * An ABFieldCalculate defines a calculate field type.
 *
 */



/** Private methods */
function AGE(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   const today = new Date();
   const oneYear = 31536000000; // (24 * 60 * 60 * 1000) * 365;
   const diffYears = (today - dataDate) / oneYear;

   if (diffYears < 1) return Math.round(diffYears * 10) / 10;
   // float 2 digits
   else return Math.floor(diffYears); // no float digit

   // const today = new Date();
   // const age = today.getFullYear() - dataDate.getFullYear();
   // if (age < 1) {
   // 	const m = today.getMonth() - dataDate.getMonth();

   // 	age = parseFloat("0." + m);

   // 	// if (m < 0 || (m === 0 && today.getDate() < dataDate.getDate())) {
   // 	// 	age--;
   // 	// }
   // }
   // return age;
}

function YEAR(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   return dataDate.getFullYear();
}

function MONTH(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // Start at 0
   return dataDate.getMonth();
}

function DAY(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   return dataDate.getDate();
}

function DATE(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // number of miliseconds in one day
   const oneDay = 86400000; // 1000 * 60 * 60 * 24

   // Convert back to days and return
   return Math.round(dataDate.getTime() / oneDay);
}

function HOUR(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // number of miliseconds in one hour
   const oneHour = 3600000; // 1000 * 60 * 60

   // Convert back to days and return
   return Math.round(dataDate.getTime() / oneHour);
}

function MINUTE(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // number of miliseconds in one hour
   const oneMinute = 60000; // 1000 * 60

   // Convert back to days and return
   return Math.round(dataDate.getTime() / oneMinute);
}

function MINUTE_TO_HOUR(mins) {
   const hours = mins / 60;
   const rhours = Math.floor(hours);
   const minutes = (hours - rhours) * 60;
   const rminutes = Math.round(minutes);

   return parseFloat(`${rhours}.${rminutes}`);
}

const ABFieldCalculateDefaults = {
   key: "calculate",
   // unique key to reference this specific DataField

   description: "Perform a calculation based upon existing values",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "calculator",
   // font-awesome icon reference.  (without the 'fa-').  so 'calculator'  to
   // reference 'fa-calculator'

   isFilterable: (field) => {
      const unsupportedInFilter = ["MINUTE_TO_HOUR", "DATE", "HOUR", "MINUTE"];
      const unsupported = unsupportedInFilter.filter((item) =>
         field.settings.formula.includes(item)
      );
      return unsupported.length == 0;
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Calculate",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "integer",
      "bigint",
      "decimal",
      "dec",
      "numeric",
      "fixed",
      "float",
      "real",
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   formula: "",
   decimalSign: "none", // "none", "comma", "period", "space"
   decimalPlaces: 0, // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
};

class ABFieldCalculateCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldCalculateDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldCalculateDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   /**
    * @method convertToJs
    *
    * @param {ABOBject} object
    * @param {string} formula
    * @param {object} rowData
    * @param {integer} place
    * @param {string} alias [Optional]
    */
   static convertToJs(
      object,
      formula,
      rowData,
      place,
      alias = null,
      recalculate = false
   ) {
      if (!formula) return "";

      // replace with current date
      formula = formula.replace(/\(CURRENT\)/g, "(new Date())");

      object.fields().forEach((f) => {
         let colName = f.columnName;
         if (colName.indexOf(".") > -1)
            // QUERY: get only column name
            colName = colName.split(".")[1];

         // if template does not contain, then should skip
         if (formula.indexOf("{" + colName + "}") < 0) return;

         const data =
            rowData[`${object.alias ?? alias}.${f.columnName}`] ??
            rowData[f.columnName];

         // number fields
         if (f.key == "number") {
            const numberVal = `(${data || 0})`; // (number) - NOTE : (-5) to support negative number
            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               numberVal
            );
         }
         // calculate and formula fields
         else if (f.key == "calculate" || f.key == "formula") {
            let calVal = f.format(rowData, recalculate) || 0;

            // pull number only
            if (typeof calVal == "string")
               calVal = calVal.replace(/[^-0-9.]/g, "");

            calVal = `(${calVal})`;

            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               calVal
            );
         }
         // date fields
         else if (f.key == "date" || f.key == "datetime") {
            const dateVal = `"${data || ""}"`; // "date"
            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               dateVal
            );
         }
         // boolean fields
         else if (f.key == "boolean") {
            const booleanVal = `(${data || 0})`; // show 1 or 0 for boolean
            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               booleanVal
            );
         }
      });

      // decimal places - toFixed()
      // FIX: floating number calculation
      // https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
      return eval(formula).toFixed(place || 0);
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // this field is read only
      delete values[this.columnName];
   }

   format(rowData, recalculate = false) {
      let place = 0;
      if (this.settings.decimalSign != "none") {
         place = this.settings.decimalPlaces;
      }

      try {
         let result = this.constructor.convertToJs(
            this.object,
            this.settings.formula,
            rowData,
            place,
            this.alias,
            recalculate
         );

         if (typeof result == "string")
            result = result.replace(/[^-0-9.]/g, "");

         switch (this.settings.decimalSign) {
            case "comma":
               result = result.replace(".", ",");
               break;
            case "space":
               result = result.replace(".", " ");
               break;
         }

         return result;
      } catch (err) {
         return "";
      }
   }
}


/***/ }),

/***/ 84898:
/*!*****************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldCombineCore.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldCombineCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldCombine
 *
 * An ABFieldCombine defines a combined field type.
 *
 */



const ABFieldCombinedDefaults = {
   key: "combined",
   // unique key to reference this specific DataField

   description: "Combined Value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "key",
   // font-awesome icon reference.  (without the 'fa-').  so 'key'  to
   // reference 'fa-key'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Combined Field",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   combinedFields: "",
   // {string} "field's uuid1, field's uuid2, field's uuid3, ..."
   // This tells us what fields will be combined.
   // if we don't have this, the old value which we filled out won't be cleared when we do "Add field" this type again.

   delimiter: "plus", // plus, space, dash, period
};

class ABFieldCombineCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldCombinedDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldCombinedDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   fromValues(values) {
      super.fromValues(values);

      this.settings.delimiter =
         values.settings.delimiter || defaultValues.delimiter;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // Remove every values, then we will use AUTO_INCREMENT of MySQL
      delete values[this.columnName];
   }

   /**
    * @method getCombinedFields
    * Retrieve the fields used to combine and generate a specific value
    *
    * @return {Array}
    */
   getCombinedFields() {
      const result = [];

      (this.settings?.combinedFields ?? "").split(",").forEach((fieldId) => {
         const fld = this.object.fields((f) => f.id == fieldId)[0];
         if (!fld) return;

         result.push(fld);
      });

      return result;
   }

   /**
    * @method format
    * Convert the value of a connected field (without a custom index) to display the label of the linked object
    *
    * @param {Object} rowData
    * @returns {String}
    */
   format(rowData) {
      let val = rowData[this.columnName] ?? "";

      this.getCombinedFields().forEach((f, index) => {
         if (
            f.key != "connectObject" ||
            f.settings.indexField ||
            f.settings.indexField2
         )
            return;

         let connectVal = rowData[f.relationName()];
         if (!connectVal) return;

         if (!Array.isArray(connectVal)) connectVal = [connectVal];

         const connectLabel = connectVal
            .map((item) => item.text ?? f.datasourceLink.displayData(item))
            .join("|");

         val = val.replace(rowData[f.columnName], connectLabel);
      });

      return val;
   }
}


/***/ }),

/***/ 65129:
/*!*****************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldConnectCore.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldConnectCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldConnect
 *
 * An ABFieldConnect defines a connect to other object field type.
 *
 */



const ABFieldConnectDefaults = {
   key: "connectObject",
   // unique key to reference this specific DataField

   description: "Connect two data objects together",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "external-link",
   // font-awesome icon reference.  (without the 'fa-').  so 'external-link'  to
   // reference 'fa-external-link'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: (field) => {
      const linkType = `${field?.settings?.linkType}:${field?.settings?.linkViaType}`;
      return ["one:many", "one:one"].indexOf(linkType) > -1;
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Connect to another record",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   linkObject: "", // ABObject.id
   // the .id of the ABObject we are connected to

   linkType: "one", // [one, many]
   // 'one' : this object can have only 1 of our linkObject
   // 'many': this object can have MANY of our linkObject

   linkViaType: "many", // [one, many]
   // 'one' : the linkedObject can only have 1 of me
   // 'many' : the linkedObject can have many of me

   linkColumn: "", // ABField.id
   // the .id of the field in the linkedObject that is our
   // connected field.

   isSource: null, // bit : 1,0
   // isSource indicates that this object is the source of the connection:
   // if linkType==one, and isSource=1, then the value in this object's field
   // 		is the connected object's id
   // if linkType == one, and isSource = 0, then the linkObject has this obj.id
   //  	in it's connected field (linkColumn)

   // the next 3 Fields are concerning how we connect to other ABObjects when
   // we are NOT using the .uuid as the connecting Value. Instead, there is an
   // ABIndex setting we are connecting with.
   isCustomFK: 0,
   // {bool} truthy [0,1, etc...]
   // indicates that this connection is using 1 or more custom foreign keys
   // for the data it is storing in it's relationship.

   indexField: "", // ABField.id
   // {string} {ABField.id}
   // In a Connection defined between A --> B, this field represents the ABField
   // that is used for the data being stored.
   // In 1:1,  1:M  or M:1  relationships, .indexField always refers to the
   //       field we are pulling the Data FROM.
   // In M:N relationships:  this will refer to the A.Field.id that is a custom
   //       key (if any).

   indexField2: "", // ABField.id
   // {string}  {ABField.id}
   // In the M:N relationship: this field refers to the B.Field.id that is a
   //       custom Key for the data we are storing.
};

class ABFieldConnectCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object, fieldDefaults = ABFieldConnectDefaults) {
      super(values, object, fieldDefaults);

      this.isConnection = true;
      // {bool}
      // is this an ABFieldConnect type of field.
      // this is a simplified helper to identify if an ABField is a type
      // of connect field.  Since this is the only place it is defined,
      // all other field types will be falsy

      // // text to Int:
      // this.settings.isSource = parseInt(this.settings.isSource || 0);
      // this.settings.isCustomFK = parseInt(this.settings.isCustomFK || 0);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldConnectDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.isSource = parseInt(this.settings.isSource || 0);
      this.settings.isCustomFK = parseInt(this.settings.isCustomFK || 0);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(/* values */) {}

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }

   relationName() {
      // there is object name - {objectName}.{columnName}
      if (this.columnName.indexOf(".") > -1) {
         const names = this.columnName.split(".");
         return `${names[0]}.${this.AB.rules.toFieldRelationFormat(names[1])}`;
      } else {
         return this.AB.rules.toFieldRelationFormat(this.columnName);
      }
   }

   /**
    * @method datasourceLink
    * return the ABObject that this field connection links to
    * @return {ABObject}
    */
   get datasourceLink() {
      const linkObj = this.AB.objectByID(this.settings.linkObject);
      if (!linkObj) {
         const configError = new Error(
            `ConnectField[${this.label}][${this.id}] unable to find linkObject[${this.settings.linkObject}]`
         );
         this.AB.notify.builder(configError, {
            field: this,
            linkObject: this.settings.linkObject,
         });
      }
      return linkObj;
   }

   /**
    * @method fieldLink
    * return the ABField that we are linked to.
    * @return {ABDataField}  or undefined if not found.
    */
   get fieldLink() {
      const objectLink = this.datasourceLink;
      if (!objectLink) return null; // note: already Notified

      const linkColumn = objectLink.fieldByID(this.settings.linkColumn);
      if (!linkColumn) {
         const configError = new Error(
            `ConnectField[${this.label}][${this.id}] unable to find linkColumn[${this.settings.linkColumn}]`
         );
         this.AB.notify.builder(configError, {
            field: this,
            linkColumn: this.settings.linkColumn,
         });
      }
      return linkColumn;
   }

   /**
    * @method pullRelationValues
    * Return the data values for this field entry in the provided data row.
    * @param {*} row
    * @return {array}
    */
   pullRelationValues(row) {
      let selectedData;

      // Get linked object
      const linkedObject = this.datasourceLink;

      let data = this.dataValue(row);
      if (data && linkedObject) {
         // convert to JSON
         if (typeof data == "string") {
            try {
               data = JSON.parse(data);
            } catch (e) {
               // must be a UUID
               // so just set that to selectedData:
               selectedData = data;
            }
         }

         selectedData = data;
      }

      return selectedData;
   }

   dataValue(rowData) {
      if (rowData == null) return "";

      const propName = `${this.object.name}.${this.relationName()}`;

      return (
         rowData[this.relationName()] ||
         rowData[propName] ||
         rowData[this.columnName] ||
         ""
      );
   }

   format(rowData) {
      const val = this.pullRelationValues(rowData);
      const linkedObject = this.datasourceLink;

      // array
      if (Array.isArray(val))
         return val
            .map((v) => {
               if (v.text == null) return linkedObject.displayData(v) || "";
               else return v.text || "";
            })
            .join(", ");
      // string
      else if (val) {
         if (val.text == null) return linkedObject.displayData(val) || "";
         else if (val.text) return val.text || "";
      }
      // empty string
      else return "";
   }

   /**
    * @method LinkString()
    * A string representation of the type of link this represents.
    * "one:many", "many:one", "one:one", etc...
    * @return {string}
    */
   get LinkString() {
      return `${this.settings.linkType}:${this.settings.linkViaType}`;
   }

   /**
    * @method linkType
    * return the type of connection we have to our connected object
    * @return {string}
    */
   linkType() {
      return this.settings.linkType;
   }

   /**
    * @method linkType
    * return the type of connection we have to our connected object
    * @return {string}
    */
   linkViaType() {
      return this.settings.linkViaType;
   }

   /**
    * @method isSource
    * does this object contain the .id of the remote object (in case of linkType : one )
    * @return {bool}
    */
   isSource() {
      return this.settings.isSource;
   }

   /**
    * @property indexField
    * @return {ABField}
    */
   get indexField() {
      if (!this.settings.isCustomFK || !this.settings.indexField) {
         return null;
      }
      const linkType = this.LinkString; // `${this.settings.linkType}:${this.settings.linkViaType}`;
      // 1:M
      if (linkType === "one:many") {
         return this.datasourceLink.fieldByID(this.settings.indexField);
      }
      // 1:1
      else if (linkType === "one:one") {
         if (this.settings.isSource) {
            return this.datasourceLink.fieldByID(this.settings.indexField);
         } else {
            return this.object.fieldByID(this.settings.indexField);
         }
      }
      // M:1
      else if (linkType === "many:one") {
         return this.object.fieldByID(this.settings.indexField);
      }
      // M:N
      else if (linkType === "many:many") {
         let indexField = this.object.fieldByID(this.settings.indexField);

         if (indexField == null)
            indexField = this.datasourceLink.fieldByID(
               this.settings.indexField
            );

         return indexField;
      }

      return null;
   }

   /**
    * @property indexField2
    * @return {ABField}
    */
   get indexField2() {
      if (!this.settings.isCustomFK || !this.settings.indexField2) {
         return null;
      }

      let indexField;

      // M:N only
      if (
         this.settings.linkType == "many" &&
         this.settings.linkViaType == "many"
      ) {
         indexField = this.object.fieldByID(this.settings.indexField2);

         if (indexField == null)
            indexField = this.datasourceLink.fieldByID(
               this.settings.indexField2
            );
      }

      return indexField;
   }

   /**
    * @method getRelationValue
    * pull values for update connect data
    * @param {Object} rowData
    * @param {Object} options - {
    *                               forUpdate: boolean
    *                           }
    * @return {Object}
    */
   getRelationValue(rowData, options = {}) {
      if (rowData == null) return;
      let colName;
      const indexField = this.indexField;
      const datasourceLink = this.datasourceLink;

      const linkType = this.LinkString; // `${this.settings.linkType}:${this.settings.linkViaType}`;

      // custom index
      // M:N
      if (linkType === "many:many") {
         const indexField2 = this.indexField2;

         if (indexField && indexField.object.id == datasourceLink.id) {
            colName = indexField.columnName;
         } else if (indexField2 && indexField2.object.id == datasourceLink.id) {
            colName = indexField2.columnName;
         }
      }
      // 1:M, 1:1 isSource = true
      else if (
         indexField &&
         (linkType === "one:many" ||
            (linkType === "one:one" && this.settings.isSource))
      ) {
         colName = indexField.columnName;
      }
      // M:1
      else if (linkType === "many:one") {
         // NOTE: M:1 has special case
         // it uses different value for search and update.
         // UPDATE uses row id
         // SEARCH uses custom index value
         if (options.forUpdate) {
            colName = datasourceLink.PK();
         } else {
            colName = indexField ? indexField.columnName : datasourceLink.PK();
         }
      }
      // NO CUSTOM INDEX
      else if (datasourceLink) {
         colName = datasourceLink.PK();
      }

      let result =
         rowData[colName] ||
         rowData[this.object?.PK()] ||
         rowData.id ||
         rowData;

      if (colName == "id") {
         result = parseInt(result);
      }

      return result;
   }
}


/***/ }),

/***/ 81314:
/*!**********************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldCore.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ABMLClass */ 46148);
/*
 * ABFieldCore
 *
 * ABFieldBase defines the common ABField structure that is shared between
 * the client and the server.  Mostly how it manages it's internal data, and
 * how it is related to the ABObject classes.
 *
 */
// const ABEmitter = require("../../platform/ABEmitter");


class ABFieldCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object, fieldDefaults) {
      super(["label"], object.AB);

      // NOTE: setup this first so later we can use .fieldType(), .fieldIcon()
      this.defaults = fieldDefaults || {};

      /*
  		{
  			id:'uuid',					// uuid value for this obj
  			key:'fieldKey',				// unique key for this Field
  			icon:'font',				// fa-[icon] reference for an icon for this Field Type
  			label:'',					// pulled from translation
			columnName:'column_name',	// a valid mysql table.column name
			isImported: 1/0,			// flag to mark is import from other object
			settings: {					// unique settings for the type of field
				showIcon:true/false,	// only useful in Object Workspace DataTable
				isImported: 1/0,		// flag to mark is import from other object
				required: 1/0,			// field allows does not allow NULL or it does allow NULL
				width: {int}			// width of display column

				// specific for dataField
			},
			translations:[]
  		}
  		*/

      this.object = object;

      this.fromValues(values);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///
   static get reservedNames() {
      return [
         "id",
         "created_at",
         "updated_at",
         "properties",
         "createdAt",
         "updatedAt",
      ];
   }

   static defaultValues() {
      return {};
   }

   // unique key to reference this specific DataField
   fieldKey() {
      return this.defaults.key;
   }

   /**
    * Sails ORM data types that can be imported to this DataField
    * @return {Array}
    */
   fieldOrmTypes() {
      if (this.defaults.compatibleOrmTypes) {
         if (Array.isArray(this.defaults.compatibleOrmTypes)) {
            return this.defaults.compatibleOrmTypes;
         } else {
            return [this.defaults.compatibleOrmTypes];
         }
      } else {
         return [];
      }
   }

   /**
    * Mysql data types that can be imported to this DataField
    * @return {Array}
    */
   fieldMysqlTypes() {
      if (this.defaults.compatibleMysqlTypes) {
         if (Array.isArray(this.defaults.compatibleMysqlTypes)) {
            return this.defaults.compatibleMysqlTypes;
         } else {
            return [this.defaults.compatibleMysqlTypes];
         }
      } else {
         return [];
      }
   }

   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   fieldIcon() {
      return this.defaults.icon;
   }

   // the multilingual text for the name of this data field.
   fieldMenuName() {
      return this.defaults.menuName;
   }

   // the multilingual text for the name of this data field.
   fieldDescription() {
      return this.defaults.description;
   }

   // the flag to set when checking if field should be filterable
   fieldIsFilterable() {
      if (this.defaults.isFilterable != null) {
         if (typeof this.defaults.isFilterable === "function") {
            return this.defaults.isFilterable(this);
         } else {
            return this.defaults.isFilterable;
         }
      }

      return 1;
   }

   // the flag to set when checking if field should be sortable
   fieldIsSortable() {
      if (this.defaults.isSortable != null) {
         if (typeof this.defaults.isSortable === "function") {
            return this.defaults.isSortable(this);
         } else {
            return this.defaults.isSortable;
         }
      }

      return 1;
   }

   // the flag to set when checking if the field should be used as a label
   fieldUseAsLabel() {
      if (this.defaults.useAsLabel != null) {
         if (typeof this.defaults.useAsLabel === "function") {
            return this.defaults.useAsLabel(this);
         } else {
            return this.defaults.useAsLabel;
         }
      }

      return 1;
   }

   fieldSupportRequire() {
      if (this.defaults.supportRequire) return this.defaults.supportRequire;
      // default
      else return true;
   }

   fieldSupportQuery() {
      if (this.defaults.supportQuery != null) {
         if (typeof this.defaults.supportQuery === "function") {
            return this.defaults.supportQuery(this);
         } else {
            return this.defaults.supportQuery;
         }
      }

      return true;
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABField instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      return {
         id: this.id,
         type: this.type || "field",
         key: this.key,
         icon: this.icon,
         isImported: this.isImported,
         columnName: this.columnName,
         settings: this.settings,
         translations: obj.translations,
      };
   }

   defaultCheck(val, defaultVal) {
      let returnVal = defaultVal;
      if (typeof val != "undefined") {
         returnVal = val;
      }
      return returnVal;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      if (!this.id) this.id = values.id; // NOTE: only exists after .save()
      this.type == values.type || "field";
      this.key = values.key || this.fieldKey();
      this.icon = values.icon || this.fieldIcon();

      values.settings = values.settings || {};

      // if this is being instantiated on a read from the Property UI,
      // .label is coming in under .settings.label
      this.label = values.label || values.settings.label || "?label?";

      this.columnName = values.columnName || "";

      this.isImported = values.isImported || 0;

      this.settings = values.settings;
      this.settings.showIcon = this.defaultCheck(values.settings.showIcon, "1");
      this.settings.required = this.defaultCheck(values.settings.required, "0");
      this.settings.width = this.defaultCheck(values.settings.width, "0");

      // convert from "0" => 0
      this.isImported = parseInt(this.isImported);
      this.settings.showIcon = parseInt(this.settings.showIcon);
      this.settings.required = parseInt(this.settings.required);
      this.settings.unique = parseInt(this.settings.unique || 0);
      this.settings.width = parseInt(this.settings.width);

      // we're responsible for setting up our specific settings:
      const defaultValues = this.constructor.defaultValues() || {};
      for (const dv in defaultValues) {
         this.settings[dv] = this.defaultCheck(
            values.settings[dv],
            defaultValues[dv]
         );
      }

      // const the MLClass now process the Translations
      super.fromValues(values);

      // final validity check: columnName really should have a value:
      this.columnName = this.columnName || this.label;

      // knex does not like .(dot) in table and column names
      // https://github.com/knex/knex/issues/2762
      this.columnName = this.columnName.replace(/[^a-zA-Z0-9_ ]/gi, "");
   }

   /**
    * @method urlPointer()
    * return a string pointer to decode this object from the root application
    * object.
    * @return {string} pointer reference
    */
   urlPointer() {
      return this.object.urlField() + this.id;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      values[this.columnName] = "";
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    */
   isValidData(data, validator) {
      // console.error('!!! Field ['+this.fieldKey()+'] has not implemented .isValidData()!!!');
      if (
         this.settings.required &&
         (data[this.columnName] == null || data[this.columnName] == "") &&
         data[this.columnName] != 0
      ) {
         validator.addError(this.columnName, "This is a required field.");
      }
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      return false;
   }

   dataValue(rowData) {
      const propName = `${this.alias || this.object.name}.${this.columnName}`;

      let result = "";
      if (rowData?.[this.columnName] != null) {
         result = rowData[this.columnName];
      } else if (rowData?.[propName] != null) {
         result = rowData[propName];
      }

      return result;
   }

   /**
    * @method format
    * return display text to detail comonent and define label of object
    *
    * @param {Object} rowData - data
    */
   format(rowData) {
      if (rowData) {
         return this.dataValue(rowData);
      } else return "";
   }

   /**
    * @method toDefinition()
    *
    * convert this instance into an ABDefinition object.
    *
    * @return {ABDefinition}
    */
   toDefinition() {
      const myDef = super.toDefinition();

      // attempt to provide a more descriptive name:
      // [obj]->[fieldName]
      if (myDef.name == "") {
         myDef.name =
            myDef.json.name || myDef.json.label || myDef.json.columnName;
      }
      if (this.object && this.object.name) {
         myDef.name = `${this.object.name}->${myDef.name}`;
      }
      return myDef;
   }
}


/***/ }),

/***/ 60437:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldDateCore.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RegEx: () => (/* binding */ RegEx),
/* harmony export */   "default": () => (/* binding */ ABFieldDateCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldDate
 *
 * An ABFieldDate defines a date field type.
 *
 */



/*function L(key, altText) {
   // TODO:git 
   // return altText; // AD.lang.label.getLabel(key) || altText;
}*/

const ABFieldDateDefaults = {
   key: "date",
   // unique key to reference this specific DataField

   description: "Pick one from a calendar.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "calendar",
   // font-awesome icon reference.  (without the 'fa-').  so 'calendar'  to
   // reference 'fa-calendar'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Date",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["date"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["date"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   dateFormat: 2, // 1 (Ignore date), 2, 3, 4, 5
   defaultDate: 1, // 1 (None), 2 (Current Date), 3 (Specific Date)
   defaultDateValue: null, // {Date}
   validateCondition: "none",
   validateRangeUnit: "days",
   validateRangeBefore: 0,
   validateRangeAfter: 0,
   validateStartDate: null,
   validateEndDate: null,
};

class ABFieldDateCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object, defaultValues = ABFieldDateDefaults) {
      super(values, object, defaultValues);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldDateDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   // TODO: current webpack install fails here without babel-loader,
   // so swtich this to old JS method of Static Values (see bottom)
   // static RegEx = "^[0-9]{4}-[0-9]{2}-[0-9]{2}$";

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.dateFormat = parseInt(this.settings.dateFormat);
      this.settings.defaultDate = parseInt(this.settings.defaultDate);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] != null) return;

      let dateResult;

      // Set current date as default
      if (this.settings.defaultDate == 2) {
         dateResult = new Date();
      }
      // Set specific date as default
      else if (
         this.settings.defaultDate == 3 &&
         this.settings.defaultDateValue
      ) {
         dateResult = new Date(this.settings.defaultDateValue);
      }

      // if no default value is set, then don't insert a value.
      if (dateResult != null) {
         values[this.columnName] = this.AB.rules.toDateFormat(dateResult, {
            format: "YYYY-MM-DD",
         });
         // values[this.columnName] = moment(dateResult).format("YYYY-MM-DD");
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
      var L = this.AB.Label();

      const currentDate = new Date();
      currentDate.setHours(0, 0, 0, 0);

      if (data[this.columnName]) {
         let value = data[this.columnName];

         if (!(value instanceof Date)) {
            console.log(`value:[${value}]`);
            value = this.AB.rules.toDate(value);
            // value = new Date(this.convertToMoment(value));
         }

         let L = this.AB.Label();

         // verify we didn't end up with an InValid Date result.
         if (
            Object.prototype.toString.call(value) === "[object Date]" &&
            isFinite(value)
         ) {
            let isValid = true;

            // Custom vaildate is here
            if (this.settings && this.settings.validateCondition) {
               const startDate = this.settings.validateStartDate
                     ? new Date(this.settings.validateStartDate)
                     : null,
                  endDate = this.settings.validateEndDate
                     ? new Date(this.settings.validateEndDate)
                     : null,
                  startDateDisplay = this.getDateDisplay(startDate),
                  endDateDisplay = this.getDateDisplay(endDate);
               const minDate = this.AB.rules.subtractDate(
                  new Date(),
                  this.settings.validateRangeBefore,
                  this.settings.validateRangeUnit
               );
               const maxDate = this.AB.rules.addDate(
                  new Date(),
                  this.settings.validateRangeAfter,
                  this.settings.validateRangeUnit
               );
               switch (this.settings.validateCondition) {
                  case "dateRange":
                     if (minDate < value && value < maxDate) isValid = true;
                     else {
                        isValid = false;
                        validator.addError(
                           this.columnName,
                           L("Should be in between {0} and {1}", [
                              this.getDateDisplay(minDate),
                              this.getDateDisplay(maxDate),
                           ])
                        );
                     }

                     break;
                  case "between":
                     if (startDate < value && value < endDate) isValid = true;
                     else {
                        isValid = false;
                        validator.addError(
                           this.columnName,
                           L("Should be in between {0} and {1}", [
                              startDateDisplay,
                              endDateDisplay,
                           ])
                        );
                     }
                     break;
                  case "notBetween":
                     if (value < startDate && endDate < value) isValid = true;
                     else {
                        isValid = false;
                        validator.addError(
                           this.columnName,
                           L("Should not be in between {0} and {1}", [
                              startDateDisplay,
                              endDateDisplay,
                           ])
                        );
                     }
                     break;
                  case "=":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() == startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should equal {0}", [startDateDisplay])
                        );
                     break;
                  case "<>":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() != startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should not equal {0}", [startDateDisplay])
                        );
                     break;
                  case ">":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() > startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should after {0}", [startDateDisplay])
                        );
                     break;
                  case "<":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() < startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should before {0}", [startDateDisplay])
                        );
                     break;
                  case ">=":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() >= startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should after or equal {0}", [startDateDisplay])
                        );
                     break;
                  case "<=":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() <= startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should before or equal {0}", [startDateDisplay])
                        );
                     break;
                  case "lessCurrentDate":
                     isValid =
                        value.getTime &&
                        value.getTime() < currentDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should before {0}", [
                              this.getDateDisplay(currentDate),
                           ])
                        );
                     break;
                  case "lessEqualCurrentDate":
                     isValid =
                        value.getTime &&
                        value.getTime() <= currentDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should before or equal {0}", [
                              this.getDateDisplay(currentDate),
                           ])
                        );
                     break;
               }
            }

            if (isValid) {
               // Reformat value to DB
               // NOTE: should we update here?
               data[this.columnName] = this.exportValue(value);
            }
         } else {
            // return a validation error
            validator.addError(this.columnName, "Should be a Date!");
         }
      }
   }

   format(rowData) {
      const d = this.dataValue(rowData);

      if (d == "" || d == null) {
         return "";
      }

      // pull format from settings.
      const dateObj = this.AB.rules.toDate(d);
      return this.getDateDisplay(dateObj);

      // const momentObj = this.convertToMoment(d);
      // return this.getDateDisplay(new Date(momentObj));
   }

   getFormat() {
      let dateFormatString = "";

      const dateFormat = this.settings?.dateFormat
         ? this.settings.dateFormat
         : "";

      switch (dateFormat) {
         //Ignore Date
         case (1, 2):
            {
               dateFormatString = "%d/%m/%Y";
            }
            break;
         //mm/dd/yyyy
         case 3:
            {
               dateFormatString = "%m/%d/%Y";
            }
            break;
         //M D, yyyy
         case 4:
            {
               dateFormatString = "%M %d, %Y";
            }
            break;
         //D M, yyyy
         case 5:
            {
               dateFormatString = "%d %M, %Y";
            }
            break;
         default:
            {
               dateFormatString = "%d/%m/%Y";
            }
            break;
      }

      return dateFormatString;
   }

   getDateDisplay(dateData) {
      const dateFormat = this.getFormat();

      return this.dateToString(dateFormat, dateData);
   }

   // convertToMoment(string) {
   //    const result = moment(string);

   //    const supportFormats = [
   //       "DD/MM/YYYY",
   //       "MM/DD/YYYY",
   //       "DD-MM-YYYY",
   //       "MM-DD-YYYY"
   //    ];

   //    supportFormats.forEach((format) => {
   //       if (!result || !result.isValid()) result = moment(string, format);
   //    });

   //    return result;
   // }

   exportValue(value) {
      return value
         ? this.AB.rules.toDateFormat(value, {
              format: "YYYY-MM-DD",
           })
         : "";
      // return this.convertToMoment(value).format("YYYY-MM-DD");
   }

   dateToString(dateFormat, dateData) {
      if (dateData && dateData.toString) return dateData.toString();
      else return "";
   }
}

// Transition Code:
// revert to static RegEx once babel-loader is working locally.
const RegEx = "^[0-9]{4}-[0-9]{2}-[0-9]{2}$";




/***/ }),

/***/ 81973:
/*!******************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldDateTimeCore.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RegEx: () => (/* binding */ RegEx),
/* harmony export */   "default": () => (/* binding */ ABFieldDateTimeCore)
/* harmony export */ });
/* harmony import */ var _ABFieldDateCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABFieldDateCore */ 60437);
/*
 * ABFieldDateTime
 *
 * An ABFieldDateTime defines a datetime field type.
 *
 */



const ABFieldDateDefaults = {
   key: "datetime",
   // unique key to reference this specific DataField

   description: "Pick one from date & time.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "clock-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'clock-o'  to
   // reference 'clock-o'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Date & Time",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["datetime"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["datetime"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   timeFormat: 2, // 1 (Ignore time), 2, 3
   defaultTime: 1, // 1 (None), 2 (Current Time), 3 (Specific Time)
   defaultTimeValue: null, // {Date}
};

class ABFieldDateTimeCore extends _ABFieldDateCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldDateDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldDateDefaults;
   }

   static defaultValues() {
      const baseDefault = super.defaultValues();
      return Object.assign(baseDefault, defaultValues);
   }

   // TODO: current webpack install fails here without babel-loader,
   // so swtich this to old JS method of Static Values (see bottom)
   // static RegEx = "^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$";

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.timeFormat = parseInt(this.settings.timeFormat);
      this.settings.defaultTime = parseInt(this.settings.defaultTime);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] != null) return;

      super.defaultValue(values);

      let dateResult;

      // From default value of ABFieldDateCore
      if (values[this.columnName]) {
         dateResult = this.AB.rules.toDate(values[this.columnName]);
         // const momentVal = this.convertToMoment(values[this.columnName]);
         // if (momentVal.isValid()) {
         //    dateResult = new Date(momentVal);
         // }
      }

      // Set current time as default
      if (this.settings.defaultTime == 2) {
         const currDate = new Date();

         if (dateResult == null) dateResult = new Date();

         dateResult.setHours(currDate.getHours());
         dateResult.setMinutes(currDate.getMinutes());
         dateResult.setSeconds(currDate.getSeconds());
         dateResult.setMilliseconds(currDate.getMilliseconds());
      }
      // Set specific time as default
      else if (
         this.settings.defaultTime == 3 &&
         this.settings.defaultTimeValue
      ) {
         const defaultTime = new Date(this.settings.defaultTimeValue);

         if (dateResult == null) dateResult = new Date();

         dateResult.setHours(defaultTime.getHours());
         dateResult.setMinutes(defaultTime.getMinutes());
         dateResult.setSeconds(defaultTime.getSeconds());
         dateResult.setMilliseconds(defaultTime.getMilliseconds());
      }

      // if no default value is set, then don't insert a value.
      if (dateResult != null)
         values[this.columnName] = dateResult.toISOString();
   }

   getFormat() {
      const timeFormat = this.getTimeFormat();

      this.settings = this.settings || {};

      if (this.settings.dateFormat == 1) {
         return timeFormat;
      }

      const dateFormat = super.getFormat();

      return `${dateFormat} ${timeFormat}`;
   }

   format(rowData) {
      const datetimeFormat = this.getFormat();
      const d = this.dataValue(rowData);
      const dateObj = this.AB.rules.toDate(d);

      if (d == "" || d == null) {
         return "";
      }

      if (this.AB.Webix)
         return this.AB.Webix.Date.dateToStr(datetimeFormat)(dateObj);
      else
         return dateObj?.toISOString() ?? "";
   }

   getTimeFormat() {
      this.settings = this.settings || {};
      switch (this.settings.timeFormat) {
         case 2:
            return " %h:%i %A";
         case 3:
            return " %H:%i";
         default:
            return "";
      }
   }

   /**
    * @method exportValue
    * @param {Date} date
    * @return {string}
    */
   exportValue(date) {
      return date?.toISOString?.() ?? "";
   }
}

// Transition Code:
// revert to static RegEx once babel-loader is working locally.
const RegEx = "^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$";




/***/ }),

/***/ 79009:
/*!***************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldEmailCore.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldEmailCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldEmail
 *
 * An ABFieldEmail defines a boolean field type.
 *
 */



const ABFieldEmailDefaults = {
   key: "email",
   // unique key to reference this specific DataField

   description: "Email fields are used to store email addresses.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "envelope",
   // font-awesome icon reference.  (without the 'fa-').  so 'envelope'  to
   // reference 'fa-envelope'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Email",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: true,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   default: "",
   defaultCheckbox: 0,
};

class ABFieldEmailCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldEmailDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldEmailDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      this.settings.default = values.settings.default || "";
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default string
         if (this.settings.default) {
            values[this.columnName] = this.settings.default;
         }
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      if (data[this.columnName]) {
         const Reg =
            /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

         let value = data[this.columnName];
         value = String(value).toLowerCase();
         if (!Reg.test(value)) {
            validator.addError(this.columnName, "Invalid email");
         }
      }
   }
}


/***/ }),

/***/ 27007:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldFileCore.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldFileCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldFile
 *
 * An ABFieldFile defines a File field type.
 *
 */



const ABFieldFileDefaults = {
   key: "file",
   // unique key to reference this specific DataField

   description: "Attach a File to this object.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "file",
   // font-awesome icon reference.  (without the 'fa-').  so 'file'  to
   // reference 'fa-file'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "File Attachment",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   removeExistingData: 0,
   fileSize: 0,
   fileType: "",
};

class ABFieldFileCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldFileDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldFileDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.fileSize = parseInt(this.settings.fileSize);
      this.settings.limitFileSize = parseInt(this.settings.limitFileSize);
      this.settings.limitFileType = parseInt(this.settings.limitFileType);
      this.settings.removeExistingData = parseInt(
         this.settings.removeExistingData
      );
   }

   /**
    * @method dataValue
    * return the file data stored as part of this field.
    *
    * An ABFieldFile column contains a json structure that contains
    *  .uuid : {string} a file uuid reference
    *  .filename : {string} the name of the file that was uploaded.
    *
    * This will return the json object.
    * @param {obj} values a key=>value hash of the current values.
    * @return {obj} { uuid, filename }, or {} if empty.
    */
   dataValue(rowData) {
      const propName = `${this.alias || this.object.name}.${this.columnName}`;

      let result = rowData[this.columnName] || rowData[propName] || {};
      if (typeof result == "string") {
         try {
            result = JSON.parse(result);
         } catch (err) {
            // ignore error
         }
      }

      return result;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    *
    * An ABFieldFile expects a json structure that contains
    *  .uuid : {string} a file uuid reference
    *  .filename : {string} the name of the file that was uploaded.
    *
    * For a default value, we return an empty json object: "{}"
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      values[this.columnName] = "{}";
   }

   format(rowData) {
      let result = this.dataValue(rowData);
      if (result) {
         if (typeof result == "string") {
            try {
               result = JSON.parse(result);
            } catch (err) {
               // ignore error.
            }
         }

         // return file name
         return result ? result.filename || "" : "";
      } else {
         return "";
      }
   }

   /**
    * @method requestParam
    * return the entry in the given input that relates to this field.
    * @param {obj} allParameters  a key=>value hash of the inputs to parse.
    * @return {obj} or undefined
    */
   requestParam(allParameters) {
      const myParameter = super.requestParam(allParameters);

      // if we have our default empty object, then remove the entry
      // and let the DB insert a null value.
      let val = myParameter?.[this.columnName];
      if (val == "{}" || val == "") {
         delete myParameter[this.columnName];
      }
      if ("string" === typeof val) {
         try {
            myParameter[this.columnName] = JSON.parse(val);
         } catch (e) {
            /* ignore */
         }
      }

      return myParameter;
   }
}


/***/ }),

/***/ 25174:
/*!*****************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldFormulaCore.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldFormulaCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldFormula
 *
 * An ABFieldFormula are used to run calculations on connected (child) records
 * and store the total of that calculation in the parent.
 *
 */



const ABFieldFormulaDefaults = {
   key: "formula",
   // unique key to reference this specific DataField

   description:
      "Perform a calculation by a formula type based upon existing values",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "circle-o-notch",
   // font-awesome icon reference.  (without the 'fa-').  so 'circle-o-notch'  to
   // reference 'fa-circle-o-notch'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Formula",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportQuery: (field) => {
      const fieldLink = field.fieldLink;
      if (fieldLink == null) return false;

      // Not support calculate field in query
      return fieldLink.key !== "calculate";
   },

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "integer",
      "bigint",
      "decimal",
      "dec",
      "numeric",
      "fixed",
      "float",
      "real",
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   field: "", // id of ABField : NOTE - store our connect field to support when there are multi - linked columns
   objectLink: "", // id of ABObject
   fieldLink: "", // id of ABField
   type: "sum", // "sum", "average", "max", "min", "count"
   where: "",
};

class ABFieldFormulaCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldFormulaDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldFormulaDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // this field is read only
      delete values[this.columnName];
   }

   /**
    * @method format
    * both calculate and format the data input based of user settings
    * for this field.
    * @param {obj} rowData
    *        a key=>value hash of the current values.
    * @param {boolean} reCalculate
    *        a boolean that signals if we should force recalculation of values
    */
   format(rowData, reCalculate = false, isGrouped = false) {
      const fieldLink = this.fieldLink;

      const reformat = (numData) => {
         // ABFieldCalculate does not need to .format again
         if (!fieldLink || fieldLink.key == "calculate") {
            return numData;
         } else {
            const rowDataFormat = {};
            rowDataFormat[fieldLink.columnName] = numData;
            return fieldLink.format(rowDataFormat);
         }
      };

      // if data exists, then will not calculate on client side
      // unless we pass reCalculate=true to force the recalculation
      if (rowData[this.columnName] != null && !reCalculate && !isGrouped) {
         // reformat data
         return reformat(rowData[this.columnName]);
      } else if (
         rowData[this.columnName] != null &&
         !reCalculate &&
         isGrouped
      ) {
         return rowData[this.columnName];
      }

      if (!fieldLink) return 0;

      const fieldBase = this.fieldBase();
      if (!fieldBase) return 0;

      let data =
         rowData[fieldBase.relationName()] ||
         rowData[fieldBase.columnName] ||
         [];
      if (!Array.isArray(data)) data = [data];

      // Filter
      if (
         data &&
         data.length &&
         this.settings &&
         this.settings.where &&
         this.settings.where.rules &&
         this.settings.where.rules.length
      ) {
         this.filterHelper.setValue(this.settings.where);
         data = data.filter((item) => this.filterHelper.isValid(item));
      }

      let numberList = [];

      // pull number from data
      switch (fieldLink.key) {
         case "calculate":
            data.forEach((d) => {
               numberList.push(parseFloat(fieldLink.format(d) || 0));
            });
            break;
         case "number":
            numberList = data.map((d) => d[fieldLink.columnName] || 0);
            break;
      }

      let result = 0;

      // get the decimal size of the numbers being calculated
      const decimalSize = fieldLink.getDecimalSize();

      // calculate
      switch (this.settings.type) {
         case "sum":
            if (numberList.length > 0) {
               // get power of 10 to the number of decimal places this number
               // is formated to require
               const multiplier = Math.pow(10, decimalSize);
               // multiply values by muliplyier and add them to pervious value
               // because in javascript adding number with decimals can cause issues
               // ex: 9.11 + 222.11 = 231.22000000000003
               let sum = 0;
               numberList.forEach((val) => {
                  sum += val * multiplier || 0;
               });
               // divide result by multiplier to get actual value
               result = sum / multiplier;
            }
            break;

         case "average":
            if (numberList.length > 0) {
               // get power of 10 to the number of decimal places this number
               // is formated to require
               const multiplier = Math.pow(10, decimalSize);
               // multiply values by muliplyier and add them to pervious value
               // because in javascript adding number with decimals can cause issues
               // ex: 9.11 + 222.11 = 231.22000000000003
               let sum = 0;
               numberList.forEach((val) => {
                  sum += val * multiplier || 0;
               });
               // divide result by multiplier to get actual value
               // and divide by length to get the average
               result = sum / multiplier / numberList.length;
            }
            break;

         case "max":
            result = Math.max(...numberList) || 0;
            break;
         case "min":
            result = Math.min(...numberList) || 0;
            break;
         case "count":
            result = numberList.length;
            break;
      }

      rowData[this.columnName] = result;

      // ABFieldCalculate does not need to .format again
      if (fieldLink.key == "calculate") {
         return result;
      } else {
         return reformat(result);
      }
   }

   fieldBase() {
      return this.object.fieldByID(this.settings.field);
   }

   get fieldLink() {
      const obj = this.AB.objectByID(this.settings.object);
      if (!obj) return null;

      const field = obj.fieldByID(this.settings.fieldLink);
      if (!field) return null;

      return field;
   }

   get filterHelper() {
      if (this._rowFilter == null) {
         this._rowFilter = this.AB.filterComplexNew(`${this.id}_filterComplex`);

         if (this.fieldLink && this.fieldLink.object) {
            this._rowFilter.fieldsLoad(this.fieldLink.object.fields());
            this._rowFilter.setValue(this.settings.where);
         }
      }

      return this._rowFilter;
   }
}


/***/ }),

/***/ 33693:
/*!***************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldImageCore.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldImageCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldImageCore
 *
 * An ABFieldImage defines a Image field type.
 *
 */



const ABFieldImageDefaults = {
   key: "image",
   // unique key to reference this specific DataField

   description: "Attach an image to this object.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "file-image-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'file-image-o'  to
   // reference 'fa-file-image-o'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Image Attachment",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   useWidth: 0,
   imageWidth: "",
   useHeight: 0,
   imageHeight: "",
   removeExistingData: 0,
   useDefaultImage: false,
   defaultImageUrl: "",
};

class ABFieldImageCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldImageDefaults);

      // NOTE: our Labels are ready here:
      // if (
      //    ABFieldImageDefaults.menuName == "*Image Attachment" &&
      //    this.AB.Label
      // ) {
      //    const L = this.AB.Label();
      //    ABFieldImageDefaults.menuName = L("Image Attachment");
      //    ABFieldImageDefaults.description = L("Attach an image to this object.");
      // }

      /*
    	{
			settings: {
				'useWidth':0,
				'imageWidth':'',
				'useHeight': 0,
				'imageHeight': '',
				'removeExistingData': 0
			}
    	}
    	*/
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldImageDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.useWidth = parseInt(this.settings.useWidth);
      this.settings.useHeight = parseInt(this.settings.useHeight);
      this.settings.imageWidth = parseInt(this.settings.imageWidth);
      this.settings.imageHeight = parseInt(this.settings.imageHeight);
      this.settings.useDefaultImage = parseInt(this.settings.useDefaultImage);
      this.settings.removeExistingData = parseInt(
         this.settings.removeExistingData
      );
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }
}


/***/ }),

/***/ 23158:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldJsonCore.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldJsonCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldJson
 *
 * An ABFieldJson defines a JSON field type.
 *
 */



const ABFieldJsonDefaults = {
   key: "json",
   // unique key to reference this specific DataField

   description: "JSON value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "font",
   // font-awesome icon reference.  (without the 'fa-').  so 'font'  to
   // reference 'fa-font'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "JSON",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["json"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["json"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {};

class ABFieldJsonCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldJsonDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldJsonDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // in the case of a JSON data type, we should NOT insert a ""
      //
      // values[this.columnName] = "";
   }
}


/***/ }),

/***/ 75124:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldListCore.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldListCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldListCore
 *
 * An ABFieldList defines a select list field type.
 *
 */

// const ABFieldSelectivity = require("../../platform/dataFields/ABFieldSelectivity");


const ABFieldListDefaults = {
   key: "list",
   // unique key to reference this specific DataField

   description:
      "Select list allows you to select predefined options below from a dropdown.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "th-list",
   // font-awesome icon reference.  (without the 'fa-').  so 'th-list'  to
   // reference 'fa-th-list'

   isFilterable: (field) => {
      if (field.settings.isMultiple) {
         return false;
      } else {
         return true;
      }
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: (field) => {
      if (field.settings.isMultiple) {
         return false;
      } else {
         return true;
      }
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Select list",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "char",
      "varchar",
      "tinytext" /* "text", "mediumtext" */,
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   hasColors: (field) => {
      if (field.settings.hasColors) {
         return true;
      } else {
         return false;
      }
   },
};

const defaultValues = {
   isMultiple: 0,
   // {bool}
   // can multiple values be selected?

   hasColors: 0,
   // {bool}
   // are we to display our values in colors?

   options: [],
   // {array}
   // The options defined for this list:
   // [ { id, text, hex, translations },...]
   //    .id {string} a unique id for this value
   //    .text {string} the displayed text of this value
   //    .hex {string} a color hex definition for this value
   //    .translations {obj} the multilingual definitions for this value.

   default: "none",
   multipleDefault: [],
};

class ABFieldListCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldListDefaults);

      this.pendingDeletions = [];
      // {array}
      // a list of pending option deletions that need to be processed
      // when this is saved.
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldListDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // translate options list
      if (this.settings.options && this.settings.options.length > 0) {
         this.settings.options.forEach((opt) => {
            this.translate(opt, opt, ["text"]);
         });
      }

      this.settings.isMultiple = parseInt(this.settings.isMultiple);
      this.settings.hasColors = parseInt(this.settings.hasColors);
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      // Un-translate options list
      obj.settings.options.forEach((opt) => {
         this.unTranslate(opt, opt, ["text"]);
      });

      return obj;
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // Multiple select list
      if (this.settings.isMultiple == true) {
         let defaultVals = [];
         this.settings.multipleDefault.forEach((def) => {
            this.settings.options.forEach((opt) => {
               if (opt.id == def.text) {
                  defaultVals.push(opt);
               }
            });
         });
         values[this.columnName] = defaultVals || [];
      }
      // Single select list
      else if (this.settings.default && this.settings.default != "") {
         values[this.columnName] = this.settings.default;
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }

   /**
    * @method options
    * Return an array of [{ id, text }] options defined by this field.
    * @return {array}
    */
   options() {
      return this.settings.options.map((opt) => {
         return {
            id: opt.id,
            text: opt.text,
            hex: opt.hex ? opt.hex : "",
            translations: opt.translations ? opt.translations : "",
         };
      });
   }

   format(rowData, options = {}) {
      let val = this.dataValue(rowData) || [];

      if (typeof val == "string") {
         try {
            val = JSON.parse(val);
         } catch (e) {
            // continue regardless of error
         }
      }

      // Convert to array
      if (!Array.isArray(val)) val = [val];

      const displayOpts = this.settings.options
         .filter((opt) => val.filter((v) => (v.id || v) == opt.id).length > 0)
         .map((opt) => {
            let text = opt.text;
            const languageCode = options.languageCode || "en";

            // Pull text of option with specify language code
            const optTran = (opt.translations || []).filter(
               (o) => o.language_code == languageCode
            )[0];
            if (optTran) text = optTran.text;

            return text;
         });

      return displayOpts.join(", ");
   }
}


/***/ }),

/***/ 78557:
/*!******************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldLongTextCore.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldLongText)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldLongText
 *
 * An ABFieldLongText defines a LongText field type.
 *
 */



const MAX_CHAR_LENGTH = 5000;

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldLongTextDefaults = {
   key: "LongText", // unique key to reference this specific DataField

   description: "Multiple lines of text",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "align-right",
   // font-awesome icon reference.  (without the 'fa-').  so 'align-right'  to
   // reference 'fa-align-right'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Long text",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["longtext", "mediumtext", "text"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   MAX_CHAR_LENGTH,
   // {integer}
   // The maximum length our ABFieldLongText can be.
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   default: "",
   supportMultilingual: 0,
};

class ABFieldLongText extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldLongTextDefaults);

      /*
    	{
			settings: {
				default: 'string',
				supportMultilingual: 1/0
			}
    	}
    	*/
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldLongTextDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.default = values.settings.default || "";

      // we're responsible for setting up our specific settings:
      this.settings.supportMultilingual =
         values.settings.supportMultilingual + "" ||
         defaultValues.supportMultilingual;

      // text to Int:
      this.settings.supportMultilingual = parseInt(
         this.settings.supportMultilingual
      );

      if (this.settings.supportMultilingual) {
         if (this.object)
            this.object.translate(this.settings, this.settings, ["default"]);
      } else this.settings.default = values.settings.default || "";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      if (this.settings.supportMultilingual)
         if (this.object)
            this.object.unTranslate(obj.settings, obj.settings, ["default"]);
         else obj.settings.default = this.settings.default;

      return obj;
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      return this.settings.supportMultilingual == 1;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] == null) {
         if (typeof this.settings.default == "string") {
            values[this.columnName] = this.settings.default;
         } else {
            values[this.columnName] = "";
         }
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      if (
         data &&
         data[this.columnName] &&
         data[this.columnName].length > MAX_CHAR_LENGTH
      ) {
         validator.addError(
            this.columnName,
            `should NOT be longer than ${MAX_CHAR_LENGTH} characters`
         );
      }
   }
}


/***/ }),

/***/ 76410:
/*!****************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldNumberCore.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldNumberCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldNumber
 *
 * An ABFieldNumber defines a Number field type.
 *
 */



const ABFieldNumberDefaults = {
   key: "number",
   // unique key to reference this specific DataField

   description: "A Float or Integer Value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "hashtag",
   // font-awesome icon reference.  (without the 'fa-').  so 'hashtag'  to
   // reference 'fa-hashtag'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Number",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: true,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "integer",
      "bigint",
      "decimal",
      "dec",
      "numeric",
      "fixed",
      "float",
      "real",
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   // 'allowRequired': 0,
   default: "",
   typeFormat: "none",
   typeDecimals: "none",
   typeDecimalPlaces: 0,
   typeRounding: "none",
   typeThousands: "none",
   validation: 0,
   validateMinimum: "",
   validateMaximum: "",
};

let L = null; //AB.Label();

class ABFieldNumberCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldNumberDefaults);

      /*
    	{
			settings: {
				'allowRequired':0,
				'default':null,
				'typeFormat': 'none',
				'typeDecimals': 'none',
				'typeDecimalPlaces': 'none',
				'typeRounding' : 'none',
				'typeThousands': 'none',
				'validation':0,
				'validateMinimum':null,
				'validateMaximum':null
			}
    	}
    	*/
      if (!L) {
         L = this.AB.Label();
      }
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldNumberDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   static formatList(iL) {
      if (iL && !L) L = iL;
      return [
         { id: "none", value: L("None") },
         {
            id: "dollar",
            value: L("$"),
            sign: "$",
            position: "prefix",
         },
         {
            id: "yen",
            value: L(""),
            sign: "",
            position: "prefix",
         },
         {
            id: "pound",
            value: L(""),
            sign: "",
            position: "prefix",
         },
         {
            id: "euroBefore",
            value: L(" (before)"),
            sign: "",
            position: "prefix",
         },
         {
            id: "euroAfter",
            value: L(" (after)"),
            sign: "",
            position: "postfix",
         },
         {
            id: "percent",
            value: L("%"),
            sign: "%",
            position: "postfix",
         },
      ];
   }

   static delimiterList() {
      return [
         { id: "none", value: L("None") },
         {
            id: "comma",
            value: L("Comma"),
            sign: ",",
         },
         {
            id: "period",
            value: L("Period"),
            sign: ".",
         },
         {
            id: "space",
            value: L("Space"),
            sign: " ",
         },
      ];
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      // this.settings.allowRequired = parseInt(this.settings.allowRequired);
      this.settings.validation = parseInt(this.settings.validation);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (this.settings.default != "") {
         values[this.columnName] = this.settings.default;
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      // const L = this.AB.Label();

      if (data[this.columnName] != null && data[this.columnName] != "") {
         let value = data[this.columnName];

         // if this is an integer:
         if (this.settings.typeDecimals == "none") {
            value = parseInt(value);
         } else {
            const places = parseInt(this.settings.typeDecimalPlaces) || 2;
            value = parseFloat(parseFloat(value).toFixed(places));
         }

         const isNumeric = (n) => {
            return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);
         };
         if (!isNumeric(value)) {
            validator.addError(this.columnName, L("invalid number"));
         }

         // validate Minimum
         if (
            this.settings.validation == true &&
            this.settings.validateMinimum != null &&
            this.settings.validateMinimum > value
         ) {
            const errMessage = L("should be greater than {0}", [
               this.settings.validateMinimum,
            ]);

            validator.addError(this.columnName, errMessage);
         }

         // validate Maximum
         if (
            this.settings.validation == true &&
            this.settings.validateMaximum != null &&
            this.settings.validateMaximum < value
         ) {
            const errMessage = L("should be less than {0}", [
               this.settings.validateMaximum,
            ]);

            validator.addError(this.columnName, errMessage);
         }
      }
   }

   format(rowData) {
      if (
         rowData?.[this.columnName] == null ||
         (rowData[this.columnName] !== 0 && rowData[this.columnName] == "")
      )
         return "";

      let data = rowData[this.columnName] || 0;

      if (typeof data == "string") {
         data = data.replace(/,/g, "");
      }

      // Validate number
      if (isNaN(parseFloat(data))) data = 0;

      const formatSign = this.constructor
         .formatList()
         .filter((item) => item.id == this.settings.typeFormat)[0];
      const decimalPlaces =
         this.settings.typeDecimalPlaces != "none"
            ? parseInt(this.settings.typeDecimalPlaces)
            : 0;

      let thousandsSign = this.constructor
         .delimiterList()
         .filter((item) => item.id == this.settings.typeThousands)[0];
      let decimalSign = this.constructor
         .delimiterList()
         .filter((item) => item.id == this.settings.typeDecimals)[0];
      let prefix = "";
      let postfix = "";

      if (formatSign && formatSign.sign) {
         switch (formatSign.position) {
            case "prefix":
               prefix = formatSign.sign;
               break;
            case "postfix":
               postfix = formatSign.sign;
               break;
         }
      }

      decimalSign = decimalSign.sign || "";
      thousandsSign = thousandsSign.sign || "";

      // round number
      if (this.settings.typeRounding == "roundDown") {
         const digit = Math.pow(10, decimalPlaces);
         data = Math.floor(data * digit) / digit;
      }

      const number = this.formatNumber(data, {
         groupDelimiter: thousandsSign,
         groupSize: 3,
         decimalDelimiter: decimalSign,
         decimalSize: decimalPlaces,
      });

      return `${prefix} ${number} ${postfix}`;
   }

   formatNumber(data, options = {}) {
      if (data === "" || data == null) return data;

      data = parseFloat(data);
      const negativeSign = data < 0 ? "-" : "";
      data = Math.abs(data);

      const dataStr = data.toString();
      const integerStr = dataStr.split(".")[0];
      const decimalStr = dataStr.split(".")[1];

      let integerValue = "";

      // Thousands digit sign
      if (options.groupDelimiter) {
         const step = 3;
         let i = integerStr.length;

         do {
            i -= step;
            const chunk =
               i > 0
                  ? integerStr.substr(i, step)
                  : integerStr.substr(0, step + i);
            integerValue = `${chunk}${
               integerValue ? options.groupDelimiter + integerValue : ""
            }`;
         } while (i > 0);
      } else {
         integerValue = integerStr;
      }

      // Integer
      let result = `${negativeSign}${integerValue}`;

      // Decimal
      if (decimalStr && options.decimalDelimiter && options.decimalSize) {
         const decimalVal = data.toFixed(options.decimalSize).split(".")[1];
         result += `${options.decimalDelimiter}${decimalVal}`;
      }

      return result;
   }

   getDecimalSize() {
      if (this.settings.typeDecimalPlaces != "none") {
         return parseInt(this.settings.typeDecimalPlaces);
      } else {
         return 0;
      }
   }
}


/***/ }),

/***/ 44955:
/*!****************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldStringCore.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldStringCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldString
 *
 * An ABFieldString defines a string field type.
 *
 */



const MAX_CHAR_LENGTH = 255;

const ABFieldStringDefaults = {
   key: "string",
   // unique key to reference this specific DataField

   description: "short string value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "font",
   // font-awesome icon reference.  (without the 'fa-').  so 'font'  to
   // reference 'fa-font'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Single line text",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   MAX_CHAR_LENGTH,
   // {integer}
   // The maximum length our ABFieldString can be.
};

const defaultValues = {
   default: "",
   supportMultilingual: 0,
};

class ABFieldStringCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldStringDefaults);

      /*
    	{
			settings: {
				default: 'string',
				supportMultilingual: 1/0
			}
    	}
        */
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldStringDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // we're responsible for setting up our specific settings:
      this.settings.default = values.settings.default || defaultValues.default;
      this.settings.supportMultilingual =
         values.settings.supportMultilingual + "" ||
         defaultValues.supportMultilingual;

      // text to Int:
      this.settings.supportMultilingual = parseInt(
         this.settings.supportMultilingual
      );

      if (this.settings.supportMultilingual) {
         this.translate(this.settings, this.settings, ["default"]);
      } else this.settings.default = values.settings.default || "";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      if (this.settings.supportMultilingual) {
         this.unTranslate(obj.settings, obj.settings, ["default"]);
      } else obj.settings.default = this.settings.default;

      return obj;
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default string
         if (this.settings.default) {
            if (this.settings.default.indexOf("{uuid}") >= 0) {
               values[this.columnName] = this.AB.uuid();
            } else {
               values[this.columnName] = this.settings.default;
            }
         }
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      if (data?.[this.columnName]?.length > MAX_CHAR_LENGTH) {
         const L = this.AB.Label();
         validator.addError(
            this.columnName,
            L("should NOT be longer than {0} characters", [MAX_CHAR_LENGTH])
         );
      }
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      return this.settings.supportMultilingual == 1;
   }
}


/***/ }),

/***/ 82361:
/*!*********************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldTextFormulaCore.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldTextFormulaCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABField */ 38817);
/*
 * ABFieldTextFormula
 *
 * An ABFieldTextFormula defines a TextFormula field type.
 *
 */



const ABFieldTextFormulaDefaults = {
   key: "TextFormula",
   // unique key to reference this specific DataField

   description: "Text Formula",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "question",
   // font-awesome icon reference.  (without the 'fa-').  so 'question'  to
   // reference 'fa-question'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Text Formula",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   textFormula: "",
   // {string} "some text or text with formula ..."
   // This tells us what the formula we need to do with text included text string.
   // if we don't have this, the old value which we filled out won't be cleared when we do "Add field" this type again.

   // 'imageWidth':'',
   // 'useHeight': 0,
   // 'imageHeight': ''
};

/** Private methods */

/**
 * @method setValueToFormula
 *
 * @param {ABOBject} object
 * @param {string} formulaString
 * @param {object} rowData
 */

function setValueToFormula(object, formulaString, rowData) {
   if (!formulaString) return;

   const fieldRegExp = /{[^{}]+}/gm;
   const matches_field_array = formulaString.match(fieldRegExp);
   matches_field_array.forEach((element) => {
      const columnName = element.replace(/{|}|"/g, "");
      object.fields().forEach((field) => {
         if (field.columnName == columnName) {
            if (field.key == "AutoIndex") {
               //Check AutoIndex Field
               const autoIndexVal = field.format(rowData) || 0;
               formulaString = formulaString.replace(element, autoIndexVal);
            } else if (field.key == "calculate") {
               //Calculate Field
               const calVal = `(${field.format(rowData) || 0})`;
               formulaString = formulaString.replace(element, eval(calVal));
            } else if (field.key == "date") {
               formulaString = formulaString.replace(
                  element,
                  rowData[columnName]
                     ? field.exportValue(rowData[columnName])
                     : ""
               );
            } else {
               formulaString = formulaString.replace(
                  element,
                  rowData[columnName] ? field.format(rowData) : ""
               );
            }
         }
      });
   });

   return formulaString;
}

/**
 * @method setBuildinValueToFormula
 *
 * @param {ABFactory} AB
 * @param {string} formulaString
 */

function setBuildinValueToFormula(AB, formulaString) {
   const buildInRegExp = /\w+\(.*?\)/gm;
   const matches_buildin_array = formulaString.match(buildInRegExp);
   if (matches_buildin_array) {
      const buildinList = getBuildInFunction();
      matches_buildin_array.forEach((element) => {
         const formula_array = element.split(/\(|\)/);
         const isBracketInBracket =
            formula_array.length > 2 && formula_array[2] != "";
         const functionName = formula_array[0];
         const parameters_array = formula_array[1].split(",");
         let isMatch = false;
         for (let i = 0; i < buildinList.length; i++) {
            let resultParameters = element;
            if (functionName == buildinList[i].id) {
               if (parameters_array.length == buildinList[i].parameter_size) {
                  switch (functionName) {
                     case "left":
                        resultParameters = getLeft(
                           parameters_array[0],
                           parameters_array[1]
                        );
                        break;
                     case "right":
                        resultParameters = getRight(
                           parameters_array[0],
                           parameters_array[1]
                        );
                        break;
                     case "mid":
                        resultParameters = getMid(
                           parameters_array[0],
                           parameters_array[1],
                           parameters_array[2]
                        );
                        break;
                     case "trim":
                        resultParameters = getTrim(parameters_array[0]);
                        break;
                     case "trimLeft":
                        resultParameters = getTrimLeft(parameters_array[0]);
                        break;
                     case "trimRight":
                        resultParameters = getTrimRight(parameters_array[0]);
                        break;
                     case "length":
                        resultParameters = getLength(parameters_array[0]);
                        break;
                     case "regexReplace":
                        resultParameters = getRegExpReplace(
                           parameters_array[0],
                           parameters_array[1].trimLeft(),
                           parameters_array[2].trimLeft()
                        );
                        break;
                     case "extractRegex":
                        resultParameters = getExtractRegex(
                           parameters_array[0],
                           parameters_array[1].trimLeft()
                        );
                        break;
                     case "replace":
                        resultParameters = getReplace(
                           parameters_array[0],
                           parameters_array[1].trimLeft(),
                           parameters_array[2].trimLeft()
                        );
                        break;
                     case "lower":
                        resultParameters = getLower(parameters_array[0]);
                        break;
                     case "upper":
                        resultParameters = getUpper(parameters_array[0]);
                        break;
                     case "capitalize":
                        resultParameters = getCapitalize(parameters_array[0]);
                        break;
                     case "random":
                        resultParameters = getRandom(parameters_array[0]);
                        break;
                     case "numberToWords":
                        resultParameters = getNumberToWords(
                           parameters_array[0]
                        );
                        break;
                     case "getDateDayOfWeekName":
                        if (isBracketInBracket) {
                           element = element + ")";
                        }
                        resultParameters = getDateDayOfWeekName(
                           AB,
                           parameters_array[0]
                        );
                        break;
                     case "getDateMonthOfYearName":
                        if (isBracketInBracket) {
                           element = element + ")";
                        }
                        resultParameters = getDateMonthOfYearName(
                           AB,
                           parameters_array[0]
                        );
                        break;
                     case "formatDate":
                        resultParameters = getFormatDate(
                           parameters_array[0],
                           parameters_array[1].trimLeft()
                        );
                        break;
                     default:
                        break;
                  }
                  isMatch = true;
                  formulaString = formulaString.replace(
                     element,
                     resultParameters
                  );
                  return;
               } else {
                  resultParameters = functionName + "(Bad Parameter)";
                  formulaString = formulaString.replace(
                     element,
                     resultParameters
                  );
               }
            }
         }
      });
   }
   return formulaString;
}

function getBuildInFunction() {
   const functionList = [
      {
         id: "left",
         value: "left({COLUMN_NAME}, 1)",
         type: "build-in",
         parameter_size: 2,
      },
      {
         id: "right",
         value: "right({COLUMN_NAME}, 1)",
         type: "build-in",
         parameter_size: 2,
      },
      {
         id: "mid",
         value: "mid({COLUMN_NAME}, 1, 1)",
         type: "build-in",
         parameter_size: 3,
      },
      {
         id: "trim",
         value: "trim({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "trimLeft",
         value: "trimLeft({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "trimRight",
         value: "trimRight({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "length",
         value: "length({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "regexReplace",
         value: "regexReplace({COLUMN_NAME}, [*], REPLACE_VALUE)",
         type: "build-in",
         parameter_size: 3,
      },
      {
         id: "extractRegex",
         value: "extractRegex({COLUMN_NAME}, [*])",
         type: "build-in",
         parameter_size: 2,
      },
      {
         id: "replace",
         value: "replace({COLUMN_NAME}, SEARCH_VALUE, REPLACE_VALUE)",
         type: "build-in",
         parameter_size: 3,
      },
      {
         id: "lower",
         value: "lower({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "upper",
         value: "upper({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "capitalize",
         value: "capitalize({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      { id: "random", value: "random(1)", type: "build-in", parameter_size: 1 },
      {
         id: "numberToWords",
         value: "numberToWords({NUMBER_COLUMN} or 012...)",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "getDateDayOfWeekName",
         value: "getDateDayOfWeekName({DATE_COLUMN})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "getDateMonthOfYearName",
         value: "getDateMonthOfYearName({DATE_COLUMN})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "formatDate",
         value: "formatDate({DATE_COLUMN}, OUTPUT_FORMAT)",
         type: "build-in",
         parameter_size: 2,
      },
   ];
   return functionList;
}

function getLeft(string, endPosition) {
   return string.substring(0, parseInt(endPosition));
}

function getRight(string, endposition) {
   const reverseStr = reverseString(string).substring(0, parseInt(endposition));
   return reverseString(reverseStr);
}

function reverseString(string) {
   return string.split(" ").reverse().join(" ");
}

function getMid(string, startPosition, length) {
   if (string.length < startPosition) return "mid(Bad Parameter)";
   return string.substring(
      parseInt(startPosition),
      parseInt(startPosition) + parseInt(length)
   );
}

function getTrim(string) {
   return string.trim();
}

function getTrimLeft(string) {
   return string.trimLeft();
}

function getTrimRight(string) {
   return string.trimRight();
}

function getLength(string) {
   return string.length;
}

function getRegExpReplace(string, regexp, replaceString) {
   return string.replace(regexp, replaceString);
}

function getExtractRegex(string, regexp) {
   const extractResult = string.match(regexp);
   if (Array.isArray(extractResult)) {
      return extractResult[0];
   }
   return extractResult;
}

function getReplace(string, searchValue, replaceValue) {
   return string.replace(searchValue, replaceValue);
}

function getLower(string) {
   return string.toLowerCase();
}

function getUpper(string) {
   return string.toUpperCase();
}

function getCapitalize(string) {
   return string
      .toLowerCase()
      .split(" ")
      .map((s) => s.charAt(0).toUpperCase() + s.substring(1))
      .join(" ");
}

function getRandom(max) {
   return Math.floor(Math.random() * (max + 1));
}

function getNumberToWords(number) {
   const string = number.trim(",").toString();

   let units,
      tens,
      scales,
      start,
      end,
      chunks,
      chunksLen,
      chunk,
      ints,
      i,
      word,
      words;

   const and = "";

   /* Is number zero? */
   if (parseInt(string) === 0) {
      return "zero";
   }

   /* Array of units as words */
   units = [
      "",
      "one",
      "two",
      "three",
      "four",
      "five",
      "six",
      "seven",
      "eight",
      "nine",
      "ten",
      "eleven",
      "twelve",
      "thirteen",
      "fourteen",
      "fifteen",
      "sixteen",
      "seventeen",
      "eighteen",
      "nineteen",
   ];

   /* Array of tens as words */
   tens = [
      "",
      "",
      "twenty",
      "thirty",
      "forty",
      "fifty",
      "sixty",
      "seventy",
      "eighty",
      "ninety",
   ];

   /* Array of scales as words */
   scales = [
      "",
      "thousand",
      "million",
      "billion",
      "trillion",
      "quadrillion",
      "quintillion",
      "sextillion",
      "septillion",
      "octillion",
      "nonillion",
      "decillion",
      "undecillion",
      "duodecillion",
      "tredecillion",
      "quatttuor-decillion",
      "quindecillion",
      "sexdecillion",
      "septen-decillion",
      "octodecillion",
      "novemdecillion",
      "vigintillion",
      "centillion",
   ];

   /* Split user arguemnt into 3 digit chunks from right to left */
   start = string.length;
   chunks = [];
   while (start > 0) {
      end = start;
      chunks.push(string.slice((start = Math.max(0, start - 3)), end));
   }

   /* Check if function has enough scale words to be able to stringify the user argument */
   chunksLen = chunks.length;
   if (chunksLen > scales.length) {
      return "";
   }

   /* Stringify each integer in each chunk */
   words = [];
   for (i = 0; i < chunksLen; i++) {
      chunk = parseInt(chunks[i]);

      if (chunk) {
         /* Split chunk into array of individual integers */
         ints = chunks[i].split("").reverse().map(parseFloat);

         /* If tens integer is 1, i.e. 10, then add 10 to units integer */
         if (ints[1] === 1) {
            ints[0] += 10;
         }

         /* Add scale word if chunk is not zero and array item exists */
         if ((word = scales[i])) {
            words.push(word);
         }

         /* Add unit word if array item exists */
         if ((word = units[ints[0]])) {
            words.push(word);
         }

         /* Add tens word if array item exists */
         if ((word = tens[ints[1]])) {
            words.push(word);
         }

         /* Add 'and' string after units or tens integer if: */
         if (ints[0] || ints[1]) {
            /* Chunk has a hundreds integer or chunk is the first of multiple chunks */
            if (ints[2] || (!i && chunksLen)) {
               words.push(and);
            }
         }

         /* Add hundreds word if array item exists */
         if ((word = units[ints[2]])) {
            words.push(word + " hundred");
         }
      }
   }

   return words.reverse().join(" ");
}

function getDateDayOfWeekName(AB, date) {
   // const localizeDT = moment(date);
   // localizeDT.locale(AD.lang.currentLanguage);
   // return localizeDT.format("dddd");

   return AB.rules.toDateFormat(date, {
      format: "dddd",
      localeCode: AB.Account.language(),
   });
}

function getDateMonthOfYearName(AB, date) {
   // const localizeDT = moment(date);
   // localizeDT.locale(AD.lang.currentLanguage);
   // return localizeDT.format("MMMM");

   return AB.rules.toDateFormat(date, {
      format: "MMMM",
      localeCode: AB.Account.language(),
   });
}

function getFormatDate(date, format) {
   const dt = new Date(date);
   return dt.toString(format);
}

class ABFieldTextFormulaCore extends _platform_dataFields_ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldTextFormulaDefaults);

      /*
    	{
			settings: {
				textDefault: 'string',
				supportMultilingual: true/false
			}
    	}
    	*/

      // // text to Int:
      // this.settings.supportMultilingual = parseInt(this.settings.supportMultilingual);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldTextFormulaDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   static getBuildInFunction() {
      return getBuildInFunction();
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default value
         // values[this.columnName] = this.settings.DEFAULT_VALUE;
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      validator = super.isValid();

      // validator.addError(this.columnName, L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      // return this.settings.supportMultilingual == 1;
      return false;
   }

   format(rowData) {
      try {
         if (!this.settings.textFormula) return "";

         let resultFormula = this.settings.textFormula;

         //Set Field value first
         resultFormula = setValueToFormula(this.object, resultFormula, rowData);

         //then Check Build-in Function
         resultFormula = setBuildinValueToFormula(this.AB, resultFormula);

         return resultFormula;
      } catch (err) {
         return "";
      }
   }
}

//// NOTE: if you need a unique [edit_type] by your returned config.editor above:
// webix.editors = {
//   "[edit_type]": {
//     focus: function () {...}
//     getValue: function () {...},
//     setValue: function (value) {...},
//     render: function () {...}
//   }
// };

//// NOTE: if you need a unique [sort_type] by your returned config.sort above:
// webix.DataStore.prototype.sorting.as.[sort_type] = function(a,b){
//     return a > b ? 1 : -1;
// }


/***/ }),

/***/ 13299:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldTreeCore.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldTreeCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABFieldSelectivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABFieldSelectivity */ 55522);
/*
 * ABFieldTreeCore
 *
 * An ABFieldTree defines a select list field type.
 *
 */



const ABFieldTreeDefaults = {
   key: "tree",
   // unique key to reference this specific DataField

   description:
      "Data tree allows you to build a hierarchical set of selectable data. (ex: Categories and sub-categories)",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "sitemap",
   // font-awesome icon reference.  (without the 'fa-').  so 'sitemap'  to
   // reference 'fa-sitemap'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Data Tree",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   options: [],
};

class ABFieldTreeCore extends _platform_dataFields_ABFieldSelectivity__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldTreeDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldTreeDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // translate options list
      if (this.settings.options && this.settings.options.length > 0) {
         this.settings.options.forEach((opt) => {
            this.translate(opt, opt, ["text"]);
         });
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      // Un-translate options list
      if (obj.settings.options && obj.settings.options.length > 0) {
         obj.settings.options.forEach((opt) => {
            this.unTranslate(opt, opt, ["text"]);
         });
      }

      return obj;
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {}

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }
}


/***/ }),

/***/ 75498:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/core/dataFields/ABFieldUserCore.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldUserCore)
/* harmony export */ });
/* harmony import */ var _platform_dataFields_ABFieldConnect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/dataFields/ABFieldConnect */ 30289);
/*
 * ABFieldUser
 *
 * An ABFieldUser defines a user field type.
 *
 */



const ABFieldUserDefaults = {
   key: "user",
   // unique key to reference this specific DataField

   description: "Add users to a record.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "user-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'user-o'  to
   // reference 'fa-user-o'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: (field) => {
      if (field.settings.isMultiple) {
         return false;
      } else {
         return true;
      }
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "User",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   USERNAME_FIELD_ID: "5760560b-c078-47ca-98bf-e18ac492a561",
   // {string} .uuid
   // the ABField.id of the SiteUser.username field.  This is what other
   // objects will link to in their ABFieldUser connections.
};

const defaultValues = {
   editable: 1,
   isMultiple: 0,
   isCurrentUser: 0,
   isShowProfileImage: 0,
   isShowUsername: 1,
};

class ABFieldUserCore extends _platform_dataFields_ABFieldConnect__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object, ABFieldUserDefaults);

      this.isUser = true;
      // {bool}
      // is this an ABFieldUser type of field.
      // this is a simplified helper to identify if an ABField is a type
      // of User field.  Since this is the only place it is defined,
      // all other field types will be falsy
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldUserDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      this.settings.editable = parseInt(this.settings.editable);
      this.settings.isMultiple = parseInt(this.settings.isMultiple);
      this.settings.isCurrentUser = parseInt(this.settings.isCurrentUser);
      this.settings.isShowProfileImage = parseInt(
         this.settings.isShowProfileImage
      );
      this.settings.isShowUsername = parseInt(this.settings.isShowUsername);
   }

   ///
   /// Working with Actual Object Values:
   ///

   format(rowData) {
      let val = this.dataValue(rowData) || [];

      if (val && !Array.isArray(val)) val = [val];
      if (!val) val = [];

      return val.map((v) => v.username || v).join(", ");
   }
}


/***/ }),

/***/ 30654:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobilePageCore.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobilePageCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 53349);
/*
 * ABMobilePageCore
 *
 * An view that represents a "Page" on the Mobile Device.
 *
 * Pages are
 *	- allowed to be displayed in the interface list
 *	- return a full list of components that can be added to the view editor
 *
 *
 */


// var ABViewManager = require("../ABViewManager");

// function L(key, altText) {
//     return AD.lang.label.getLabel(key) || altText;
// }

const ABMobilePageDefaults = {
   key: "mobile-page", // unique key identifier for this ABView
   icon: "file", // icon reference: (without 'fa-'  )
};

const ABPropertyComponentDefaults = {
   type: "page",
   // {string}
   // What type of "Page" this is: ['page', 'popup', 'reportPage']

   defaultPage: 0,
   // {bool} 1|0
   // is this the default page for the Mobile App? If so, this is the initial
   // Page that is displayed when the App is loaded.
   // NOTE: there can be only 1 page defined in the app as .defaultPage

   hideTitle: 0,
   // {bool} 1|0
   // By default we will display this.label as our Title. Set this to 1 to not
   // show the tile on the page.

   hideTabs: 0,
   // {bool} 1|0
   // By default, pages will show any Tab options on their display.  Set this
   // to 1 to not show the tab options for this Page. (good for pages that
   // are linkedPages with forms )
};

class ABMobilePageCore extends _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABMobilePageDefaults);

      // 	{
      // 		id:'uuid',					// uuid value for this obj
      // 		key:'viewKey',				// unique key for this View Type
      // 		icon:'font',				// fa-[icon] reference for an icon for this View Type

      //		name: '',					// unique page name

      // 		label:'',					// pulled from translation

      //		settings: {					// unique settings for the type of field
      //		},

      //		translations:[]
      // 	}

      this.parent = null; // will be set by the pageNew() that creates this obj.
      // {obj} .parent
      // this points to the ABView object that manages this object as a child.
      // this param is shared across ABViews as well as ABMobilePage, but has
      // different implications ... so we default an ABMobilePage.parent = null
      // and the place that Creates the Page must assign the .parent externally.
   }

   static common() {
      return ABMobilePageDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABMobilePage instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.name = this.name;
      obj.route = this.route;

      obj.myAppID = this.myAppID;

      obj.menuType = this.menuType;

      obj.defaultPage = this.defaultPage;

      // icon of popup page
      if (this.settings.type == "popup") obj.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") obj.label = obj.name;

      // compile our pages
      obj.pageIDs = (this._pages || []).map((p) => p.id);

      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      const DV = ABPropertyComponentDefaults;

      this.route =
         values.route || (this.name || this.label).replaceAll(" ", "_");

      // icon of popup page
      if (values.settings.type == "popup") this.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") this.label = this.name;

      // track which application this Page belongs to:
      this.myAppID = values.myAppID;
      if (!this.myAppID && this.application) {
         this.myAppID = this.application.id;
      }

      this.menuType = values.menuType || "menu";
      // {string}  ["menu", "tab"]
      // indicates if this Page was added as a Mobile App's "menu" or "Tab"

      this.defaultPage = values.defaultPage || 0;
      // {bool}  1|0
      // indicates if this is the default page that is loaded when the mobile app
      // is started.
      // NOTE: only 1 Page in a Mobile App can have this setting = 1.

      this.settings.hideTitle = parseInt(
         values.settings.hideTitle ?? DV.hideTitle
      );
      // {bool} 1|0
      // By default an ABMobilePage will display it's this.label for a title
      // on the page.  Setting this to TRUE (1) will hide the title.

      this.settings.hideTabs = parseInt(
         values.settings.hideTabs ?? DV.hideTabs
      );
      // {bool} 1|0
      // By default, pages will show any Tab options on their display.  Set this
      // to 1 to not show the tab options for this Page. (good for pages that
      // are linkedPages with forms )

      // now properly handle our sub pages.
      var pages = [];
      (values.pageIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            pages.push(this.pageNew(def));
         } else {
            this.emit(
               "warning",
               `App[${this.application.name}][${this.application.id}]->Page[${this.name}][${this.id}] referenced an unknown Page[${id}]`,
               {
                  appID: this.application.id,
                  pageID: this.id,
                  missingPageID: id,
               }
            );
         }
      });
      this._pages = pages;

      // the default columns of ABView is 1
      // this.settings.columns = this.settings.columns || 1;
      // this.settings.gravity = this.settings.gravity || [1];

      // convert from "0" => 0
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      return Promise.resolve()
         .then(() => {
            // When deleting an ABMobilePage
            // be sure to remove any of it's ABMobilePage as well
            // This cleans out any dangling ABDefinitions

            var allPageDeletes = [];
            var allPages = this.pages();
            this._pages = [];
            // doing ._pages = [] prevents any of my updates when
            // a sub-page is .destroy()ed

            allPages.forEach((p) => {
               allPageDeletes.push(p.destroy());
            });
            return Promise.all(allPageDeletes);
         })
         .then(() => {
            var parent = this.parent || this.application;

            return parent.pageRemove(this);
         })
         .then(() => {
            return super.destroy();
         });
   }

   /**
    * @method save()
    * persist this instance of ABMobilePage
    * @return {Promise}
    *         .resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // now we can persist ourself in our parent
            var parent = this.parent || this.application;

            return parent.pageInsert(this);
         })
         .then(() => {
            // make sure .defaultPage is properly set
            if (this.defaultPage) {
               return this.application.setPageDefault(this);
            }
         })
         .then(() => {
            return this;
         });
   }

   /**
    * @method refreshInstance()
    * This returns a NEW instance of a ABMobilePage based upon the latest
    * version of it's Definition.  It also resolves any current listeners
    * this copy currently has and prepare this to discard itself.
    */
   refreshInstance() {
      console.warn(
         "This version of ABMobilePage hasn't updated it's refreshInstance()",
         this
      );
      return this;
   }

   ///
   /// Pages
   ///

   /**
    * @method pages()
    *
    * return an array of all the ABMobilePages for this ABMobilePage.
    *
    * @param {fn} filter		a filter fn to return a set of ABMobilePages that this fn
    *							returns true for.
    * @param {boolean} deep	flag to find in sub pages
    *
    * @return {array}			array of ABMobilePages
    */
   pages(filter = () => true, deep = false) {
      var result = [];

      // find into sub-pages recursively
      if (filter && deep) {
         // if (this._pages && this._pages.length > 0) {
         //    result = this._pages.filter(filter);

         //    if (result.length < 1) {
         //       this._pages.forEach((p) => {
         //          var subPages = p.pages(filter, deep);
         //          if (subPages && subPages.length > 0) {
         //             result = subPages;
         //          }
         //       });
         //    }
         // }
         result = this.application._searchDeep(this, "_pages", filter);
      }
      // find root pages
      else {
         result = this._pages.filter(filter);
      }

      return result;
   }

   /**
    * @method pageInsert()
    *
    * save the given ABMobilePage in our ._pages array and persist the current
    * values if they changed.
    *
    * @param {ABMobilePage} page The instance of the page to save.
    * @return {Promise}
    */
   pageInsert(page) {
      var isIncluded = this.pages((o) => o.id === page.id).length > 0;
      if (!isIncluded) {
         // if not already included, then add and save the Obj definition:
         this._pages.push(page);
         return this.save();
      }

      // Nothing was required so return
      return Promise.resolve();
   }

   /**
    * @method pageNew()
    *
    * return an instance of a new (unsaved) ABMobilePage that is tied to this
    * ABMobilePage.
    *
    * NOTE: this new page is not included in our this.pages until a .save()
    * is performed on the page.
    *
    * @return {ABMobilePage}
    */
   pageNew(values) {
      // make sure this is an ABMobilePage description
      values.key = ABMobilePageDefaults.key;

      // NOTE: this returns a new ABView component.
      // when creating a new page, the 3rd param should be null, to signify
      // the top level component.
      var page = this.application.viewNew(values, this.application, null);
      page.parent = this;
      return page;
   }

   /**
    * @method pageRemove()
    *
    * remove the given ABMobilePage from our ._pages array and persist the current
    * values.
    *
    * @param {ABMobilePage} page The instance of the page to remove.
    * @return {Promise}
    */
   pageRemove(page) {
      var origLen = this._pages.length;
      this._pages = this.pages((p) => p.id != page.id);

      if (this._pages.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
      return Promise.resolve();
   }

   updateIcon(obj) {
      // icon of page
      if (obj.settings.type == "popup") {
         obj.icon = "clone";
      } else {
         obj.icon = ABMobilePageDefaults.icon;
      }
      return obj;
   }

   /**
    * @method clone()
    * clone the defintions of this ABMobilePage object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {obj}
    *        defs of the copied ABView
    */
   clone(lookUpIds, parent) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // copy
      let result = super.clone(lookUpIds, parent);

      // page's name should not be duplicate
      result.name = null;

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABMobilePage object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // now continue with the default .copy()
      return super.copy(lookUpIds, parent, options);
   }
}


/***/ }),

/***/ 69999:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewCore.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ABMLClass */ 46148);
/*
 * ABViewCore
 *
 * ABViewCore defines the common ABView structure that is shared between
 * the client and the server.  Mostly how it manages it's internal data, and
 * how it is related to the ABView classes.
 *
 */



const ABMobileViewDefaults = {
   key: "mobile-view", // {string} unique key for this view
   icon: "window-maximize", // {string} fa-[icon] reference for this view
   labelKey: "view", // {string} the multilingual label key for the class label
   tabicon: "", // no default tab icons
};

const ABViewPropertyComponentDefaults = {
   label: "",
};

class ABMobileViewCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(["label"], application.AB);

      this.__events = [];
      // keep track of any event listeners attached to this ABView object

      this.defaults = defaultValues || ABMobileViewDefaults;

      this.application = application;

      this.parent = parent || null;

      this.warningsSilent = false;
      // {bool}
      // Should we suppress our configuration warnings?

      this.__missingViews = [];
      // {array}
      // Any ABView.id we have stored that we can't find.

      this.fromValues(values);
   }

   static common() {
      return ABMobileViewDefaults;
   }

   static defaultValues() {
      return ABViewPropertyComponentDefaults;
   }

   /**
    * @method newInstance()
    * return a new instance of this ABView.  Most likely called from interfaces
    * that create new UI elements like the ABDesigner.
    * @param {ABApplication} application  	: the root ABApplication this view is under
    * @param {ABView/ABApplication} parent	: the parent object of this ABView.
    * @return {ABView}
    */
   static newInstance(application, parent) {
      // return a new instance from ABViewManager:
      return application.viewNew(
         { key: this.common().key },
         application,
         parent
      );
   }

   viewKey() {
      return this.defaults.key;
   }

   viewIcon() {
      return this.defaults.icon;
   }

   tabIcon() {
      return this.defaults.tabicon;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABView instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      // MLClass translation
      var obj = super.toObj();

      var result = {
         id: this.id,
         type: this.type || this.viewKey(),
         key: this.key,
         icon: this.icon,
         tabicon: this.tabicon,
         name: this.name,
         settings: this.AB.cloneDeep(this.settings || {}),
         // accessLevels: this.accessLevels,
         translations: obj.translations,
      };

      // encode our child view references
      result.viewIDs = (this._views || []).map((v) => v.id).filter((id) => id);
      result.viewIDs = result.viewIDs.concat(this.__missingViews);

      if (this.position) result.position = this.position;

      // encode our .isRoot() reference.
      // (NOTE: this is set so our server side code can distinguish) between a .view
      // and a root page:
      // NOTE: we intentionally do NOT pull this out in .fromValues()
      result.isRoot = this.isRoot();

      return result;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      this.id = values.id; // NOTE: only exists after .save()
      // {string} .id
      // the uuid of this ABObject Definition.

      this.type = values.type || this.viewKey();
      // {string} .type
      // the type of ABDefinition this is.

      this.key = values.key || this.viewKey();
      // {string} .key
      // the unique lookup key for our ABViewManager to create new
      // instances of this object.

      this.icon = values.icon || this.viewIcon();
      // {string} .icon
      // the font awesome icon reference for showing an icon for this
      // view in the AppBuilder interface builder.

      this.tabicon = values.tabicon || this.tabIcon();

      this.name = values.name;
      // {string} .name
      // A name reference for this ABView. This is a reference that isn't
      // translateable and will be used for lookups across languages.

      // if this is being instantiated on a read from the Property UI,
      // .label is coming in under .settings.label
      values.settings = values.settings || {};
      this.label = values.label || values.settings.label || "?label?";

      this.settings = values.settings || {};
      // {obj} .settings
      // the property settings for this ABView

      // make sure .settings.height is an int and not a string
      this.settings.height = parseInt(this.settings.height || 0);

      // this.accessLevels = values.accessLevels || {};
      // {obj} .accessLevels
      // Hash: { ABRole.id : accessLevel }
      // tracks the Role -> AccessLevel settings of this particular
      // view.
      // accessLevel: 0 : no access, 1 : view only, 2: full access

      // let the MLClass now process the translations:
      super.fromValues(values);

      // If the View / DataCollection does not have a .name already,
      // use the English label translation as the .name instead.
      if (!this.name && Array.isArray(this.translations)) {
         for (var i = 0; i < this.translations.length; i++) {
            if (i == 0) {
               // Use the first label found, in case there is no 'en'
               this.name = this.translations[i].label;
            }
            if (this.translations[i].language_code == "en") {
               // But the 'en' label will have final priority
               this.name = this.translations[i].label;
               break;
            }
         }
      }

      // default value for our label
      if (this.label == "?label?") {
         if (this.parent) {
            this.label =
               this.parent.label +
               "." +
               (this.field?.()?.columnName ?? this.defaults.key);
         }
      }

      var views = [];
      this.__missingViews = this.__missingViews || [];
      (values.viewIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            views.push(this.application.viewNew(def, this.application, this));
         } else {
            this.__missingViews.push(id);
         }
      });
      this._views = views;

      this.position = values.position || {};

      if (this.position.x != null) this.position.x = parseInt(this.position.x);
      if (this.position.y != null) this.position.y = parseInt(this.position.y);

      this.position.dx = parseInt(this.position.dx || 1);
      this.position.dy = parseInt(this.position.dy || 1);
   }

   isRoot() {
      return this.parent == null || this.parent == this.application;
   }

   /**
    * @method allParents()
    * return a flattened array of all the ABViews parents
    * @return {array}      array of ABViews
    */
   allParents() {
      var parents = [];
      var curView = this;

      // add current view to array
      parents.unshift(curView);

      while (!curView.isRoot() && curView.parent) {
         parents.unshift(curView.parent);

         curView = curView.parent;
      }

      return parents;
   }

   /**
    * @method isAccessibleForRoles()
    * return true/false if this ABViewPage is accessible for one of the
    * passed in ABRoles.
    * @param {array[ABRole]} roles
    *        an array of {ABRole} instances.
    * @return {bool}
    */
   // isAccessibleForRoles(roles) {
   //    var foundRole = false;

   //    var accessibleRoles = Object.keys(this.accessLevels) || [];
   //    (roles || []).forEach((r) => {
   //       if (accessibleRoles.indexOf(r.uuid || r) > -1) {
   //          foundRole = true;
   //       }
   //    });

   //    return foundRole;
   // }

   /**
    * @method getUserAccess()
    *
    * return the access level of the current user on the current view
    *
    * @return {integer}  // 0 = No Access // 1 = Read Only // 2 = Full Access
    */
   // getUserAccess() {
   //    // by default everyone has no access
   //    var accessLevel = 0;

   //    if (this.application.isAccessManaged) {
   //       // check to see if the current users is the access manager
   //       var isAccessManager = false;
   //       // first check if manager is defined by their role
   //       if (parseInt(this.application.accessManagers.useRole) == 1) {
   //          // if so check if any of the user's role match the managers
   //          this.AB.Account.roles().forEach((role) => {
   //             if (
   //                this.application.accessManagers.role.indexOf(
   //                   role.id || role.uuid
   //                ) > -1
   //             ) {
   //                // if so set the access level to full access
   //                isAccessManager = true;
   //                accessLevel = 2;
   //             }
   //          });
   //       }
   //       // if the user isn't already set as the manager and the manager is defined by their account
   //       if (
   //          !isAccessManager &&
   //          parseInt(this.application.accessManagers.useAccount) == 1
   //       ) {
   //          // check if the user's account matches the managers
   //          if (
   //             this.application.accessManagers.account.indexOf(
   //                this.AB.Account.uuid() + ""
   //             ) > -1
   //          ) {
   //             // if so set the access level to full access
   //             isAccessManager = true;
   //             accessLevel = 2;
   //          }
   //       }

   //       // if the user is not the manager check if the page has access levels defined for roles
   //       if (
   //          this.accessLevels &&
   //          Object.keys(this.accessLevels).length > 0 &&
   //          !isAccessManager
   //       ) {
   //          // check to see if the user's roles matches one of the roles defined
   //          this.AB.Account.roles().forEach((role) => {
   //             var currentRole = this.accessLevels[role.id || role.uuid];
   //             if (currentRole && parseInt(currentRole) > accessLevel)
   //                // if the access level is higher than a previous role set to the new level
   //                accessLevel = parseInt(currentRole);
   //          });
   //       }
   //    } else {
   //       accessLevel = 2;
   //    }

   //    return accessLevel;
   // }

   /**
    * @method parentFormComponent
    * return the closest form object this component is on.
    */
   parentFormComponent() {
      var form = null;

      var curr = this;
      while (curr.key != "mobile-form" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "mobile-form") {
         form = curr;
      }

      return form;
   }

   /**
    * @method parentDetailComponent
    * return the closest detail object that this component is on.
    * @returns {ABViewDetail} detail component
    */
   parentDetailComponent() {
      var detail = null;

      var curr = this;
      while (curr.key != "mobile-detail" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "mobile-detail") {
         detail = curr;
      }

      return detail;
   }

   pageParent(filterFn) {
      if (filterFn == null) filterFn = () => true;

      // if current page is the root page, then return itself.
      if (this.isRoot()) {
         return this;
      }

      var parentPage = this.parent;
      while (
         parentPage &&
         (parentPage.key != "mobile-page" || !filterFn(parentPage))
      ) {
         parentPage = parentPage.parent;
      }

      return parentPage;
   }

   pageRoot() {
      var rootPage = this.pageParent();

      while (!rootPage.isRoot()) {
         rootPage = rootPage.pageParent();
      }

      return rootPage;
   }

   /**
    * @property datacollection
    * return data source
    *
    * @return {ABDataCollection}
    */
   get datacollection() {
      let dataviewID = (this.settings || {}).dataviewID;
      if (!dataviewID) {
         if (
            [
               "mobile-form",
               "grid",
               "line",
               "area",
               "bar",
               "gantt",
               "kanban",
            ].indexOf(this.key) > -1
         ) {
            // NOTE: ignore kanban side forms where this is the case:
            if (this.key == "mobile-form" && this._currentObject) return null;

            if (this.warningsSilent) return null;

            var errNoDCID = new Error(
               `ABViewCore:get datacollection(): View[${this.key}] didn't define a dataviewID.`
            );
            this.AB.notify.builder(errNoDCID, {
               view: this,
               settings: this.settings,
            });
         } else {
            // These views shouldn't matter if they don't have a datacollection.
            if (
               [
                  "button",
                  "label",
                  "mobile-page",
                  "tab",
                  "viewcontainer",
               ].indexOf(this.key) == -1
            ) {
               console.warn(
                  `TODO: figure out which ABView* require a .dataviewID: ${this.key}?`
               );
            }
         }
         return null;
      }

      var dc = this.AB.datacollectionByID(dataviewID);
      if (!dc) {
         var errNoDC = new Error(
            `MobileView[${this.label}][${this.id}] is unable to find associated DataCollection`
         );
         this.AB.notify.builder(errNoDC, {
            view: this,
            dataviewID,
         });
      }
      return dc;
   }

   ///
   /// Update Access accessLevels
   ///

   /**
    * @method updateAccessLevels()
    *
    *
    * @param {string} roleId
    *
    * @param {string} accessLevel
    *
    * @return {Promise}
    *
    */
   // updateAccessLevels(roleId, accessLevel) {
   //    if (parseInt(accessLevel) == 0) {
   //       if (this.accessLevels[roleId]) delete this.accessLevels[roleId];
   //    } else {
   //       this.accessLevels[roleId] = accessLevel;
   //    }

   //    return this.save(false, false);
   // }

   ///
   /// Views
   ///

   /**
    * @method views()
    *
    * return an array of all the ABViews children
    *
    * @param {fn} filter  	a filter fn to return a set of ABViews that this fn
    *						returns true for.
    * @param {boolean} deep
    *
    * @return {array} 	array of ABViews
    */
   views(filter = () => true, deep = false) {
      var result = [];

      if (!this._views || this._views.length < 1) return result;

      // find into recursively
      if (filter && deep) {
         // result = result.concat(this._views.filter(filter));

         // this._views.forEach((v) => {
         //    var subViews = v.views(filter, deep);
         //    if (subViews && subViews.length > 0) {
         //       result = result.concat(subViews);
         //    }
         // });
         result = this.application._searchDeep(this, "_views", filter);
      } else {
         result = this._views.filter(filter);
      }

      return result;
   }

   /**
    * @method viewByID()
    *
    * return the specific View referenced by the given ID.
    *
    * @param {uuid} ID
    *        the {ABMobileView}.id of the child view we are requesting
    *
    * @return {ABMobileView || undefined}
    */
   viewByID(ID) {
      return this.views((v) => v.id == ID, true)[0];
   }

   /**
    * @method viewNew()
    * @return {ABView}
    */
   viewNew(values, application, parent) {
      return this.application.viewNew(
         values,
         application || this.application,
         parent || this
      );
   }

   /**
    * @method viewDestroy()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   // viewDestroy(view) {
   //    console.error("DEPRECIATED: where is this called?");
   //    return this.viewRemove(view);
   // }

   /**
    * @method viewRemove()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   viewRemove(view) {
      var origLen = this._views.length;
      this._views = this.views(function (v) {
         return v.id != view.id;
      });

      if (this._views.length < origLen) {
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewInsert()
    *
    * persist the current ABView in our list of ._views.
    *
    * @param {ABView} object
    * @return {Promise}
    */
   viewInsert(view) {
      var isIncluded =
         this.views(function (v) {
            return v.id == view.id;
         }).length > 0;
      if (!isIncluded) {
         this._views.push(view);
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewReorder()
    *
    * reorder the current ABView in our list of ._views.
    *
    * @param {string} viewId - id of the active view
    * @param {string} toPosition - 'to' postion
    * @return {Promise}
    */
   viewReorder(viewId, toPosition) {
      var from = this._views.findIndex((v) => v.id == viewId);
      if (from < 0) return;

      // move drag item to 'to' position
      this._views.splice(toPosition, 0, this._views.splice(from, 1)[0]);

      // save to database
      return this.save(true);
   }

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      // unsubscribe events
      this.eventClear(true);

      return Promise.resolve()
         .then(() => {
            // When deleting an ABView
            // be sure to remove any of it's ABViews as well
            // This cleans out any dangling ABDefinitions

            var allViewDeletes = [];
            var allViews = this.views();
            this._views = [];
            // doing ._views = [] prevents any of my updates when
            // a sub-view is .destroy()ed

            allViews.forEach((v) => {
               allViewDeletes.push(v.destroy());
            });
            return Promise.all(allViewDeletes);
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects
            if (this.parent && !this.pages) {
               return this.parent.viewRemove(this);
            }
         })
         .then(() => {
            return super.destroy();
         })
         .then(() => {
            this.emit("destroyed");
         });
   }

   /**
    * @method save()
    * persist this instance of ABView
    * @return {Promise}
    *		.resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects:
            if (this.parent && !this.pages) {
               // if we have a .parent, make sure we are included in our .parent's
               // viewIDs
               return this.parent.viewInsert(this);
            }
         })
         .then(() => {
            return this;
         });
   }

   /**
    * @method wantsAdd()
    * Some widgets can indicate to their containing ABMobilePage that
    * it wants to provide an [Add] feature.
    * @return {bool}
    */
   get wantsAdd() {
      // the default widget doesn't.
      // only those that actually do, should override this.
      return false;
   }

   ///
   /// Events
   ///

   /**
    * @method eventAdd()
    *
    *
    *
    * @param {object} evt - {
    * 							emitter: object,
    * 							eventName: string,
    * 							listener: function
    * 						}
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      var exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventClear()
    * unsubscribe all events.
    * should do it before destroy a component
    *
    * @param {bool} deep - clear events of child views
    */
   eventClear(deep) {
      if (deep) {
         this.views().forEach((v) => {
            v.eventClear(deep);
         });
      }

      if (this.__events && this.__events.length > 0) {
         this.__events.forEach((e) => {
            e.emitter.removeListener(e.eventName, e.listener);
         });
      }
   }

   /**
    * @method clone()
    * clone the definitions of this ABView object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    * @return {obj}
    *        obj defs of this ABView
    */
   clone(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pages", "views"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.viewNew(config, this.application, parent);

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // copy sub pages
      if (this.pages && !options.ignoreSubPages) {
         result._pages = [];
         this.pages().forEach((p) => {
            let copiedSubPage = p.clone(lookUpIds, result, options);
            copiedSubPage.parent = result;

            result._pages.push(copiedSubPage);
         });
      }

      // copy sub views
      if (this.views && !options.ignoreSubViews) {
         result._views = [];
         this.views().forEach((v) => {
            let copiedView = v.clone(lookUpIds, result, options);

            result._views.push(copiedView);
         });
      }

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABView object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    *        options.newName {string}
    *             new user determined name for page
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pageIDs", "viewIDs"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.application.viewNew(config, this.application, parent);

      // keep the parent
      result.parent = parent || this.parent;

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application.
         // pages with null parent ids default to getting put on root
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // page's name should not be duplicate
      if (this.key == "mobile-page") {
         result.name =
            options?.newName ||
            `${result.name}_copied_${this.AB.uuid().slice(0, 3)}`;

         result.label = options?.newName || `${result.label} (copied)`;
      }

      return Promise.resolve()
         .then(() => {
            // copy sub pages
            var allSaves = [];

            if (this._pages && !options.ignoreSubPages) {
               result._pages = [];
               this.pages().forEach((p) => {
                  // this prevents result.save() from happening on each of these
                  // p.copy():
                  if (p.isRoot())
                     this.application._pages.push({ id: lookUpIds[p.id] });

                  allSaves.push(
                     p
                        .copy(lookUpIds, result, options)
                        .then((copiedSubPage) => {
                           copiedSubPage.parent = result;
                           // remove the temp {id:} entry above:
                           this.application._pages =
                              this.application._pages.filter(
                                 (p2) => p2.id != lookUpIds[p.id]
                              );

                           // now add the full copiedSubPage:
                           result._pages.push(copiedSubPage);
                        })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // copy sub views
            var allSaves = [];

            if (this._views && !options.ignoreSubViews) {
               result._views = [];
               this.views().forEach((v) => {
                  allSaves.push(
                     // send a null for parent, so that the .save() wont trigger
                     // a save of the parent.
                     v.copy(lookUpIds, result, options).then((copiedView) => {
                        // now patch up the parent connection:
                        // copiedView.parent = result;
                        if (
                           result._views.filter((vi) => vi.id == copiedView.id)
                              .length < 1
                        ) {
                           result._views.push(copiedView);
                        }
                     })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // now we do 1 save for all the views
            return result.save();
         })
         .then(() => {
            return result;
         });
   }
}


/***/ }),

/***/ 25538:
/*!*****************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewCustomCore.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewCustomCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 53349);


const ABViewCustomPropertyComponentDefaults = {
   dataviewID: null,
   field: null,
   height: 0,
   hideTitle: 0,
   hideTabs: 0,
};

const ABViewDefaults = {
   key: "mobile-custom", // {string} unique key for this view
   icon: "palette", // {string} fa-[icon] reference for this view
   labelKey: "Custom", // {string} the multilingual label key for the class label
};

class ABViewCustomCore extends _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewCustomPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   // field() {
   //    var dv = this.datacollection;
   //    if (!dv) return null;

   //    var object = dv.datasource;
   //    if (!object) return null;

   //    return object.fieldByID(this.settings.field);
   // }

   /**
    * @method wantsAdd()
    * Some widgets can indicate to their containing ABMobilePage that
    * it wants to provide an [Add] feature.
    * @return {bool}
    */
   get wantsAdd() {
      // we do if we have a setting for linkPageAdd
      return this.settings.wantsAdd ?? false;
   }
}


/***/ }),

/***/ 74455:
/*!*********************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormButtonCore.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormButtonCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 53349);


const ABViewFormButtonPropertyComponentDefaults = {
   includeSave: true,
   saveLabel: "",
   includeCancel: false,
   cancelLabel: "",
   includeReset: false,
   resetLabel: "",
   afterCancel: null,
   alignment: "right",
   isDefault: false, // mark default button of form widget
};

const ABViewFormButtonDefaults = {
   key: "mobile-button",
   // {string} unique key for this view

   icon: "square",
   // {string} fa-[icon] reference for this view

   labelKey: "button",
   // {string} the multilingual label key for the class label
};

class ABMobileViewFormButtonCore extends _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormButtonDefaults
      );
   }

   static common() {
      return ABViewFormButtonDefaults;
   }

   static defaultValues() {
      return ABViewFormButtonPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   toObj() {
      // labels are multilingual values:
      let labels = [];

      if (this.settings.saveLabel) labels.push("saveLabel");

      if (this.settings.cancelLabel) labels.push("cancelLabel");

      if (this.settings.resetLabel) labels.push("resetLabel");

      this.unTranslate(this.settings, this.settings, labels);

      let result = super.toObj();

      return result;
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      return null;
   }

   fromValues(values) {
      super.fromValues(values);

      // labels are multilingual values:
      let labels = [];

      if (this.settings.saveLabel) labels.push("saveLabel");

      if (this.settings.cancelLabel) labels.push("cancelLabel");

      if (this.settings.resetLabel) labels.push("resetLabel");

      this.unTranslate(this.settings, this.settings, labels);

      Object.keys(ABViewFormButtonPropertyComponentDefaults).forEach((k) => {
         let val =
            this.settings[k] ?? ABViewFormButtonPropertyComponentDefaults[k];
         try {
            val = JSON.parse(val);
         } catch (e) {
            // just ignore the error and save val
         }
         this.settings[k] = val;
      });

      // this.settings.includeSave = JSON.parse(
      //    this.settings.includeSave ||
      //       ABViewFormButtonPropertyComponentDefaults.includeSave
      // );
      // this.settings.includeCancel = JSON.parse(
      //    this.settings.includeCancel ||
      //       ABViewFormButtonPropertyComponentDefaults.includeCancel
      // );
      // this.settings.includeReset = JSON.parse(
      //    this.settings.includeReset ||
      //       ABViewFormButtonPropertyComponentDefaults.includeReset
      // );

      // this.settings.isDefault = JSON.parse(
      //    this.settings.isDefault ||
      //       ABViewFormButtonPropertyComponentDefaults.isDefault
      // );
   }
}


/***/ }),

/***/ 52670:
/*!***********************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormCheckboxCore.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormCheckboxCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 3199);


const ABMobileViewFormCheckboxPropertyComponentDefaults = {};

const ABMobileViewFormCheckboxDefaults = {
   key: "mobile-checkbox", // {string} unique key for this view
   icon: "check-square-o", // {string} fa-[icon] reference for this view
   labelKey: "checkbox", // {string} the multilingual label key for the class label
};

class ABMobileViewFormCheckboxCore extends _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormCheckboxDefaults
      );
   }

   static common() {
      return ABMobileViewFormCheckboxDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormCheckboxPropertyComponentDefaults;
   }
}


/***/ }),

/***/ 55866:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormConnectCore.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormConnectCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 3199);


const ABMobileViewFormConnectPropertyComponentDefaults = {
   formView: "", // id of form to add new data
   filterConditions: {
      glue: "and",
      rules: [],
   },
   sortFields: [],
   popupWidth: 700,
   popupHeight: 450,
};

const ABMobileViewFormConnectDefaults = {
   key: "mobile-connect", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "Connect", // {string} the multilingual label key for the class label
};

class ABMobileViewFormConnectCore extends _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormConnectDefaults
      );
   }

   static common() {
      return ABMobileViewFormConnectDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormConnectPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.filterConditions =
         this.settings.filterConditions ||
         ABMobileViewFormConnectPropertyComponentDefaults.filterConditions;
   }
}


/***/ }),

/***/ 97835:
/*!***************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormCore.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 53349);
/* harmony import */ var _rules_ABViewRuleListFormRecordRules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rules/ABViewRuleListFormRecordRules */ 35924);
/* harmony import */ var _rules_ABViewRuleListFormSubmitRules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rules/ABViewRuleListFormSubmitRules */ 48828);

// const ABMobileViewFormItem = require("../../platform/mobile/ABMobileViewFormItem");




const ABViewFormDefaults = {
   key: "mobile-form", // unique key identifier for this ABMobileViewForm
   icon: "list-alt", // icon reference: (without 'fa-' )
   labelKey: "Form", // {string} the multilingual label key for the class label
};

const ABViewFormPropertyComponentDefaults = {
   dataviewID: null,
   showLabel: true,
   labelPosition: "left",
   labelWidth: 120,
   height: 200,
   clearOnLoad: false,
   clearOnSave: false,
   displayRules: [],
   editForm: "none", // The url pointer of ABViewForm

   //	[{
   //		action: {string},
   //		when: [
   //			{
   //				fieldId: {UUID},
   //				comparer: {string},
   //				value: {string}
   //			}
   //		],
   //		values: [
   //			{
   //				fieldId: {UUID},
   //				value: {object}
   //			}
   //		]
   //	}]
   recordRules: [],

   //	[{
   //		action: {string},
   //		when: [
   //			{
   //				fieldId: {UUID},
   //				comparer: {string},
   //				value: {string}
   //			}
   //		],
   //		value: {string}
   //	}]
   submitRules: [],
};

class ABMobileViewFormCore extends _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewFormDefaults);
   }

   static common() {
      return ABViewFormDefaults;
   }

   static defaultValues() {
      return ABViewFormPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.labelPosition =
         this.settings.labelPosition ||
         ABViewFormPropertyComponentDefaults.labelPosition;

      // convert from "0" => true/false
      this.settings.showLabel = JSON.parse(
         this.settings.showLabel != null
            ? this.settings.showLabel
            : ABViewFormPropertyComponentDefaults.showLabel
      );
      this.settings.clearOnLoad = JSON.parse(
         this.settings.clearOnLoad != null
            ? this.settings.clearOnLoad
            : ABViewFormPropertyComponentDefaults.clearOnLoad
      );
      this.settings.clearOnSave = JSON.parse(
         this.settings.clearOnSave != null
            ? this.settings.clearOnSave
            : ABViewFormPropertyComponentDefaults.clearOnSave
      );

      // convert from "0" => 0
      this.settings.labelWidth = parseInt(
         this.settings.labelWidth == null
            ? ABViewFormPropertyComponentDefaults.labelWidth
            : this.settings.labelWidth
      );
      this.settings.height = parseInt(
         this.settings.height == null
            ? ABViewFormPropertyComponentDefaults.height
            : this.settings.height
      );
   }

   // Use this function in kanban
   objectLoad(object) {
      this._currentObject = object;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      var viewsToAllow = ["mobile-label", "mobile-button", "mobile-text"],
         allComponents = this.application.viewAll();

      return allComponents.filter((c) => {
         return viewsToAllow.indexOf(c.common().key) > -1;
      });
   }

   /**
    * @method fieldComponents()
    * return an array of all the ABViewFormField children
    * @param {fn} filter
    *        a filter fn to return a set of ABViewFormField that this fn
    *	       returns true for.
    * @return {array} 	array of ABViewFormField
    */
   fieldComponents(filter) {
      const flattenComponents = (views) => {
         let components = [];

         views.forEach((v) => {
            if (v == null) return;

            components.push(v);

            if (v._views?.length) {
               components = components.concat(flattenComponents(v._views));
            }
         });

         return components;
      };

      if (this._views?.length) {
         const allComponents = flattenComponents(this._views);

         if (filter == null) {
            filter = (comp) =>
               comp instanceof this.AB.Class.ABMobileViewFormItem;
         }

         return allComponents.filter(filter);
      } else {
         return [];
      }
   }

   /**
    * @method addFieldToForm()
    * Create a New Form Item on this Form from a given ABFieldXXX object.
    * @param {ABFieldXXX} field
    * @param {int} yPosition
    * @return {ABMobileViewFormXXX}
    */
   addFieldToForm(field, yPosition) {
      if (field == null) return;

      // TODO: figure out how to decode the Data Field and return a form
      // element.

      var fieldComponent = field.formComponentMobile();
      if (fieldComponent == null) return;

      var newView = fieldComponent.newInstance(this.application, this);
      if (newView == null) return;

      // set settings to component
      newView.settings = newView.settings || {};
      newView.settings.fieldId = field.id;
      // TODO : Default settings

      if (yPosition != null) newView.position.y = yPosition;

      // add a new component
      this._views.push(newView);

      return newView;
   }

   get RecordRule() {
      let object = this.datacollection.datasource;

      if (this._recordRule == null) {
         this._recordRule = new _rules_ABViewRuleListFormRecordRules__WEBPACK_IMPORTED_MODULE_1__["default"]();
      }

      this._recordRule.formLoad(this);
      this._recordRule.fromSettings(this.settings.recordRules);
      this._recordRule.objectLoad(object);

      return this._recordRule;
   }

   /**
    * @method recordRulesReady()
    * This returns a Promise that gets resolved when all record rules report
    * that they are ready.
    * @return {Promise}
    */
   async recordRulesReady() {
      return this.RecordRule.rulesReady();
   }

   doRecordRulesPre(rowData) {
      return this.RecordRule.processPre({ data: rowData, form: this });
   }

   doRecordRules(rowData) {
      // validate for record rules
      if (rowData) {
         let object = this.datacollection.datasource;
         let ruleValidator = object.isValidData(rowData);
         let isUpdatedDataValid = ruleValidator.pass();
         if (!isUpdatedDataValid) {
            console.error("Updated data is invalid.", { rowData: rowData });
            return Promise.reject(new Error("Updated data is invalid."));
         }
      }

      return this.RecordRule.process({ data: rowData, form: this });
   }

   doSubmitRules(rowData) {
      var object = this.datacollection.datasource;

      var SubmitRules = new _rules_ABViewRuleListFormSubmitRules__WEBPACK_IMPORTED_MODULE_2__["default"]();
      SubmitRules.formLoad(this);
      SubmitRules.fromSettings(this.settings.submitRules);
      SubmitRules.objectLoad(object);

      return SubmitRules.process({ data: rowData, form: this });
   }
}


/***/ }),

/***/ 37089:
/*!*********************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormCustomCore.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormCustomCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 3199);


const ABViewFormCustomPropertyComponentDefaults = {};

const ABViewFormCustomDefaults = {
   key: "mobile-fieldcustom",
   // {string} unique key for this view
   icon: "object-group",
   // {string} fa-[icon] reference for this view
   labelKey: "custom",
   // {string} the multilingual label key for the class label
};

class ABMobileViewFormCustomCore extends _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormCustomDefaults
      );
   }

   static common() {
      return ABViewFormCustomDefaults;
   }

   static defaultValues() {
      return ABViewFormCustomPropertyComponentDefaults;
   }
}


/***/ }),

/***/ 30483:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormDateCore.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormDatepickerCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 3199);


const ABMobileViewFormDatepickerPropertyComponentDefaults = {
   timepicker: false,
};

const ABMobileViewFormDatepickerDefaults = {
   key: "mobile-date", // {string} unique key for this view
   icon: "calendar", // {string} fa-[icon] reference for this view
   labelKey: "datepicker", // {string} the multilingual label key for the class label
};

class ABMobileViewFormDatepickerCore extends _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormDatepickerDefaults
      );
   }

   static common() {
      return ABMobileViewFormDatepickerDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormDatepickerPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///
}


/***/ }),

/***/ 41098:
/*!***********************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormDatetimeCore.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormDatetimeCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 3199);


const ABMobileViewFormDatetimePropertyComponentDefaults = {
   timepicker: false,
};

const ABMobileViewFormDatetimeDefaults = {
   key: "mobile-datetime", // {string} unique key for this view
   icon: "calendar", // {string} fa-[icon] reference for this view
   labelKey: "Date and Time", // {string} the multilingual label key for the class label
};

class ABMobileViewFormDatetimeCore extends _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormDatetimeDefaults
      );
   }

   static common() {
      return ABMobileViewFormDatetimeDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormDatetimePropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///
}


/***/ }),

/***/ 31508:
/*!********************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormEmailCore.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormEmailCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 3199);


const ABMobileViewFormEmailPropertyComponentDefaults = {
   timepicker: false,
};

const ABMobileViewFormEmailDefaults = {
   key: "mobile-email", // {string} unique key for this view
   icon: "envelope", // {string} fa-[icon] reference for this view
   labelKey: "Email", // {string} the multilingual label key for the class label
};

class ABMobileViewFormEmailCore extends _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormEmailDefaults
      );
   }

   static common() {
      return ABMobileViewFormEmailDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormEmailPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///
}


/***/ }),

/***/ 37206:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormFileCore.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormFileCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 3199);


const ABViewFormFilePropertyComponentDefaults = {};

const ABViewFormFileDefaults = {
   key: "mobile-file",
   // {string} unique key for this view
   icon: "file",
   // {string} fa-[icon] reference for this view
   labelKey: "file",
   // {string} the multilingual label key for the class label
};

class ABMobileViewFormFileCore extends _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormFileDefaults
      );
   }

   static common() {
      return ABViewFormFileDefaults;
   }

   static defaultValues() {
      return ABViewFormFilePropertyComponentDefaults;
   }
}


/***/ }),

/***/ 9462:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormFormulaCore.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormFormulaCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 3199);


const ABViewFormFormulaPropertyComponentDefaults = {};

const ABViewFormFormulaDefaults = {
   key: "mobile-formula",
   // {string} unique key for this view
   icon: "circle-o-notch",
   // {string} fa-[icon] reference for this view
   labelKey: "Formula",
   // {string} the multilingual label key for the class label
};

class ABMobileViewFormFormulaCore extends _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormFormulaDefaults
      );
   }

   static common() {
      return ABViewFormFormulaDefaults;
   }

   static defaultValues() {
      return ABViewFormFormulaPropertyComponentDefaults;
   }
}


/***/ }),

/***/ 37238:
/*!********************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormImageCore.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormImageCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormFile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormFile */ 94298);


const ABViewFormImagePropertyComponentDefaults = {};

const ABViewImageFileDefaults = {
   key: "mobile-image",
   // {string} unique key for this view
   icon: "file-image-o",
   // {string} fa-[icon] reference for this view
   labelKey: "Image",
   // {string} the multilingual label key for the class label
};

class ABMobileViewFormImageCore extends _platform_mobile_ABMobileViewFormFile__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewImageFileDefaults
      );
   }

   static common() {
      return ABViewImageFileDefaults;
   }

   static defaultValues() {
      return ABViewFormImagePropertyComponentDefaults;
   }
}


/***/ }),

/***/ 95927:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormItemCore.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormItemCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 53349);


const ABViewFormFieldPropertyComponentDefaults = {
   required: 0,
   disable: 0,
};

class ABMobileViewFormItemCore extends _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   static defaultValues() {
      return ABViewFormFieldPropertyComponentDefaults;
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      let form = this.parentFormComponent();
      if (form == null) return null;

      let datacollection = form.datacollection;
      if (datacollection == null) return null;

      return datacollection;
   }

   field() {
      if (this.settings.objectId) {
         let object = this.AB.objectByID(this.settings.objectId);
         if (!object) return null;

         return object.fieldByID(this.settings.fieldId);
      } else {
         let form = this.parentFormComponent();
         if (form == null) return null;

         let object;
         if (form._currentObject) {
            object = form._currentObject;
         } else {
            let datacollection = form.datacollection;
            if (datacollection == null) return null;

            object = datacollection.datasource;
         }

         if (object == null) return null;

         let field = object.fieldByID(this.settings.fieldId);
         return field;
      }
   }
}


/***/ }),

/***/ 75410:
/*!*********************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormNumberCore.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormNumberCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 3199);


const ABMobileViewFormNumberPropertyComponentDefaults = {
   isStepper: 0,
};

const ABMobileViewFormNumberDefaults = {
   key: "mobile-numberbox", // {string} unique key for this view
   icon: "hashtag", // {string} fa-[icon] reference for this view
   labelKey: "number", // {string} the multilingual label key for the class label
};

class ABMobileViewFormNumberCore extends _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormNumberDefaults
      );
   }

   static common() {
      return ABMobileViewFormNumberDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormNumberPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewFormText instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, ["label", "formLabel"]);

      var obj = super.toObj();
      obj.views = []; // no subviews
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // if this is being instantiated on a read from the Property UI,
      this.settings.isStepper =
         this.settings.isStepper ||
         ABMobileViewFormNumberPropertyComponentDefaults.isStepper;

      // convert from "0" => 0
      this.settings.isStepper = parseInt(this.settings.isStepper);
   }
}


/***/ }),

/***/ 43002:
/*!***********************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormReadonlyCore.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormReadonly)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormCustom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormCustom */ 88358);


const ABMobileViewFormReadonlyPropertyComponentDefaults = {};

const ABMobileViewFormReadonlyDefaults = {
   key: "mobile-fieldreadonly", // {string} unique key for this view
   icon: "calculator", // {string} fa-[icon] reference for this view
   labelKey: "readonly", // {string} the multilingual label key for the class label
};

class ABMobileViewFormReadonly extends _platform_mobile_ABMobileViewFormCustom__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormReadonlyDefaults
      );
   }

   static common() {
      return ABMobileViewFormReadonlyDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormReadonlyPropertyComponentDefaults;
   }
}


/***/ }),

/***/ 18061:
/*!*****************************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormSelectMultipleCore.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormSelectMultipleCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormSelectSingle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormSelectSingle */ 88001);


const ABMobileViewFormSelectMultiplePropertyComponentDefaults = {
   type: "richselect", // 'richselect' or 'radio'
};

const ABMobileViewFormSelectMultipleDefaults = {
   key: "mobile-selectmultiple", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "selectmultiple", // {string} the multilingual label key for the class label
};

class ABMobileViewFormSelectMultipleCore extends _platform_mobile_ABMobileViewFormSelectSingle__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormSelectMultipleDefaults
      );
   }

   static common() {
      return ABMobileViewFormSelectMultipleDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormSelectMultiplePropertyComponentDefaults;
   }
}


/***/ }),

/***/ 10807:
/*!***************************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormSelectSingleCore.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormSelectSingleCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 3199);


const ABMobileViewFormSelectSinglePropertyComponentDefaults = {
   type: "richselect", // 'richselect' or 'radio'
};

const ABMobileViewFormSelectSingleDefaults = {
   key: "mobile-selectsingle", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "selectsingle", // {string} the multilingual label key for the class label
};

class ABMobileViewFormSelectSingleCore extends _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormSelectSingleDefaults
      );
   }

   static common() {
      return ABMobileViewFormSelectSingleDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormSelectSinglePropertyComponentDefaults;
   }
}


/***/ }),

/***/ 10048:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewFormTextboxCore.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormTextboxCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 3199);


const ABViewFormTextboxPropertyComponentDefaults = {
   type: "single", // 'single', 'multiple' or 'rich'
   placeholder: "", // default placeholder text
};

const ABViewFormTextboxDefaults = {
   key: "mobile-textbox", // {string} unique key for this view
   icon: "i-cursor", // {string} fa-[icon] reference for this view
   labelKey: "textbox", // {string} the multilingual label key for the class label
};

class ABMobileViewFormTextboxCore extends _platform_mobile_ABMobileViewFormItem__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormTextboxDefaults
      );
   }

   static common() {
      return ABViewFormTextboxDefaults;
   }

   static defaultValues() {
      return ABViewFormTextboxPropertyComponentDefaults;
   }

   toObj() {
      // placeholder is a multilingual value:
      this.unTranslate(this.settings, this.settings, ["placeholder"]);

      return super.toObj();
   }

   fromValues(values) {
      super.fromValues(values);

      // placeholder is a multilingual value:
      this.unTranslate(this.settings, this.settings, ["placeholder"]);
   }
}


/***/ }),

/***/ 35272:
/*!****************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewLabelCore.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewLabelCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 53349);


const ABViewLabelPropertyComponentDefaults = {
   text: "",
   format: 0, // 0 - normal, 1 - title, 2 - description
   alignment: "left",
};

const ABViewDefaults = {
   key: "mobile-label", // {string} unique key for this view
   icon: "font", // {string} fa-[icon] reference for this view
   labelKey: "Label", // {string} the multilingual label key for the class label
};

class ABMobileViewLabelCore extends _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewLabelPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, ["label", "text"]);

      var obj = super.toObj();
      obj.viewIDs = [];
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values); // <-- this performs the translations

      // if this is being instantiated on a read from the Property UI,
      // .text is coming in under .settings.label
      this.text = values.text || values.settings.text || "*text";

      this.settings.format =
         this.settings.format || ABViewLabelPropertyComponentDefaults.format;
      this.settings.alignment =
         this.settings.alignment ||
         ABViewLabelPropertyComponentDefaults.alignment;

      // we are not allowed to have sub views:
      this._views = [];

      // convert from "0" => 0
      this.settings.format = parseInt(this.settings.format);

      this.translate(this, this, ["label", "text"]);
   }

   //// Allow external interface to manipulate our settings:

   /**
    * @method formatNormal
    * display text in the normal format.
    */
   formatNormal() {
      this.settings.format = 0;
   }

   /**
    * @method formatTitle
    * display text as a Title.
    */
   formatTitle() {
      this.settings.format = 1;
   }

   /**
    * @method formatDescription
    * display text as a description.
    */
   formatDescription() {
      this.settings.format = 2;
   }
}


/***/ }),

/***/ 26218:
/*!***************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewListCore.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewListCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 53349);


const ABViewListPropertyComponentDefaults = {
   dataviewID: null,
   field: null,
   height: 0,
   hideTitle: 0,
   hideTabs: 0,
};

const ABViewDefaults = {
   key: "mobile-list", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "List", // {string} the multilingual label key for the class label
};

class ABViewListCore extends _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewListPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   field() {
      var dv = this.datacollection;
      if (!dv) return null;

      var object = dv.datasource;
      if (!object) return null;

      return object.fieldByID(this.settings.field);
   }

   /**
    * @method wantsAdd()
    * Some widgets can indicate to their containing ABMobilePage that
    * it wants to provide an [Add] feature.
    * @return {bool}
    */
   get wantsAdd() {
      // we do if we have a setting for linkPageAdd
      return this.settings.linkPageAdd != "";
   }
}


/***/ }),

/***/ 63445:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewTimelineCore.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewTimelineCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 53349);


const ABViewTimelinePropertyComponentDefaults = {
   dataviewID: null,
   field: null,
   height: 0,
   hideTitle: 0,
   hideTabs: 0,
};

const ABViewDefaults = {
   key: "mobile-timeline", // {string} unique key for this view
   icon: "timeline", // {string} fa-[icon] reference for this view
   labelKey: "Timeline", // {string} the multilingual label key for the class label
};

class ABViewTimelineCore extends _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewTimelinePropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   field() {
      var dv = this.datacollection;
      if (!dv) return null;

      var object = dv.datasource;
      if (!object) return null;

      return object.fieldByID(this.settings.field);
   }

   /**
    * @method wantsAdd()
    * Some widgets can indicate to their containing ABMobilePage that
    * it wants to provide an [Add] feature.
    * @return {bool}
    */
   get wantsAdd() {
      // we do if we have a setting for linkPageAdd
      return this.settings.linkPageAdd != "";
   }
}


/***/ }),

/***/ 46446:
/*!*************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/ABProcessLaneCore.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessLaneCore)
/* harmony export */ });
/* harmony import */ var _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/process/ABProcessParticipant */ 74843);
/**
 * ABProcessLane
 * manages the lanes in a Process Diagram.
 *
 * Lanes manage users in the system, and provide a way to lookup a SiteUser.
 */


const ABProcessLaneDefaults = {
   type: "process.lane",
   // {string} .type
   // unique key to reference this specific object

   // icon: "key"
   // {string} .icon
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
};

class ABProcessLaneCore extends _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      super(attributes, process, AB);

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
   }

   static defaults() {
      return ABProcessLaneDefaults;
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      this.type = attributes.type || ABProcessLaneDefaults.type;
   }

   /**
    * @method toObj()
    * properly compile the current state of this object instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   // toObj() {
   //     // default label value
   //     if (!this.label && this.name && this.name != "") {
   //         this.label = this.name;
   //     }

   //     // untranslate this object:
   //     var data = super.toObj();

   //     var fieldsToSave = [
   //         "id",
   //         "name",
   //         "type",
   //         "processID",
   //         "diagramID",
   //         "where"
   //     ];
   //     fieldsToSave.forEach((f) => {
   //         data[f] = this[f];
   //     });

   //     return data;
   // }
}


/***/ }),

/***/ 71206:
/*!********************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/ABProcessParticipantCore.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessParticipantCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ABMLClass */ 46148);
/**
 * ABProcessParticipant
 * manages the participant lanes in a Process Diagram.
 *
 * Participants manage users in the system, and provide a way to lookup a SiteUser.
 */


const ABProcessParticipantDefaults = {
   type: "process.participant",
   // {string} .type
   // unique key to reference this specific object

   // icon: "key" // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
};

class ABProcessParticipantCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      super(["label"], AB);

      this.process = process;
      if (!this.processID) {
         this.processID = process.id;
      }

      this.fromValues(attributes);

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
   }

   static defaults() {
      return ABProcessParticipantDefaults;
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      // These Values are needed By ABDefinition:
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || ABProcessParticipantDefaults.type;
      this.key = attributes.key || ABProcessParticipantDefaults.type;

      // Process Values:
      this.processID = attributes.processID || null;
      this.diagramID = attributes.diagramID || "?diagramID?";
      this.laneIDs = attributes.laneIDs || [];
      this.stashed = false;
      if (attributes.stashed && attributes.stashed != "") {
         this.stashed = attributes.stashed;
      }

      function validChecker(attribute) {
         return typeof attribute != "undefined" && attribute != null;
      }

      this.useRole = 0;
      if (validChecker(attributes.useRole)) {
         this.useRole = parseInt(attributes.useRole);
      }

      this.role = 0;
      if (validChecker(attributes.role)) {
         this.role = attributes.role;
      }

      this.useAccount = 0;
      if (validChecker(attributes.useAccount)) {
         this.useAccount = parseInt(attributes.useAccount);
      }

      this.account = 0;
      if (validChecker(attributes.account)) {
         this.account = attributes.account;
      }

      this.useField = 0;
      if (validChecker(attributes.useField)) {
         this.useField = parseInt(attributes.useField);
      }

      this.userField = [];
      if (validChecker(attributes.userField)) {
         this.userField = attributes.userField;
      }

      // depreciated
      this.fields = [];
      if (validChecker(attributes.fields)) {
         this.fields = attributes.fields;
      }

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label && this.name && this.name != "") {
         this.label = this.name;
      }

      // untranslate this object:
      var data = super.toObj();

      var fieldsToSave = [
         "id",
         "name",
         "type",
         "processID",
         "diagramID",
         "laneIDs",
         "where",
         "useRole",
         "role",
         "useAccount",
         "account",
         "useField",
         "userField",
         "fields",
         "stashed",
      ];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   /**
    * @method onProcessReady()
    * perform any tasks/checks necessary after the parent Process is
    * setup and ready.
    */
   onProcessReady() {}
}


/***/ }),

/***/ 83316:
/*!****************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/ABProcessTaskManager.js ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * ABProcessTaskManager
 *
 * An interface for managing the different ABProcessTasks in AppBuilder.
 *
 */

/*
 * Tasks
 * A name => ABProcessElement hash of the different ABProcessElements available.
 */
var Tasks = {};

/*
 * DEFINITIONTYPES
 * a hash of BPMN:Element.type to Default values
 * for each of our Process Objects.
 *
 * NOTE: For Tasks, the key should be target.type,
 * for Triggers or End elements, the key should be
 * the target.eventDefinitionType
 */
var DEFINITIONTYPES = {};

var AllProcessElements = [
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessEnd */ 76975)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessGatewayExclusive */ 33401)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskEmail */ 21297)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskService */ 66859)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceAccountingBatchProcessing */ 55048)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceAccountingFPClose */ 29084)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceAccountingFPYearClose */ 26575)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceAccountingJEArchive */ 87512)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceCalculate */ 77855)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceInsertRecord */ 22641)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceQuery */ 76061)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceGetResetPasswordUrl */ 47995)),
   await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskSubProcess */ 75175)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskUser */ 67429)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskUserApproval */ 70852)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskUserExternal */ 82659)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskUserForm */ 89476)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTrigger */ 50135)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTriggerLifecycle */ 82712)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTriggerTimer */ 63807)),
];

AllProcessElements.forEach((ELEMENT) => {
   ELEMENT = ELEMENT.default;
   Tasks[ELEMENT.defaults().key] = ELEMENT;

   switch (ELEMENT.defaults().category) {
      case "start":
      case "end":
         DEFINITIONTYPES[ELEMENT.DiagramReplace().target.eventDefinitionType] =
            ELEMENT.defaults();
         break;

      case "gateway":
      case "task":
         DEFINITIONTYPES[ELEMENT.DiagramReplace().target.type] =
            ELEMENT.defaults();
         break;
   }
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   /*
    * @function allTasks
    * return all the currently defined ABProcessTasks in an array.
    * @return [{ABProcessTask},...]
    */
   allTasks: function () {
      var tasks = [];
      for (var t in Tasks) {
         tasks.push(Tasks[t]);
      }
      return tasks;
   },

   /*
    * @function newTask
    * return an instance of an ABProcessTask based upon the values.type value.
    * @return {ABProcessTask}
    */
   newTask: function (values, process, AB) {
      if (values.key) {
         return new Tasks[values.key](values, process, AB);
      } else {
         //// TODO: what to do here?
      }
   },

   DiagramReplaceDefinitionsForType: function (type) {
      var definitions = AllProcessElements.filter((e) => {
         return e.defaults().category == type;
      }).map((e) => {
         return e.DiagramReplace();
      });
      return definitions;
   },

   StartEvents: function () {
      return this.DiagramReplaceDefinitionsForType("start");
   },

   Gateways: function () {
      return this.DiagramReplaceDefinitionsForType("gateway");
   },

   Tasks: function () {
      return this.DiagramReplaceDefinitionsForType("task");
   },

   EndEvents: function () {
      return this.DiagramReplaceDefinitionsForType("end");
   },

   definitionForElement: function (element) {
      // pull the key from the embedded .eventDefinition
      // if there is one
      var key = null;
      if (element.businessObject.eventDefinitions) {
         var def = element.businessObject.eventDefinitions[0];
         if (def) {
            key = def.$type;
         }
      }

      // if not, then just use the base .type
      if (!key) {
         key = element.type;
      }

      return DEFINITIONTYPES[key];
   },
});

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 72935:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessElementCore.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/ABMLClass */ 46148);


class ABProcessTaskCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB, defaultValues) {
      super(["label"], AB);

      this.defaults = defaultValues || { key: "core", icon: "core" };
      // {obj} .defaults
      // a value hash of default values for an ABProcessTask
      // NOTE: needs to be set before .fromValues()

      this.fromValues(attributes);

      this.process = process;
      if (!this.processID) {
         this.processID = process.id;
      }
      // {ABProcess} .process
      // The parent ABProcess this process element is a part of.

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
      this.state = null;
   }

   ///
   /// Static Methods
   ///

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      // ABDefinition Related fields:
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || "process.task.unknown";

      // ABProcess related fields:
      this.key = attributes.key || this.defaults.key || "?key?";
      this.processID = attributes.processID || null;
      this.diagramID = attributes.diagramID || "?diagramID?";
      this.laneDiagramID = attributes.laneDiagramID || "?laneID?";
      // laneDiagramID : connects to the parent object that defines any
      //      default User information for the Task.  In our case, it
      //      might be a {ABProcessParticipant} object, or a {ABProcessLane}
      //      object.  by default, a diagram's Participant obj doesn't define
      //      any lanes, and therefore can provide that info.  Once a lane
      //      is added, however, an object is assigned to it, and the
      //      Lane will provide that info.

      // initialize any defined settings
      if (this.defaults && this.defaults.settings) {
         this.defaults.settings.forEach((s) => {
            if (typeof attributes[s] == "undefined") this[s] = null;
            else this[s] = attributes[s];
         });
      }

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label && this.name && this.name != "") {
         this.label = this.name;
      }

      // untranslate this object:
      var data = super.toObj();

      var fieldsToSave = [
         "id",
         "name",
         "type",
         "processID",
         "diagramID",
         "laneDiagramID",
         "key",
      ];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      // save any defined settings
      if (this.defaults && this.defaults.settings) {
         this.defaults.settings.forEach((s) => {
            data[s] = this[s];
         });
      }

      return data;
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * errorConfig()
    * Respond with an error when expected configuration parameters do not
    * pull data.
    * @param {obj} instance
    *        the instance data of this task
    * @param {string} msg
    *        the display message for this error.
    * @param {array[string]} fields
    *        an array of parameter keys that should be included in the error
    *        for additional information.
    * @return {Promise.reject(error)}
    */
   errorConfig(instance, msg, fields = []) {
      this.log(instance, msg);
      var error = new Error(`${this.type}: ${msg}`);
      var info = { task: this };
      if (!Array.isArray(fields)) fields = [fields];
      fields.forEach((field) => {
         info[field] = this[field];
      });
      this.AB.notify.builder(error, info);
      return Promise.reject(error);
   }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context
    *        the context data of the process instance
    * @param {obj} defaults
    *        any values to include from our child classes
    * @param {obj} val
    *        any values to override the default state
    */
   initState(context, defaults, val) {
      defaults = defaults || {};
      if (!val) {
         val = defaults;
         defaults = {};

         // in this case, then auto initi blank instanceValues:
         if (this.defaults && this.defaults.instanceValues) {
            this.defaults.instanceValues.forEach((v) => {
               defaults[v] = null;
            });
         }
      }

      context.taskState = context.taskState || {};

      // don't overwrite your settings if they already exist:
      if (!context.taskState[this.diagramID]) {
         context.taskState[this.diagramID] = {
            initialized: true,
            status: "initialized",
         };
         for (var d in defaults) {
            context.taskState[this.diagramID][d] = defaults[d];
         }
         for (var v in val) {
            context.taskState[this.diagramID][v] = val[v];
         }
      }
   }

   /*
    * @function isEndTask
    * return true if the current type of task is an End task. False otherwise.
    * @return {bool}
    */
   isEndTask() {
      return false;
   }

   /**
    * log()
    * enter a log in the current process instance
    * @param {obj} instance  the current ABProcessInstance
    * @param {...} ...allArgs the remaining parameters sent to the log
    */
   log(instance, ...allArgs) {
      var text = `${this.diagramID} : ${
         this.name ? this.name : this.key
      } : ${allArgs.join(" ")}`;
      instance.log.push(text);
   }

   /**
    * myLane()
    * return the ABProcessParticipant | ABProcessLane element we are
    * in.
    * @return {ABProcessParticipant|ABProcessLane}
    */
   myLane() {
      return this.process.elementForDiagramID(this.laneDiagramID);
   }

   /**
    * myState()
    * return the current state values for this ABProcessTask
    * @param {obj} instance  the current ABProcessInstance
    * @return {obj}
    */
   myState(instance) {
      return instance.context.taskState[this.diagramID];
   }

   /**
    * nextTasks()
    * follow the current instance diagram and return the next task(s)
    * after this task.
    * @param {obj} instance  the current ABProcessInstance
    * @return {array}  [ABProcessTask, ...] or {null} if an error
    */
   nextTasks(instance) {
      var nextTasks = [];

      var myDiagramObj = instance.hashDiagramObjects[this.diagramID];
      if (!myDiagramObj) {
         let error = new Error(
            `Configuration Error: Did not find my definition for dID[${this.diagramID}]`
         );
         this.onError(instance, error);
         return null;
      }

      // myDiagramObj :
      // {
      //     "bpmn2:outgoing": [{"_text": "SequenceFlow_00fbxm3"} ...],
      //     "_attributes": {id: "StartEvent_1"},
      //     "_type": "start"
      // }

      // find my possible exits:
      var exitFlows = myDiagramObj["bpmn2:outgoing"];
      if (!exitFlows) {
         let error = new Error(
            `Configuration Error: Did not find any outgoing flows for dID[${this.diagramID}]`
         );
         this.AB.notify.builder(error, { task: this });
         this.onError(instance, error);
         return null;
      }

      if (!Array.isArray(exitFlows)) {
         exitFlows = [exitFlows];
      }

      var tasksFromFlow = (flow) => {
         // follow a flow and grab each of it's exit tasks
         // place them into nextTasks[];

         var flowObj = instance.hashDiagramObjects[flow["_text"]];
         if (!flowObj) return;

         var targetIDs = flowObj["_attributes"]["targetRef"];
         if (!targetIDs) return;

         if (!Array.isArray(targetIDs)) {
            targetIDs = [targetIDs];
         }

         targetIDs.forEach((tid) => {
            var targetTask = this.process.elementForDiagramID(tid);
            if (targetTask) {
               if (nextTasks) {
                  nextTasks.push(targetTask);
               }
            } else {
               let error = new Error(
                  `Configuration Error: No ProcessTask instance for diagramID[${tid}]`
               );
               this.AB.notify.builder(error, { task: this });
               this.onError(instance, error);
               nextTasks = null;
            }
         });
      };

      exitFlows.forEach((f) => {
         tasksFromFlow(f);
      });

      return nextTasks;
   }

   /**
    * onError()
    * perform the following actions (log it) on an error.
    * @param {obj} instance  the current ABProcessInstance
    * @param {Error} error
    */
   onError(instance, error) {
      if (error) {
         var text = `${error.toString()}`;
         this.log(instance, text);
      }
      var myState = this.myState(instance);
      myState.status = "error";
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can request from other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return null;
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      return null;
   }

   /**
    * processDataObjects()
    * return an array of avaiable ABObjects that this element
    * can provide to other ProcessElements.
    * @return {array} | null
    */
   processDataObjects() {
      return null;
   }

   /**
    * hashProcessDataValues()
    * return a hash of live Process Data Values
    * @param {obj} instance
    * @return {array} | null
    */
   hashProcessDataValues(instance) {
      var listDataFields = this.process.processDataFields(this);
      var currentProcessValues = {};
      listDataFields.forEach((f) => {
         currentProcessValues[f.key] = this.process.processData(this, [
            instance,
            f.key,
         ]);
      });
      return currentProcessValues;
   }

   /**
    * reset()
    * prepare this task to run again if it was already completed.
    *
    * This might happen in a process where a loop is formed and tasks
    * are repeated until a certain outcome.
    *
    * @param {obj} instance  the current ABProcessInstance
    */
   reset(instance) {
      // a task wants to run me.  Possibly again.
      var myState = this.myState(instance);

      // if I haven't setup my state (why?) then just
      // do that again:
      if (!myState) {
         this.initState(instance.context);
      } else {
         // if I have already "completed" and we are being
         // asked to run again (it's possible)
         if (myState.status == "completed" || myState.status == "error") {
            // remove my current state
            delete instance.context.taskState[this.diagramID];

            // store a new state in the context
            this.initState(instance.context);

            // remember our previous state
            var newState = this.myState(instance);
            newState._prevState = myState;
            this.log(instance, " Reset() called. Running again. ");
         }
      }
   }

   /**
    * stateCompleted()
    * mark this task has having completed.
    * @param {obj} instance  the current ABProcessInstance
    */
   stateCompleted(instance) {
      var myState = this.myState(instance);
      myState.status = "completed";
   }

   /**
    * stateUpdate()
    * update my state values with the given values data
    * @param {obj} instance  the current ABProcessInstance
    * @param {obj} values    the new state values
    */
   stateUpdate(instance, values) {
      values = values || {};
      var myState = this.myState(instance);
      for (var v in values) {
         myState[v] = values[v];
      }
   }

   /**
    * wantToDoSomething()
    * determine if this task still has something to do.
    * @param {obj} instance  the instance data of the process we are working on
    * @return {bool} true if there is still pending actions
    */
   wantToDoSomething(instance) {
      var state = this.myState(instance);
      if (state) {
         return state.status != "completed" && state.status != "error";
      } else {
         // my state wasn't defined?
         console.warn(
            "ABProcessTaskCore:wantToDoSomething(): called without having initialized our state first.",
            instance
         );
         // initialize our state and try again
         this.initState(instance.context);
         return this.wantToDoSomething(instance);
      }
   }

   /**
    * @method onProcessReady()
    * Perform any setup actions after the parent process has indicated it is "ready"
    */
   onProcessReady() {}

   get startElements() {
      let startElems =
         this.process.elements(
            (elem) =>
               elem && elem.defaults && elem.defaults.category === "start"
         ) || [];
      return startElems;
   }

   get previousElements() {
      return this.process.connectionPreviousTask(this);
   }

   get objectOfStartElement() {
      const startElem = this.startElements[0];
      if (!startElem) return null;

      return this.AB.objectByID(startElem.objectID);
   }

   get objectOfPrevElement() {
      let prevElem = this.previousElements[0];
      if (!prevElem) return null;

      let objectID;
      switch (prevElem.type) {
         case "process.task.service.query":
            objectID = prevElem.qlObj ? prevElem.qlObj.objectID : null;
            break;
         case "process.task.service.insertRecord":
         default:
            objectID = prevElem.objectID;
            break;
      }

      return this.AB.objectByID(objectID);
   }
}


/***/ }),

/***/ 15728:
/*!******************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessEndCore.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskEndCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


var ABProcessTaskEndDefaults = {
   category: "end",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "stop",
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to
   // reference 'fa-user'

   key: "End",
   // key: {string}
   // unique key to reference this specific Task
};

class ABProcessTaskEndCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.end";
      super(attributes, process, AB, ABProcessTaskEndDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskEndDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Terminate End Event",
         actionName: "replace-with-terminate-end",
         className: "bpmn-icon-end-event-terminate",
         target: {
            type: "bpmn:EndEvent",
            eventDefinitionType: "bpmn:TerminateEventDefinition",
         },
      };
   }

   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // An End Event doesn't perform any other actions
   //         // than to signal it has successfully completed.
   //         // But it provides no Additional Tasks to work on.
   //         // for testing:
   //         this.stateCompleted(instance);
   //         this.log(instance, "End Event Reached");
   //         resolve(true);
   //     });
   // }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   initState(context, val) {
      var myDefaults = {
         triggered: false,
      };

      super.initState(context, myDefaults, val);
   }

   /*
    * @function isEndTask
    * return true if the current type of task is an End task. False otherwise.
    * @return {bool}
    */
   isEndTask() {
      return true;
   }

   /**
    * nextTasks()
    * return the next tasks to be run after this task is complete.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve([])
    */
   nextTasks(instance) {
      // I'm an End Event.  There are no nextTasks()
      return [];
   }
}


/***/ }),

/***/ 89670:
/*!*******************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessGatewayExclusiveCore.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessGatewayExclusiveCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


var ABProcessGatewayExclusiveDefaults = {
   category: "gateway",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle",
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to
   // reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "GatewayExclusive",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["conditions"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

class ABProcessGatewayExclusiveCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.gateway.exclusive";
      super(attributes, process, AB, ABProcessGatewayExclusiveDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessGatewayExclusiveDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Exclusive Gateway",
         actionName: "replace-with-exclusive-gateway",
         className: "bpmn-icon-gateway-xor",
         target: {
            type: "bpmn:ExclusiveGateway",
         },
      };
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      this.conditions = this.conditions || {};
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        ABProcessGatewayExclusiveDefaults.fields.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            userFormID: null,
            userFormResponse: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.userFormResponse`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
}


/***/ }),

/***/ 95316:
/*!************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskEmailCore.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskEmailCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);
// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()


var ABProcessTaskEmailDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [
      "to",
      "from",
      "subject",
      "message",
      "toCustom",
      "fromCustom",
      "toUsers",
      "fromUsers",
      "toCustomFields",
      "fromCustomFields",
   ],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "email", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "Email",
   // key: {string}
   // unique key to reference this specific Task
};

class ABProcessTaskEmailCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.email";
      super(attributes, process, AB, ABProcessTaskEmailDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskEmailDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Send Task",
         actionName: "replace-with-send-task",
         className: "bpmn-icon-send",
         target: {
            type: "bpmn:SendTask",
         },
      };
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      ABProcessTaskEmailDefaults.fields.forEach((f) => {
         this[f] = attributes[f];
      });
   }

   /**
    * onProcessReady()
    * Perform our warnings checks once the parent Process is ready
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      ABProcessTaskEmailDefaults.fields.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // for testing:
   //         var myState = this.myState(instance);
   //         myState.status = "completed";
   //         this.log(instance, "Email Sent successfully");
   //         resolve(true);
   //     });
   // }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   initState(context, val) {
      var myDefaults = {
         to: [],
         from: [],
         subject: this.subject,
         message: this.message,
      };

      super.initState(context, myDefaults, val);
   }
}


/***/ }),

/***/ 80281:
/*!***************************************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingBatchProcessingCore.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AccountingBatchProcessingCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


var AccountingBatchProcessingDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingBatchProcessing",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "objectBatch",
      "processBatchValue",
      "fieldBatchEntries",
      "fieldBatchFinancialPeriod",
      "objectJE",
      "fieldJEAccount",
      "fieldJERC",
      "fieldJEStatus",
      "fieldJEStatusComplete",
      "objectBR",
      "fieldBRFinancialPeriod",
      "fieldBRAccount",
      "fieldBRRC",
      "fieldBREntries",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

class AccountingBatchProcessingCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.batchProcessing";
      super(attributes, process, AB, AccountingBatchProcessingDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingBatchProcessingDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
}


/***/ }),

/***/ 35137:
/*!*******************************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingFPCloseCore.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AccountingFPCloseCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


var AccountingFPCloseDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingFPClose",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "processFPValue",
      "objectFP",
      "objectGL",
      "objectAcc",
      "fieldFPStart",
      "fieldFPOpen",
      "fieldFPStatus",
      "fieldFPActive",
      "fieldGLStarting",
      "fieldGLRunning",
      "fieldGLAccount",
      "fieldGLRc",
      "fieldGLDebit",
      "fieldGLCredit",
      "fieldAccType",
      "fieldAccAsset",
      "fieldAccExpense",
      "fieldAccLiabilities",
      "fieldAccEquity",
      "fieldAccIncome",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

class AccountingFPCloseCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.fpClose";
      super(attributes, process, AB, AccountingFPCloseDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingFPCloseDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingFPCloseDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingFPCloseDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
}


/***/ }),

/***/ 41211:
/*!***********************************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingFPYearCloseCore.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AccountingFPYearCloseCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


var AccountingFPYearCloseDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingFPYearClose",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "processFPYearValue",
      "objectFPYear",
      "objectFPMonth",
      "objectGL",
      "objectAccount",
      "valueFundBalances",
      "valueNetIncome",
      "fieldFPYearStart",
      "fieldFPYearEnd",
      "fieldFPYearStatus",
      "fieldFPYearActive",
      "fieldFPMonthStart",
      "fieldFPMonthEnd",
      "fieldGLStartBalance",
      "fieldGLRunningBalance",
      "fieldGLrc",
      "fieldAccNumber",
      "fieldAccType",
      "fieldAccTypeIncome",
      "fieldAccTypeExpense",
      "fieldAccTypeEquity",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

class AccountingFPYearCloseCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.fpYearClose";
      super(attributes, process, AB, AccountingFPYearCloseDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingFPYearCloseDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingFPCloseDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingFPCloseDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
}


/***/ }),

/***/ 96974:
/*!*********************************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingJEArchiveCore.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AccountingJEArchiveCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


let AccountingJEArchiveDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "archive", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingJEArchive",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "processBatchValue",
      "objectBatch",
      "objectBalance",
      "objectJE",
      "objectJEArchive",

      "fieldBatchFiscalMonth",
      "fieldJeAccount",
      "fieldJeRC",
      "fieldJeArchiveBalance",
      "fieldBrFiscalMonth",
      "fieldBrAccount",
      "fieldBrRC",
      "fieldsMatch",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

class AccountingJEArchiveCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.jeArchive";
      super(attributes, process, AB, AccountingJEArchiveDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingJEArchiveDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
}


/***/ }),

/***/ 97286:
/*!***********************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskServiceCalculateCore.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CalculateTaskCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


let CalculateDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "calculator", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "Calculate",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["formulaText"],
};

class CalculateTaskCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.calculate";
      super(attributes, process, AB, CalculateDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return CalculateDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      const label = `${this.label}->Value`;
      // this is a calculate task, so let's include a fake ABFieldNumber
      // for the .field value, so other tasks that limit their operations
      // to fields can use this as a number
      if (!this._fakeNum) {
         this._fakeObj = this.AB.objectNew({});
         this._fakeNum = this.AB.fieldNew(
            { key: "number", name: label, label },
            this._fakeObj
         );
      }
      return {
         key: `${this.id}.value`,
         label,
         field: this._fakeNum,
      };
   }
}


/***/ }),

/***/ 74351:
/*!**************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskServiceCore.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskServiceCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);
/**
 * ABProcessTaskServiceCore
 *
 * This defines the base Service Task element that can be placed on a BPMN
 * diagram.  In our system, we will let the designer choose a sub class
 * to make active for this element.
 *
 * Currently a ServiceTask performs a dedicated operation on the server.
 *  - performing a query, looking up data, etc...
 *
 */


var ABProcessTaskServiceDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "TaskService",
   // key: {string}
   // unique key to reference this specific Task

   settings: [],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

class ABProcessTaskServiceCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service";
      super(attributes, process, AB, ABProcessTaskServiceDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskServiceDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Service Task",
         actionName: "replace-with-service-task",
         className: "bpmn-icon-service",
         target: {
            type: "bpmn:ServiceTask",
         },
      };
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        ABProcessTaskServiceDefaults.fields.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        ABProcessTaskServiceDefaults.fields.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            userFormID: null,
            userFormResponse: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.userFormResponse`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
}


/***/ }),

/***/ 25418:
/*!*********************************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskServiceGetResetPasswordUrlCore.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskGetResetPasswordUrlCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);
// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()


const ABProcessTaskGetResetPasswordUrlDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "plus-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "GetResetPasswordUrl",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["email"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

class ABProcessTaskGetResetPasswordUrlCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.getResetPasswordUrl";
      super(attributes, process, AB, ABProcessTaskGetResetPasswordUrlDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskGetResetPasswordUrlDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return {
         key: `${this.id}.url`,
         label: `${this.label}->URL`,
      };
   }
}


/***/ }),

/***/ 45136:
/*!**************************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskServiceInsertRecordCore.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ InsertRecordCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


let InsertRecordDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "plus-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "InsertRecord",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "objectID",
      "fieldValues",
      "isRepeat",
      "repeatMode",
      "repeatColumn",
   ],
};

class InsertRecordCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.insertRecord";
      super(attributes, process, AB, InsertRecordDefaults);

      this.results = [];

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return InsertRecordDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.isRepeat = JSON.parse(attributes.isRepeat || false);
   }

   get startElement() {
      let startElem = null;
      let currProcess = this.process;

      // Find the start (trigger) task
      while (!startElem && currProcess) {
         startElem = currProcess.elements(
            (elem) => elem?.defaults?.category == "start"
         )[0];

         // If .currProcess is a sub task, then go to the parent process for get the start task
         currProcess = currProcess.process;
      }

      return startElem;
   }

   get previousElement() {
      return this.process.connectionPreviousTask(this)[0];
   }

   get objectOfStartElement() {
      let startElem = this.startElement;
      if (!startElem) return null;

      let startElemObj = this.AB.objectByID(startElem.objectID);
      return startElemObj;
   }

   get objectOfPrevElement() {
      let prevElem = this.previousElement;
      if (!prevElem) return null;

      let objectID;
      switch (prevElem.type) {
         case "process.task.service.query":
            objectID = prevElem.qlObj ? prevElem.qlObj.objectID : null;
            break;
         case "process.task.service.insertRecord":
         default:
            objectID = prevElem.objectID;
            break;
      }

      return this.AB.objectByID(objectID);
   }

   get fieldRepeat() {
      let obj = this.objectOfStartElement;
      if (!obj) return null;

      return obj.fields((f) => f.id == this.repeatColumn)[0];
   }

   /**
    * processDataFields()
    * return a single available data field from this element
    * this will be the record inserted by this task
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return [
         {
            key: `${this.id}.[PK]`,
            label: `${this.label}-> Inserted record [PK]`,
            field: {
               id: this.id,
               object: { id: this.objectID },
               key: "InsertedRecord",
               columnName: "uuid",
            },
            object: this.objectID,
            set: true,
         },
      ];
   }
   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
     toObj() {
         var data = super.toObj();
 
         AccountingBatchProcessingDefaults.settings.forEach((f) => {
             data[f] = this[f];
         });
 
         return data;
     }
     */

   ////
   //// Process Instance Methods
   ////
}


/***/ }),

/***/ 79078:
/*!*******************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskServiceQueryCore.js ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskServiceQueryCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);
/* harmony import */ var _platform_ql_ABQLManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../platform/ql/ABQLManager.js */ 66586);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_platform_ql_ABQLManager_js__WEBPACK_IMPORTED_MODULE_1__]);
_platform_ql_ABQLManager_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




const ABProcessTaskServiceQueryDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "TaskServiceQuery",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["qlObj"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

class ABProcessTaskServiceQueryCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.query";
      super(attributes, process, AB, ABProcessTaskServiceQueryDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskServiceQueryDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      // Before we make instances of qlObj:
      this._datasources = [];

      // comvert our qlObj into an ABQLxxx instance.
      if (this.qlObj) {
         this.qlObj = _platform_ql_ABQLManager_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromAttributes(this.qlObj, this, this.AB);
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this object instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      const data = super.toObj();

      // convert qlObj into obj format:
      if (this.qlObj) data.qlObj = this.qlObj.toObj();

      return data;
   }

   registerDatasource(obj) {
      this._datasources.push(obj);
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        const myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      // in this Task, we can return the Response to the UserForm
      let fields = null;

      if (this._datasources.length > 0) {
         fields = [];

         this._datasources.forEach((s) => {
            const param = s.processDataField(this.id, this.label);

            if (param) {
               fields.push(param);
            }
         });
      }

      return fields;
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      const parts = key.split(".");

      if (parts[0] === this.id) {
         const myState = this.myState(instance);

         return myState[parts[1]];
      }

      return null;
   }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 76987:
/*!*****************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskSubProcessCore.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SubProcessCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


let SubProcessDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "object-group", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "SubProcess",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "isEnable",
      "parameterId",
      "connectionAttrs",
      "elementIDs",
      "loopType",
   ],
};

const NOSPAM = {
   /*message : bool */
};
// prevent sending the same message over and over.

class SubProcessCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.subProcess";
      super(attributes, process, AB, SubProcessDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return SubProcessDefaults;
   }

   static DiagramReplace() {
      // taken from "bpmn-js/lib/features/replace/ReplaceOptions"
      return {
         label: "Sub Process",
         actionName: "replace-with-subprocess",
         className: "bpmn-icon-subprocess-expanded",
         target: {
            type: "bpmn:SubProcess",
            isExpanded: true,
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      // Convert string to boolean
      this.isEnable = this.isEnable == null ? true : JSON.parse(this.isEnable);

      let currElements = this._elements || {};
      this._unknownElementIDs = [];
      this._elements = {};
      (attributes.elementIDs || []).forEach((eID) => {
         let ele = this.AB.processElementNew(eID, this);
         if (ele) {
            this._elements[eID] = ele;
         } else {
            // current eID isn't one of our definitions yet, so might be
            // a temporary .diagramID from an unsaved task:
            if (currElements[eID]) {
               this._elements[eID] = currElements[eID];
            } else {
               this._unknownElementIDs.push(eID);
            }
         }
      });

      this._unknownElementIDs.forEach((eID) => {
         let key = `Process[${this.processID}] Task[${this.label}] is referencing an unknown element id:[${eID}]`;
         if (!NOSPAM[key]) {
            let err = new Error(key);
            this.AB.notify.builder(err, { processTask: this.id, eID });
            NOSPAM[key] = true;
         }
      });

      this._connections = attributes.connectionAttrs || {};
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      let data = super.toObj();

      data.elementIDs = [];
      for (let e in this._elements) {
         data.elementIDs.push(this._elements[e].id);
      }

      data.connectionAttrs = this._connections;

      return data;
   }

   /**
    * @method processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataFields(currElement) {
      if (this.parameterId == null) return [];

      // only call processDataFields once, filter it to get the different queries
      let dataFieldsAll = this.process.processDataFields(this) || [];

      // get the subtask data
      let dataFieldOpt = dataFieldsAll.filter(
         (opt) => opt.key === this.parameterId
      )[0];

      // get data from insert tasks
      let dataFieldsAllInserted = dataFieldsAll.filter(
         (opt) => (opt?.field?.key ?? opt?.field) === "InsertedRecord"
      );

      if (dataFieldOpt == null) return [];

      let result = [];

      // Connect field type
      if (
         dataFieldOpt.field &&
         dataFieldOpt.field.key == "connectObject" &&
         dataFieldOpt.field.datasourceLink &&
         dataFieldOpt.field.datasourceLink.fields
      ) {
         result.push({
            key: `${this.id}.uuid`,
            label: `${this.label}->Repeat Data.ID`,
            object: dataFieldOpt.field.datasourceLink,
         });

         dataFieldOpt.field.datasourceLink.fields().forEach((f) => {
            result.push({
               key: `${this.id}.${f.id}`,
               label: `${this.label}->Repeat Data.${f.label}`,
               field: f,
               object: f.object,
            });
         });
      }
      // Other field types
      else {
         result.push({
            key: dataFieldOpt.field
               ? `${this.id}.${dataFieldOpt.field.id}`
               : `${this.id}.subProcess`,
            label: `${this.label}->Repeat Data`,
            field: dataFieldOpt.field,
            object: dataFieldOpt.object,
         });
      }

      dataFieldsAllInserted.forEach((opt) => {
         result.push({
            key: `${opt.key || opt.id}`,
            label: `Parent Process Data->${opt.label}`,
            field: opt.field,
            object: opt.object,
         });
      });

      // Get any tasks that exist inside the subprocess
      let previousFields = this.process.processDataFields.call(
         this,
         currElement
      );
      if (previousFields && previousFields.length > 0) {
         result = result.concat(previousFields);
      }

      return result;
   }

   /**
    * @method processData()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processData(currElement, params) {
      let instance = params[0];
      let key = params[1];
      let data;

      if (instance && key?.startsWith?.(this.id)) {
         let fieldId = key.split(".")[1];
         let myState = this.myState(instance);
         let stateData = myState ? myState.data : null;
         data = stateData;

         if (stateData && fieldId) {
            let dataFieldOpt = (
               this.process.processDataFields(this) || []
            ).filter((opt) => opt.key == this.parameterId)[0];

            if (dataFieldOpt?.field?.key == "connectObject") {
               if (!Array.isArray(stateData)) stateData = [stateData];

               // Extract data
               data = stateData.map((item) => {
                  if (fieldId == "uuid" || fieldId == "id") {
                     return item.uuid || item.id || item;
                  } else if (dataFieldOpt.field.datasourceLink) {
                     let returnField = dataFieldOpt.field.datasourceLink.fields(
                        (f) => f.id == fieldId
                     )[0];
                     if (returnField) return item[returnField.columnName];
                     else return item;
                  }
               });
            }
         }
      }

      // Filter none data items
      if (Array.isArray(data)) data = data.filter((d) => d != null);

      if (data == null || data.length == 0)
         data = this.process.processData.call(this, currElement, params);

      if (data == null || data.length == 0)
         data = this.process.processData(this, params);

      return data;
   }

   allPreviousTasks(...params) {
      return this.process.allPreviousTasks.call(this, ...params);
   }

   allPreviousConnectionsForElement(...params) {
      return this.process.allPreviousConnectionsForElement.call(
         this,
         ...params
      );
   }

   allPreviousConnectionsForConnection(...params) {
      return this.process.allPreviousConnectionsForConnection.call(
         this,
         ...params
      );
   }

   //
   // Diagram Elements
   //

   /**
    * @method connections()
    * return an array of connections that describe the relationships between
    * our process elements.
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return [{SimpleConnectionObj}]
    */
   connections(fn) {
      return this.process.connections.call(this, fn);
   }

   /**
    * @method connectionForDiagramID()
    * return the connection for the given diagram id
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionForDiagramID(dID) {
      if (!dID) return;

      return this.process.connectionForDiagramID.call(this, dID);
   }

   /**
    * @method connectionsIncoming()
    * return the connections that are entering this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsIncoming(dID) {
      if (!dID) return;

      return this.process.connectionsIncoming.call(this, dID);
   }

   /**
    * @method connectionsOutgoing()
    * return the connections that are leaving this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsOutgoing(dID) {
      if (!dID) return;

      return this.process.connectionsOutgoing.call(this, dID);
   }

   /**
    * @method connectionRemove()
    * remove the connection info for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionRemove(element) {
      if (!element) return;

      this.process.connectionRemove.call(this, element);
   }

   /**
    * @method connectionSimplyElement()
    * given a BPMN diagram element, return a simplified object that describes
    * the connection between two elements.
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    * @return {SimpleConnectionObj}
    *        .id : {string} diagram id of the connection element
    *        .type : {string} the type of connection
    *        .from : {string} the diagram id of the source element
    *        .to : {string} the diagram id of the dest element
    */
   connectionSimplyElement(element) {
      if (!element) return;

      return this.process.connectionSimplyElement.call(this, element);
   }

   /**
    * @method connectionUpsert()
    * add or update the connection information for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionUpsert(element) {
      if (!element) return;

      this.process.connectionUpsert.call(this, element);
   }

   /**
    * @method connectionPreviousTask()
    * return the ABProcessElement(s) that was a previous Element
    * (eg connects to) this element.
    * @param {ABProcessElement} currElement
    * @return {array}
    */
   connectionPreviousTask(currElement) {
      if (!currElement) return;

      return this.process.connectionPreviousTask.call(this, currElement);
   }

   /**
    * @method elements()
    * return an array of elements that match the given filter (or all elements
    * if no filter is provided).
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return {[ABProcessTask, ABProcessParticipant, etc...]}
    */
   elements(fn = () => true) {
      return this.process.elements.call(this, fn);
   }

   /**
    * @method elementAdd()
    * insert an element to be tracked by this process.
    * @param {ABProcessElement} element
    *        the full instance of an ABProcessElement to track.
    */
   elementAdd(element) {
      if (!element) return;

      this.process.elementAdd.call(this, element);
   }

   /**
    * @method elementForDiagramID()
    * return the object that is tied to the given xml diagram ID.
    * @param {string} dID the diagram ID
    * @return {ABProcess[OBJ]}
    */
   elementForDiagramID(dID) {
      if (!dID) return null;

      return this.process.elementForDiagramID.call(this, dID);
   }

   /**
    * @method elementRemove()
    * remove an element from being tracked by this process.
    * @param {obj|ABProcessElement} def
    *        a definition of, or full Object instance of the ABProcessElement
    *        to remove.
    */
   elementRemove(def) {
      if (!def) return;

      this.process.elementRemove.call(this, def);
   }
}


/***/ }),

/***/ 45383:
/*!*******************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskUserApprovalCore.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskUserApprovalCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);
/* harmony import */ var _platform_dataFields_ABFieldList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../platform/dataFields/ABFieldList.js */ 23122);




var ABProcessTaskApprovalDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: ["userFormID", "userFormResponse"],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "Approval",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["who", "toUsers", "formBuilder"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

class ABProcessTaskUserApprovalCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.user.approval";
      super(attributes, process, AB, ABProcessTaskApprovalDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskApprovalDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      function fixBoolean(obj) {
         if (obj) {
            Object.keys(obj).forEach((k) => {
               if (obj[k] == "false") {
                  obj[k] = false;
               } else if (obj[k] == "true") {
                  obj[k] = true;
               } else if (typeof obj[k] == "object") {
                  fixBoolean(obj[k]);
               }
            });
         }
      }
      fixBoolean(this.formBuilder);
   }

   /**
    * @method toObj()
    * properly compile the current state of this object instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   /*     
    toObj() {
        var data = super.toObj();

        ABProcessTaskApprovalDefaults.fields.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
*/
   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {};
        ABProcessTaskApprovalDefaults.instanceValues.forEach((v) => {
            myDefaults[v] = null;
        });

        super.initState(context, myDefaults, val);
    }
*/

   /*
    * preProcessFormIOComponents()
    * we need to parse the form.io components to ensure the proper columnName
    * and labels are being used. We also will translate the columnNames at this
    * point in the code
    */
   preProcessFormIOComponents() {
      var fields = this.process.processDataFields(this);
      if (fields && this.formBuilder && this.formBuilder.components) {
         this.formBuilder.components.forEach((c) => {
            if (c.abFieldID) {
               fields.filter((entry) => {
                  if (entry.field?.id == c.abFieldID) {
                     c.label = entry.field.label;
                     c.key = entry.key;
                     if (c.data?.values && entry.field.settings.options) {
                        var vals = [];
                        entry.field.settings.options.forEach((opt) => {
                           vals.push({
                              label: opt.text,
                              value: opt.id,
                           });
                        });
                        c.data.values = vals;
                     }
                  }
               });
            } else if (c.components && c.components.length) {
               c.key = c.path;
               c.components.forEach((o) => {
                  if (o.abFieldID) {
                     // these are plucked conneted values
                     // gather up all their fields to be used
                     var pluck = fields.filter((f) => {
                        return f.key == c.path;
                     })[0];
                     if (!pluck) return;
                     pluck.object.fields().filter((entry) => {
                        if (entry?.id == o.abFieldID) {
                           o.label = entry.label;
                           o.key = entry.columnName;
                           if (o.data?.values && entry.settings.options) {
                              var vals = [];
                              entry.settings.options.forEach((opt) => {
                                 vals.push({
                                    label: opt.text,
                                    value: opt.id,
                                 });
                              });
                              o.data.values = vals;
                           }
                        }
                     });
                  }
               });
            }
         });
      }
      return this.formBuilder;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      // we need to get the button events defined by the form.io formBuilder
      var options = [];
      this.formBuilder.components.forEach((comp) => {
         if (comp.type == "button" && comp.action == "event" && comp.event) {
            options.push({
               id: comp.event,
               text: comp.label,
            });
         }
      });
      // in this Task, we can return the Response to the UserForm
      // The Response can be in the form of a List Field, with one or more
      // return options.

      var myID = this.diagramID;

      // create an ABFieldList object:
      // make sure the options follow what is currently defined for our
      // responses:
      var myObj = this.AB.objectNew({});
      var listField = new _platform_dataFields_ABFieldList_js__WEBPACK_IMPORTED_MODULE_1__["default"](
         {
            id: `${myID}.userFormResponse`,
            label: `${this.label}->Response`,
            columnName: `${myID}.userFormResponse`,
            settings: {
               options: options,
            },
         },
         myObj
      );

      // NOTE: We are pretending our response is a type of ABFieldList. But our
      // ABField objects no longer allow "." in our columnNames:
      //    ( https://github.com/digi-serve/appbuilder_class_core/blob/212cf5fa1c1d5c959aa246c730582ed50809ee0f/dataFields/ABFieldCore.js#L262 )
      // But our Process tasks really will be expecting it there so lets put
      // it back:
      listField.columnName = `${myID}.userFormResponse`;

      return [
         {
            key: `${myID}.userFormResponse`,
            label: `${this.label}->Response`,
            field: listField,
            object: null,
         },
      ];
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      if (key) {
         var parts = key.split(".");
         if (parts[0] == this.diagramID) {
            var myState = this.myState(instance);
            return myState[parts[1]];
         }
      }
      return null;
   }
}


/***/ }),

/***/ 29564:
/*!***********************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskUserCore.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskUserCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);
/**
 * ABProcessTaskUserCore
 *
 * This defines the base User Task element that can be placed on a BPMN
 * diagram.  In our system, we will let the designer choose a sub class
 * to make active for this element.
 *
 * Currently a UserTask expects a human user to perform an action.  These
 * actions are in the possible forms:
 *  - confirm offline action
 *  - approve data
 *  - fill out a form
 *
 */



var ABProcessTaskUserDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "user", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "TaskUser",
   // key: {string}
   // unique key to reference this specific Task

   settings: [],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

class ABProcessTaskUserCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.user";
      super(attributes, process, AB, ABProcessTaskUserDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskUserDefaults;
   }

   static DiagramReplace() {
      // taken from "bpmn-js/lib/features/replace/ReplaceOptions"
      return {
         label: "User Task",
         actionName: "replace-with-user-task",
         className: "bpmn-icon-user",
         target: {
            type: "bpmn:UserTask",
         },
      };
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // for testing:
   //         var myState = this.myState(instance);
   //         myState.status = "completed";
   //         this.log(instance, "Email Sent successfully");
   //         resolve(true);
   //     });
   // }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   initState(context, val) {
      var myDefaults = {
         roles: [],
         ui: null,
      };

      super.initState(context, myDefaults, val);
   }
}


/***/ }),

/***/ 9879:
/*!*******************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskUserExternalCore.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskUserExternalCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);
// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()


const ABProcessTaskUserExternalDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "plus-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: ["userFormID", "userFormResponse"],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "External",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["who", "toUsers", "url"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

const settings = {
   who: 0,
   toUsers: null,
   url: "",
};

class ABProcessTaskUserExternalCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      for (const key in settings)
         attributes[key] = attributes[key] ?? settings[key];
      super(
         Object.assign(
            {
               type: "process.task.service.external",
            },
            attributes
         ),
         process,
         AB,
         ABProcessTaskUserExternalDefaults
      );

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskUserExternalDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return [
         {
            key: `${this.id}.userFormResponse`,
            label: `${this.label}->Response`,
         },
      ];
   }
}


/***/ }),

/***/ 53205:
/*!***************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskUserFormCore.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskUserFormCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


const ABProcessTaskUserFormDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "form", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [""],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "Form",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["formBuilder"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

const settings = {};

class ABProcessTaskUserFormCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      for (const key in settings)
         attributes[key] = attributes[key] ?? settings[key];
      super(
         Object.assign(
            {
               type: "process.task.service.form",
            },
            attributes
         ),
         process,
         AB,
         ABProcessTaskUserFormDefaults
      );

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskUserFormDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return (this.formBuilder?.components ?? [])
         .filter((comp) => comp.type != "button")
         .map((comp) => {
            return {
               key: comp.key,
               label: `${this.label}->${comp.label}`,
            };
         });
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      if (!key) return null;

      const myState = this.myState(instance);

      return myState[key];
   }
}


/***/ }),

/***/ 63438:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTriggerCore.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTriggerCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


var ABProcessTriggerDefaults = {
   category: "start",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "key", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "Trigger",
   // key: {string}
   // unique key to reference this specific Task
};

class ABProcessTriggerCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "trigger";
      super(attributes, process, AB, ABProcessTriggerDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTriggerDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Signal Start Event",
         actionName: "replace-with-signal-start",
         className: "bpmn-icon-start-event-signal",
         target: {
            type: "bpmn:StartEvent",
            // type: {string} the general bpmn category
            //      "StartEvent", "Task", "EndEvent", "ExclusiveGateway"
            eventDefinitionType: "bpmn:SignalEventDefinition",
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.triggerKey = attributes.triggerKey || "triggerKey.??";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      data.triggerKey = this.triggerKey;

      return data;
   }
}


/***/ }),

/***/ 58448:
/*!*******************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTriggerLifecycleCore.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTriggerLifecycle)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessTrigger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessTrigger.js */ 50135);
// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()


var ABProcessTaskTriggerLifecycleDefaults = {
   category: "start",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [
      "objectID",
      "lifecycleKey" /* , "triggerKey" is tracked in ABProcessTrigger */,
   ],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "key",
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "TriggerLifecycle",
   // key: {string}
   // unique key to reference this specific Task
};

class ABProcessTriggerLifecycle extends _platform_process_tasks_ABProcessTrigger_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "trigger";
      super(attributes, process, AB, ABProcessTaskTriggerLifecycleDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskTriggerLifecycleDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Object Lifecycle Trigger",
         actionName: "replace-with-signal-lifecycle-start",
         // type: {string} a unique key to reference this element
         className: "bpmn-icon-start-event-signal",
         target: {
            type: "bpmn:StartEvent",
            // type: {string} the general bpmn category
            //      "StartEvent", "Task", "EndEvent", "ExclusiveGateway"
            eventDefinitionType: "ab:SignalLifecycle",
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.objectID = attributes.objectID || "objID.??";
      this.lifecycleKey = attributes.lifecycleKey || "lifecycle.key??";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      data.objectID = this.objectID;
      data.lifecycleKey = this.lifecycleKey;
      return data;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      var fields = null;
      if (this.objectID) {
         fields = [];
         var object = this.AB.objectByID(this.objectID);
         if (object) {
            var myID = this.diagramID;
            object.fields().forEach((field) => {
               fields.push({
                  key: `${myID}.${field.id}`,
                  label: `${this.label}->${object.label}->${field.label}`,
                  field,
                  object,
               });
            });
            fields.push({
               key: `${myID}.uuid`,
               label: `${this.label}->${object.label}`,
               field: null,
               object,
            });
         } else {
            // OK, so we have an this.objectID defined, but we can't find it.
            // that's something we need to alert:
            var error = new Error(
               `ABProcessTriggerLifecycleCore.processDataFields():TaskID[${this.id}]: could not find referenced object by ID [${this.objectID}]`
            );
            this.AB.notify.builder(error, {
               task: this.id,
               objID: this.objectID,
            });
         }
      }
      return fields;
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      var parts = key.split(".");
      if (parts[0] == this.diagramID) {
         var myState = this.myState(instance);
         if (myState["data"]) {
            var object = this.AB.objectByID(this.objectID);
            var field = object.fields((f) => {
               return f.id == parts[1];
            })[0];
            if (field) {
               if (parts[2]) {
                  return field[parts[2]].call(field, myState["data"]);
               } else {
                  // instance.context.data[field.column_name];
                  // if field is "calculate" or "TextFormula" data is not stored
                  // in data base and we need to run format method
                  if (["calculate", "TextFormula"].indexOf(field.key) != -1) {
                     return field.format(myState["data"]);
                  } else if (
                     field.key == "connectObject" ||
                     field.key == "user"
                  ) {
                     return (
                        myState["data"][field.relationName()] ||
                        myState["data"][field.columnName]
                     );
                  } else {
                     return myState["data"][field.columnName];
                  }
               }
            } else if (parts[1] == "uuid") {
               return myState["data"]["uuid"];
            } else {
               ///
               /// Questioning the validity of this section of code.
               /// In order to get here, we tried to find field, and it
               /// didn't exist.
               /// then we turn around and REPEAT the same attempt
               /// and check for field again.
               /*
               // parts[1] should be a field.id
               object = this.AB.objectByID(this.objectID);
               field = object.fields((f) => {
                  return f.id == parts[1];
               })[0];
               if (field) {
                  if (parts[2]) {
                     return field[parts[2]].call(field, myState["data"]);
                  } else {
                     // instance.context.data[field.column_name];
                     return myState["data"][field.columnName];
                  }
               }
               */
            }
         }
      }
      return null;
   }

   /**
    * processDataObjects()
    * return an array of avaiable ABObjects that this element
    * can provide to other ProcessElements.
    * @return {array} | null
    */
   processDataObjects() {
      var objects = null;
      if (this.objectID) {
         objects = [this.AB.objectByID(this.objectID)];
      }
      return objects;
   }
}


/***/ }),

/***/ 14570:
/*!***************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTriggerTimerCore.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTriggerTimer)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessTrigger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessTrigger.js */ 50135);


var ABProcessTaskTriggerLifecycleDefaults = {
   category: "start",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [
      "repeatEvery",
      "repeatTime",
      "repeatDaily",
      "repeatWeekly",
      "repeatMonthly",
      "isEnabled",
   ],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "clock-o", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "TimerStartEvent",
   // key: {string}
   // unique key to reference this specific Task

   repeatEvery: "daily",
   repeatTime: "01:00",
   repeatDaily: "day",
   repeatWeekly: "FRI",
   repeatMonthly: "last",
   isEnabled: true,
};

class ABProcessTriggerTimer extends _platform_process_tasks_ABProcessTrigger_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, application) {
      attributes.type = attributes.type || "trigger";
      super(
         attributes,
         process,
         application,
         ABProcessTaskTriggerLifecycleDefaults
      );
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskTriggerLifecycleDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Timer Start Event",
         actionName: "replace-with-signal-timer-start",
         // type: {string} a unique key to reference this element
         className: "bpmn-icon-start-event-timer",
         target: {
            type: "bpmn:StartEvent",
            // type: {string} the general bpmn category
            //      "StartEvent", "Task", "EndEvent", "ExclusiveGateway"
            eventDefinitionType: "ab:SignalTriggerTimer",
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.repeatEvery =
         attributes.repeatEvery ||
         ABProcessTaskTriggerLifecycleDefaults.repeatEvery;

      this.repeatDaily =
         attributes.repeatDaily ||
         ABProcessTaskTriggerLifecycleDefaults.repeatDaily;

      this.repeatWeekly =
         attributes.repeatWeekly ||
         ABProcessTaskTriggerLifecycleDefaults.repeatWeekly;

      this.repeatMonthly =
         attributes.repeatMonthly ||
         ABProcessTaskTriggerLifecycleDefaults.repeatMonthly;

      // Convert UTC to local time
      if (attributes.repeatTime) {
         let timeVals = attributes.repeatTime.split(":");
         let currDate = new Date();
         currDate.setUTCHours(timeVals[0]);
         currDate.setUTCMinutes(timeVals[1]);
         this.repeatTime = `${currDate.getHours()}:${currDate.getMinutes()}`;
      } else {
         this.repeatTime = ABProcessTaskTriggerLifecycleDefaults.repeatTime;
      }

      if (typeof attributes.isEnabled != "undefined") {
         this.isEnabled = JSON.parse(attributes.isEnabled);
      } else {
         this.isEnabled = ABProcessTaskTriggerLifecycleDefaults.isEnabled;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      data.repeatEvery = this.repeatEvery;
      data.repeatDaily = this.repeatDaily;
      data.repeatWeekly = this.repeatWeekly;
      data.repeatMonthly = this.repeatMonthly;

      // Convert local time to UTC
      data.repeatTime = this.repeatTime;
      if (data.repeatTime && data.repeatTime instanceof Date) {
         data.repeatTime = `${data.repeatTime.getUTCHours()}:${data.repeatTime.getMinutes()}`;
      }

      data.isEnabled = this.isEnabled;

      return data;
   }

   getCronExpression() {
      let timeVals = this.repeatTime.split(":");
      let second = "*";
      let minute = timeVals[1];
      let hour = timeVals[0];
      let day;
      let month;
      let dayWeek;
      let year = "*";

      switch (this.repeatEvery) {
         case "daily":
            day = "*";
            month = "*";
            dayWeek = this.repeatDaily == "weekday" ? "1-5" : "*";
            break;
         case "weekly":
            day = "*";
            month = "*";
            dayWeek = this.repeatWeekly;
            break;
         case "monthly":
            day = this.repeatMonthly;
            month = "*";
            dayWeek = "*";
            break;
      }

      return `${second} ${minute} ${hour} ${day} ${month} ${dayWeek} ${year}`;
   }
}


/***/ }),

/***/ 95223:
/*!***********************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLCore.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ABEmitter */ 4025);
/*
 * ABQL
 *
 * An ABQL defines the base class for our AB Query Language Objects.
 * These classes share a common way to
 *   - parse input strings for commands
 *
 *
 */

class ABQLCore extends _platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, parameterDefinitions, prevOP, task, AB) {
      super();

      // manage the incoming Parameter Definitions
      if (!Array.isArray(parameterDefinitions)) {
         parameterDefinitions = [parameterDefinitions];
      }

      this.parameterDefinitions = parameterDefinitions;

      this.object = prevOP ? prevOP.object : null;
      // {ABObject}
      // The current {ABObject} the current Query Language Operation is associated
      // with.

      // if the previous Operation defined an .objectOut then our .object is THAT
      // one.
      if (prevOP && prevOP.objectOut) this.object = prevOP.objectOut;

      this.prevOP = prevOP;
      this.task = task;
      // {ABProcessTaskxxx}
      // This is running under a specific ABProcessTaskServiceQuery.  When
      // searching for data from the Process, we must go through this.task
      // to do so.

      this.AB = AB;
      this.next = null;

      this.fromAttributes(attributes);
   }

   ///
   /// Instance Methods
   ///
   initObject(attributes) {}

   fromAttributes(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */

      // super.fromValues(attributes);
      this.key = this.constructor.key ?? null;

      // this.entryComplete = attributes.entryComplete || false;
      this.params = attributes.params ?? {};
      // {hash}
      // The configuration values entered by the AppBuilder UI for this
      // operation.

      this.objectID = attributes.objectID || null;

      // be sure to do a hard lookup if an objectID was saved:
      if (this.objectID) this.object = this.objectLookup(this.objectID);

      this.initObject(attributes);

      // at least dump a warning here:
      if (this.objectID && !this.object)
         this.AB.notify.developer(
            new Error(
               `ABQLCore.fromAttributes(): unable to initialize ABObject [${this.objectID}]`
            ),
            {
               attributes,
               objectID: this.objectID,
            }
         );

      if (attributes.next) {
         let nextOP = null;

         (this.NextQLOps ?? this.constructor.NextQLOps).forEach((OP) => {
            if (OP.key === attributes.next.key) nextOP = OP;
         });

         if (nextOP) {
            // exact match, so add next:
            const qlOP = new nextOP(attributes.next, this, this.task, this.AB);

            this.next = qlOP;
         }
      }
   }

   /**
    * @method objectLookup()
    * return a matching {ABObject} that is represented by the given id.
    * NOTE: we will try to match on: our initial .objectID first, then
    * the given objID.
    * NOTE: this will match an object.id as well as object.label
    * @param {string} objID
    */
   objectLookup(objID) {
      return this.AB.objects((o) => {
         const quotedLabel = `"${o.label}"`;

         return (
            // o.id === this.objectID ||
            o.id === objID || quotedLabel.indexOf(objID) === 0
         );
      })[0];
   }

   /**
    * @method availableProcessDataFieldsHash()
    * return a { "field.key" => {processFieldDef} } hash of the currently
    * available fields in the process.
    * @return {obj}
    */
   availableProcessDataFieldsHash() {
      const availableProcessDataFields =
         this.task.process.processDataFields(this.task) ?? [];
      const hashFieldIDs = {};

      availableProcessDataFields.forEach((f) => {
         if (f.field) {
            hashFieldIDs[f.field.id] = f;
         } else {
            hashFieldIDs[f.key] = f;
         }
      });

      return hashFieldIDs;
   }

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {}

   /**
    * @method toObj()
    * properly compile the current state of this ABQL instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      const obj = {
         key: this.constructor.key,
         // entryComplete: this.entryComplete,
         params: this.params,
         // currQuery: this.currQuery,
         // queryValid: this.queryValid,
         objectID: this.object?.id ?? null,
      };

      if (this.next) {
         obj.next = this.next.toObj();
      }

      return obj;
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLCore);


/***/ }),

/***/ 83854:
/*!***************************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLFindCore.js ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 33262);
/* harmony import */ var _ABQLSet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ABQLSet.js */ 71598);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_ABQLSet_js__WEBPACK_IMPORTED_MODULE_1__]);
_ABQLSet_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
/*
 * ABQLFindCore
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */



// {array} of {ABQLxxx} options
// this is an array of what possible next Operations can come after an
// ABQLFind task is complete.  In this case the {ABQLSet} operations come
// next.  {ABQLSet} operations work on a Set|{Array} or data results.

const ParameterDefinitions = [
   {
      type: "objectConditions",
      name: "cond",
   },
];

class ABQLFindCore extends _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);
   }

   ///
   /// Instance Methods
   ///
}

ABQLFindCore.key = "find";
ABQLFindCore.label = "find";
ABQLFindCore.NextQLOps = _ABQLSet_js__WEBPACK_IMPORTED_MODULE_1__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLFindCore);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 43455:
/*!******************************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLManagerCore.js ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ql_ABQLRootObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ql/ABQLRootObject.js */ 93556);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_platform_ql_ABQLRootObject_js__WEBPACK_IMPORTED_MODULE_0__]);
_platform_ql_ABQLRootObject_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
/*
 * ABQLManagerCore
 *
 * An interface for managing the different ABQL Operations available in our
 * AppBuilder.
 *
 */


const QLOps = [_platform_ql_ABQLRootObject_js__WEBPACK_IMPORTED_MODULE_0__["default"]];

const ABQLManagerCore = {
   /**
    * @method fromAttributes()
    * return an {ABQL} object that represents the given attributes that
    * were saved from the previous .toObj()
    * @param {object} attributes
    *		  the values returned from the previous .toObj() call
    * @param {ABProcessTask***} task
    *		  the current ABProcessTaskServiceQuery that contains this QL
    * @param {ABFactory} AB
    *		  the current ABFactory we are operating under.
    * @return {ABQL} | null
    */
   fromAttributes: function (attributes, task, AB) {
      if (!attributes) return null;

      const matchingOPs = [];

      ABQLManagerCore.QLOps.forEach((Op) => {
         if (Op.key === attributes.key) matchingOPs.push(Op);
      });

      if (matchingOPs.length === 1) {
         // let this Operation initialize and return the last OP
         // in the chain
         const qlOP = new matchingOPs[0](attributes, task, AB);

         return qlOP;
      } else return null;
   },

   /**
    * @array QLOps
    * An array of the root QL Operations.
    */
   QLOps: QLOps,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLManagerCore);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 24325:
/*!*********************************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLRootObjectCore.js ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 33262);
/* harmony import */ var _platform_ql_ABQLFind_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/ql/ABQLFind.js */ 88794);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_platform_ql_ABQLFind_js__WEBPACK_IMPORTED_MODULE_1__]);
_platform_ql_ABQLFind_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
/*
 * ABQLRootObjectCore
 *
 * An ABQL defines a Query Language Operation. A QL Operation
 * is intended to be evaluated at run time and return a value that can be
 * assigned to form value or an object.
 *
 *
 */


// Define the Operations that can be performed off of a RootObject.
// Each Root Object might have a different set of Operations, so we
// define them here.

const NextQLOps = [_platform_ql_ABQLFind_js__WEBPACK_IMPORTED_MODULE_1__["default"]];

const ParameterDefinitions = [
   {
      type: "objectName",
      name: "name",
   },
];

class ABQLObjectCore extends _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, task, AB) {
      // NOTE: keep this so we can insert the prevOp == null
      super(attributes, ParameterDefinitions, null, task, AB);
   }

   ///
   /// Instance Methods
   ///
   initObject(/* attributes */) {
      if (!this.object && this.params) {
         const objNameDef = this.parameterDefinitions.find((pDef) => {
            return pDef.type === "objectName";
         });

         if (objNameDef) {
            this.objectID = this.params[objNameDef.name];
            this.object = this.objectLookup(this.objectID);
         }

         if (!this.object) {
            // This function exists on platform_web but not platform_service
            this.warningMessage?.("has no object set.", {
               objectID: this.objectID,
            });
         }
      }
   }

   toObj() {
      const obj = super.toObj();

      // if we don't have an objectID, but we have an objectName parameter
      // definition then save that as our objectID
      if (!obj.objectID && this.params) {
         const objNameDef = this.parameterDefinitions.find((pDef) => {
            return pDef.type === "objectName";
         });

         if (objNameDef) obj.objectID = this.params[objNameDef.name];
      }

      return obj;
   }
}

ABQLObjectCore.key = "object";
ABQLObjectCore.label = "object";
ABQLObjectCore.NextQLOps = NextQLOps;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLObjectCore);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 50051:
/*!**********************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLRow.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ql_ABQLRowUpdate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ql/ABQLRowUpdate.js */ 35011);
/* harmony import */ var _platform_ql_ABQLRowSave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/ql/ABQLRowSave */ 83937);
/* harmony import */ var _platform_ql_ABQLRowPluck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/ql/ABQLRowPluck */ 87215);
/*
 * ABQLRow
 *
 * Defines all the QL operations that can be performed on a Row of data. This is a
 * Single row/instance of an object.
 *
 */





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([_platform_ql_ABQLRowUpdate_js__WEBPACK_IMPORTED_MODULE_0__["default"], _platform_ql_ABQLRowSave__WEBPACK_IMPORTED_MODULE_1__["default"], _platform_ql_ABQLRowPluck__WEBPACK_IMPORTED_MODULE_2__["default"]]);


/***/ }),

/***/ 95285:
/*!*******************************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLRowPluckCore.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ql_ABQLSetPluck_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ql/ABQLSetPluck.js */ 66966);
/* harmony import */ var _platform_ql_ABQLRowUpdate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/ql/ABQLRowUpdate.js */ 35011);
/* harmony import */ var _platform_ql_ABQLRowSave_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/ql/ABQLRowSave.js */ 83937);
/*
/*
 * ABQLRowPluckCore
 *
 * An ABQLRowPluckCore can process a value of data and puck out a specified
 * field to then make an object of values that only contain that field.
 *
 */

// const ABQLValue = require("./ABQLValue.js");
// const ABQLSet = require("./ABQLSet.js");
// import ABQLSet from "./ABQLSet";




class ABQLRowPluckCore extends _platform_ql_ABQLSetPluck_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // Dynamic NextQLOps
   get NextQLOps() {
      let nextQLOps = [];

      const field = this.field ?? this.object.fieldByID(this.fieldID) ?? null;

      // Update .NextQLOps WARN: update to static it affects to every ABQLRowPluck instances.
      switch (field?.key) {
         // M:1 M:N connect field, then set ABQLSet to next steps
         case "connectObject":
            if (field.settings.linkType === "many") {
               // NOTE: Could not require("./ABQLSet.js") on the top. It returns an empty object. Why ><
               const ABQLSet = __webpack_require__(/*! ./ABQLSet.js */ 71598);

               nextQLOps = ABQLSet;

               break;
            }

            // return ABQLRow.js
            nextQLOps = this.prevOP.constructor.NextQLOps.filter(
               (NextQLOp) =>
                  NextQLOp.key === this.constructor.key ||
                  NextQLOp.key === _platform_ql_ABQLRowUpdate_js__WEBPACK_IMPORTED_MODULE_1__["default"].key
            );

            break;

         case "user":
            // TODO set this up corectlys
            if (
               field.settings.linkType === "many" ||
               field.settings.isMultiple // may be unnessicary
            ) {
               // NOTE: Could not require("./ABQLSet.js") on the top. It returns an empty object. Why ><
               const ABQLSet = __webpack_require__(/*! ./ABQLSet.js */ 71598);

               nextQLOps = ABQLSet;

               break;
            }

            // default
            nextQLOps = this.prevOP.constructor.NextQLOps.filter(
               (NextQLOp) =>
                  NextQLOp.key === this.constructor.key ||
                  NextQLOp.key === _platform_ql_ABQLRowUpdate_js__WEBPACK_IMPORTED_MODULE_1__["default"].key ||
                  NextQLOp.key === _platform_ql_ABQLRowSave_js__WEBPACK_IMPORTED_MODULE_2__["default"].key
            );

            break;

         default:
            // Normal field and _PK
            nextQLOps = this.prevOP.constructor.NextQLOps.filter(
               (NextQLOp) => NextQLOp.key === _platform_ql_ABQLRowSave_js__WEBPACK_IMPORTED_MODULE_2__["default"].key
            );

            break;
      }

      return nextQLOps;
   }
}

ABQLRowPluckCore.key = "row_pluck";
ABQLRowPluckCore.label = "Read the value from the field";
ABQLRowPluckCore.NextQLOps = []; // Static NextQLOps

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLRowPluckCore);


/***/ }),

/***/ 18844:
/*!******************************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLRowSaveCore.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ql_ABQLSetSave_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ql/ABQLSetSave.js */ 68879);
/*
/*
 * ABQLRowSaveCore
 *
 * An ABQLRowSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */



class ABQLRowSaveCore extends _platform_ql_ABQLSetSave_js__WEBPACK_IMPORTED_MODULE_0__["default"] {}

ABQLRowSaveCore.key = "row_save";
ABQLRowSaveCore.label = "Save the value as";
ABQLRowSaveCore.NextQLOps = [];
// NOTE: currently, this is an ending step. but it doesn't have to be...

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLRowSaveCore);


/***/ }),

/***/ 58910:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLRowUpdateCore.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 33262);
/*
 * ABQLRowUpdateCore
 *
 * An ABQLRow Update allows you to update the values on the current
 * Row of data.
 *
 */


// const ABQLRow = require("./ABQLRow.js");

const ParameterDefinitions = [
   {
      type: "objectValues",
      name: "values",
   },
];

class ABQLRowUpdateCore extends _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);

      // #Hack! : when an Operation provides the same .NextQlOps that it
      // was defined in, we can't require it again ==> circular dependency.
      // so we manually set it here from the operation that created us:
      this.constructor.NextQLOps = prevOP.constructor.NextQLOps;
   }

   ///
   /// Instance Methods
   ///
}

ABQLRowUpdateCore.key = "update";
ABQLRowUpdateCore.label = "Update this record";
ABQLRowUpdateCore.NextQLOps = [];
// NOTE: .NextQLOps => see the #Hack in the constructor

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLRowUpdateCore);


/***/ }),

/***/ 71598:
/*!**********************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLSet.js ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * ABQLSet
 *
 * Here we define the group of operations that can be performed on a SET of data.
 * A SET is an array of objects/row data.
 *
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/ql/ABQLSetFirst.js */ 1454)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/ql/ABQLSetPluck.js */ 66966)),
   await Promise.all(/*! import() */[__webpack_require__.e("vendors"), __webpack_require__.e("app")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/ql/ABQLSetSave.js */ 68879)),
]);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 31663:
/*!*******************************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLSetFirstCore.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 33262);
/* harmony import */ var _ABQLRow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ABQLRow.js */ 50051);
/*
/*
 * ABQLSetFirstCore
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */



// {array} of {ABQLxxx} options
// this is an array of what possible next Operations can come after an
// ABQLSetFirst task is complete.  In this case the {ABQLRow} operations come
// next.  {ABQLRow} operations work on a single row of data.

class ABQLSetFirstCore extends _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, [], prevOP, task, AB);
   }

   ///
   /// Instance Methods
   ///
}

ABQLSetFirstCore.key = "first";
ABQLSetFirstCore.label = "Select the first record";
ABQLSetFirstCore.NextQLOps = _ABQLRow_js__WEBPACK_IMPORTED_MODULE_1__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLSetFirstCore);


/***/ }),

/***/ 14154:
/*!*******************************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLSetPluckCore.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 33262);
/*
/*
 * ABQLSetPluckCore
 *
 * An ABQLSetPluck can process a set (array) of data and puck out a specified
 * field to then make an array of values that only contain that field.
 *
 */


// const ABQLSet = require("./ABQLSet.js");

const ParameterDefinitions = [
   {
      type: "objectFields",
      name: "fieldID",
   },
];

class ABQLSetPluckCore extends _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);
   }

   ///
   /// Instance Methods
   ///

   fromAttributes(attributes) {
      // #Hack! : when an Operation provides the same .NextQlOps that it
      // was defined in, we can't require it again ==> circular dependency.
      // so we manually set it here from the operation that created us:
      this.constructor.NextQLOps = this.prevOP.constructor.NextQLOps;

      // we need to gather our .field and .objectOut before we
      // allow our base class to continue forward:

      this.fieldID = attributes.fieldID;
      this.field = this.object?.fieldByID(this.fieldID);

      //// TODO: figure out how to dynamically update the next row of options
      //// based upon the current choice of field.
      // // based upon the type of field, we now configure what next steps
      // // are available.
      // if (this.field) {
      //    // if connected, then we can stay with same .NextQLOps
      //    // so we can just leave what we did above.

      //    // if a discreet value, then we need to remove SetPluck
      //    if (!this.field.isConnection) {
      //       this.constructor.NextQLOps = [
      //          ...this.prevOP.constructor.NextQLOps,
      //       ].filter((o) => o.key != this.constructor.key);
      //    }
      // }

      if (attributes.objectOutID)
         this.objectOut = this.objectLookup(attributes.objectOutID);

      super.fromAttributes(attributes);
   }

   toObj() {
      const obj = super.toObj();

      if (this.fieldID) {
         obj.fieldID = this.fieldID;

         if (this.objectOut) obj.objectOutID = this.objectOut.id;
      } else {
         obj.fieldID = this.params.field || null;

         const field = this.object.fieldByID(obj.fieldID);

         if (field?.isConnection) obj.objectOutID = field.datasourceLink.id;
      }

      return obj;
   }
}

ABQLSetPluckCore.key = "set_pluck";
ABQLSetPluckCore.label = "Read the value from the field";
ABQLSetPluckCore.NextQLOps = [];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLSetPluckCore);


/***/ }),

/***/ 83044:
/*!******************************************************!*\
  !*** ./src/js/AppBuilder/core/ql/ABQLSetSaveCore.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 33262);
/*
/*
 * ABQLSetSaveCore
 *
 * An ABQLSetSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */



const ParameterDefinitions = [
   {
      type: "taskParam",
      name: "task_param",
   },
];

class ABQLSetSaveCore extends _platform_ql_ABQL_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);

      // TODO: register with the task that we can provide data.
      if (this.taskParam) {
         task.registerDatasource(this);
         this.registered = true;
      }
   }

   ///
   /// Instance Methods
   ///

   fromAttributes(attributes) {
      // #Hack! : when an Operation provides the same .NextQlOps that it
      // was defined in, we can't require it again ==> circular dependency.
      // so we manually set it here from the operation that created us:
      this.constructor.NextQLOps = this.prevOP.constructor.NextQLOps;

      super.fromAttributes(attributes);

      this.taskParam = attributes.taskParam || this.params.task_param;
   }

   toObj() {
      const obj = super.toObj();

      obj.taskParam = this.taskParam || this.params.task_param;

      return obj;
   }

   processDataField(id, label) {
      // we have to report back on:
      // key:  id.taskParam
      // label: label->taskParam
      // object: ABObject
      // field: ABField
      // set : {bool}

      let field = null;
      // {ABField}
      // if the value being stored is NOT a connectObject, then it is
      // a particular field in the previous object.

      // if we are saving a specific field of an Object, pass that
      // ABField along:
      if (this.prevOP?.field?.key !== "connectObject")
         field = this?.prevOP?.field;

      return {
         key: `${id}.${this.taskParam || this.params.task_param}`,
         label: `${label}->${this.taskParam || this.params.task_param}`,
         field: field,
         object: this.object,
         set: true,
      };
   }
}

ABQLSetSaveCore.key = "set_save";
ABQLSetSaveCore.label = "Save the value as";
ABQLSetSaveCore.NextQLOps = [];
// NOTE: currently, this is an ending step. but it doesn't have to be...

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLSetSaveCore);


/***/ }),

/***/ 93997:
/*!*************************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewContainerCore.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewContainerCore)
/* harmony export */ });
/* harmony import */ var _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/views/ABView */ 69459);
/*
 * ABViewContainerCore
 *
 * An ABViewContainerCore defines a UI display component.
 *
 * A container might have multiple columns of display info.
 *
 */



// function L(key, altText) {
// 	return AD.lang.label.getLabel(key) || altText;
// }

const ABViewDefaults = {
   key: "viewcontainer", // {string} unique key for this view
   icon: "braille", // {string} fa-[icon] reference for this view
   labelKey: "Container", // {string} the multilingual label key for the class label
};

const ABPropertyComponentDefaults = {
   columns: 1,
   gravity: 1,
   movable: true,
   removable: true,
};

class ABViewContainerCore extends _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    * @param {obj} defaultValues special sub class defined default values.
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.columns = parseInt(
         this.settings.columns || ABPropertyComponentDefaults.columns
      );

      if (typeof this.settings.gravity != "undefined") {
         this.settings.gravity.map(function (gravity) {
            return parseInt(gravity);
         });
      }

      if (this.settings.removable != null) {
         this.settings.removable = JSON.parse(this.settings.removable); // convert to boolean
      } else {
         this.settings.removable = ABPropertyComponentDefaults.removable;
      }

      if (this.settings.movable != null) {
         this.settings.movable = JSON.parse(this.settings.movable); // convert to boolean
      } else {
         this.settings.movable = ABPropertyComponentDefaults.movable;
      }
   }

   viewsSortByPosition() {
      // Sort views from y, x positions
      return this.views().sort((a, b) => {
         if (a.position.y == b.position.y) return a.position.x - b.position.x;
         else return a.position.y - b.position.y;
      });
   }

   // saveReorder() {
   //    return this.application.viewReorder(this);
   // }
}


/***/ }),

/***/ 7852:
/*!****************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewCore.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ABMLClass */ 46148);
/*
 * ABViewCore
 *
 * ABViewCore defines the common ABView structure that is shared between
 * the client and the server.  Mostly how it manages it's internal data, and
 * how it is related to the ABView classes.
 *
 */



const ABViewDefaults = {
   key: "view", // {string} unique key for this view
   icon: "window-maximize", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.view", // {string} the multilingual label key for the class label
   tabicon: "", // no default tab icons
};

const ABViewPropertyComponentDefaults = {
   label: "",
};

class ABViewCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(["label"], application.AB);

      this.__events = [];
      // keep track of any event listeners attached to this ABView object

      this.defaults = defaultValues || ABViewDefaults;

      this.application = application;

      this.parent = parent || null;

      this.warningsSilent = false;
      // {bool}
      // Should we suppress our configuration warnings?

      this.__missingViews = [];
      // {array}
      // Any ABView.id we have stored that we can't find.

      this.fromValues(values);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewPropertyComponentDefaults;
   }

   /**
    * @method newInstance()
    * return a new instance of this ABView.  Most likely called from interfaces
    * that create new UI elements like the ABDesigner.
    * @param {ABApplication} application  	: the root ABApplication this view is under
    * @param {ABView/ABApplication} parent	: the parent object of this ABView.
    * @return {ABView}
    */
   static newInstance(application, parent) {
      // return a new instance from ABViewManager:
      return application.viewNew(
         { key: this.common().key },
         application,
         parent
      );
   }

   viewKey() {
      return this.defaults.key;
   }

   viewIcon() {
      return this.defaults.icon;
   }

   tabIcon() {
      return this.defaults.tabicon;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABView instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      // // NOTE: ensure we have a uuid() set:
      // if (!this.id) {
      //    this.id = this.application.uuid();
      // }

      // this.application.unTranslate(this, this, ["label"]);

      // MLClass translation
      var obj = super.toObj();

      var result = {
         id: this.id,
         type: this.type || "view",
         key: this.key,
         icon: this.icon,
         tabicon: this.tabicon,
         name: this.name,
         settings: this.AB.cloneDeep(this.settings || {}),
         accessLevels: this.accessLevels,
         translations: obj.translations,
      };

      // encode our child view references
      result.viewIDs = (this._views || []).map((v) => v.id).filter((id) => id);
      result.viewIDs = result.viewIDs.concat(this.__missingViews);

      if (this.position) result.position = this.position;

      // encode our .isRoot() reference.
      // (NOTE: this is set so our server side code can distinguish) between a .view
      // and a root page:
      // NOTE: we intentionally do NOT pull this out in .fromValues()
      result.isRoot = this.isRoot();

      return result;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      this.id = values.id; // NOTE: only exists after .save()
      // {string} .id
      // the uuid of this ABObject Definition.

      this.type = values.type || "view";
      // {string} .type
      // the type of ABDefinition this is.

      this.key = values.key || this.viewKey();
      // {string} .key
      // the unique lookup key for our ABViewManager to create new
      // instances of this object.

      this.icon = values.icon || this.viewIcon();
      // {string} .icon
      // the font awesome icon reference for showing an icon for this
      // view in the AppBuilder interface builder.

      this.tabicon = values.tabicon || this.tabIcon();

      this.name = values.name;
      // {string} .name
      // A name reference for this ABView. This is a reference that isn't
      // translateable and will be used for lookups across languages.

      // if this is being instantiated on a read from the Property UI,
      // .label is coming in under .settings.label
      values.settings = values.settings || {};
      this.label = values.label || values.settings.label || "?label?";

      this.settings = values.settings || {};
      // {obj} .settings
      // the property settings for this ABView

      // make sure .settings.height is an int and not a string
      this.settings.height = parseInt(this.settings.height || 0);

      this.accessLevels = values.accessLevels || {};
      // {obj} .accessLevels
      // Hash: { ABRole.id : accessLevel }
      // tracks the Role -> AccessLevel settings of this particular
      // view.
      // accessLevel: 0 : no access, 1 : view only, 2: full access

      // let the MLClass now process the translations:
      super.fromValues(values);

      // If the View / DataCollection does not have a .name already,
      // use the English label translation as the .name instead.
      if (!this.name && Array.isArray(this.translations)) {
         for (var i = 0; i < this.translations.length; i++) {
            if (i == 0) {
               // Use the first label found, in case there is no 'en'
               this.name = this.translations[i].label;
            }
            if (this.translations[i].language_code == "en") {
               // But the 'en' label will have final priority
               this.name = this.translations[i].label;
               break;
            }
         }
      }

      // default value for our label
      if (this.label == "?label?") {
         if (this.parent) {
            this.label = this.parent.label + "." + this.defaults.key;
         }
      }

      var views = [];
      this.__missingViews = this.__missingViews || [];
      (values.viewIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            views.push(this.application.viewNew(def, this.application, this));
         } else {
            this.__missingViews.push(id);
         }
      });
      this._views = views;

      // convert from "0" => 0
      this.position = values.position || {};

      if (this.position.x != null) this.position.x = parseInt(this.position.x);
      if (this.position.y != null) this.position.y = parseInt(this.position.y);

      this.position.dx = parseInt(this.position.dx || 1);
      this.position.dy = parseInt(this.position.dy || 1);
   }

   isRoot() {
      return this.parent == null || this.parent == this.application;
   }

   /**
    * @method allParents()
    * return a flattened array of all the ABViews parents
    * @return {array}      array of ABViews
    */
   allParents() {
      var parents = [];
      var curView = this;

      // add current view to array
      parents.unshift(curView);

      while (!curView.isRoot() && curView.parent) {
         parents.unshift(curView.parent);

         curView = curView.parent;
      }

      return parents;
   }

   /**
    * @method isAccessibleForRoles()
    * return true/false if this ABViewPage is accessible for one of the
    * passed in ABRoles.
    * @param {array[ABRole]} roles
    *        an array of {ABRole} instances.
    * @return {bool}
    */
   isAccessibleForRoles(roles) {
      var foundRole = false;

      var accessibleRoles = Object.keys(this.accessLevels) || [];
      (roles || []).forEach((r) => {
         if (accessibleRoles.indexOf(r.uuid || r) > -1) {
            foundRole = true;
         }
      });

      return foundRole;
   }

   /**
    * @method getUserAccess()
    *
    * return the access level of the current user on the current view
    *
    * @return {integer}  // 0 = No Access // 1 = Read Only // 2 = Full Access
    */
   getUserAccess() {
      // by default everyone has no access
      var accessLevel = 0;

      if (this.application.isAccessManaged) {
         // check to see if the current users is the access manager
         var isAccessManager = false;
         // first check if manager is defined by their role
         if (parseInt(this.application.accessManagers.useRole) == 1) {
            // if so check if any of the user's role match the managers
            this.AB.Account.roles().forEach((role) => {
               if (
                  this.application.accessManagers.role.indexOf(
                     role.id || role.uuid
                  ) > -1
               ) {
                  // if so set the access level to full access
                  isAccessManager = true;
                  accessLevel = 2;
               }
            });
         }
         // if the user isn't already set as the manager and the manager is defined by their account
         if (
            !isAccessManager &&
            parseInt(this.application.accessManagers.useAccount) == 1
         ) {
            // check if the user's account matches the managers
            if (
               this.application.accessManagers.account.indexOf(
                  this.AB.Account.uuid() + ""
               ) > -1
            ) {
               // if so set the access level to full access
               isAccessManager = true;
               accessLevel = 2;
            }
         }

         // if the user is not the manager check if the page has access levels defined for roles
         if (
            this.accessLevels &&
            Object.keys(this.accessLevels).length > 0 &&
            !isAccessManager
         ) {
            // check to see if the user's roles matches one of the roles defined
            this.AB.Account.roles().forEach((role) => {
               var currentRole = this.accessLevels[role.id || role.uuid];
               if (currentRole && parseInt(currentRole) > accessLevel)
                  // if the access level is higher than a previous role set to the new level
                  accessLevel = parseInt(currentRole);
            });
         }
      } else {
         accessLevel = 2;
      }

      return accessLevel;
   }

   /**
    * @method parentFormComponent
    * return the closest form object this component is on.
    */
   parentFormComponent() {
      var form = null;

      var curr = this;
      while (curr.key != "form" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "form") {
         form = curr;
      }

      return form;
   }

   /**
    * @method parentDetailComponent
    * return the closest detail object that this component is on.
    * @returns {ABViewDetail} detail component
    */
   parentDetailComponent() {
      var detail = null;

      var curr = this;
      while (curr.key != "detail" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "detail") {
         detail = curr;
      }

      return detail;
   }

   pageParent(filterFn) {
      if (filterFn == null) filterFn = () => true;

      // if current page is the root page, then return itself.
      if (this.isRoot()) {
         return this;
      }

      var parentPage = this.parent;
      while (
         parentPage &&
         (parentPage.key != "page" || !filterFn(parentPage))
      ) {
         parentPage = parentPage.parent;
      }

      return parentPage;
   }

   pageRoot() {
      var rootPage = this.pageParent();

      while (!rootPage.isRoot()) {
         rootPage = rootPage.pageParent();
      }

      return rootPage;
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this view.  This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this view object.
    * @return {string}
    */
   urlPointer() {
      if (this.parent) {
         return this.parent.urlView() + this.id;
      } else {
         return this.application.urlPage() + this.id;
      }
   }

   /**
    * @method urlView
    * return a string pointer to this object's views.
    * @return {string}
    */
   urlView() {
      return this.urlPointer() + "/_views/";
   }

   /**
    * @property datacollection
    * return data source
    *
    * @return {ABDataCollection}
    */
   get datacollection() {
      let dataviewID = (this.settings || {}).dataviewID;
      if (!dataviewID) {
         if (
            ["form", "grid", "line", "area", "bar", "gantt", "kanban"].indexOf(
               this.key
            ) > -1
         ) {
            // NOTE: ignore kanban side forms where this is the case:
            if (this.key == "form" && this._currentObject) return null;

            if (this.warningsSilent) return null;

            var errNoDCID = new Error(
               `ABViewCore:get datacollection(): View[${this.key}] didn't define a dataviewID.`
            );
            this.AB.notify.builder(errNoDCID, {
               view: this,
               settings: this.settings,
            });
         } else {
            // These views shouldn't matter if they don't have a datacollection.
            if (
               ["button", "label", "page", "tab", "viewcontainer"].indexOf(
                  this.key
               ) == -1
            ) {
               console.warn(
                  `TODO: figure out which ABView* require a .dataviewID: ${this.key}?`
               );
            }
         }
         return null;
      }

      var dc = this.AB.datacollectionByID(dataviewID);
      if (!dc) {
         var errNoDC = new Error(
            `View[${this.label}][${this.id}] is unable to find associated DataCollection`
         );
         this.AB.notify.builder(errNoDC, {
            view: this,
            dataviewID,
         });
      }
      return dc;
   }

   ///
   /// Update Access accessLevels
   ///

   /**
    * @method updateAccessLevels()
    *
    *
    * @param {string} roleId
    *
    * @param {string} accessLevel
    *
    * @return {Promise}
    *
    */
   updateAccessLevels(roleId, accessLevel) {
      if (parseInt(accessLevel) == 0) {
         if (this.accessLevels[roleId]) delete this.accessLevels[roleId];
      } else {
         this.accessLevels[roleId] = accessLevel;
      }

      return this.save(false, false);
   }

   ///
   /// Views
   ///

   /**
    * @method views()
    *
    * return an array of all the ABViews children
    *
    * @param {fn} filter  	a filter fn to return a set of ABViews that this fn
    *						returns true for.
    * @param {boolean} deep
    *
    * @return {array} 	array of ABViews
    */
   views(filter = () => true, deep = false) {
      var result = [];

      if (!this._views || this._views.length < 1) return result;

      // find into recursively
      if (filter && deep) {
         result = result.concat(this._views.filter(filter));

         this._views.forEach((v) => {
            var subViews = v.views(filter, deep);
            if (subViews && subViews.length > 0) {
               result = result.concat(subViews);
            }
         });
      } else {
         result = this._views.filter(filter);
      }

      return result;
   }

   /**
    * @method viewNew()
    *
    *
    * @return {ABView}
    */
   viewNew(values, application, parent) {
      return this.application.viewNew(
         values,
         application || this.application,
         parent || this
      );
   }

   /**
    * @method viewDestroy()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   viewDestroy(view) {
      console.error("DEPRECIATED: where is this called?");
      return this.viewRemove(view);
   }

   /**
    * @method viewRemove()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   viewRemove(view) {
      var origLen = this._views.length;
      this._views = this.views(function (v) {
         return v.id != view.id;
      });

      if (this._views.length < origLen) {
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewInsert()
    *
    * persist the current ABView in our list of ._views.
    *
    * @param {ABView} object
    * @return {Promise}
    */
   viewInsert(view) {
      var isIncluded =
         this.views(function (v) {
            return v.id == view.id;
         }).length > 0;
      if (!isIncluded) {
         this._views.push(view);
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewReorder()
    *
    * reorder the current ABView in our list of ._views.
    *
    * @param {string} viewId - id of the active view
    * @param {string} toPosition - 'to' postion
    * @return {Promise}
    */
   viewReorder(viewId, toPosition) {
      var from = this._views.findIndex((v) => v.id == viewId);
      if (from < 0) return;

      // move drag item to 'to' position
      this._views.splice(toPosition, 0, this._views.splice(from, 1)[0]);

      // save to database
      return this.save(true);
   }

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      // unsubscribe events
      this.eventClear(true);

      return Promise.resolve()
         .then(() => {
            // When deleting an ABView
            // be sure to remove any of it's ABViews as well
            // This cleans out any dangling ABDefinitions

            var allViewDeletes = [];
            var allViews = this.views();
            this._views = [];
            // doing ._views = [] prevents any of my updates when
            // a sub-view is .destroy()ed

            allViews.forEach((v) => {
               allViewDeletes.push(v.destroy());
            });
            return Promise.all(allViewDeletes);
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects
            if (this.parent && !this.pages) {
               return this.parent.viewRemove(this);
            }
         })
         .then(() => {
            return super.destroy();
         })
         .then(() => {
            this.emit("destroyed");
         });
   }

   /**
    * @method save()
    * persist this instance of ABView
    * @return {Promise}
    *		.resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects:
            if (this.parent && !this.pages) {
               // if we have a .parent, make sure we are included in our .parent's
               // viewIDs
               return this.parent.viewInsert(this);
            }
         })
         .then(() => {
            return this;
         });
   }

   ///
   /// Events
   ///

   /**
    * @method eventAdd()
    *
    *
    *
    * @param {object} evt - {
    * 							emitter: object,
    * 							eventName: string,
    * 							listener: function
    * 						}
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      var exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventClear()
    * unsubscribe all events.
    * should do it before destroy a component
    *
    * @param {bool} deep - clear events of child views
    */
   eventClear(deep) {
      if (deep) {
         this.views().forEach((v) => {
            v.eventClear(deep);
         });
      }

      if (this.__events && this.__events.length > 0) {
         this.__events.forEach((e) => {
            e.emitter.removeListener(e.eventName, e.listener);
         });
      }
   }

   /**
    * @method clone()
    * clone the definitions of this ABView object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    * @return {obj}
    *        obj defs of this ABView
    */
   clone(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pages", "views"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.viewNew(config, this.application, parent);

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // copy sub pages
      if (this.pages && !options.ignoreSubPages) {
         result._pages = [];
         this.pages().forEach((p) => {
            let copiedSubPage = p.clone(lookUpIds, result, options);
            copiedSubPage.parent = result;

            result._pages.push(copiedSubPage);
         });
      }

      // copy sub views
      if (this.views && !options.ignoreSubViews) {
         result._views = [];
         this.views().forEach((v) => {
            let copiedView = v.clone(lookUpIds, result, options);

            result._views.push(copiedView);
         });
      }

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABView object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    *        options.newName {string}
    *             new user determined name for page
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pageIDs", "viewIDs"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.application.viewNew(config, this.application, parent);

      // keep the parent
      result.parent = parent || this.parent;

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application.
         // pages with null parent ids default to getting put on root
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // page's name should not be duplicate
      if (this.key == "page") {
         result.name =
            options?.newName ||
            `${result.name}_copied_${this.AB.uuid().slice(0, 3)}`;

         result.label = options?.newName || `${result.label} (copied)`;
      }

      return Promise.resolve()
         .then(() => {
            // copy sub pages
            var allSaves = [];

            if (this._pages && !options.ignoreSubPages) {
               result._pages = [];
               this.pages().forEach((p) => {
                  // this prevents result.save() from happening on each of these
                  // p.copy():
                  if (p.isRoot())
                     this.application._pages.push({ id: lookUpIds[p.id] });

                  allSaves.push(
                     p
                        .copy(lookUpIds, result, options)
                        .then((copiedSubPage) => {
                           copiedSubPage.parent = result;
                           // remove the temp {id:} entry above:
                           this.application._pages =
                              this.application._pages.filter(
                                 (p2) => p2.id != lookUpIds[p.id]
                              );

                           // now add the full copiedSubPage:
                           result._pages.push(copiedSubPage);
                        })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // copy sub views
            var allSaves = [];

            if (this._views && !options.ignoreSubViews) {
               result._views = [];
               this.views().forEach((v) => {
                  allSaves.push(
                     // send a null for parent, so that the .save() wont trigger
                     // a save of the parent.
                     v.copy(lookUpIds, result, options).then((copiedView) => {
                        // now patch up the parent connection:
                        // copiedView.parent = result;
                        if (
                           result._views.filter((vi) => vi.id == copiedView.id)
                              .length < 1
                        ) {
                           result._views.push(copiedView);
                        }
                     })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // now we do 1 save for all the views
            return result.save();
         })
         .then(() => {
            return result;
         });
   }
}


/***/ }),

/***/ 63255:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewDetailItemCore.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewDetailItemCore)
/* harmony export */ });
/* harmony import */ var _platform_views_ABViewWidget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 79562);


class ABViewDetailItemCore extends _platform_views_ABViewWidget__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   detailComponent() {
      let detailView = null;

      let curr = this;
      while (
         !curr.isRoot() &&
         curr.parent &&
         curr.key != "detail" &&
         curr.key != "dataview"
      ) {
         curr = curr.parent;
      }

      if (curr.key == "detail" || curr.key == "dataview") {
         detailView = curr;
      }

      return detailView;
   }

   field() {
      let detailComponent = this.detailComponent();
      if (detailComponent == null) return null;

      let datacollection = detailComponent.datacollection;
      if (datacollection == null) return null;

      let object = datacollection.datasource;
      if (object == null) return null;

      let field = object.fields((v) => v.id == this.settings.fieldId)[0];

      // set .alias to support queries that contains alias name
      // [aliasName].[columnName]
      if (field && this.settings.alias) {
         field.alias = this.settings.alias;
      }

      return field;
   }

   getCurrentData() {
      let detailCom = this.detailComponent();
      if (!detailCom) return null;

      let dv = detailCom.datacollection;
      if (!dv) return null;

      let field = this.field();
      if (!field) return null;

      let currData = dv.getCursor();
      if (currData) return currData[field.columnName];
      else return null;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      return null;
   }
}


/***/ }),

/***/ 95484:
/*!************************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewFormItemCore.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewFormComponentCore)
/* harmony export */ });
/* harmony import */ var _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/views/ABView */ 69459);


const ABViewFormFieldPropertyComponentDefaults = {
   required: 0,
   disable: 0,
};

class ABViewFormComponentCore extends _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   static defaultValues() {
      return ABViewFormFieldPropertyComponentDefaults;
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      let form = this.parentFormComponent();
      if (form == null) return null;

      let datacollection = form.datacollection;
      if (datacollection == null) return null;

      return datacollection;
   }

   field() {
      if (this.settings.objectId) {
         let object = this.AB.objectByID(this.settings.objectId);
         if (!object) return null;

         return object.fieldByID(this.settings.fieldId);
      } else {
         let form = this.parentFormComponent();
         if (form == null) return null;

         let object;
         if (form._currentObject) {
            object = form._currentObject;
         } else {
            let datacollection = form.datacollection;
            if (datacollection == null) return null;

            object = datacollection.datasource;
         }

         if (object == null) return null;

         let field = object.fieldByID(this.settings.fieldId);
         return field;
      }
   }
}


/***/ }),

/***/ 16605:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewPageCore.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPageCore)
/* harmony export */ });
/* harmony import */ var _platform_views_ABViewContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 90669);
/*
 * ABViewPage
 *
 * An ABView that represents a "Page" in the system.
 *
 * Pages are
 *	- allowed to be displayed in the interface list
 *	- return a full list of components that can be added to the view editor
 *
 *
 */


// var ABViewManager = require("../ABViewManager");

// function L(key, altText) {
//     return AD.lang.label.getLabel(key) || altText;
// }

const ABViewDefaults = {
   key: "page", // unique key identifier for this ABView
   icon: "file", // icon reference: (without 'fa-' )
};

const ABPropertyComponentDefaults = {
   type: "page", // 'page', 'popup' or 'reportPage'
   popupWidth: 700,
   popupHeight: 450,
   pageWidth: null,
   fixedPageWidth: 0,
   pageBackground: "ab-background-default",
};

class ABViewPageCore extends _platform_views_ABViewContainer__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);

      // 	{
      // 		id:'uuid',					// uuid value for this obj
      // 		key:'viewKey',				// unique key for this View Type
      // 		icon:'font',				// fa-[icon] reference for an icon for this View Type

      //		name: '',					// unique page name

      // 		label:'',					// pulled from translation

      //		settings: {					// unique settings for the type of field
      //		},

      //		translations:[]
      // 	}

      this.parent = null; // will be set by the pageNew() that creates this obj.
      // {obj} .parent
      // this points to the ABView object that manages this object as a child.
      // this param is shared across ABViews as well as ABViewPage, but has
      // different implications ... so we default an ABViewPage.parent = null
      // and the place that Creates the Page must assign the .parent externally.
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   static getPageActionKey(view) {
      return [
         "opstools",
         "AB_" + String(view.application.name).replace(/[^a-z0-9]/gi, ""),
         String(view.name)
            .replace(/[^a-z0-9]/gi, "")
            .toLowerCase(),
         "view",
      ].join(".");
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewPage instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.name = this.name;

      obj.myAppID = this.myAppID;

      // icon of popup page
      if (this.settings.type == "popup") obj.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") obj.label = obj.name;

      // compile our pages
      obj.pageIDs = (this._pages || []).map((p) => p.id);

      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // icon of popup page
      if (values.settings.type == "popup") this.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") this.label = this.name;

      // track which application this Page belongs to:
      this.myAppID = values.myAppID;
      if (!this.myAppID && this.application) {
         this.myAppID = this.application.id;
      }

      // now properly handle our sub pages.
      var pages = [];
      (values.pageIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            pages.push(this.pageNew(def));
         } else {
            this.AB.error(
               `App[${this.application.name}][${this.application.id}]->Page[${this.name}][${this.id}] referenced an unknown Page[${id}]`
            );
         }
      });
      this._pages = pages;

      // the default columns of ABView is 1
      this.settings.columns = this.settings.columns || 1;
      this.settings.gravity = this.settings.gravity || [1];

      // convert from "0" => 0
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      return Promise.resolve()
         .then(() => {
            // When deleting an ABViewPage
            // be sure to remove any of it's ABViewPages as well
            // This cleans out any dangling ABDefinitions and cleans up the
            // OpsPortal Permissions:

            var allPageDeletes = [];
            var allPages = this.pages();
            this._pages = [];
            // doing ._pages = [] prevents any of my updates when
            // a sub-page is .destroy()ed

            allPages.forEach((p) => {
               allPageDeletes.push(p.destroy());
            });
            return Promise.all(allPageDeletes);
         })
         .then(() => {
            var parent = this.parent || this.application;

            return parent.pageRemove(this);
         })
         .then(() => {
            return super.destroy();
         });

      // return new Promise((resolve, reject) => {
      //    // verify we have been .save() before:
      //    if (this.id) {
      //       this.application
      //          .viewDestroy(this)
      //          .then(() => {
      //             // remove the page in list
      //             var parent = this.parent || this.application;
      //             var remainingPages = parent.pages((p) => {
      //                return p.id != this.id;
      //             });
      //             parent._pages = remainingPages;

      //             resolve();
      //          })
      //          .catch(reject);
      //    } else {
      //       resolve(); // nothing to do really
      //    }
      // });
   }

   /**
    * @method save()
    * persist this instance of ABViewPage
    * @return {Promise}
    *         .resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // now we can persist ourself in our parent
            var parent = this.parent || this.application;

            return parent.pageInsert(this);
         })
         .then(() => {
            return this;
         });
   }

   /**
    * @method refreshInstance()
    * This returns a NEW instance of a ABViewPage based upon the latest
    * version of it's Definition.  It also resolves any current listeners
    * this copy currently has and prepare this to discard itself.
    */
   refreshInstance() {
      console.warn(
         "This version of ABViewPage hasn't updated it's refreshInstance()",
         this
      );
      return this;
   }

   ///
   /// Pages
   ///

   /**
    * @method pages()
    *
    * return an array of all the ABViewPages for this ABViewPage.
    *
    * @param {fn} filter		a filter fn to return a set of ABViewPages that this fn
    *							returns true for.
    * @param {boolean} deep	flag to find in sub pages
    *
    * @return {array}			array of ABViewPages
    */
   pages(filter = () => true, deep = false) {
      var result = [];

      // find into sub-pages recursively
      if (filter && deep) {
         if (this._pages && this._pages.length > 0) {
            result = this._pages.filter(filter);

            if (result.length < 1) {
               this._pages.forEach((p) => {
                  var subPages = p.pages(filter, deep);
                  if (subPages && subPages.length > 0) {
                     result = subPages;
                  }
               });
            }
         }
      }
      // find root pages
      else {
         result = this._pages.filter(filter);
      }

      return result;
   }

   /**
    * @method pageInsert()
    *
    * save the given ABViewPage in our ._pages array and persist the current
    * values if they changed.
    *
    * @param {ABViewPage} page The instance of the page to save.
    * @return {Promise}
    */
   pageInsert(page) {
      var isIncluded = this.pages((o) => o.id === page.id).length > 0;
      if (!isIncluded) {
         // if not already included, then add and save the Obj definition:
         this._pages.push(page);
         return this.save();
      }

      // Nothing was required so return
      return Promise.resolve();
   }

   /**
    * @method pageNew()
    *
    * return an instance of a new (unsaved) ABViewPage that is tied to this
    * ABViewPage.
    *
    * NOTE: this new page is not included in our this.pages until a .save()
    * is performed on the page.
    *
    * @return {ABViewPage}
    */
   pageNew(values) {
      // make sure this is an ABViewPage description
      values.key = ABViewDefaults.key;

      // NOTE: this returns a new ABView component.
      // when creating a new page, the 3rd param should be null, to signify
      // the top level component.
      var page = this.application.viewNew(values, this.application, null);
      page.parent = this;
      return page;
   }

   /**
    * @method pageRemove()
    *
    * remove the given ABViewPage from our ._pages array and persist the current
    * values.
    *
    * @param {ABViewPage} page The instance of the page to remove.
    * @return {Promise}
    */
   pageRemove(page) {
      var origLen = this._pages.length;
      this._pages = this.pages(function (p) {
         return p.id != page.id;
      });

      if (this._pages.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
      return Promise.resolve();
   }

   /**
    * @method urlView()
    * return the url pointer for views in this application.
    * @return {string}
    */
   urlPage() {
      return this.urlPointer() + "/_pages/";
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this view.  This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this view object.
    * @return {string}
    */
   urlPointer() {
      if (this.parent) {
         return this.parent.urlPage() + this.id;
      } else {
         return this.application.urlPage() + this.id;
      }
   }

   updateIcon(obj) {
      // icon of page
      if (obj.settings.type == "popup") {
         obj.icon = "clone";
      } else {
         obj.icon = ABViewDefaults.icon;
      }
      return obj;
   }

   /**
    * @method clone()
    * clone the defintions of this ABViewPage object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {obj}
    *        defs of the copied ABView
    */
   clone(lookUpIds, parent) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // copy
      let result = super.clone(lookUpIds, parent);

      // page's name should not be duplicate
      result.name = null;

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABViewPage object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // now continue with the default .copy()
      return super.copy(lookUpIds, parent, options);
   }
}


/***/ }),

/***/ 82218:
/*!**********************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewWidgetCore.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewWidgetCore)
/* harmony export */ });
/* harmony import */ var _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/views/ABView */ 69459);


const ABViewDefaults = {
   key: "viewwidget", // {string} unique key for this view
   icon: "circle-o-notch ", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.widget", // {string} the multilingual label key for the class label
};

const ABPropertyComponentDefaults = {
   columnSpan: 1,
   rowSpan: 1,
};

class ABViewWidgetCore extends _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    * @param {obj} defaultValues special sub class defined default values.
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.columnSpan = parseInt(
         this.settings.columnSpan || ABPropertyComponentDefaults.columnSpan
      );
      this.settings.rowSpan = parseInt(
         this.settings.rowSpan || ABPropertyComponentDefaults.rowSpan
      );
   }
}


/***/ }),

/***/ 10285:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABApplication.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABClassApplication)
/* harmony export */ });
/* harmony import */ var _core_ABApplicationCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABApplicationCore.js */ 71750);
/* harmony import */ var _views_ABViewPage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./views/ABViewPage */ 22305);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_ABApplicationCore_js__WEBPACK_IMPORTED_MODULE_0__]);
_core_ABApplicationCore_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// const _ = require("lodash");

// prettier-ignore
// const ABApplicationCore = require("../core/ABApplicationCore.js");


// const ABViewPage = require("./views/ABViewPage");


// const ABViewManager = require("./ABViewManager");
// import ABViewManager from "./ABViewManager";

class ABClassApplication extends _core_ABApplicationCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      // now listen for any updates to our managed objects
      this._handler_page_updated = (definition) => {
         var currPage = this._pages.find((p) => p.id === definition.id);
         if (currPage) {
            this._pages = this._pages.filter((p) => p.id != currPage.id);
            this._pages.push(currPage.refreshInstance());
         }
      };
      this._pages.forEach((p) => {
         p.on("definition.updated", this._handler_page_updated);
      });
   }

   static applications(/*fn = () => true*/) {
      console.error(
         "ABApplication.applicationForID(): Depreciated. Who is doing this?"
      );
      return null;
   }
   static applicationForID(/*id*/) {
      var errDepreciated = new Error(
         "ABApplication.applicationForID(): Depreciated. Who is doing this?"
      );
      console.error(errDepreciated);
      return null;
   }

   static definitionForID(/*id*/) {
      var errDepreciated = new Error(
         "ABApplication.definitionForID(): Depreciated. Who is doing this?"
      );
      console.error(errDepreciated);
      return null;
   }

   areaKey() {
      return this.AB.kebabCase(`ab-${this.name}`);
   }

   /**
    * @method refreshInstance()
    * Used when a definition.updated message is detected on this ABApplication.
    * This method will return a new instance based upon the current definition
    * and properly resolve any handlers and pending network Requests.
    * @return {ABObject}
    */
   refreshInstance() {
      var newObj = this.AB.applicationByID(this.id);

      // remove my listeners
      this._pages.forEach((p) => {
         p.removeListener("definition.updated", this._handler_page_updated);
      });

      return newObj;
   }

   ///
   /// Definition
   ///

   /**
    * @method _listInsert()
    * save the given entity into our desired list:
    * @param {varid} entity
    * @param {string} key
    *        the key of the list we are managing
    * @return {Promise}
    */
   async _listInsert(entity, key) {
      var isIncluded = this[key].indexOf(entity.id) != -1;
      if (!isIncluded) {
         this[key].push(entity.id);
         await this.save();
      }
   }

   async _listRemove(entity, key) {
      var begLen = this[key].length;
      this[key] = this[key].filter((id) => {
         return id != entity.id;
      });
      // if there was a change then save this.
      if (begLen != this[key].length) {
         await this.save();
      }
   }

   /**
    * @method datacollectionInsert()
    * persist the current ABDataCollection in our list of .datacollectionIDs.
    * @param {ABDataCollection} dc
    * @return {Promise}
    */
   datacollectionInsert(dc) {
      return this._listInsert(dc, "datacollectionIDs");
   }

   /**
    * @method datacollectionRemove()
    * remove the given ABDataCollection from our list of .datacollectionIDs.
    * @param {ABDataCollection} dc
    * @return {Promise}
    */
   datacollectionRemove(dc) {
      return this._listRemove(dc, "datacollectionIDs");
   }

   /**
    * @method objectInsert()
    * persist the current ABObject in our list of .objectIDs.
    * @param {ABObject} object
    * @return {Promise}
    */
   objectInsert(object) {
      return this._listInsert(object, "objectIDs");
   }

   /**
    * @method objectRemove()
    * remove the current ABObject from our list of .objectIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABObject} object
    * @return {Promise}
    */
   objectRemove(object) {
      return this._listRemove(object, "objectIDs");
   }

   /**
    * @method processInsert()
    * persist the current ABProcess in our list of .processIDs.
    * @param {ABProcess} process
    * @return {Promise}
    */
   processInsert(process) {
      return this._listInsert(process, "processIDs");
   }

   /**
    * @method processRemove()
    * remove the current ABProcess from our list of .processIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABProcess} process
    * @return {Promise}
    */
   processRemove(process) {
      return this._listRemove(process, "processIDs");
   }

   /**
    * @method queryInsert()
    * persist the current ABObjectQuery in our list of .queryIDs.
    * @param {ABObjectQuery} query
    * @return {Promise}
    */
   queryInsert(query) {
      return this._listInsert(query, "queryIDs");
   }

   /**
    * @method queryRemove()
    * remove the current ABObjectQuery from our list of .queryIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABObjectQuery} query
    * @return {Promise}
    */
   queryRemove(query) {
      return this._listRemove(query, "queryIDs");
   }

   /**
    * @method exportIDs()
    * export any relevant .ids for the necessary operation of this application.
    * @param {array} ids
    *         the array of ids to insert any relevant .ids into
    */
   exportIDs(ids) {
      // make sure we don't get into an infinite loop:
      if (ids.indexOf(this.id) > -1) return;

      ids.push(this.id);

      // start with Objects:
      this.objectsIncluded().forEach((o) => {
         o.exportIDs(ids);
      });

      // get all Hints
      this.hintsIncluded().forEach((h) => {
         h.exportIDs(ids);
      });

      // Queries
      this.queriesIncluded().forEach((q) => {
         q.exportIDs(ids);
      });

      // Datacollections
      // NOTE: currently the server doesn't make instances of DataCollections
      // so we manually parse the related info here:
      this.datacollectionIDs.forEach((dID) => {
         if (ids.indexOf(dID) > -1) return;

         var def = this.AB.definitionByID(dID);
         if (def) {
            ids.push(dID);
            if (def.settings.datasourceID) {
               var object = this.AB.objectByID(def.settings.datasourceID);
               if (object) {
                  object.exportIDs(ids);
               }
            }
         }
      });

      // Processes
      this.processes().forEach((p) => {
         p.exportIDs(ids);
      });

      // Pages
      // NOTE: currently the server doesn't make instances of ABViews
      // so we manually parse the object data here:
      var parseView = (view) => {
         if (ids.indexOf(view.id) > -1) return;
         ids.push(view.id);
         (view.pageIDs || []).forEach((pid) => {
            var pdef = this.AB.definitionByID(pid);
            if (pdef) {
               parseView(pdef);
            }
         });

         (view.viewIDs || []).forEach((vid) => {
            var vdef = this.AB.definitionByID(vid);
            if (vdef) {
               parseView(vdef);
            }
         });
      };

      var pageIDs = this._pages.map((p) => p.id);
      (pageIDs || []).forEach((pid) => {
         var pdef = this.AB.definitionByID(pid);
         if (pdef) {
            parseView(pdef);
         }
      });

      // return only unique entries:
      ids = this.AB.uniq(ids);
   }

   /**
    * @method pageNew()
    * return a new instance of an ABViewPage
    * @param values
    *        The initial settings for the page.
    * @return {ABViewPage}
    */
   pageNew(values) {
      return new _views_ABViewPage__WEBPACK_IMPORTED_MODULE_1__["default"](values, this);
   }

   /**
    * @method pageInsert()
    * Insert a new ABViewPage into this Application.
    * @param {ABViewPage} page
    *        The instance of the page to save.
    * @return {Promise}
    */
   async pageInsert(page) {
      // var isIncluded = this.pageByID(page.id);
      var isIncluded = this._pages.filter((p) => p.id == page.id)[0];
      if (!isIncluded) {
         this._pages.push(page);
         // Save our own Info:
         return this.save();
      }
   }

   /**
    * @method pageRemove()
    * remove the current ABViewPage from our list of pages.
    * @param {ABViewPage} page
    * @return {Promise}
    */
   async pageRemove(page) {
      var origLen = this._pages.length;
      this._pages = this.pages(function (p) {
         return p.id != page.id;
      });

      if (this._pages.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
   }

   save() {
      // if someone just changed the name of our ABApplication, reflect that
      // in our Def.Name
      if (this.name != this.label) {
         this.name = this.label;
      }
      return super.save();
   }

   warningsEval() {
      super.warningsEval();

      //
      // check for valid object references:
      //
      var checks = {
         objectIDs: "object",
         queryIDs: "query",
         datacollectionIDs: "datacollection",
      };

      Object.keys(checks).forEach((k) => {
         this[k].forEach((id) => {
            var def = this.AB.definitionByID(id);
            if (!def) {
               this.warningsMessage(` is referencing a missing ${checks[k]}`, {
                  appID: this.id,
                  id,
               });
            }
         });
      });

      //
      // Make sure there is some way to access this Application:
      //
      if (this.roleAccess.length == 0 && !this.isAccessManaged) {
         this.warningsMessage(" has no Role assigned, and is unaccessible.");
      }

      // do our Role references exist?
      var allRoles = this.AB.Account.rolesAll().map((r) => r.id);
      this.roleAccess.forEach((r) => {
         if (allRoles.indexOf(r) == -1) {
            this.warningsMessage(
               `Specified Role Access [${r}] does not exist in this system`,
               { role: r }
            );
         }
      });

      // Make sure all our Pages perform a new warningsEval();
      this.pages().forEach((p) => {
         p.warningsEval();
      });
   }

   warningsAll() {
      var warnings = [].concat(this._warnings);
      [
         "objectsIncluded",
         "queriesIncluded",
         "datacollectionsIncluded",
         "processes",
         "pages",
         "views",
      ].forEach((k) => {
         this[k]().forEach((o) => {
            warnings = warnings.concat(o.warningsAll());
         });
      });

      return warnings;
   }

   warningsMessage(msg, data = {}) {
      let message = `Application[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   /**
    * @method mobileAppNew()
    *
    * return an instance of a new (unsaved) ABMobileApp that is tied to this
    * ABApplication.
    *
    * @return {ABMobileApp}
    */
   // mobileAppNew(values) {
   //    return new ABMobileApp(values, this);
   // }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 38094:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABApplicationMobile.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABClassApplicationMobile)
/* harmony export */ });
/* harmony import */ var _core_ABApplicationMobileCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABApplicationMobileCore.js */ 39807);
/* harmony import */ var _mobile_ABMobilePage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mobile/ABMobilePage */ 77831);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_ABApplicationMobileCore_js__WEBPACK_IMPORTED_MODULE_0__]);
_core_ABApplicationMobileCore_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
const _ = __webpack_require__(/*! lodash */ 96486);

// prettier-ignore



const ABViewManager = __webpack_require__(/*! ./ABViewManager */ 67348);

class ABClassApplicationMobile extends _core_ABApplicationMobileCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);
   }

   ///
   /// Definition
   ///

   /**
    * @method pageNew()
    * return a new instance of an ABViewPageMobile
    * @param values
    *        The initial settings for the page.
    * @return {ABViewPageMobile}
    */
   pageNew(values) {
      return new _mobile_ABMobilePage__WEBPACK_IMPORTED_MODULE_1__["default"](values, this);
   }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 64971:
/*!***************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABComponent.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABComponent)
/* harmony export */ });
/* harmony import */ var _ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABEmitter */ 4025);


// const CustomComponentManager = require("../../webix_custom_components/customComponentManager");

// let L = (...params) => AB.Multilingual.label(...params);

class ABComponent extends _ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {object} App
    *      ?what is this?
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, AB) {
      super();

      // Transition Code:
      // make sure we have an this.AB
      if (App && App.AB) {
         this.AB = App.AB;
      }

      // passed in AB will override
      if (AB) {
         this.AB = AB;
         // {ABFactory} AB
      }

      if (!App) {
         if (AB._App) {
            App = AB._App;
         } else {
            App = {
               uuid: AB.jobID(),

               /*
                * AB
                * the {ABFactory} for our interface.
                */
               AB: AB,

               /*
                * actions:
                * a hash of exposed application methods that are shared among our
                * components, so one component can invoke an action that updates
                * another component.
                */
               actions: {},

               /*
                * config
                * webix configuration settings for our current browser
                */
               config: {}, // AB.UISettings.config(),

               /*
                * custom
                * a collection of custom components for this App Instance.
                */
               custom: null,

               /*
                * Icons
                * this will provide you with the list of avaialbe font awesome 4.7.0 icons to use in interface building
                */
               icons: {}, // AB.UISettings.icons,

               Label: AB.Label(),

               /*
                * labels
                * a collection of labels that are common for the Application.
                */
               labels: {
                  // add: L("Add"),
                  // create: L("Create"),
                  // delete: L("Delete"),
                  // edit: L("Edit"),
                  // export: L("Export"),
                  // formName: L("Name"),
                  // import: L("Import"),
                  // rename: L("Rename"),
                  // ok: L("Ok"),
                  // cancel: L("Cancel"),
                  // save: L("Save"),
                  // yes: L("Yes"),
                  // no: L("No"),
                  // none: L("None"),
                  // close: L("Close"),
                  // default: L("Default"),
                  // defaultPlaceholder: L("Enter default value"),
                  // disable: L("Disable"),
                  // required: L("Required"),
                  // unique: L("Unique"),
                  // invalidMessage: {
                  //    required: L("This field is required"),
                  // },
                  // createErrorMessage: L("System could not create <b>{0}</b>."),
                  // createSuccessMessage: L("<b>{0}</b> is created."),
                  // updateErrorMessage: L("System could not update <b>{0}</b>."),
                  // updateSucessMessage: L("<b>{0}</b> is updated."),
                  // deleteErrorMessage: L("System could not delete <b>{0}</b>."),
                  // deleteSuccessMessage: L("<b>{0}</b> is deleted."),
                  // renameErrorMessage: L("System could not rename <b>{0}</b>."),
                  // renameSuccessMessage: L("<b>{0}</b> is renamed."),
                  // // Data Field  common Property labels:
                  // dataFieldHeaderLabel: L("Section Title"),
                  // dataFieldHeaderLabelPlaceholder: L("Section Name"),
                  // dataFieldLabel: L("Label"),
                  // dataFieldLabelPlaceholder: L("Label"),
                  // dataFieldColumnName: L("Field Name"),
                  // dataFieldColumnNamePlaceholder: L("Database field name"),
                  // dataFieldShowIcon: L("show icon?"),
                  // componentDropZone: L("add widgets here"),
               },

               /*
                * unique()
                * A function that returns a globally unique Key.
                * @param {string} key   The key to modify and return.
                * @return {string}
                */
               unique: function (key) {
                  return `${key}${this.uuid}`;
               },
            };
            AB._App = App;
         }
      }

      // if (!App.custom) {
      //    if (!AB.custom) {
      //       var componentManager = new CustomComponentManager();
      //       componentManager.initComponents(App);
      //    } else {
      //       App.custom = AB.custom;
      //    }
      // }

      this.App = App;

      this.idBase = idBase || "?idbase?";
   }

   actions(_actions) {
      console.error("!!! REFACTOR out .actions()");
      if (_actions) {
         for (var a in _actions) {
            this.App.actions[a] = _actions[a];
         }
      }
   }

   Label() {
      return (...params) => {
         // console.error("!! App.label() depreciated.");
         return this.AB.Multilingual.label(...params);
      };
   }

   unique(key) {
      return this.App.unique(`${this.idBase}_${key}`);
   }
}


/***/ }),

/***/ 98383:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABDataCollection.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABDataCollection)
/* harmony export */ });
/* harmony import */ var _ABObjectQuery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABObjectQuery */ 59545);
/* harmony import */ var _core_ABDataCollectionCore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ABDataCollectionCore */ 47621);
/* harmony import */ var _ABEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ABEmitter */ 4025);
/* harmony import */ var _ABMobileDC__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ABMobileDC */ 79464);






class DC extends _ABEmitter__WEBPACK_IMPORTED_MODULE_2__["default"] {
   constructor(attributes, AB) {
      super();
      // this.setMaxListeners(0);
      this.AB = AB;
   }
}

class ABDataCollection extends _core_ABDataCollectionCore__WEBPACK_IMPORTED_MODULE_1__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);
      this.setMaxListeners(0);
      this.blacklistLoadData = {};
      // { key : ?? }
      // keep track of previous loadData() calls that might not
      // have fully completed yet. We don't want to get in a
      // race condition where we keep trying to load the same frame
      // over and over again.

      this.$state = null;
      // {Framework7.store} The shared F7 data store
   }

   ///
   /// Cursor
   ///

   /**
    * currentUserUsername
    * must return the proper value for the current user that would match a "user" field
    * in an object.
    * This is platform dependent, so must be implemented by a child object.
    * @return {string}
    */
   currentUserUsername() {
      return this.AB.Account.username();
   }

   ///
   /// Data
   ///

   setState(state) {
      this.$state = state;
   }

   hasMore() {
      // if we are not yet initialized:
      if (!this.isDataInitialized) {
         return true;
      }

      return (this.__totalCount || 0) > this.$state[this.id].length;
   }

   initStore(defStore) {
      let id = this.id;
      defStore.state[id] = [];
      defStore.getters[id] = function ({ state }) {
         return state[id];
      };

      // now check all the fields we are managing and see if they
      // need to initStore()
      let obj = this.datasource;
      if (obj) {
         obj.fields().forEach((f) => {
            if (f.isConnection) {
               f.initStore(defStore);
            }
         });
      }
   }

   init() {
      // prevent initialize many times
      if (this.initialized) return;
      // this.initialized = true;  // <<---- DO NOT SET THIS HERE, it goes in CORE

      super.init();

      //// Now connect our platform hub to our Object Triggers:

      // events
      this.AB.on("ab.datacollection.create", (data) => {
         // debugger;
         this.emit("ab.datacollection.create", data);
      });

      this.AB.on("ab.datacollection.update", (data) => {
         // debugger;
         this.emit("ab.datacollection.update", data);
      });

      // We are subscribing to notifications from the server that an item may
      // be stale and needs updating
      // We will improve this later and verify that it needs updating before
      // attempting the update on the client side
      this.AB.on("ab.datacollection.stale", (data) => {
         // debugger;
         this.emit("ab.datacollection.stale", data);
      });

      this.AB.on("ab.datacollection.delete", (data) => {
         // debugger;
         this.emit("ab.datacollection.delete", data);
      });

      this.bindParentDc();
   }

   bindParentDc() {
      // if we pass the master datacollection and the field it is linked to
      // we want to bind it with that field as second param so dataFeed is
      // used on the slave datacollection
      let dataCollectionLink = this.datacollectionLink;
      let fieldLink = this.fieldLink;
      if (!this.settings.loadAll && dataCollectionLink && fieldLink) {
         let dc = this.__dataCollection;
         // the second param is the field id we bind the data to the master with
         dc.bind(dataCollectionLink.__dataCollection, fieldLink.id);
         // defining dataFeed allows us to query the database when the table is scrolled
         dc.define("dataFeed", (value, params) => {
            let cursorUpdated = false;
            // check if the current cursor was updated
            if (this?.datacollectionLink?.getCursor()?.id == value) {
               cursorUpdated = true;
            }

            // this is the same item that was already bound...don't reload data
            if (cursorUpdated) {
               // now that we have the modified wheres the dataCollections wheres
               // need to be modified for subsequent loads on scroll so lets set them
               // this.reloadWheres(wheres);

               // reload data
               this.reloadData(0, 20);
            }
         });
      }
   }

   loadData(start, limit = 20) {
      return super.loadData(start, limit).catch((err) => {
         // hideProgressOfComponents() is a platform specific action.
         this.hideProgressOfComponents();
         this.emit("loadData", {});

         // propagate the error here:
         if (err) {
            this.AB.notify.developer(err, {
               context: "ABDataCollection.loadData()",
            });
            throw err;
         }
      });
   }

   /**
    * processIncomingData()
    * is called from loadData() once the data is returned.  This method
    * allows the platform to make adjustments to the data based upon any
    * platform defined criteria.
    * @param {obj} data  the data as it was returned from the Server
    *        which should be in following format:
    *        {
    *          status: "success", // or "error"
    *          data:[ {ABObjectData}, {ABObjectData}, ...]
    *        }
    */
   processIncomingData(data) {
      // Web Platform:

      // data check:
      if (data.data && !Array.isArray(data.data)) {
         data.data = [data.data];
      }

      // standardize the heights

      /*
       // In v2: we move the row height calculation into the Interface designer.
       //

      // calculate default value of $height of rows
      let obj = this.datasource;
      let defaultHeight = 0;
      let minHeight = 0;
      let imageFields = obj.fields((f) => f.key == "image");
      let hiddenFields = obj.objectWorkspace.hiddenFields;
      imageFields.forEach(function (f) {
         if (hiddenFields.indexOf(f.columnName) == -1) {
            if (
               parseInt(f.settings.useHeight) == 1 &&
               parseInt(f.settings.imageHeight) > minHeight
            ) {
               minHeight = parseInt(f.settings.imageHeight) + 20;
            } else {
               minHeight = 100;
            }
         }
      });
      if (minHeight > 0) {
         defaultHeight = minHeight;
      }

      (data.data || []).forEach((d) => {
         // define $height of rows to render in webix elements
         if (
            d.properties != null &&
            d.properties.height != "undefined" &&
            parseInt(d.properties.height) > 0
         ) {
            d.$height = parseInt(d.properties.height);
         } else if (defaultHeight > 0) {
            d.$height = defaultHeight;
         }
      });
      */

      return super.processIncomingData(data).then(() => {
         // Web Platform:
         // when that is done:
         this.hideProgressOfComponents();
      });
   }

   ///
   /// Components
   ///

   /**
    * @method attachFlexlayout
    *
    *
    * @param {Object} component - a webix flexlayout element instance
    */
   attachFlexlayout(component) {
      var dc = this.__dataCollection;

      // prevent attach many times
      if (this.__flexComponentIds.indexOf(component.config.id) > -1) {
         return;
      } else {
         // keep component id to an array
         this.__flexComponentIds.push(component.config.id);
      }
   }

   /**
    * @method bind
    *
    *
    * @param {Object} component - a webix element instance
    */
   bind(component) {
      console.error("ABDataCollection.bind()!: Who is calling this?");
      var dc = this.__dataCollection;

      // prevent bind many times
      if (
         this.__bindComponentIds.indexOf(component.config.id) > -1 &&
         $$(component.config.id).data &&
         $$(component.config.id).data.find &&
         $$(component.config.id).data.find({}).length > 0
      )
         return;
      // keep component id to an array
      else this.__bindComponentIds.push(component.config.id);

      if (
         component.config.view == "datatable" ||
         component.config.view == "dataview" ||
         component.config.view == "treetable" ||
         component.config.view == "kanban"
      ) {
         if (dc) {
            var items = dc.count();
            if (
               items == 0 &&
               (this._dataStatus == this.dataStatusFlag.notInitial ||
                  this._dataStatus == this.dataStatusFlag.initializing) &&
               component.showProgress
            ) {
               component.showProgress({ type: "icon" });
            }

            component.define("datafetch", 20);
            component.define("datathrottle", 500);

            // initial data of treetable
            if (component.config.view == "treetable") {
               if (
                  this.datasource &&
                  this.datasource.isGroup &&
                  this.__treeCollection
               ) {
                  component.define("data", this.__treeCollection);
                  component.refresh();
               } else {
                  // NOTE: tree data does not support dynamic loading when scrolling
                  // https://forum.webix.com/discussion/3078/dynamic-loading-in-treetable
                  component.define("data", []);
                  component.parse(dc.find({}));
               }
            } else {
               component.data.sync(dc);
            }

            // Implement .onDataRequest for paging loading
            if (!this.settings.loadAll) {
               component.___AD = component.___AD || {};
               // if (component.___AD.onDataRequestEvent) component.detachEvent(component.___AD.onDataRequestEvent);
               if (!component.___AD.onDataRequestEvent) {
                  component.___AD.onDataRequestEvent = component.attachEvent(
                     "onDataRequest",
                     (start, count) => {
                        if (component.showProgress)
                           component.showProgress({ type: "icon" });

                        if (start < 0) start = 0;

                        // // load more data to the data collection
                        // dc.loadNext(count, start);

                        // since the where clause can change if we are following
                        // another cursor, include the where as part of the key:
                        let [where] = this.getWhereClause(start, 0);
                        let key = `${JSON.stringify(where)}-${start}-${count}`;
                        if (this.blacklistLoadData[key]) {
                           return false;
                        }
                        this.blacklistLoadData[key] = true;

                        this.loadData(start, count).finally(() => {
                           // remove from blacklist
                           delete this.blacklistLoadData[key];
                        });

                        return false; // <-- prevent the default "onDataRequest"
                     }
                  );
               }

               // // NOTE : treetable should use .parse or TreeCollection
               // // https://forum.webix.com/discussion/1694/tree-and-treetable-using-data-from-datacollection
               // if (
               //    component.config.view == "treetable" &&
               //    !this.datasource.isGroup
               // ) {
               //    component.___AD = component.___AD || {};
               //    if (!component.___AD.onDcLoadData) {
               //       component.___AD.onDcLoadData = () => {
               //          component.parse(dc.find({}));
               //       };

               //       this.on("loadData", component.___AD.onDcLoadData);
               //    }
               // }
            }
         } else {
            component.data.unsync();
         }
      } else if (component.bind) {
         if (dc) {
            // Do I need to check if there is any data in the collection before binding?
            component.bind(dc);
         } else {
            component.unbind();
         }

         if (component.refresh) component.refresh();
      }
   }

   unbind(component) {
      if (!component) return;

      component.detachEvent("onDataRequest");
      if (component.___AD) {
         if (component.___AD.onDataRequestEvent)
            delete component.___AD.onDataRequestEvent;

         if (component.___AD.onDcLoadData) {
            if (this.off) this.off("loadData", component.___AD.onDcLoadData);
            delete component.___AD.onDcLoadData;
         }
      }

      if (component.data && component.data.unsync) {
         component.data.unsync();
         component.define("data", []);
      }

      if (component.unbind) component.unbind();

      if (component.refresh) component.refresh();

      // remove from array
      this.__bindComponentIds = (this.__bindComponentIds || []).filter(
         (id) => id != component.config.id
      );
   }

   hideProgressOfComponents() {
      // @TODO: do we simply .emit("loading.complete") and have components
      // listen for that event?
      console.warn(".hideProgressOfComponents() not implemented yet.");
      this.__bindComponentIds.forEach((comId) => {
         // @TODO: this is webix code.
         // if ($$(comId) && $$(comId).hideProgress) $$(comId).hideProgress();
      });
   }

   /** Private methods */

   /**
    * @method _dataCollectionNew
    * Get webix.DataCollection
    *
    * @return {webix.DataCollection}
    *
    * @param {Array} data - initial data
    */
   _dataCollectionNew(data) {
      // debugger;

      // get a webix data collection
      let dc = new _ABMobileDC__WEBPACK_IMPORTED_MODULE_3__["default"]({
         data: data || [],
         DC: this,
      });

      // this._extendCollection(dc);

      return dc;
   }

   /**
    * @method _treeCollectionNew
    * Get webix.TreeCollection
    *
    * @return {webix.TreeCollection}
    *
    */
   _treeCollectionNew() {
      // get a webix data collection
      let treeStore = new webix.TreeCollection();

      this._extendCollection(treeStore);

      return treeStore;
   }

   // _extendCollection(dataStore) {
   //    console.error(
   //       "TODO: ABDataCollection._extendCollection(): remove this call!"
   //    );
   //    return;

   //    // Apply this data collection to support multi-selection
   //    // https://docs.webix.com/api__refs__selectionmodel.html
   //    webix.extend(dataStore, webix.SelectionModel);

   //    dataStore.___AD = dataStore.___AD || {};

   //    // Implement .onDataRequest for paging loading
   //    if (!this.settings.loadAll) {
   //       if (!dataStore.___AD.onDataRequestEvent) {
   //          dataStore.___AD.onDataRequestEvent = dataStore.attachEvent(
   //             "onDataRequest",
   //             (start, count) => {
   //                if (start < 0) start = 0;

   //                // load more data to the data collection
   //                this.loadData(start, count);

   //                return false; // <-- prevent the default "onDataRequest"
   //             }
   //          );
   //       }

   //       if (!dataStore.___AD.onAfterLoadEvent) {
   //          dataStore.___AD.onAfterLoadEvent = dataStore.attachEvent(
   //             "onAfterLoad",
   //             () => {
   //                this.emit("loadData", {});
   //             }
   //          );
   //       }
   //    }

   //    // override unused functions of selection model
   //    dataStore.addCss = function () {};
   //    dataStore.removeCss = function () {};
   //    dataStore.render = function () {};

   //    if (!dataStore.___AD.onAfterLoad) {
   //       dataStore.___AD.onAfterLoad = dataStore.attachEvent(
   //          "onAfterLoad",
   //          () => {
   //             this.hideProgressOfComponents();
   //          }
   //       );
   //    }
   // }

   parseTreeCollection(data = {}) {
      if (
         !(this.__datasource instanceof _ABObjectQuery__WEBPACK_IMPORTED_MODULE_0__["default"]) ||
         !this.__datasource.isGroup ||
         !this.__treeCollection
      )
         return;

      let addRowToTree = (join = {}, parentAlias = null) => {
         let alias = join.alias;

         (data.data || []).forEach((row) => {
            let dataId = row[`${alias}.uuid`] || row[`${alias}.id`];
            if (!dataId) return;

            // find parent nodes
            let parentItemIds = [];
            let parentId =
               row[`${parentAlias}.uuid`] || row[`${parentAlias}.id`];
            if (parentId) {
               parentItemIds = this.__treeCollection
                  .find(
                     (item) =>
                        item._alias == parentAlias && item._dataId == parentId
                  )
                  .map((item) => item.id);
            }

            // check exists
            let exists = this.__treeCollection.find((item) => {
               return (
                  item._alias == alias &&
                  item._dataId == dataId &&
                  (parentItemIds.length == 0 ||
                     parentItemIds.indexOf(item.$parent) > -1)
               );
            }, true);
            if (exists) return;

            let treeNode = {};
            treeNode._alias = alias;
            treeNode._dataId = dataId;
            treeNode._itemId = row.id; // Keep row id for set cursor to data collection

            Object.keys(row).forEach((propName) => {
               // Pull value from alias
               if (propName.indexOf(`${alias}.`) == 0) {
                  treeNode[propName] = row[propName];
               }
            });

            if (row.translations) treeNode.translations = row.translations;

            // child nodes
            if (parentItemIds.length > 0)
               parentItemIds.forEach((parentItemId) => {
                  this.__treeCollection.add(treeNode, null, parentItemId);
               });
            // root node
            else this.__treeCollection.add(treeNode, null);
         });

         // Sub-joins
         (join.links || []).forEach((link) => {
            addRowToTree(link, alias);
         });
      };

      // Show loading cursor
      (this.__bindComponentIds || []).forEach((comId) => {
         //// Webix Command here:
         let boundComp = $$(comId);
         if (boundComp && boundComp.showProgress)
            boundComp.showProgress({ type: "icon" });

         if (boundComp.data && boundComp.data.unsync) boundComp.data.unsync();
      });

      addRowToTree(this.__datasource.joins());

      // Hide loading cursor
      (this.__bindComponentIds || []).forEach((comId) => {
         let boundComp = $$(comId);
         if (boundComp && boundComp.hideProgress) boundComp.hideProgress();
         boundComp.define("data", this.__treeCollection);
      });
   }

   warningsEval() {
      super.warningsEval();

      if (!this.datasource) {
         this.warningsMessage(`doesn't have a datasource.`);
      } else if (this.linkDatacollectionID) {
         const linkDC = this.AB.datacollectionById(this.linkDatacollectionID);

         if (!linkDC)
            this.warningsMessage(
               `can't resolve linkDatacollectionID[${this.linkDatacollectionID}]`
            );
      }
   }

   warningsMessage(msg, data = {}) {
      let message = `Datacollection[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   get userScopes() {
      return this.AB.Account.scopes();
   }
}


/***/ }),

/***/ 34802:
/*!****************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABDefinition.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABDefinition)
/* harmony export */ });
/* harmony import */ var _core_ABDefinitionCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABDefinitionCore */ 17953);


class ABDefinition extends _core_ABDefinitionCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, AB) {
   //    super(attributes, AB);
   // }
}


/***/ }),

/***/ 4025:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABEmitter.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABEmitter)
/* harmony export */ });
/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter2 */ 56387);
/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter2__WEBPACK_IMPORTED_MODULE_0__);
/**
 * ABEmitter
 *
 * This is the platform dependent implementation of an Emitter object.
 *
 */



class ABEmitter extends (eventemitter2__WEBPACK_IMPORTED_MODULE_0___default()) {
   constructor() {
      super(/*{ maxListeners: 0 }*/);
   }
}


/***/ }),

/***/ 5701:
/*!**********************************************!*\
  !*** ./src/js/AppBuilder/platform/ABHint.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABHint)
/* harmony export */ });
/* harmony import */ var _core_ABHintCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABHintCore */ 36717);


class ABHint extends _core_ABHintCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      // listen
      // this.AB.on("ab.abprocess.update", (data) => {
      //    if (this.id == data.objectId) this.fromValues(data.data);
      // });
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy(App) {
      let L = this.AB.Label();
      // remove all my Elements
      var allSteps = this.steps();
      var allDestroy = [];
      allSteps.forEach((e) => {
         allDestroy.push(e.destroy());
      });
      // remove reference on App and View
      let hintIndex = App.hintIDs.indexOf(this.id);
      if (hintIndex > -1) {
         App.hintIDs.splice(hintIndex, 1);
         App.save();
      }

      let view = App.views((v) => {
         return v.id == this.settings.view;
      })[0];

      if (view) {
         delete view.settings.hintID;
         view.save();
      }

      return Promise.all(allDestroy).then(() => {
         // now remove myself
         return new Promise((resolve, reject) => {
            this.toDefinition()
               .destroy()
               .then(() => {
                  webix.message({
                     text: L("Tutorial Deleted"),
                     type: "success",
                     expire: 3000,
                  });
                  resolve();
               })
               .catch((err) => {
                  reject(err);
               });
         });
      });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *                .resolve( {this} )
    */
   save() {
      return this.toDefinition()
         .save()
         .then((data) => {
            // if I didn't have an .id then this was a create()
            // and I need to update my data with the generated .id

            if (!this.id) {
               this.id = data.id;
            }
            return this;
         });
   }

   isValid() {
      // debugger;
      return true;
      // var validator = this.AB.Validation.validator();

      // // label/name must be unique:
      // var isNameUnique =
      //    this.AB.processes((o) => {
      //       return o.name.toLowerCase() == this.name.toLowerCase();
      //    }).length == 0;
      // if (!isNameUnique) {
      //    validator.addError(
      //       "name",
      //       L(`Process name must be unique ("{0}" already in use)`, [this.name])
      //    );
      // }

      // return validator;
   }

   /**
    * @method warningsAll()
    * Return an array of mis configuration warnings for our object or any
    * of our sub elements.
    * @return {array} [ { message: "warning message", data:{} } ]
    */
   warningsAll() {
      // debugger;
      // report both OUR warnings, and any warnings from any of our fields
      // var allWarnings = [].concat(this._warnings);
      // this.elements().forEach((e) => {
      //    e.warningsEval();
      //    allWarnings = allWarnings.concat(e.warnings());
      // });
      // if (this.elements().length == 0) {
      //    allWarnings.push({ message: "No process Tasks defined.", data: {} });
      // }
      // // perform a check of our xml document to see if we have any unknown
      // // shapes
      // if (!this._DOMParser) {
      //    if (window.DOMParser) {
      //       // Handy snippet from https://stackoverflow.com/questions/17604071/parse-xml-using-javascript
      //       this._DOMParser = function (xmlStr) {
      //          return new window.DOMParser().parseFromString(
      //             xmlStr,
      //             "text/xml"
      //          );
      //       };
      //    } else if (
      //       typeof window.ActiveXObject != "undefined" &&
      //       new window.ActiveXObject("Microsoft.XMLDOM")
      //    ) {
      //       this._DOMParser = function (xmlStr) {
      //          var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
      //          xmlDoc.async = "false";
      //          xmlDoc.loadXML(xmlStr);
      //          return xmlDoc;
      //       };
      //    } else {
      //       throw new Error("No XML parser found");
      //    }
      // }
      // // find any references to our generic shapes
      // let xml = this._DOMParser(this.xmlDefinition);
      // const genericShapes = [
      //    "bpmn2:startEvent",
      //    "bpmn2:task",
      //    "bpmn2:endEvent",
      // ];
      // genericShapes.forEach((s) => {
      //    let allElements = xml.getElementsByTagName(s);
      //    for (let x = 0; x < allElements.length; x++) {
      //       // if we don't know about this shape
      //       let ele = allElements[x];
      //       let myEle = this.elementForDiagramID(allElements[x].id);
      //       if (!myEle) {
      //          this.unknownShape(allElements[x]);
      //       }
      //    }
      // });
      // // if any unknown shapes have been reported:
      // if (this._unknownShapes.length) {
      //    allWarnings.push({
      //       message: "Generic Tasks still undefined.",
      //       data: {},
      //    });
      // }
      //
      // return allWarnings;
   }

   createHintUI() {
      // if already loaded skip
      if ($$(this.id)) return;

      let L = this.AB.Label();
      let steps = [];
      let next = 0;
      let display = webix.storage.cookie.get(this.id);
      if (display?.hide) return;
      let dontShow = `<label class="dontShow">
                        <input onclick="webix.storage.cookie.put(this.dataset.hintId, {'hide': this.checked});" data-hint-id="${
                           this.id
                        }" type="checkbox"> 
                        ${L("Don't show this again.")}
                     </label>`;
      this.stepIDs.forEach((step) => {
         next++;
         let newStep = {};
         newStep.id = this._steps[step].id;
         newStep.el = this._steps[step].settings.el;
         newStep.event = this._steps[step].settings.event;
         newStep.title = this._steps[step].name;
         newStep.text = this._steps[step].text + dontShow;
         if (this.stepIDs[next]) {
            newStep.nextEl = this._steps[this.stepIDs[next]].settings.el;
            if (newStep.nextEl) {
               newStep.hintId = this.id;
               newStep.eventEl = "button"; // added this so we do not trigger a second advance on the hint when triggering the click below
               newStep.next = function (event) {
                  let nextEl = this.nextEl;
                  let theNextEl = document.querySelector(nextEl);
                  if (theNextEl && theNextEl.checkVisibility()) {
                     return false;
                  } else {
                     document.querySelector(this.el).click();
                     return false;
                  }
               };
            }
         }
         if (newStep.el) steps.push(newStep);
      });

      let ui = {
         view: "hint",
         id: this.id,
         steps: steps,
         on: {
            onNext: (step) => {
               setTimeout(() => {
                  const boxes = document.querySelectorAll(
                     "input[data-hint-id='" + this.id + "']"
                  );
                  let display = webix.storage.cookie.get(this.id);
                  boxes.forEach((b) => {
                     b.checked = display?.hide || false;
                  });
               }, 100);
            },
            onPrevious: (step) => {
               setTimeout(() => {
                  const boxes = document.querySelectorAll(
                     "input[data-hint-id='" + this.id + "']"
                  );
                  let display = webix.storage.cookie.get(this.id);
                  boxes.forEach((b) => {
                     b.checked = display?.hide || false;
                  });
               }, 100);
            },
         },
      };

      webix.delay(
         () => {
            webix.ui(ui).start();
         },
         null,
         null,
         2000
      );

      // $$(this.id);
   }
}


/***/ }),

/***/ 32711:
/*!***********************************************!*\
  !*** ./src/js/AppBuilder/platform/ABIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABIndex)
/* harmony export */ });
/* harmony import */ var _core_ABIndexCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABIndexCore */ 59815);


class ABIndex extends _core_ABIndexCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, object) {
   //    super(attributes, object);
   // }

   /**
    * @method save()
    * persist this instance of ABIndex with it's parent ABObject
    * @return {Promise}
    */
   save() {
      return super
         .save()
         .then(() => this.object.indexSave(this))
         .then(() => this.migrateCreate());
   }

   /**
    * @method destroy()
    * destroy the current instance of ABIndex
    * also remove it from our parent ABObject
    * @return {Promise}
    */
   destroy() {
      return new Promise((resolve, reject) => {
         if (this.id) {
            this.migrateDrop()
               .then(() => {
                  return super.destroy();
               })
               .then(() => this.object.indexRemove(this))
               .then(resolve)
               .catch(reject);
         } else {
            resolve();
         }
      });
   }

   warningsEval() {
      super.warningsEval();

      (this._unknownFieldIDs || []).forEach((id) => {
         this.warningsMessage(`is referencing an unknown field id[${id}]`);
      });

      if (this.fields.length == 0) {
         this.warningsMessage(`is not referencing any fields`);
      }
   }

   /**
    * @method warningsMessage()
    * generate a commonly formatted warning message for this ABField.
    * This is expected to be called from within a .warningsEval()
    * method when generating warnings.
    * @param {string} msg
    *        the warning string to display
    * @param {json} data
    *        any relevant additional information for a developer to refer to.
    */
   warningsMessage(msg, data = {}) {
      let message = `Index[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   ///
   /// DB Migrations
   ///

   migrateCreate() {
      return this.AB.Network.post({
         url: `/definition/migrate/object/${this.object.id}/index/${this.id}`,
         // data: this.toObj(),
      });
   }

   migrateDrop() {
      return this.AB.Network["delete"]({
         url: `/definition/migrate/object/${this.object.id}/index/${this.id}`,
      });
   }
}


/***/ }),

/***/ 46148:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABMLClass.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMLClass)
/* harmony export */ });
/* harmony import */ var _core_ABMLClassCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABMLClassCore */ 90477);
/**
 * ABMLClass
 * manage the multilingual information of an instance of a AB Defined Class.
 *
 * these classes have certain fields ("label", "description"), that can be
 * represented in different language options as defined by our platform.
 *
 * This platform ABMLClass will define 2 methods that allow for the translation
 * untranslation of this data.
 */
// var ABMLClassCore = require("../core/ABMLClassCore");


class ABMLClass extends _core_ABMLClassCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(fieldList, AB) {
      super(fieldList, AB);

      this._warnings = [];
      // {array}
      // an array of warning messages for this object.
      // each warning entry should be in the format:
      // WarningMessage: {
      //    message: {string} "message to display"
      //    data: {json} additional debugging information
      // }
   }

   // fromValues(attributes) {
   //    super.fromValues(attributes);
   // }

   /**
    * @method warnings()
    * returns the stored warnings for this ONE object.
    * @return {array} WarningMessage
    */
   warnings() {
      return this._warnings;
   }

   /**
    * @method warningsEval()
    * This method causes an object to re-evaluate it's settings to see if there
    * are any potential errors.
    */
   warningsEval() {
      this._warnings = [];
   }

   /**
    * @method warningsAll()
    * returns all relevant warnings for the current Object. This includes any
    * sub fields, links, views, etc...
    * @return {array} warning structures
    *          [ {WarningMessage}, ... ]
    */
   warningsAll() {
      return this.warnings();
   }

   /**
    * @method languageDefault
    * return a default language code.
    * @return {string}
    */
   languageDefault() {
      return this.AB.Account.language() || "en";
   }

   /**
    * @method destroy()
    * remove this definition.
    * @return {Promise}
    */
   async destroy() {
      var def = this.toDefinition();
      if (def.id) {
         return def.destroy().catch((err) => {
            if (err.toString().indexOf("No record found") > -1) {
               // this is weird, but not breaking:
               console.log(
                  `ABMLClass.destroy(): could not find record for id[${def.id}]`
               );
               console.log(def);
               return;
            }
            throw err;
         });
      }
      return Promise.resolve();
   }

   /**
    * @method save()
    * persist this definition of our {ABxxx} Object
    * @return {Promise}
    */
   async save() {
      var def = this.toDefinition();
      // if not name, try to use our label as the name
      def.name = def.name || this.name || this.label || "name";
      var data = await def.save();
      if (!this.id) {
         this.id = data.id;
      }
   }
}


/***/ }),

/***/ 79464:
/*!**************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABMobileDC.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileDC)
/* harmony export */ });
/* harmony import */ var _ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABEmitter */ 4025);
/**
 * ABMobileDC
 *
 * This is the platform dependent implementation of our DataCollection object.
 *
 * The ABDataCollection objects are designed around working with an instance
 * of a Webix Datacollection to manage getting the data into the various UI
 * elements.
 *
 * Now on Framework7 we have to work with F7 stores.  This object is designed
 * to follow our existing Object API, while working with F7 Stores to update
 * the UI.
 *
 * GOAL: we will implement an object that mimics the Webix.DataCollection
 * features that are used in our CORE part of the codebase.  And then recode
 * our PLATFORM.DataCollection to approach things more in line with F7
 *
 */



class ABMobileDC extends _ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(Options) {
      super(/*{ maxListeners: 0 }*/);

      this.data = Options.data || [];
      this.DC = Options.DC;

      this.cursorID = null;

      // Mock the ABDataCollectionCore.init(): initialization of the
      // "changeCursor" event:
      this.___AD = { onAfterCursorChange: () => true };
   }

   //
   // 1) We need to connect our DC to a parent DC that we are linked to.
   // Once the Parent DC is selected, we need to pull the current selection
   // and then perform another reload() based upon
   bind(DC, id) {}

   // 2) continuous Scrolling:
   //    Implemented at the level of the UI component:
   //    <div onInfinite={ this.loadMore() }
   //    loadMore() {
   //       if (this.DC.hasMore()) {
   //          this.DC.loadMore(); // <<-- DC will update the $store
   //       }
   //    }
   /*

 dc.bind(dataCollectionLink.__dataCollection, fieldLink.id);
// defining dataFeed allows us to query the database when the table is scrolled
dc.define("dataFeed", (value, params) => {
   let cursorUpdated = false;
   // check if the current cursor was updated
   if (this?.datacollectionLink?.getCursor()?.id == value) {
      cursorUpdated = true;
   }

   // this is the same item that was already bound...don't reload data
   if (cursorUpdated) {
      // now that we have the modified wheres the dataCollections wheres
      // need to be modified for subsequent loads on scroll so lets set them
      // this.reloadWheres(wheres);

      // reload data
      this.reloadData(0, 20);
   }
});

*/

   get PK() {
      return this.DC.datasource.PK();
   }

   stateValues() {
      if (!this.DC.$state) return (this.DC.$state = []);
      return this.DC.$state[this.DC.id];
   }

   add(value, indx) {
      if (!Array.isArray(value)) {
         value = [value];
      }
      let allValues = this.stateValues();
      allValues.splice(indx, 0, ...value);
      this.setValues(allValues);
   }

   clearAll() {
      this.setValues([]);
      this.cursorID = null;
   }

   count() {
      return this.stateValues().length;
   }

   exists(ID) {
      let allValues = this.stateValues();
      let found = allValues.find((v) => ID == this.id(v));
      return "undefined" !== typeof found;
   }

   /**
    * filter(fn)
    * Apply a filter to the current data set.
    */
   filter(fn) {
      this.__unfilteredData = this.stateValues();

      if (typeof fn == "undefined") {
         this.setValues(this.__unfilteredData);
         delete this.__unfilteredData;
         return;
      }

      this.setValues(this.__unfilteredData.filter(fn));
   }

   find(fn = () => true) {
      if (typeof fn != "function") {
         if (typeof fn == "object") {
            if (Object.keys(fn).length == 0) {
               fn = () => true;
            } else {
               throw new Error("Improper parameter to .find():", fn);
            }
         }
      }
      return this.stateValues().filter(fn);
   }

   /**
    * @method getCursor()
    * returns the ID of the item the cursor is set to.
    * @return {string}
    */
   getCursor() {
      return this.cursorID;
   }

   getFirstId() {
      var allValues = this.stateValues();
      if (allValues.length == 0) return null;
      return this.id(allValues[0]);
   }

   getNextId(id) {
      var idxFound = -1;
      var PK = this.PK;
      var allValues = this.stateValues();
      for (var i = 0, val_len = allValues.length; i < val_len; i++) {
         if (this.id(allValues[i]) == id) {
            idxFound = i;
            break;
         }
      }

      if (idxFound == -1) {
         return null;
      }

      return this.id(allValues[idxFound + 1]);
   }

   id(value) {
      return value[this.PK] || value.id || value.uuid;
   }

   getItem(id) {
      var PK = this.PK;
      var allValues = this.stateValues();
      return allValues.find((v) => this.id(v) == id);
   }

   /**
    * @method load()
    * can be called with a
    * - data
    */
   load(fn) {
      if ("function" == typeof fn) {
         var result = fn();
         // did the fn() return a Promise?
         // if so, then wait for the result and pass to .parse()
         if (result?.then) {
            result.then((data) => {
               if (data) this.parse(data);
            });
         } else {
            // pass the result on to .parse()
            if (result) this.parse(result);
         }
      } else {
         this.parse(fn);
      }
   }

   /**
    * @method parse()
    * take the provided data response from the server and store the
    * data into our $store.
    * data format could be the response packet:
    *    {data: [], total_count: 11, pos: 0, offset: 0, limit: 20}
    * or just the array of data to store: []
    */
   parse(data) {
      // check to see if data is in expanded format:
      // { data, pos, total_count, }

      let dataIn = data.data || data;
      let pos = data.pos || 0;
      let tc = data.total_count || 0;

      if (Array.isArray(dataIn) && dataIn.length == 0) {
         if (tc == 0) {
            // this is an actual empty data set.
            this.clearAll();
         }
         return;
      }

      if (pos == 0) {
         this.setValues(dataIn);
      } else {
         let allValues = this.stateValues();
         allValues.splice(pos, 0, ...dataIn);
         this.setValues(allValues);
      }

      // remove any stored filter
      delete this.__unfilteredData;
   }

   remove(id) {
      var PK = this.PK;
      var allValues = this.stateValues();
      this.setValues(allValues.filter((v) => this.id(v) != id));

      if (this.__unfilteredData) {
         this.__unfilteredData = this.__unfilteredData.filter(
            (v) => this.id(v) != id
         );
      }

      if (this.cursorID == id) this.cursorID = null;
   }

   setCursor(ID) {
      this.cursorID = ID;
      this.emit("onAfterCursorChange");

      // ABDataCollectionCore.init() : attempts to set up this dynamic,
      // but we are initializing this here instead:
      let currCursorItem = this.getItem(ID);
      this.DC.emit("changeCursor", currCursorItem);
   }

   setValues(data) {
      // this.DC.dataInitialized();
      this.DC.$state[this.DC.id] = data;
   }

   updateItem(ID, data) {
      let item = this.getItem(ID);
      for (var p in data) {
         if (data.hasOwnProperty(p)) {
            item[p] = data[p];
         }
      }

      var allValues = this.stateValues().map((v) => {
         if ((v.id || v.uuid) == (data.id || data.uuid)) {
            return item;
         } else {
            return v;
         }
      });

      this.setValues(allValues);
   }

   // DataCollectionCore.setCursor()
   /*

   attachEvent(str, fn() ) // onAfterCursorChange

   updateItem(d.id,updateItemData);

   loadNext(count, start);
*/
}


/***/ }),

/***/ 41637:
/*!***********************************************!*\
  !*** ./src/js/AppBuilder/platform/ABModel.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABModel)
/* harmony export */ });
/* harmony import */ var _core_ABModelCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABModelCore */ 312);


//
// ABModel
//
// Represents the Data interface for an ABObject data.
//
// 2 ways to use an ABModel to load a DataTable:
// 	Method 1:
// 	gather all the data externally and send to the DataTable
//		Model.findAll()
//		.then((data)=>{
//			DataTable.parse(data);
//		})
//
// 	Method 2:
// 	Set the Model object with a condition / skip / limit, then
// 	use it to load the DataTable:
//		Model.where({})
//		.skip(XX)
//		.limit(XX)
//		.loadInto(DataTable);

function errorPopup(error) {
   // Show the pop up
   if (error && error.data && error.data.error == "READONLY") {
      webix.alert({
         title: "Your action is blocked",
         ok: "Ok",
         text: error.data.message || "",
         type: "alert-warning",
      });
   }
}

/*
 * @function no_socket_trigger()
 * a common routine to trigger an update.
 * In the case where our AB.Network.type() isn't a socket implementation
 * we need to manually trigger the expected socket events ourselves.
 * This fn() attempts to simulate the socket responses in such a case.
 * @param {ABModel} model
 *        The ABModel currently processing the network transaction.
 * @param {string} key
 *        The socket update trigger we are simulating.
 * @param {json} data
 *        The relevant response from our network transaction.
 */
function no_socket_trigger(model, key, data) {
   // If we do not have socket updates available, then trigger an
   // update event with this data.
   if (model.AB.Network.type() != "socket") {
      model.AB.emit(key, {
         objectId: model.object.id,
         data,
      });
   }
}

class ABModel extends _core_ABModelCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(object) {
      super(object);

      this.handler_create = (...params) => {
         this.handler_common("ab.datacollection.create", ...params);
      };

      this.handler_delete = (...params) => {
         this.handler_common("ab.datacollection.delete", ...params);
      };

      this.handler_findAll = (...params) => {
         this.handler_common(null, ...params);
      };

      this.handler_logs = (context, err, data) => {
         if (err) {
            context.reject?.(err);
            return;
         }
         context.resolve?.(data);
      };

      this.handler_update = (...params) => {
         this.handler_common("ab.datacollection.update", ...params);
      };

      this.handler_common = (key, context, err, data) => {
         // key: {string} the relevant socket event key
         //      can be null if not relevant.
         // context : {obj} any provided context data provided on the
         //           this.AB.Network.get() call.
         // err: {Error} any returned error message from api
         // data: {obj} returned data from the model-get api in format:
         //       {data: [], total_count: 1, pos: 0, offset: 0, limit: 0}
         if (err) {
            context.reject?.(err);
            return;
         }

         if (this.isCsvPacked(data)) {
            let lengthPacked = JSON.stringify(data).length;
            data = this.csvUnpack(data);

            // JOHNNY: getting "RangeError: Invalid string length"
            // when data.data is too large. So we are just going
            // to .stringify() the rows individually and count the
            // length of each one.

            let lengthUnpacked = 0;
            if (Array.isArray(data.data)) {
               for (var d = 0; d < data.data.length; d++) {
                  lengthUnpacked += JSON.stringify(data.data[d]).length;
               }
            } else {
               lengthUnpacked += JSON.stringify(data.data).length;
            }

            Object.keys(data)
               .filter((k) => k != "data")
               .map((k) => {
                  lengthUnpacked += `${k}:${data[k]},`.length;
               });

            lengthUnpacked += 5; // for the brackets

            console.log(
               `CSV Pack: ${lengthUnpacked} -> ${lengthPacked} (${(
                  (lengthPacked / lengthUnpacked) *
                  100
               ).toFixed(2)}%)`
            );
         }

         if (key) {
            // on "update" & "create" we want to normalizeData()
            if (key.indexOf("delete") == -1) {
               // on anything with a key, we shouldn't have data.data
               data = data.data || data;

               this.normalizeData(data);
            } else {
               // triggers to ab.datacollection.delete need to send the .id
               // of the item deleted:
               data = data.data || context.id;
            }
         } else {
            // on a findAll we normalize data.data
            this.normalizeData(data.data);
         }

         context.resolve?.(data);

         if (key) {
            no_socket_trigger(this, key, data);
         }
      };
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   // Prepare multilingual fields to be untranslated
   // Before untranslating we need to ensure that values.translations is set.
   prepareMultilingualData(values) {
      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();
      // if mlFields are inside of the values saved we want to translate otherwise do not because it will reset the translation field and you may loose unchanged translations
      var shouldTranslate = false;
      if (mlFields.length) {
         mlFields.forEach(function (field) {
            if (values[field] != null) {
               shouldTranslate = true;
            }
         });
      }
      if (shouldTranslate) {
         if (
            values.translations == null ||
            typeof values.translations == "undefined" ||
            values.translations == ""
         ) {
            values.translations = [];
         }
         this.object.unTranslate(values, values, mlFields);
      }
   }

   request(method, params) {
      return this.AB.Network[method](params);
   }

   /**
    * @method batchCreate
    * update model values on the server.
    */
   batchCreate(values) {
      values.batch.map((vals) => {
         return this.prepareMultilingualData(vals.data);
      });

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, (context, err, data) => {
            if (err) {
               reject(err);
               return;
            }
            this.normalizeData(data);
            resolve(data);
            // FIX: now with sockets, the triggers are fired from socket updates.
            // trigger a create event
            // triggerEvent('create', this.object, data);
         });

         this.AB.Network.post(
            {
               url: this.object.urlRestBatch(),
               params: values,
            },
            {
               key: jobID,
               context: {},
            }
         )
            // .then((data) => {
            //    this.normalizeData(data);

            //    resolve(data);

            //    // FIX: now with sockets, the triggers are fired from socket updates.
            //    // trigger a create event
            //    // triggerEvent('create', this.object, data);
            // })
            .catch(reject);
      });
   }

   /**
    * @method create
    * update model values on the server.
    */
   create(values) {
      this.prepareMultilingualData(values);

      // add default values record if no value is passed for column
      this.object.fields().forEach((f) => {
         if (values[f.columnName] === undefined) {
            f.defaultValue(values);
         }
      });

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_create);
         this.AB.Network.post(
            {
               url: this.object.urlRest(),
               params: values,
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         ).catch((err) => {
            errorPopup(err);
            reject(err);
         });
      });
   }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer|UUID} id  the .id of the instance to remove.
    * @return {Promise}
    */
   delete(id) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_delete);
         this.AB.Network["delete"](
            {
               url: this.object.urlRestItem(id),
            },
            {
               key: jobID,
               context: { resolve, reject, id },
            }
         ).catch((err) => {
            errorPopup(err);
            reject(err);
         });
      });
   }

   /**
    * @method findAll
    * performs a data find with the provided condition.
    */
   async findAll(cond) {
      cond = cond || {};

      // 		// prepare our condition:
      // 		var newCond = {};

      // 		// if the provided cond looks like our { where:{}, skip:xx, limit:xx } format,
      // 		// just use this one.
      // 		if (cond.where) {
      // 			newCond = cond;
      // 		} else {

      // 			// else, assume the provided condition is the .where clause.
      // 			newCond.where = cond;
      // 		}

      // /// if this is our depreciated format:
      // if (newCond.where.where) {
      // 	OP.Error.log('Depreciated Embedded .where condition.');
      // }

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_findAll);
         this.AB.Network.get(
            {
               url: this.object.urlRest(),
               params: cond,
               // params: newCond
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         )
            // .then((data) => {
            //    this.normalizeData(data.data);

            //    resolve(data);
            // })
            .catch((err) => {
               if (err && err.code) {
                  switch (err.code) {
                     case "ER_PARSE_ERROR":
                        this.AB.notify.developer(err, {
                           message:
                              "AppBuilder:ABModel:findAll(): Parse Error with provided condition",
                           condition: cond,
                        });
                        break;

                     default:
                        this.AB.notify.developer(err, {
                           message:
                              "AppBuilder:ABModel:findAll(): Unknown Error with provided condition",
                           condition: cond,
                        });
                        break;
                  }
               }
               reject(err);
            });
      });
   }

   /**
    * @method loadInto
    * loads the current values into the provided Webix DataTable
    * @param {DataTable} DT  A Webix component that can dynamically load data.
    */
   loadInto(DT) {
      // if a limit was applied, then this component should be loading dynamically
      if (this._limit) {
         DT.define("datafetch", this._limit);
         DT.define("datathrottle", 250); // 250ms???

         // catch the event where data is requested:
         // here we will do our own findAll() so we can persist
         // the provided .where condition.

         // oh yeah, and make sure to remove any existing event handler when we
         // perform a new .loadInto()
         DT.___AD = DT.___AD || {};
         if (DT.___AD.onDataRequestEvent) {
            DT.detachEvent(DT.___AD.onDataRequestEvent);
         }
         DT.___AD.onDataRequestEvent = DT.attachEvent(
            "onDataRequest",
            (start, count) => {
               var cond = {
                  where: this._where,
                  sort: this._sort,
                  limit: count,
                  skip: start,
               };

               if (DT.showProgress) DT.showProgress({ type: "icon" });

               this.findAll(cond).then((data) => {
                  /*
                   // In V2: we move the row height processing into 
                   // the interface designer 

                  data.data.forEach((item) => {
                     if (
                        item.properties != null &&
                        item.properties.height != "undefined" &&
                        parseInt(item.properties.height) > 0
                     ) {
                        item.$height = parseInt(item.properties.height);
                     } else if (parseInt(this._where.height) > 0) {
                        item.$height = parseInt(this._where.height);
                     }
                  });
                  */
                  DT.parse(data);

                  if (DT.hideProgress) DT.hideProgress();
               });

               return false; // <-- prevent the default "onDataRequest"
            }
         );

         DT.refresh();
      }

      // else just load it all at once:
      var cond = {};
      if (this._where) cond.where = this._where;
      if (this._sort) cond.sort = this._sort;
      if (this._limit != null) cond.limit = this._limit;
      if (this._skip != null) cond.skip = this._skip;

      if (DT.showProgress) DT.showProgress({ type: "icon" });

      this.findAll(cond)
         .then((data) => {
            // v2: we no longer process item $height
            /*
            data.data.forEach((item) => {
               if (
                  item.properties != null &&
                  item.properties.height != "undefined" &&
                  parseInt(item.properties.height) > 0
               ) {
                  item.$height = parseInt(item.properties.height);
               } else if (parseInt(this._where.height) > 0) {
                  item.$height = parseInt(this._where.height);
               }
            });
            */

            DT.parse(data);

            if (DT.hideProgress) DT.hideProgress();
         })
         .catch((err) => {
            console.error("!!!!!", err);
         });
   }

   /**
    * @method logs()
    * return the log history related to this model's ABObject.
    * @param {hash} options
    *        a key=>value hash of optional search criteria
    *        .rowId {string} the uuid of the individual entry we are querying
    *        .levelName {string} the type of entry ["insert", "update", "delete"]
    *        .username {string} the entries associated with the given user
    *        .startDate {date} entries that happened ON or AFTER this date
    *        .endDate {date} entries that happened ON or BEFORE this date
    *        .start {integer} paging control: how many entries to skip
    *        .limit {integer} paging control: only return this # entries
    * @return {Promise}
    */
   logs(options) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_logs);
         this.AB.Network.get(
            {
               url: this.object.urlRestLog(),
               params: options,
               // params: newCond
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         ).catch((err) => {
            if (err && err.code) {
               this.AB.notify.developer(err, {
                  context: "AppBuilder:ABModel:logs(): Error",
                  options,
               });
            }
            reject(err);
         });
      });
   }

   /**
    * @method limit
    * set the limit value for this set of data
    * @param {integer} limit  the number or elements to return in this call
    * @return {ABModel} this object that is chainable.
    */
   limit(limit) {
      this._limit = limit;
      return this;
   }

   /**
    * @method skip
    * set the skip value for this set of data
    * @param {integer} skip  the number or elements to skip
    * @return {ABModel} this object that is chainable.
    */
   skip(skip) {
      this._skip = skip;
      return this;
   }

   /**
    * @method update
    * update model values on the server.
    */
   update(id, values) {
      this.prepareMultilingualData(values);

      // remove empty properties
      for (var key in values) {
         if (values[key] == null) delete values[key];
      }

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_update);
         this.AB.Network.put(
            {
               url: this.object.urlRestItem(id),
               params: values,
            },
            { key: jobID, context: { resolve, reject } }
         )
            // .then((data) => {
            //    this.normalizeData(data);

            //    resolve(data);

            //    // If we do not have socket updates available, then trigger an
            //    // update event with this data.
            //    if (this.AB.Network.type() != "socket") {
            //       this.AB.emit("ab.datacollection.update", {
            //          objectId: this.object.id,
            //          data,
            //       });
            //    }
            // })
            .catch((err) => {
               errorPopup(err);
               reject(err);
            });
      });
   }

   /**
    * @method batchUpdate
    * update value to many rows on the server.
    */
   batchUpdate({ rowIds, values }) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, (context, err /*, data */) => {
            if (err) {
               reject(err);
               return;
            }
            // this.normalizeData(data);
            resolve(true);
            // what about checking for socket updates?
         });
         this.AB.Network.put(
            {
               url: this.object.urlRestBatch(),
               params: {
                  rowIds,
                  values,
               },
            },
            { key: jobID, context: {} }
         )
            // .then(() => {
            //    resolve(true);
            // })
            .catch(reject);
      });
   }
}


/***/ }),

/***/ 70558:
/*!**************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABModelApi.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABModelAPI)
/* harmony export */ });
/* harmony import */ var _ABModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABModel */ 41637);
//
// ABModelAPI
//
// Represents the Data interface for an ABObjectQuery data.



class ABModelAPI extends _ABModel__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ///
   /// Instance Methods
   ///

   /**
    * @method findAll
    * performs a data find with the provided condition.
    */
   async findAll(cond = {}) {
      cond.isAPI = true;
      cond.url = this.object?.request?.url;

      return super.findAll(cond);
   }

   /**
    * @method batchCreate
    * update model values on the server.
    */
   batchCreate(values) {
      const error = new Error(
         "ABObjectApi.ABModelAPI.batchCreate() does not be implemented."
      );
      return Promise.reject(error);
   }

   /**
    * @method create
    * update model values on the server.
    */
   async create(values) {
      const error = new Error(
         "ABObjectApi.ABModelAPI.create() does not be implemented."
      );
      return Promise.reject(error);
   }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer|UUID} id  the .id of the instance to remove.
    * @return {Promise}
    */
   delete(id) {
      const error = new Error(
         "ABObjectApi.ABModelAPI.delete() does not be implemented."
      );
      return Promise.reject(error);
   }

   /**
    * @method update
    * update model values on the server.
    */
   update(id, values) {
      const error = new Error(
         "ABObjectApi.ABModelAPI.update() does not be implemented."
      );
      return Promise.reject(error);
   }

   /**
    * @method batchUpdate
    * update value to many rows on the server.
    */
   batchUpdate({ rowIds, values }) {
      const error = new Error(
         "ABObjectApi.ABModelAPI.batchUpdate() does not be implemented."
      );
      return Promise.reject(error);
   }
}


/***/ }),

/***/ 19901:
/*!**********************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABModelApiNetsuite.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABModelAPINetsuite)
/* harmony export */ });
/* harmony import */ var _ABModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABModel */ 41637);
//
// ABModelAPINetsuite
//
// Represents the Data interface for a connection to Netsuite.



class ABModelAPINetsuite extends _ABModel__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ///
   /// Instance Methods
   ///

   /**
    * @method normalizeData()
    * For a Netsuite object, there are additional steps we need to handle
    * to normalize our data.
    */
   normalizeData(data) {
      super.normalizeData(data);

      if (!Array.isArray(data)) {
         data = [data];
      }

      var boolFields = this.object.fields((f) => f.key == "boolean");
      let allFields = this.object.fields();

      data.forEach((d) => {
         // Netsuite sometimes keeps keys all lowercase
         // which might not match up with what it told us in the meta-catalog
         // which we need:
         for (var i = 0; i < allFields.length; i++) {
            let actualColumn = allFields[i].columnName;
            let lcColumn = actualColumn.toLowerCase();

            if (
               typeof d[actualColumn] == "undefined" &&
               typeof d[lcColumn] != "undefined"
            ) {
               d[actualColumn] = d[lcColumn];
               delete d[lcColumn];
            }
         }

         // Netsuite Booleans are "T" or "F"
         boolFields.forEach((bField) => {
            let val = d[bField.columnName];
            // just how many ways can a DB indicate True/False?
            if (typeof val == "string") {
               val = val.toLowerCase();

               if (val === "t") val = true;
               else val = false;

               d[bField.columnName] = val;
            }
         });
      });
   }
}


/***/ }),

/***/ 56972:
/*!****************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABModelQuery.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABModelQuery)
/* harmony export */ });
/* harmony import */ var _ABModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABModel */ 41637);
//
// ABModelQuery
//
// Represents the Data interface for an ABObjectQuery data.



class ABModelQuery extends _ABModel__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ///
   /// Instance Methods
   ///

   /**
    * @method batchCreate
    * update model values on the server.
    */
   batchCreate(values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.batchCreate() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method create
    * update model values on the server.
    */
   create(values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.create() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer|UUID} id  the .id of the instance to remove.
    * @return {Promise}
    */
   delete(id) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.delete() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method update
    * update model values on the server.
    */
   update(id, values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.update() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method batchUpdate
    * update value to many rows on the server.
    */
   batchUpdate({ rowIds, values }) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.batchUpdate() should not be called."
      );
      return Promise.reject(error);
   }
}


/***/ }),

/***/ 83311:
/*!************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABObject.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObject)
/* harmony export */ });
/* harmony import */ var _core_ABObjectCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABObjectCore */ 92741);

// import ABObjectWorkspaceViewCollection from "./workspaceViews/ABObjectWorkspaceViewCollection";

var L = null;

// NOTE: this has been moved to NetworkRestSocket:
//
// // Start listening for server events for object updates and call triggerEvent as the callback
// if (typeof io != "undefined") {
//    io.socket.on("ab.object.update", function (msg) {
//       AB.emit("ab.object.update", {
//          objectId: msg.objectId,
//          data: msg.data,
//       });
//    });
// } else {
//    console.error("TODO: ABObject: configure Socket.io");
// }

// io.socket.on("ab.object.delete", function (msg) {
// });

class ABObject extends _core_ABObjectCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      if (!L) L = AB.Label();
      super(attributes, AB);

      // this.workspaceViews = new ABObjectWorkspaceViewCollection(
      //    attributes,
      //    this,
      //    AB
      // );

      // listen for our ABFields."definition.updated"
      this.fields().forEach((f) => {
         f.on("definition.updated", (field) => {
            // create a new Field with the updated def
            var def = this.AB.definitionByID(field.id);
            if (!def) return;

            var newField = this.AB.fieldNew(def, this);

            // we want to keep the same fieldID order:
            var newFields = [];
            this.fields().forEach((f) => {
               if (f.id === field.id) {
                  newFields.push(newField);
                  return;
               }
               newFields.push(f);
            });

            this._fields = newFields;
         });
      });

      // listen
      // this.AB.on("ab.object.update", (data) => {
      //    if (this.id == data.objectId) this.fromValues(data.data);
      // });

      this._pendingNetworkRequests = {};
      // {hash}   uuid : {Promise}
      // convert our migrateXXXX() operations to be Relay/offline compatible.
      // if a queued operation is sent after a web browser refresh, then
      // we will NOT have a pending promise to .resolve()/.reject()

      this._handler_object_migrate = (context, err, response) => {
         // NOTE:
         var pending = this._pendingNetworkRequests?.[context.uuid];
         if (err) {
            pending?.reject(err);
            return;
         }
         pending?.resolve(response);
      };
      this.AB.Network.on("object.migrate", this._handler_object_migrate);
   }

   /**
    * @method refreshInstance()
    * Used when a definition.updated message is detected on this ABObject.
    * This method will return a new instance based upon the current definition
    * and properly resolve any handlers and pending network Requests.
    * @return {ABObject}
    */
   refreshInstance() {
      var newObj = this.AB.objectByID(this.id);

      // prevent doing this multiple times:
      if (this._pendingNetworkRequests) {
         // remove object.migrate listener
         this.AB.Network.removeListener(
            "object.migrate",
            this._handler_object_migrate
         );

         // transfer the pending network requests
         newObj._pendingNetworkRequests = this._pendingNetworkRequests;
         this._pendingNetworkRequests = null;
      }

      return newObj;
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
		{
			id: uuid(),
			name: 'name',
			labelFormat: 'xxxxx',
			isImported: 1/0,
			isExternal: 1/0,
			urlPath:'string',
			importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
										// to get other object:  ABApplication.objectFromRef(obj.importFromObject);
			translations:[
				{}
			],
			fields:[
				{ABDataField}
			]
		}
		*/

      super.fromValues(attributes);

      if (this.workspaceViews) this.workspaceViews.fromObj(attributes);
   }

   //// TODO: Refactor isValid() to ignore op and not error if duplicateName is own .id

   isValid() {
      var validator = this.AB.Validation.validator();

      // label/name must be unique:
      var isNameUnique =
         this.AB.objects((o) => {
            return (
               o.id != this.id &&
               o.name.toLowerCase() == this.name.toLowerCase()
            );
         }).length == 0;
      if (!isNameUnique) {
         validator.addError(
            "name",
            L('Object name must be unique ("{0}" already in use)', [this.name])
         );
      }

      // Check the common validations:
      // TODO:
      // if (!inputValidator.validate(values.label)) {
      // 	_logic.buttonSaveEnable();
      // 	return false;
      // }

      return validator;
   }

   /**
    * @method isValidData
    * Parse through the given data and return an array of any invalid
    * value errors.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   isValidData(data) {
      var validator = this.AB.Validation.validator();
      this.fields().forEach((f) => {
         // check if value was passed, if so validate it
         if (data.hasOwnProperty(f.columnName)) f.isValidData(data, validator);
      });

      return validator;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fieldNew()
    *
    * return an instance of a new (unsaved) ABField that is tied to this
    * ABObject.
    *
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    *
    * @param {obj} values  the initial values for this field.
    *						{ key:'{string}'} is required
    * @return {ABField}
    */
   // fieldNew ( values ) {
   // 	// NOTE: ABFieldManager returns the proper ABFieldXXXX instance.
   // 	return ABFieldManager.newField( values, this );
   // }

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   async destroy() {
      /*
        return new Promise((resolve, reject) => {
            // Remove the import object, then its model will not be destroyed
            if (this.isImported) {
                this.application
                    .objectDestroy(this)
                    .catch(reject)
                    .then(() => {
                        resolve();
                    });

                return;
            }

            // OK, some of our Fields have special follow up actions that need to be
            // considered when they no longer exist, so before we simply drop this
            // object/table, drop each of our fields and give them a chance to clean up
            // what needs cleaning up.

            // ==> More work, but safer.
            var fieldDrops = [];
            this.fields().forEach((f) => {
                fieldDrops.push(f.destroy());
            });

            Promise.all(fieldDrops)
                .then(() => {
                    return new Promise((next, err) => {
                        // now drop our table
                        // NOTE: our .migrateXXX() routines expect the object to currently exist
                        // in the DB before we perform the DB operations.  So we need to
                        // .migrateDrop()  before we actually .objectDestroy() this.
                        this.migrateDrop()
                            .then(() => {
                                // finally remove us from the application storage
                                return this.application.objectDestroy(this);
                            })
                            .then(next)
                            .catch(err);
                    });
                })

                // flag .disable to queries who contains this removed object
                .then(() => {
                    return new Promise((next, err) => {
                        this.application
                            .queries(
                                (q) =>
                                    q.objects((o) => o.id == this.id).length > 0
                            )
                            .forEach((q) => {
                                q._objects = q.objects((o) => o.id != this.id);

                                q.disabled = true;
                            });

                        next();
                    });
                })
                .then(resolve)
                .catch(reject);
        });
 */

      var removeFromApplications = () => {
         var allRemoves = [];
         this.AB.applications().forEach((app) => {
            allRemoves.push(app.objectRemove(this));
         });
         return Promise.all(allRemoves);
      };

      var disableRelatedQueries = () => {
         return new Promise((next /*, err */) => {
            this.AB.queries(
               (q) => q.objects((o) => o.id == this.id).length > 0
            ).forEach((q) => {
               // q._objects = q.objects((o) => o.id != this.id);

               q.disabled = true;
            });

            next();
         });
      };

      try {
         // 1) remove us from all Application:
         await removeFromApplications();

         // 2) disable any connected Queries
         await disableRelatedQueries();

         // if an imported Object (FederatedTable, Existing Table, etc...)
         // then skip this step
         if (this.isImported) {
            return Promise.resolve();
         }

         // time to remove my table:
         // NOTE: our .migrateXXX() routines expect the object to currently exist
         // in the DB before we perform the DB operations.  So we need to
         // .migrateDrop()  before we actually .destroy() this.
         await this.migrateDrop();

         // now remove my definition

         // start with my fields:
         var fieldDrops = [];

         // Only ABObjects should attempt any fieldDrops.
         // ABObjectQueries can safely skip this step:
         if (this.type == "object") {
            var allFields = this.fields();
            this._fields = []; // clear our field counter so we don't retrigger
            // this.save() on each field.destroy();

            allFields.forEach((f) => {
               fieldDrops.push(f.destroy());
            });
         }
         await Promise.all(fieldDrops);

         await super.destroy();
         this.emit("destroyed");
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABObject.destroy(): error destroying object.",
         });
      }

      // return Promise.resolve()
      //    .then(() => {
      //       // 1) remove us from all Application:
      //       return removeFromApplications();
      //    })
      //    .then(() => {
      //       // 2) disable any connected Queries
      //       return disableRelatedQueries();
      //    })
      //    .then(() => {
      //       // if an imported Object (FederatedTable, Existing Table, etc...)
      //       // then skip this step
      //       if (this.isImported) {
      //          return Promise.resolve();
      //       }

      //       // time to remove my table:
      //       // NOTE: our .migrateXXX() routines expect the object to currently exist
      //       // in the DB before we perform the DB operations.  So we need to
      //       // .migrateDrop()  before we actually .destroy() this.
      //       return this.migrateDrop();
      //    })
      //    .then(() => {
      //       // now remove my definition

      //       // start with my fields:
      //       var fieldDrops = [];

      //       // Only ABObjects should attempt any fieldDrops.
      //       // ABObjectQueries can safely skip this step:
      //       if (this.type == "object") {
      //          var allFields = this.fields();
      //          this._fields = []; // clear our field counter so we don't retrigger
      //          // this.save() on each field.destroy();

      //          allFields.forEach((f) => {
      //             fieldDrops.push(f.destroy());
      //          });
      //       }

      //       return Promise.all(fieldDrops)
      //          .then(() => {
      //             // now me.
      //             return super.destroy();
      //          })
      //          .then(() => {
      //             this.emit("destroyed");
      //          });
      //    });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   async save() {
      var isAdd = false;

      // if this is our initial save()
      if (!this.id) {
         this.label = this.label || this.name;
         isAdd = true;
      }

      try {
         await super.save();
         if (isAdd) {
            await this.migrateCreate();
         }
         return this;
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABObject.save()",
            obj: this.toObj(),
         });
         throw err;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var result = super.toObj();

      // result.objectWorkspaceViews = this.workspaceViews.toObj();

      return result;
   }

   ///
   /// DB Migrations
   ///

   migrateCreate() {
      return new Promise((resolve, reject) => {
         var uuid = this.AB.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "object.migrate",
            context: { uuid, id: this.id },
         };
         this.AB.Network.post(
            {
               url: `/definition/migrate/object/${this.id}`,
            },
            jobResponse
         );
      });
   }

   migrateDrop() {
      return new Promise((resolve, reject) => {
         var uuid = this.AB.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "object.migrate",
            context: { uuid, id: this.id },
         };
         this.AB.Network["delete"](
            {
               url: `/definition/migrate/object/${this.id}`,
            },
            jobResponse
         );
      });
   }

   ///
   /// Working with Client Components:
   ///

   /**
    * @method columnResize()
    *
    * save the new width of a column
    *
    * @param {} id The instance of the field to save.
    * @param {int} newWidth the new width of the field
    * @param {int} oldWidth the old width of the field
    * @return {Promise}
    */
   columnResize(columnName, newWidth /*, oldWidth */) {
      var fieldID = null;
      for (var i = 0; i < this._fields.length; i++) {
         if (this._fields[i].columnName == columnName) {
            fieldID = this._fields[i].id;
            break;
            // this._fields[i].settings.width = newWidth;
         }
      }

      // Johnny: This is better but still not right.  the ABObject should not be
      // storing sizes for field widths.  That is a function of the UI and which
      // Grid is being displayed.  THAT GRID should be storing a column width
      // locally.
      // TODO: once we have v2 in place.

      var fieldSettings = this.AB.localSettings(fieldID);
      fieldSettings = fieldSettings || {};
      fieldSettings.width = newWidth;

      return this.AB.localSettings(fieldID, fieldSettings);
      // return this.save();
   }

   // return the column headers for this object
   // @param {bool} isObjectWorkspace  return the settings saved for the object workspace
   columnHeaders(
      isObjectWorkspace,
      isEditable,
      summaryColumns,
      countColumns,
      hiddenFieldNames
   ) {
      summaryColumns = summaryColumns || [];
      countColumns = countColumns || [];

      var headers = [];
      // var columnNameLookup = {};

      // get the header for each of our fields:
      this.fields().forEach((f) => {
         var header = f.columnHeader({
            isObjectWorkspace: isObjectWorkspace,
            editable: isEditable,
         });

         if (isEditable) {
            header.validationRules = f.settings.validationRules;
         }

         header.alias = f.alias || undefined; // query type
         header.fieldID = f.id;
         // header.fieldURL = f.urlPointer();

         // if the field specifies a width
         if (f.settings.width != 0) {
            header.width = f.settings.width;
         }

         // if the User has already updated a local width for this
         var fieldSettings = this.AB.localSettings(f.id);
         if (fieldSettings && fieldSettings.width) {
            if (!header.width || fieldSettings.width > header.width) {
               // set column width to the customized width
               header.width = fieldSettings.width;
            }
         }

         if (!header.width) {
            // set column width to adjust:true by default;
            header.adjust = true;
         }

         // add the summary footer
         if (summaryColumns.indexOf(f.id) > -1) {
            if (f.key == "calculate" || f.key == "formula") {
               header.footer = { content: "totalColumn", field: f };
            } else {
               header.footer = { content: "summColumn" };
            }
         }
         // add the count footer
         else if (countColumns.indexOf(f.id) > -1)
            header.footer = { content: "countColumn" };

         headers.push(header);
         // columnNameLookup[header.id] = f.columnName; // name => id
      });

      // update our headers with any settings applied in the Object Workspace
      /*
      // In v2: this is handled by the ABDesigner
      //
      if (isObjectWorkspace) {
         let hiddenFieldList = [];

         if (hiddenFieldNames && hiddenFieldNames.length > 0)
            hiddenFieldList = hiddenFieldNames;
         // else if (this.workspaceHiddenFields)
         //    hiddenFieldList = this.workspaceHiddenFields;

         if (hiddenFieldList.length > 0) {
            hiddenFieldList.forEach((hfID) => {
               headers.forEach((h) => {
                  if (columnNameLookup[h.id] == hfID) {
                     h.hidden = true;
                  }
               });
            });
         }
      }
      */

      return headers;
   }

   // after a component has rendered, tell each of our fields to perform
   // any custom display operations
   // @param {Webix.DataStore} data a webix datastore of all the rows effected
   //        by the render.
   customDisplays(data, App, DataTable, rowIds, isEditable) {
      if (!data || !data.getFirstId) return;

      // var fields = this.fields(f => this.workspaceHiddenFields.indexOf(f.columnName) < 0);
      let fields = [];
      DataTable.eachColumn((columnName) => {
         let field = this.fields((f) => f.columnName == columnName)[0];
         if (field) fields.push(field);
      });

      if (rowIds != null) {
         rowIds.forEach((id) => {
            let row = data.getItem(id);
            if (row) {
               fields.forEach((f) => {
                  let node = DataTable.getItemNode({
                     row: row.id,
                     column: f.columnName,
                  });
                  f.customDisplay(row, App, node, {
                     editable: isEditable,
                  });
               });
            }
         });
      } else {
         let id = data.getFirstId();
         while (id) {
            var row = data.getItem(id);
            if (row) {
               fields.forEach((f) => {
                  var node = DataTable.getItemNode({
                     row: row.id,
                     column: f.columnName,
                  });
                  f.customDisplay(row, App, node, {
                     editable: isEditable,
                  });
               });
            }
            id = data.getNextId(id);
         }
      }
   }

   // Display data with label format of object
   displayData(rowData) {
      if (rowData == null) return "";

      // translate multilingual
      //// TODO: isn't this a MLObject??  use this.translate()
      var mlFields = this.multilingualFields();
      this.translate(rowData, rowData, mlFields);

      var labelData = this.labelFormat || "";

      // default label
      if (!labelData && this.fields().length > 0) {
         var defaultField = this.fields((f) => f.fieldUseAsLabel())[0];
         if (defaultField) labelData = `{${defaultField.id}}`;
         else
            labelData = `${this.AB.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`; // show id of row
      }

      // get column ids in {colId} template
      // ['{colId1}', ..., '{colIdN}']
      var colIds = labelData.match(/\{[^}]+\}/g);

      if (colIds && colIds.forEach) {
         colIds.forEach((colId) => {
            var colIdNoBracket = colId.replace("{", "").replace("}", "");

            var field = this.fieldByID(colIdNoBracket);
            if (field == null) return;

            labelData = labelData.replace(colId, field.format(rowData) || "");
         });
      }

      // if label is empty, then show .id
      if (!labelData.trim()) {
         let labelSettings = this.labelSettings || {};
         if (labelSettings && labelSettings.isNoLabelDisplay) {
            labelData = L(labelSettings.noLabelText || "[No Label]");
         } else {
            // show id of row
            labelData = `${this.AB.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`;
         }
      }

      return labelData;
   }

   currentView() {
      console.error("ABObject.currentView(): who is calling this?");
      return null;
      // return this.workspaceViews.getCurrentView();
   }

   warningsAll() {
      // report both OUR warnings, and any warnings from any of our fields
      var allWarnings = super.warningsAll();
      this.fields().forEach((f) => {
         allWarnings = allWarnings.concat(f.warnings());
      });

      this.indexes().forEach((i) => {
         allWarnings = allWarnings.concat(i.warnings());
      });

      return allWarnings.filter((w) => w);
   }

   warningsEval() {
      super.warningsEval();

      let allFields = this.fields();

      if (allFields.length == 0) {
         this.warningsMessage("has no fields");
      }

      (this._unknownFieldIDs || []).forEach((id) => {
         this.warningsMessage(`is referencing an unknown field id[${id}]`);
      });

      (this._unknownIndex || []).forEach((id) => {
         this.warningsMessage(`is referencing an unknown index id[${id}]`);
      });

      allFields.forEach((f) => {
         f.warningsEval();
      });

      this.indexes().forEach((i) => {
         i.warningsEval();
      });
   }

   warningsMessage(msg, data = {}) {
      let message = `Object[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
      // this.emit("warning", warnMsg, data);
   }

   isUuid(text) {
      console.error(
         "ABObject.isUuid(): is depreciated.  directly reference AB.Rules.isUUID() instead."
      );
      return this.AB.isUUID(text);
   }
}


/***/ }),

/***/ 9611:
/*!***************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABObjectApi.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectApi)
/* harmony export */ });
/* harmony import */ var _core_ABObjectApiCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABObjectApiCore */ 31549);


/**
 * ABObjectApi
 * These are ABObjects that were Imported from existing Tables in the
 * system.
 *
 * NOTE: on the web client, these should function just like ABObjects
 */
class ABObjectApi extends _core_ABObjectApiCore__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 65506:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABObjectApiNetsuite.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectApiNetsuite)
/* harmony export */ });
/* harmony import */ var _core_ABObjectApiNetsuiteCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABObjectApiNetsuiteCore */ 55336);


/**
 * ABObjectApiNetsuite
 * These are ABObjects that were Imported from existing Tables in the
 * system.
 *
 * NOTE: on the web client, these should function just like ABObjects
 */
class ABObjectApiNetsuite extends _core_ABObjectApiNetsuiteCore__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 18700:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABObjectExternal.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectExternal)
/* harmony export */ });
/* harmony import */ var _ABObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABObject */ 83311);


/**
 * ABObjectExternal
 * These are ABObjects that ... (might need to be refactored out?)
 * NOTE: on the web client, these should function just like ABObjects
 */
class ABObjectExternal extends _ABObject__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 94910:
/*!******************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABObjectImport.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectImport)
/* harmony export */ });
/* harmony import */ var _ABObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABObject */ 83311);


/**
 * ABObjectImport
 * These are ABObjects that were Imported from existing Tables in the
 * system.
 *
 * NOTE: on the web client, these should function just like ABObjects
 */
class ABObjectImport extends _ABObject__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 59545:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABObjectQuery.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectQuery)
/* harmony export */ });
/* harmony import */ var _core_ABObjectQueryCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABObjectQueryCore */ 20391);
//
// ABObjectQuery
//
// A type of Object in our system that is based upon a complex relationship of multiple
// existing Objects.
//
// In the QueryBuilder section of App Builder, a new Query Object can be created.
// An initial Object can be chosen from our current list of Objects. After that, additional Objects
// and a specified join type can be specified.
//
// A list of fields from each specified Object can also be included as the data to be returned.
//
// A where statement is also part of the definition.
//



var ABFactory = null;
if (typeof io != "undefined") {
   io.socket.on("ab.query.update", function (msg) {
      if (ABFactory) {
         ABFactory.emit("ab.query.update", {
            queryId: msg.queryId,
            data: msg.data,
         });
      } else {
         console.error(
            "ABObjectQuery:: received io.socket msg before ABFactory is defined"
         );
         console.error("TODO: move this to ABFactory!");
      }
   });
} else {
   console.error("TODO: install socket.io client for sails updates.");
}

// io.socket.on("ab.query.delete", function (msg) {
// });

class ABObjectQuery extends _core_ABObjectQueryCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      if (!ABFactory) {
         ABFactory = AB;
      }
      // listen
      this.AB.on("ab.query.update", (data) => {
         if (this.id == data.queryId) this.fromValues(data.data);
      });

      // .fromValues() should already have been called in super()
      // so now add in our conditionScan()
      // NOTE: this can be folded into the Core once filterComplex
      // is fully implemented and not on Platform only.

      // now scan our conditions to make sure they are
      // 1) reference fields that exist in our Query
      // 2) completely filled out conditions.
      this.conditionScan(this.where);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObjectQuery
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   // destroy() {
   //    return super.destroy().then(() => {
   //       console.error("Move .queryRemove() to Appbuilder Designer.");
   //       // return this.AB.queryRemove(this);
   //    });
   // }

   /**
    * @method save()
    *
    * persist this instance of ABObjectQuery with it's parent ABApplication
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   // async save() {
   //    try {
   //       await super.save();
   //       return this;
   //    } catch (err) {
   //       this.AB.notify.developer(err, {
   //          context: "ABObjectQuery.save()",
   //          query: this.toObj(),
   //       });
   //       throw err;
   //    }
   // }

   ///
   /// Fields
   ///

   /**
    * @method importFields
    * instantiate a set of fields from the given attributes.
    * Our attributes are a set of field URLs That should already be created in their respective
    * ABObjects.
    * @param {array} fieldSettings The different field urls for each field
    *             { }
    * @param {bool} shouldAliasColumn
    *        should we add the object alias to the columnNames?
    *        this is primarily used on the web client
    */
   importFields(fieldSettings) {
      super.importFields(fieldSettings);

      this._fields.forEach((fieldEntry) => {
         // include object name {aliasName}.{columnName}
         // to use it in grid headers & hidden fields
         fieldEntry.field.columnName = `${fieldEntry.alias}.${fieldEntry.field.columnName}`;
      });
   }

   /**
    * @method columnResize()
    *
    * save the new width of a column
    *
    * @param {} id The instance of the field to save.
    * @param {int} newWidth the new width of the field
    * @param {int} oldWidth the old width of the field
    * @return {Promise}
    */
   columnResize(columnName, newWidth, oldWidth) {
      let field = this.fields((f) => f.columnName == columnName)[0];
      if (field) {
         field.settings.width = newWidth;

         return this.save();
      } else {
         return Promise.resolve();
      }
   }

   ///
   /// Working with Client Components:
   ///

   // return the column headers for this object
   // @param {bool} isObjectWorkspace  return the settings saved for the object workspace
   columnHeaders(
      isObjectWorkspace,
      isEditable,
      summaryColumns,
      countColumns,
      hiddenFieldNames
   ) {
      var headers = super.columnHeaders(
         isObjectWorkspace,
         isEditable,
         summaryColumns,
         countColumns,
         hiddenFieldNames
      );

      headers.forEach((h) => {
         // pull object by alias
         let object = this.objectByAlias(h.alias);
         if (!object) return;

         let field = object.fieldByID(h.fieldID);
         if (!field) return;

         // NOTE: query v1
         let alias = "";
         if (Array.isArray(this.joins())) {
            alias = field.object.name;
         } else {
            alias = h.alias;
         }

         // include object name {aliasName}.{columnName}
         // to use it in grid headers & hidden fields
         h.id = `${alias}.${field.columnName}`;

         // label
         if (this.settings && this.settings.hidePrefix) {
            h.header = `${field.label || ""}`;
         } else {
            h.header = `${field.object.label || ""}.${field.label || ""}`;
         }

         // icon
         if (field.settings && field.settings.showIcon) {
            h.header = `<span class="webix_icon fa fa-${field.fieldIcon()}"></span>${
               h.header
            }`;
         }

         // If this query supports grouping, then add folder icon to display in grid
         if (this.isGroup) {
            let originTemplate = h.template;

            h.template = (item, common) => {
               if (item[h.id])
                  return (
                     common.icon(item, common) +
                     (originTemplate
                        ? originTemplate(item, common, item[h.id])
                        : item[h.id])
                  );
               else return "";
            };
         }

         h.adjust = true;
         h.minWidth = 220;
      });

      return headers;
   }

   /**
    * @method conditionScan()
    * Scan the provided condition object and determine if there are any
    * configuration issues.
    * @param {obj} rule
    *        the QueryBuilder rule that we are scanning.
    * @param {array} listWarnings
    *        An array of warnings that we should add our notices to.
    */
   conditionScan(rule) {
      if (!rule) {
         return;
      }

      if (rule.glue) {
         (rule.rules || []).forEach((r) => {
            this.conditionScan(r);
         });
         return;
      }

      // 1) we need to have any key as one of our fields.
      let field = this.fieldByID(rule.key);
      if (!field && rule.key != "this_object") {
         this.warningsMessage(
            "condition does not reference one of our fields",
            {
               rule,
            }
         );
      }

      // 2) completely filled out conditions.
      if (!this._conditionCheck) {
         this._conditionCheck = this.AB.filterComplexNew(
            `${this.id}_conditionCheck`
         );
         // {FilterComplex} ._conditionCheck
         // has our .isConditionComplete() method.
      }
      if (!this._conditionCheck.isConditionComplete(rule)) {
         this.warningsMessage("incomplete condition definition", {
            rule,
         });
      }
   }

   warningsEval() {
      super.warningsEval();

      this.conditionScan(this.where);

      /// include importFields() warnings:
      this.__missingObject.forEach((f) => {
         this.warningsMessage(
            `IMPORT FIELDS: could not resolve object[${
               f.objectID
            }] for fieldSetting ${JSON.stringify(f)}`,
            {
               fieldInfo: f,
            }
         );
      });

      this.__missingFields.forEach((f) => {
         this.warningsMessage(
            `IMPORT FIELDS: Object[${f.objID}] could not find field[${
               f.fieldID
            }] for fieldSetting ${JSON.stringify(f.fieldInfo)}`,
            {
               object: f.objID,
               fieldInfo: f.fieldInfo,
            }
         );
      });

      this.__cantFilter.forEach((f) => {
         this.warningsMessage(
            `Field[${f.field.id}] referenced in fieldSetting[${JSON.stringify(
               f.fieldInfo
            )}] did not pass .canFilterField`,
            {
               field: f.field.toObj(),
               fieldInfo: f.fieldInfo,
            }
         );
      });

      this.__duplicateFields.forEach((f) => {
         this.warningsMessage(
            `Field[${
               f.fieldInfo.fieldID
            }] referenced in fieldSetting[${JSON.stringify(
               f.fieldInfo
            )}] is a duplicate`,
            {
               fieldInfo: f.fieldInfo,
            }
         );
      });

      this.__linkProblems.forEach((f) => {
         this.warningsMessage(f.message, f.data);
      });
   }

   warningsMessage(msg, data = {}) {
      let message = `Query[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   isUuid(text) {
      console.error(
         "ABObject.isUuid(): is depreciated.  directly reference AB.Rules.isUUID() instead."
      );
      return this.AB.isUUID(text);
   }
}


/***/ }),

/***/ 33046:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABProcess.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcess)
/* harmony export */ });
/* harmony import */ var _core_ABProcessCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABProcessCore */ 44166);


class ABProcess extends _core_ABProcessCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      this._unknownShapes = [];
      // {array} [ BPMN:Shape, ... ]
      // Generic Shapes that are added to the Process are registered here.
      // We will list these as warnings to the ABDesigner.

      // listen
      this.AB.on("ab.abprocess.update", (data) => {
         if (this.id == data.objectId) this.fromValues(data.data);
      });
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy() {
      // remove all my Elements
      var allElements = this.elements();
      var allDestroy = [];
      allElements.forEach((e) => {
         allDestroy.push(e.destroy());
      });

      return Promise.all(allDestroy).then(() => {
         // now remove myself
         return new Promise((resolve, reject) => {
            this.toDefinition()
               .destroy()
               .then(() => {
                  // allow normal processing to contine now:
                  resolve();
               })
               .then(() => {
                  // in the background
                  // remove this reference from ALL Applications that link
                  // to me:
                  console.error(
                     "TODO: ABProcess.destroy(): refactor to .emit('destroyed') and let containing Apps self remove."
                  );
                  var appsWithProcess = this.AB.applications().find((a) => {
                     return a.hasProcess(this);
                  });
                  if (appsWithProcess.length > 0) {
                     appsWithProcess.forEach((a) => {
                        a.processRemove(this);
                     });
                  }
               })
               .catch((err) => {
                  reject(err);
               });
         });
      });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   save() {
      // if this is an update:
      // if (this.id) {
      // 	return ABDefinition.update(this.id, this.toDefinition());
      // } else {

      // 	return ABDefinition.create(this.toDefinition());
      // }

      // make sure all our tasks have save()ed.
      var allSaves = [];
      var allTasks = this.elements();
      allTasks.forEach((t) => {
         allSaves.push(t.save());
      });
      return Promise.all(allSaves).then(() => {
         // now we can save our Process definition
         return this.toDefinition()
            .save()
            .then((data) => {
               // if I didn't have an .id then this was a create()
               // and I need to update my data with the generated .id

               if (!this.id) {
                  this.id = data.id;
               }

               // Also, our embedded elements now all have .ids
               // where they might not have before.  So now
               // rebuild our this._elements hash with all id
               var _new = {};
               let _old = this._elements;
               Object.keys(this._elements).forEach((k) => {
                  _new[this._elements[k].id] = this._elements[k];
               });
               this._elements = _new;

               // check to see if an update happened and then make
               // sure we have that saved.
               let needSave = false;
               Object.keys(_new).forEach((k) => {
                  if (!_old[k]) {
                     needSave = true;
                  }
               });

               if (needSave) {
                  return this.save();
               }
            });
      });
   }

   isValid() {
      var validator = this.AB.Validation.validator();

      // label/name must be unique:
      var isNameUnique =
         this.AB.processes((o) => {
            return o.name.toLowerCase() == this.name.toLowerCase();
         }).length == 0;
      if (!isNameUnique) {
         let L = this.AB.Label();
         validator.addError(
            "name",
            L(`Process name must be unique ("{0}" already in use)`, [this.name])
         );
      }

      return validator;
   }

   /**
    * @method elementNewForModelDefinition()
    * create a new process element defined by the given BPMN:Element
    *
    * the BPMN:Element definition comes from the BPMN Modeler when a new
    * diagram element is created.
    *
    * @param {BPMN:Element} element
    *        the BPMN modeler diagram element definition
    * @return {ABProcess[OBJ]}
    */
   elementNewForModelDefinition(element) {
      var task = this.AB.processElementNewForModelDefinition(element, this);
      if (task) {
         this.elementAdd(task);
      }
      return task;
   }

   /**
    * @method unknownShape()
    * store a reference to a BPMN Shape that is in our XML diagram,
    * but we don't have an element for.
    * @param {BPMN:Shape} shape
    */
   unknownShape(shape) {
      this.unknownShapeRemove(shape);
      this._unknownShapes.push(shape);
   }

   /**
    * @method unknownShapeRemove()
    * make sure we no longer track the provided BPMN Shape as an unknown shape.
    * @param {BPMN:Shape} shape
    */
   unknownShapeRemove(shape) {
      this._unknownShapes = this._unknownShapes.filter((s) => s.id != shape.id);
   }

   /**
    * @method warningsAll()
    * Return an array of mis configuration warnings for our object or any
    * of our sub elements.
    * @return {array} [ { message: "warning message", data:{} } ]
    */
   warningsAll() {
      // report both OUR warnings, and any warnings from any of our fields
      var allWarnings = [].concat(this._warnings);
      this.elements().forEach((e) => {
         e.warningsEval();
         allWarnings = allWarnings.concat(e.warnings());
      });

      if (this.elements().length == 0) {
         allWarnings.push({ message: "No process Tasks defined.", data: {} });
      }

      // perform a check of our xml document to see if we have any unknown
      // shapes
      if (!this._DOMParser) {
         if (window.DOMParser) {
            // Handy snippet from https://stackoverflow.com/questions/17604071/parse-xml-using-javascript
            this._DOMParser = function (xmlStr) {
               return new window.DOMParser().parseFromString(
                  xmlStr,
                  "text/xml"
               );
            };
         } else if (
            typeof window.ActiveXObject != "undefined" &&
            new window.ActiveXObject("Microsoft.XMLDOM")
         ) {
            this._DOMParser = function (xmlStr) {
               var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
               xmlDoc.async = "false";
               xmlDoc.loadXML(xmlStr);
               return xmlDoc;
            };
         } else {
            throw new Error("No XML parser found");
         }
      }

      // find any references to our generic shapes
      let xml = this._DOMParser(this.xmlDefinition);
      const genericShapes = [
         "bpmn2:startEvent",
         "bpmn2:task",
         "bpmn2:endEvent",
      ];
      genericShapes.forEach((s) => {
         let allElements = xml.getElementsByTagName(s);
         for (let x = 0; x < allElements.length; x++) {
            // if we don't know about this shape
            let ele = allElements[x];
            let myEle = this.elementForDiagramID(allElements[x].id);
            if (!myEle) {
               this.unknownShape(allElements[x]);
            }
         }
      });

      // if any unknown shapes have been reported:
      if (this._unknownShapes.length) {
         allWarnings.push({
            message: "Generic Tasks still undefined.",
            data: {},
         });
      }

      return allWarnings;
   }
}


/***/ }),

/***/ 81410:
/*!**********************************************!*\
  !*** ./src/js/AppBuilder/platform/ABStep.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABStep)
/* harmony export */ });
/* harmony import */ var _core_ABStepCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABStepCore */ 53618);


// let L = (...params) => AB.Multilingual.label(...params);

class ABStep extends _core_ABStepCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      // listen
      // this.AB.on("ab.abprocess.update", (data) => {
      //    if (this.id == data.objectId) this.fromValues(data.data);
      // });
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy() {
      // debugger;

      return new Promise((resolve, reject) => {
         this.toDefinition()
            .destroy()
            .then(() => {
               resolve();
            })
            .catch((err) => {
               reject(err);
            });
      });

      // remove all my Elements
      // var allElements = this.elements();
      // var allDestroy = [];
      // allElements.forEach((e) => {
      //    allDestroy.push(e.destroy());
      // });

      // return Promise.all(allDestroy).then(() => {
      //    // now remove myself
      //    return new Promise((resolve, reject) => {
      //       this.toDefinition()
      //          .destroy()
      //          .then(() => {
      //             // allow normal processing to contine now:
      //             resolve();
      //          })
      //          .then(() => {
      //             // in the background
      //             // remove this reference from ALL Applications that link
      //             // to me:
      //             console.error(
      //                "TODO: ABProcess.destroy(): refactor to .emit('destroyed') and let containing Apps self remove."
      //             );
      //             var appsWithProcess = this.AB.applications().find((a) => {
      //                return a.hasProcess(this);
      //             });
      //             if (appsWithProcess.length > 0) {
      //                appsWithProcess.forEach((a) => {
      //                   a.processRemove(this);
      //                });
      //             }
      //          })
      //          .catch((err) => {
      //             reject(err);
      //          });
      //    });
      // });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *                .resolve( {this} )
    */
   save() {
      // debugger;
      return this.toDefinition()
         .save()
         .then((data) => {
            // if I didn't have an .id then this was a create()
            // and I need to update my data with the generated .id

            if (!this.id) {
               this.id = data.id;
            }
            return this;
         });
   }

   isValid() {
      // debugger;
      return true;
      // var validator = this.AB.Validation.validator();

      // // label/name must be unique:
      // var isNameUnique =
      //    this.AB.processes((o) => {
      //       return o.name.toLowerCase() == this.name.toLowerCase();
      //    }).length == 0;
      // if (!isNameUnique) {
      //    validator.addError(
      //       "name",
      //       L(`Process name must be unique ("{0}" already in use)`, [this.name])
      //    );
      // }

      // return validator;
   }

   /**
    * @method warningsAll()
    * Return an array of mis configuration warnings for our object or any
    * of our sub elements.
    * @return {array} [ { message: "warning message", data:{} } ]
    */
   warningsAll() {
      // debugger;
      // report both OUR warnings, and any warnings from any of our fields
      // var allWarnings = [].concat(this._warnings);
      // this.elements().forEach((e) => {
      //    e.warningsEval();
      //    allWarnings = allWarnings.concat(e.warnings());
      // });
      // if (this.elements().length == 0) {
      //    allWarnings.push({ message: "No process Tasks defined.", data: {} });
      // }
      // // perform a check of our xml document to see if we have any unknown
      // // shapes
      // if (!this._DOMParser) {
      //    if (window.DOMParser) {
      //       // Handy snippet from https://stackoverflow.com/questions/17604071/parse-xml-using-javascript
      //       this._DOMParser = function (xmlStr) {
      //          return new window.DOMParser().parseFromString(
      //             xmlStr,
      //             "text/xml"
      //          );
      //       };
      //    } else if (
      //       typeof window.ActiveXObject != "undefined" &&
      //       new window.ActiveXObject("Microsoft.XMLDOM")
      //    ) {
      //       this._DOMParser = function (xmlStr) {
      //          var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
      //          xmlDoc.async = "false";
      //          xmlDoc.loadXML(xmlStr);
      //          return xmlDoc;
      //       };
      //    } else {
      //       throw new Error("No XML parser found");
      //    }
      // }
      // // find any references to our generic shapes
      // let xml = this._DOMParser(this.xmlDefinition);
      // const genericShapes = [
      //    "bpmn2:startEvent",
      //    "bpmn2:task",
      //    "bpmn2:endEvent",
      // ];
      // genericShapes.forEach((s) => {
      //    let allElements = xml.getElementsByTagName(s);
      //    for (let x = 0; x < allElements.length; x++) {
      //       // if we don't know about this shape
      //       let ele = allElements[x];
      //       let myEle = this.elementForDiagramID(allElements[x].id);
      //       if (!myEle) {
      //          this.unknownShape(allElements[x]);
      //       }
      //    }
      // });
      // // if any unknown shapes have been reported:
      // if (this._unknownShapes.length) {
      //    allWarnings.push({
      //       message: "Generic Tasks still undefined.",
      //       data: {},
      //    });
      // }
      //
      // return allWarnings;
   }
}


/***/ }),

/***/ 67348:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABViewManager.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewManager)
/* harmony export */ });
/* harmony import */ var _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABViewManagerCore */ 85642);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_0__]);
_core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


class ABViewManager extends _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_0__["default"] {}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 15656:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABViewManagerMobile.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewManagerMobile)
/* harmony export */ });
/* harmony import */ var _core_ABViewManagerMobileCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABViewManagerMobileCore */ 40080);
/* harmony import */ var _core_ABViewManagerMobileCore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_core_ABViewManagerMobileCore__WEBPACK_IMPORTED_MODULE_0__);


class ABViewManagerMobile extends (_core_ABViewManagerMobileCore__WEBPACK_IMPORTED_MODULE_0___default()) {}


/***/ }),

/***/ 10758:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/platform/FilterComplex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FilterComplex)
/* harmony export */ });
/* harmony import */ var _core_FilterComplexCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/FilterComplexCore */ 89391);


/**
 * @function _toInternal()
 * translate our external QB conditions into our internal format that
 * makes the cond.rule unique by adding the field.id to the rule.
 * @param {obj} cond - {
 *                         rules: [
 *                            {
 *                               alias: string || undefined,
 *                               key: uuid,
 *                               rule: string,
 *                               value: object,
 *                            }
 *                         ]
 *                      }
 *        the QB condition format we use exernally in our AB system.
 */
function _toInternal(cond, fields = []) {
   if (!cond) return;
   if (cond.key) {
      // Convert to format
      // {
      //    glue: "and",
      //    rules: [
      //       {
      //          field: "test_col",
      //          condition: { type: "greater", filter: 100 },
      //       },
      //    ],
      // }
      const field = fields.filter((f) => f.id == cond.key)[0];
      cond.field = field?.id;

      cond.condition = {
         type: cond.rule,
         filter: cond.value,
      };

      if (Array.isArray(cond.value)) cond.includes = cond.value;
      else cond.includes = (cond.value ?? "").split(",");

      if (field?.key == "date" || field?.key == "datetime") {
         cond.condition.filter = cond.condition.filter
            ? AB.rules.toDate(cond.condition.filter)
            : null;

         cond.includes = cond.includes.map((v) => AB.rules.toDate(v));
      }

      delete cond.key;
      delete cond.rule;
      delete cond.value;
   }

   if (cond.rules && cond.rules.length) {
      (cond.rules ?? []).forEach((r) => {
         _toInternal(r, fields);
      });
   }
}

/**
 * @function _toExternal()
 * translate our internal QB conditions into our external format that
 * where the cond.rule no longer has the field.id.
 * @param {obj} cond - {
 *                         glue: "and",
 *                         rules: [
 *                            {
 *                               field: "test_col",
 *                               condition: { type: "greater", filter: 100 },
 *                            },
 *                         ],
 *                      }
 *        the QB condition format we use internally
 */
function _toExternal(cond, fields = []) {
   if (!cond) return;
   if (cond.field) {
      let field = fields.filter((f) => f.id == cond.field)[0];
      // cond.alias = alias || undefined;
      cond.key = field?.id ?? cond.field;
      cond.condition = cond.condition ?? {};
      cond.rule = cond.condition.type;

      let values =
         cond.includes.map((v) => (v instanceof Date ? v.toISOString() : v)) ??
         [];

      // Convert multi-values to a string
      if (cond.condition.filter) {
         if (cond.condition.filter instanceof Date) {
            if (values.indexOf(cond.condition.filter.toISOString()) < 0) {
               values.push(cond.condition.filter);
            }
         } else if (values.indexOf(cond.condition.filter) < 0)
            values.push(cond.condition.filter);
      }

      cond.value = values
         .map((v) => {
            // Convert date format
            if (field && (field.key == "date" || field.key == "datetime"))
               return field.exportValue(new Date(v));

            return v;
         })
         .join(",");

      delete cond.field;
      delete cond.type;
      delete cond.includes;
      delete cond.condition;
   }

   if (cond.rules && cond.rules.length) {
      (cond.rules ?? []).forEach((r) => {
         _toExternal(r, fields);
      });
   }
}

class FilterComplex extends _core_FilterComplexCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(idBase, AB, options = {}) {
      idBase = idBase ?? "ab_filterComplex";

      super(idBase, AB);

      let L = this.AB.Label();

      this._options = options ?? {};

      this._initComplete = false;
      // {bool}
      // trying to prevent multiple .init() from being called due to
      // various ways of initializing the component.

      this.observing = false;
      // {bool}
      // try to prevent multiple observers generating >1 "changed"
      // event.

      let labels = (this.labels = {
         common: (AB._App ?? {}).labels,
         component: {
            // and: L("And"),
            // or: L("Or"),
            // thisObject: L("This Object"),
            // inQuery: L("In Query"),
            // notInQuery: L("Not In Query"),
            // inQueryField: L("By Query Field"),
            // notInQueryField: L("Not By Query Field"),
            // inQueryFieldQueryPlaceholder: L("Choose a Query"),
            // inQueryFieldFieldPlaceholder: L("Choose a Field"),
            // sameAsUser: L("Same As User"),
            // notSameAsUser: L("Not Same As User"),
            // sameAsField: L("Same As Field"),
            // notSameAsField: L("Not Field"),
            // inDataCollection: L("In Data Collection"),
            // notInDataCollection: L("Not In Data Collection"),
            // containsCondition: L("contains"),
            // notContainsCondition: L("doesn't contain"),
            // isCondition: L("is"),
            // isNotCondition: L("is not"),
            // isEmpty: L("is empty"),
            // isNotEmpty: L("is not empty"),
            // beforeCondition: L("is before"),
            // afterCondition: L("is after"),
            // onOrBeforeCondition: L("is on or before"),
            // onOrAfterCondition: L("is on or after"),
            // beforeCurrentCondition: L("is before current date"),
            // afterCurrentCondition: L("is after current date"),
            // onOrBeforeCurrentCondition: L("is on or before current date"),
            // onOrAfterCurrentCondition: L("is on or after current date"),
            // onLastDaysCondition: L("last ... days"),
            // onNextDaysCondition: L("next ... days"),
            // equalCondition: L(":"),
            // notEqualCondition: L(""),
            // lessThanCondition: L("<"),
            // moreThanCondition: L(">"),
            // lessThanOrEqualCondition: L(""),
            // moreThanOrEqualCondition: L(""),
            // equalListCondition: L("equals"),
            // notEqualListCondition: L("does not equal"),
            // checkedCondition: L("is checked"),
            // notCheckedCondition: L("is not checked"),
            // isCurrentUserCondition: L("is current user"),
            // isNotCurrentUserCondition: L("is not current user"),
            // containsCurrentUserCondition: L("contains current user"),
            // notContainsCurrentUserCondition: L("does not contain current user"),
            // contextDefaultOption: L("choose option"),
            // equalsProcessValue: L("equals process value"),
            // notEqualsProcessValueCondition: L("not equals process value"),
            // inProcessValueCondition: L("in process value"),
            // notInProcessValueCondition: L("not in process value"),
         },
      });

      // internal list of Webix IDs to reference our UI components.
      let ids = (this.ids = {
         popup: this.unique(`${idBase}_popup`),
         querybuilder: this.unique(`${idBase}_querybuilder`),
         save: this.unique(`${idBase}_save`),
      });

      // Set current username
      this.Account.username = this.AB.Account.username();

      this._settings.recordRuleFieldOptions = [];

      // webix UI definition:
      // this.ui = {
      //    rows: [
      //       {
      //          view: "layout",
      //          type: "clean",
      //          borderless: this._options.borderless ?? true,
      //          rows: [
      //             {
      //                id: ids.querybuilder,
      //                view: "query",
      //                data: () => [],
      //                // data: async (field) => await this.pullOptions(field),
      //                fields: [],
      //                disabled: true,
      //                height: this._options.height,
      //             },
      //          ],
      //       },
      //       {
      //          id: ids.save,
      //          view: "button",
      //          css: "webix_primary",
      //          value: L("Save"),
      //          hidden: this._options.isSaveHidden ?? false,
      //          click: () => {
      //             if (this.myPopup) this.myPopup.hide();
      //             this.emit("save", this.getValue());
      //          },
      //       },
      //    ],
      // };
   }

   // setting up UI
   init(options) {
      if (this._initComplete) return;

      super.init(options);

      console.error("@TODO: Filtercomplex and more webix references");
      /*
      const el = $$(this.ids.querybuilder);

      if (el) {
         if (!this.observing) {
            this.__blockOnChange = true;
            el.getState().$observe("value", (v) => {
               if (this.__blockOnChange) return false;

               this.emit("changed", this.getValue());
            });
            this.__blockOnChange = false;

            // HACK!! The process of setting the $observe() is actually
            // calling the cb() when set.  This is clearing our .condition
            // if we call init() after we have setValues(). which can happen
            // when using the popUp() method.
            let _cond = this.condition;
            this.condition = _cond;
            this.observing = true;
         }
         this._initComplete = true;
      }
      */
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    * @param condition {Object} - [Optional] {
    *                                           glue: "and" | "or",
    *                                           rules: []
    *                                        }
    */
   isValid(rowData, condition = this.condition) {
      // let helper = () => true;

      // let $query = $$(this.ids.querybuilder);
      // if ($query) {
      //    helper = $query.getFilterFunction();
      //    return helper(rowData);
      // } else {
      return super.isValid(rowData, condition);
      // }
   }

   /**
    * @method isConditionComplete()
    * Check a given condition entry and indicate if it is fully
    * filled out.
    * @param {obj} cond
    *        The Condition object we are checking.  If a Macro
    *        condition if provided: { glue:"and", rules:[] } then
    *        this method will return True/False if All rules are
    *        complete.
    *        If an individual rule is provided, then it evaluates
    *        the completness of that rule. { key, rule, value }
    * @return {bool}
    */
   isConditionComplete(cond) {
      if (!cond) return false;

      let isComplete = true;
      // start optimistically.

      if (cond.glue) {
         (cond.rules ?? []).forEach((r) => {
            isComplete = isComplete && this.isConditionComplete(r);
         });
      } else {
         // every condition needs a .key & .rule
         if (!cond.key || cond.key == "") {
            isComplete = false;
         }

         if (!cond.rule || cond.rule == "") {
            isComplete = false;
         }

         if (isComplete) {
            switch (cond.rule) {
               case "is_current_user":
               case "is_not_current_user":
               case "contain_current_user":
               case "not_contain_current_user":
               case "same_as_user":
               case "not_same_as_user":
               case "less_current":
               case "greater_current":
               case "less_or_equal_current":
               case "greater_or_equal_current":
               case "is_empty":
               case "is_not_empty":
                  // There are only a few rules that don't need a
                  // value
                  break;

               default:
                  // The rest do need a .value
                  if (!cond.value || cond.value == "") {
                     isComplete = false;
                  }
                  break;
            }
         }
      }

      return isComplete;
   }

   setValue(settings) {
      super.setValue(settings);
      this.condition = settings;

      // const el = $$(this.ids.querybuilder);
      // if (el) {
      //    if (!settings) {
      //       // Clear settings value of webix.query
      //       el.define("value", {
      //          glue: "and",
      //          rules: [],
      //       });
      //       return;
      //    }

      //    let qbSettings = this.AB.cloneDeep(settings);

      //    // Settings should match a condition built upon our QB format:
      //    // {
      //    //    glue:"and",
      //    //    rules:[
      //    //       {
      //    //          key:"uuid",
      //    //          rule:"",
      //    //          value:""
      //    //       }
      //    //    ]
      //    // }
      //    // externally our key should be the field.id and the rules should be
      //    // the "contains", "not_contains", "equal" ... keywords.
      //    // However, internally, we convert these rules into .ids that are
      //    // unique for each field (see uiInit()).  So when we bring in settings
      //    // we need to translate them into our internal format:

      //    _toInternal(qbSettings, this._Fields);

      //    this.__blockOnChange = true;
      //    el.define("value", qbSettings);
      //    this.__blockOnChange = false;
      // }
   }

   getValue() {
      // if ($$(this.ids.querybuilder)) {
      //    let settings = this.AB.cloneDeep(
      //       $$(this.ids.querybuilder).getState().value ?? {}
      //    );

      //    // what we pull out of the QB will have .rules in our internal format:
      //    // {field.id}_{rule}  (see uiInit() )
      //    // But we need to store them in our generic QB format for use outside
      //    // our FilterComplex widget.
      //    _toExternal(settings, this._Fields);
      //    this.condition = settings;
      // }

      return super.getValue();
   }

   fieldsLoad(fields = [], object = null) {
      super.fieldsLoad(fields, object);
      console.log("TODO: How to handle FilterComplex's dependence on webix?");
      // this.uiInit();
   }

   toShortHand() {
      return "Add Filters";
   }

   uiInit() {
      this.uiQueryCustomValue();

      let el = $$(this.ids.querybuilder);
      if (el) {
         // Clear fields
         while (el.config.fields.length > 0) {
            el.config.fields.pop();
         }
         // Set fields
         (this.fieldsToQB() ?? []).forEach((f) => {
            el.config.fields.push(f);
         });
         if (el.config.fields.length) {
            el.enable();
         } else {
            this.setValue("");
            el.disable();
         }
      }
   }

   // HACK: have to overwrite Webix Query's function to support our custom input requirement.
   // HooWoo
   uiQueryCustomValue() {
      const $el = $$(this.ids.querybuilder);
      if (!$el) return;

      // window.query.views.filter.prototype.CreateFilter = (
      $el.$app.require("jet-views", "filter").prototype.CreateFilter = (
         field,
         type,
         format,
         conditions,
         place
      ) => {
         let inputs = this.uiValue(field);

         let ui = {
            id: place.config.id,
            view: "filter",
            localId: "filter",
            conditions: conditions,
            field: field,
            mode: type,
            template: function (o) {
               let str = o[field];
               let parser =
                  format ?? (type == "date" ? webix.i18n.dateFormatStr : null);
               if (parser) str = parser(str);
               return str;
            },
            inputs: inputs,
            margin: 6,
         };

         let filter = webix.ui(ui, place);

         // let data = [];
         // const $query = $$(this.ids.querybuilder);
         // if ($query) {
         //    data = $query.app.getService("backend").data(field);
         // }
         // filter.parse(data);

         return filter;
      };
   }

   uiValue(fieldColumnName) {
      let result;

      // Special case: this_object
      if (fieldColumnName == "this_object") {
         return []
            .concat(this.uiQueryValue("this_object"))
            .concat(this.uiDataCollectionValue("this_object"))
            .concat(this.uiCustomValue("this_object"))
            .concat(this.uiContextValue("this_object", "uuid"));
      }

      let field = (this._Fields ?? []).filter(
         (f) => f.id == fieldColumnName
      )[0];

      switch (field?.key) {
         case "boolean":
            result = this.uiBooleanValue(field);
            break;
         case "connectObject":
            result = []
               .concat(this.uiQueryValue(field))
               .concat(this.uiUserValue(field))
               .concat(this.uiDataCollectionValue(field))
               .concat(this.uiContextValue(field))
               .concat(this.uiNoneValue());
            break;
         case "date":
         case "datetime":
            result = ["datepicker", "daterangepicker"];
            break;
         case "list":
            result = this.uiListValue(field);
            break;
         case "user":
            result = []
               .concat(this.uiNoneValue())
               .concat(this.uiUserValue(field));
            break;
         // case "number":
         //    result = ["text"];
         //    break;
         case "string":
         case "LongText":
         case "email":
            result = this.uiNoneValue();
            break;
      }

      // Add filter options to Custom index
      const LinkType = `${field?.settings?.linkType}:${field?.settings?.linkViaType}`;
      if (
         field?.settings?.isCustomFK &&
         // 1:M
         (LinkType == "one:many" ||
            // 1:1 isSource = true
            (LinkType == "one:one" && field?.settings?.isSource))
      ) {
         result = (result ?? []).concat(this.uiTextValue(field));
      } else if (field?.key != "connectObject") {
         result = (result ?? [])
            .concat(this.uiTextValue(field))
            .concat(this.uiQueryFieldValue(field))
            .concat(this.uiContextValue(field));
      }
      // Special case: from Process builder
      // .processFieldsLoad()
      else if (fieldColumnName.indexOf("uuid") > -1) {
         result = this.uiContextValue(null, fieldColumnName);
      }

      if (this._settings.isRecordRule) {
         result = (result ?? []).concat(this.uiRecordRuleValue(field));
      }

      result = (result ?? []).concat(this.uiCustomValue(field));

      return result;
   }

   uiNoneValue() {
      return [
         {
            batch: "none",
            borderless: true,
            view: "template",
            template: "",
         },
      ];
   }

   uiBooleanValue(field) {
      return [
         {
            batch: "boolean",
            view: "checkbox",
         },
      ];
   }

   uiTextValue(field) {
      return [
         {
            batch: "text",
            view: "text",
            on: {
               onAfterRender: function () {
                  // HACK: focus on webix.text and webix.textarea
                  // Why!! If the parent layout has zIndex lower than 101,
                  // then is not able to focus to webix.text and webix.textarea
                  let $layout =
                     this.queryView(function (a) {
                        return !a.getParentView();
                     }, "parent") ?? this;
                  $layout.$view.style.zIndex = 202;
               },
            },
         },
      ];
   }

   uiQueryValue(field) {
      let options = [];

      let isQueryField =
         this._QueryFields?.filter((f) => f.id == field.id).length > 0;

      // populate the list of Queries for this_object:
      if (field == "this_object" && this._Object) {
         options = this.queries((q) => q.canFilterObject(this._Object));
      }
      // populate the list of Queries for a query field
      else if (isQueryField) {
         options = this.queries(
            (q) =>
               (this._Object ? this._Object.id : "") != q.id && // Prevent filter looping
               q.canFilterObject(field.datasourceLink)
         );
      }

      options?.forEach((q) => {
         options.push({
            id: q.id,
            value: q.label,
         });
      });

      return [
         {
            batch: "query",
            view: "combo",
            options: options ?? [],
         },
      ];
   }

   uiListValue(field) {
      return [
         {
            batch: "list",
            view: "combo",
            options: field?.settings?.options?.map(function (x) {
               return {
                  id: x.id,
                  value: x.text,
               };
            }),
         },
      ];
   }

   uiUserValue(field) {
      return [
         {
            batch: "user",
            view: "combo",
            options: this.AB.Account.userList().map((u) => {
               return {
                  id: u.username,
                  value: u.username,
               };
            }),
         },
      ];
   }

   uiDataCollectionValue(field) {
      let linkObjectId;
      if (field == "this_object" && this._Object) {
         linkObjectId = this._Object.id;
      } else {
         linkObjectId = field?.settings?.linkObject;
      }

      return [
         {
            batch: "datacollection",
            view: "combo",
            options: linkObjectId
               ? this.AB.datacollections(
                    (dc) => dc?.datasource?.id == linkObjectId
                 ).map((dc) => {
                    return {
                       id: dc.id,
                       value: dc.label,
                    };
                 })
               : [],
         },
      ];
   }

   uiQueryFieldValue(field) {
      return [
         {
            batch: "queryField",
            view: "combo",
            placeholder: this.labels.component.inQueryFieldQueryPlaceholder,
            options: this.queries(
               (q) => this._Object == null || q.id != this._Object.id
            ).map((q) => {
               return {
                  id: q.id,
                  value: q.label,
               };
            }),
         },
      ];
   }

   uiRecordRuleValue(field) {
      return [
         {
            batch: "recordRule",
            view: "select",
            options: this._settings.recordRuleFieldOptions ?? [],
         },
      ];
   }

   uiContextValue(field, processFieldKey = null) {
      let L = this.AB.Label();
      const processFields = (this._ProcessFields ?? [])
         .filter((pField) => {
            if (!pField) return false;

            let result = false;
            switch (field) {
               case "this_object":
                  result =
                     this._Object.id === pField.object?.id && !pField.field;

                  break;

               default:
                  switch (field.key) {
                     case "boolean":
                        result = ["boolean"].includes(pField.field?.key);

                        break;

                     case "connectObject":
                        result =
                           field.settings.linkObject ===
                           (pField.field?.object.id ?? pField.object.id);

                        if (!field.settings.isCustomFK) {
                           result = result && !pField.field;

                           break;
                        }

                        result =
                           result &&
                           (field.settings.indexField ||
                              field.settings.indexField2) === pField.field?.id;

                        break;

                     case "date":
                     case "datetime":
                        result = ["date", "datetime"].includes(
                           pField.field?.key
                        );

                        break;

                     case "calculate":
                     case "formula":
                     case "number":
                        result = ["calculate", "formula", "number"].includes(
                           pField.field?.key
                        );

                        break;

                     case "string":
                     case "LongText":
                     case "email":
                     case "AutoIndex":
                     case "list":
                        result = [
                           "string",
                           "LongText",
                           "email",
                           "AutoIndex",
                           "list",
                        ].includes(pField.field?.key);

                        break;

                     case "user":
                        result = ["user"].includes(pField.field?.key);

                        break;

                     default:
                        if (pField.key) {
                           // uuid
                           const processFieldId = pField.key.split(".").pop();

                           result =
                              processFieldId === field.id ||
                              processFieldId === field.key ||
                              processFieldId === processFieldKey ||
                              pField.key === processFieldKey;
                        }

                        break;
                  }

                  break;
            }

            return result;
         })
         .map((e) => {
            return {
               id: e.key,
               value: L("context({0})", [e.label]),
            };
         });

      if (!processFields) return [];

      return [
         {
            batch: "context",
            view: "select",
            options: [
               {
                  id: "empty",
                  value: this.labels.component.contextDefaultOption,
               },
               ...processFields,
            ],
         },
      ];
   }

   uiCustomValue(field) {
      if (!field) return [];

      const customOptions = this._customOptions ?? {};
      const options = customOptions[field.id ?? field] ?? {};
      return options.values ?? [];
   }

   popUp(...options) {
      const condition = Object.assign({}, this.condition);

      if (!this.myPopup) {
         let ui = {
            id: this.ids.popup,
            view: "popup",
            height: 400,
            width: 800,
            body: this.ui,
         };

         if (!$$(this.ids.popup)) {
            this.myPopup = webix.ui(ui);
            this.init(this._settings);
            if (this._Fields) {
               this.fieldsLoad(this._Fields, this._Object);
            }

            // NOTE: do this, before the .setValue() operation, as we need to have
            // our fields and filters defined BEFORE a setValue() is performed.
            // this.uiInit();

            if (condition) {
               this.setValue(condition);
            }

            this.myPopup.show(...options);
         } else {
            $$(this.ids.popup).show(...options);
         }
      } else {
         this.myPopup.show(...options);
      }
   }

   /**
    * @method addCustomOption
    *
    * @param {string|uuid} fieldId
    * @param {Object} options - {
    *                               conditions: [],
    *                               values: []
    *                           }
    */
   addCustomOption(fieldId, options = {}) {
      this._customOptions = this._customOptions ?? {};
      this._customOptions[fieldId] = options;
   }
}


/***/ }),

/***/ 84470:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/platform/RowFilter.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RowFilter)
/* harmony export */ });
/* harmony import */ var _core_RowFilterCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/RowFilterCore */ 51509);


class RowFilter extends _core_RowFilterCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(App, idBase, AB) {
      super(App, idBase, AB);

      console.error("TODO: Switch RowFilter => FilterComplex");

      // internal list of Webix IDs to reference our UI components.
      let ids = (this.ids = {
         component: this.unique(`${idBase}_rowFilter`),
         filterForm: this.unique(`${idBase}_rowFilter_form`),
         addNewFilter: this.unique(`${idBase}_rowFilter_addNewFilter`),

         glue: this.unique(`${idBase}_rowFilter_glue`),
         field: this.unique(`${idBase}_rowFilter_field`),
         rule: this.unique(`${idBase}_rowFilter_rule`),
         inputValue: this.unique(`${idBase}_rowFilter_inputValue`),

         queryCombo: this.unique(`${idBase}_rowFilter_queryCombo`),
         queryFieldCombo: this.unique(`${idBase}_rowFilter_queryFieldCombo`),
         queryFieldComboQuery: this.unique(
            `${idBase}_rowFilter_queryFieldComboQuery`
         ),
         queryFieldComboField: this.unique(
            `${idBase}_rowFilter_queryFieldComboField`
         ),
         fieldMatch: this.unique(`${idBase}_rowFilter_fieldMatchCombo`),

         dataCollection: this.unique(`${idBase}_rowFilter_dataCollection`),

         listOptions: this.unique(`${idBase}_rowFilter_listOptions`),

         datePicker: this.unique(`${idBase}_rowFilter_datePicker`),
      });

      // Set current username
      // this.Account.username = this.AB.Account.username();

      var batchName; // we need to revert to this default when switching away from a in/by query field

      let L = this.AB.Label();

      // Default options list to push to all fields
      this.queryFieldOptions = [
         {
            value: L("By Query Field"),
            id: "in_query_field",
         },
         {
            value: L("Not In Query"),
            id: "not_in_query_field",
         },
      ];

      this.recordRuleOptions = [];
      this.recordRuleFieldOptions = [];

      let _logic = this._logic || {};

      /**
       * @method getFieldList
       * return field list to render options
       */
      _logic.getFieldList = () => {
         return (this._Fields || []).map((f) => {
            let label = f.label;

            // include object's name to options
            if (this._settings.showObjectName && f.object) {
               label = f.object.label + "." + f.label;
            }

            return {
               id: f.id,
               value: label,
               alias: f.alias || undefined, // ABObjectQuery
            };
         });
      };

      _logic.getFilterUI = () => {
         let instance = this;
         let config_settings = this.config_settings || {};

         return {
            id: "f" + webix.uid(),
            isolate: true,
            cols: [
               {
                  // Add / Or
                  view: "combo",
                  id: ids.glue,
                  width: 80,
                  value: config_settings.glue || "and",
                  options: [
                     {
                        value: L("And"),
                        id: "and",
                     },
                     {
                        value: L("Or"),
                        id: "or",
                     },
                  ],
                  on: {
                     onChange: function (newVal, oldVal) {
                        _logic.selectCombineCondition(newVal);
                     },
                  },
               },
               {
                  // Field list
                  view: "combo",
                  id: ids.field,
                  suggest: {
                     on: {
                        onBeforeShow: function () {
                           this.define("width", 400);
                           this.resize();
                        },
                     },
                     data: _logic.getFieldList(),
                  },
                  on: {
                     onChange: function (columnId) {
                        var $viewCond = this.getParentView();
                        _logic.selectField(columnId, $viewCond);
                     },
                  },
               },
               // Comparer
               {
                  id: ids.rule,
                  width: 220,
                  cells: [
                     {},
                     // Query
                     {
                        batch: "query",
                        view: "combo",
                        value: "in_query",
                        options: [
                           {
                              value: L("In Query"),
                              id: "in_query",
                           },
                           {
                              value: L("Not In Query"),
                              id: "not_in_query",
                           },
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                           {
                              value: L("is empty"),
                              id: "is_empty",
                           },
                           {
                              value: L("is not empty"),
                              id: "is_not_empty",
                           },
                           {
                              value: L("Same As User"),
                              id: "same_as_user",
                           },
                           {
                              value: L("Not Same As User"),
                              id: "not_same_as_user",
                           },
                           {
                              value: L("In Data Collection"),
                              id: "in_data_collection",
                           },
                           {
                              value: L("Not In Data Collection"),
                              id: "not_in_data_collection",
                           },
                        ].concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition, oldValue) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },

                     // Date
                     {
                        batch: "date",
                        view: "combo",
                        value: "less",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                           {
                              value: L("is before"),
                              id: "less",
                           },
                           {
                              value: L("is after"),
                              id: "greater",
                           },
                           {
                              value: L("is on or before"),
                              id: "less_or_equal",
                           },
                           {
                              value: L("is on or after"),
                              id: "greater_or_equal",
                           },
                           {
                              value: L("is before current date"),
                              id: "less_current",
                           },
                           {
                              value: L("is after current date"),
                              id: "greater_current",
                           },
                           {
                              value: L("is on or before current date"),
                              id: "less_or_equal_current",
                           },
                           {
                              value: L("is on or after current date"),
                              id: "greater_or_equal_current",
                           },
                           {
                              value: L("last ... days"),
                              id: "last_days",
                           },
                           {
                              value: L("next ... days"),
                              id: "next_days",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Number
                     {
                        batch: "number",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L(":"),
                              id: "equals",
                           },
                           {
                              value: L(""),
                              id: "not_equal",
                           },
                           {
                              value: L("<"),
                              id: "less",
                           },
                           {
                              value: L(">"),
                              id: "greater",
                           },
                           {
                              value: L(""),
                              id: "less_or_equal",
                           },
                           {
                              value: L(""),
                              id: "greater_or_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // List
                     {
                        batch: "list",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                           {
                              value: L("Same As User"),
                              id: "same_as_user",
                           },
                           {
                              value: L("Not Same As User"),
                              id: "not_same_as_user",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition, oldValue) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Boolean
                     {
                        batch: "boolean",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // User
                     {
                        batch: "user",
                        view: "combo",
                        value: "is_current_user",
                        options: [
                           {
                              value: L("is current user"),
                              id: "is_current_user",
                           },
                           {
                              value: L("is not current user"),
                              id: "is_not_current_user",
                           },
                           {
                              value: L("contains current user"),
                              id: "contain_current_user",
                           },
                           {
                              value: L("does not contain current user"),
                              id: "not_contain_current_user",
                           },
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // String
                     {
                        batch: "string",
                        view: "combo",
                        value: "contains",
                        options: [
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Email
                     {
                        batch: "email",
                        view: "combo",
                        value: "contains",
                        options: [
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                  ],
               },
               // Value
               {
                  id: ids.inputValue,
                  isolate: true,
                  cells: [
                     {
                        batch: "empty",
                     },

                     // Query
                     {
                        id: ids.queryCombo,

                        batch: "query",
                        view: "combo",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Query Field
                     {
                        id: ids.queryFieldCombo,
                        batch: "queryField",
                        rows: [
                           {
                              id: ids.queryFieldComboQuery,
                              view: "combo",
                              options: [],
                              placeholder: L("Choose a Query"),
                              on: {
                                 onChange: function (value) {
                                    var $viewComparer = this.getParentView();
                                    var $viewCond = $viewComparer
                                       .getParentView()
                                       .getParentView();
                                    _logic.onChangeQueryFieldCombo(
                                       value,
                                       $viewCond
                                    );

                                    _logic.onChange();
                                 },
                              },
                           },
                           {
                              id: ids.queryFieldComboField,
                              view: "combo",
                              options: [],
                              placeholder: L("Choose a Field"),
                              on: {
                                 onChange: _logic.onChange,
                              },
                           },
                        ],
                     },

                     // Field match
                     {
                        id: ids.fieldMatch,
                        batch: "fieldMatch",
                        view: "combo",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Data collection
                     {
                        id: ids.dataCollection,
                        batch: "dataCollection",
                        view: "richselect",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Date
                     {
                        // inputView.format = field.getDateFormat();
                        batch: "date",
                        id: ids.datePicker,
                        view: "datepicker",
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Number
                     {
                        batch: "number",
                        view: "text",
                        validate: webix.rules.isNumber,
                        on: {
                           onTimedKeyPress: function () {
                              if (this.validate()) _logic.onChange();
                           },
                        },
                     },
                     // List
                     {
                        batch: "list",
                        id: ids.listOptions,
                        view: "combo",
                        options: [],
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Boolean
                     {
                        batch: "boolean",
                        view: "checkbox",
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // User
                     {
                        batch: "user",
                        view: "combo",
                        options: this.AB.Account.userList().map((u) => {
                           return {
                              id: u.username,
                              value: u.username,
                           };
                        }),
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // String
                     {
                        batch: "string",
                        view: "text",
                        on: {
                           onTimedKeyPress: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Email
                     {
                        batch: "email",
                        view: "text",
                        on: {
                           onTimedKeyPress: function () {
                              _logic.onChange();
                           },
                        },
                     },
                  ],
               },
               {
                  view: "button",
                  css: "webix_primary",
                  icon: "fa fa-plus",
                  type: "icon",
                  autowidth: true,
                  click: function () {
                     var $viewForm = this.getFormView();

                     var indexView = $viewForm.index(this.getParentView());

                     _logic.addNewFilter(indexView + 1);
                  },
               },
               {
                  view: "button",
                  css: "webix_danger",
                  icon: "fa fa-trash",
                  type: "icon",
                  autowidth: true,
                  click: function () {
                     var $viewCond = this.getParentView();

                     _logic.removeNewFilter($viewCond);
                  },
               },
            ],
         };
      };

      _logic.getAddButtonUI = () => {
         return {
            view: "button",
            id: ids.addNewFilter,
            css: "webix_primary",
            type: "form",
            label: L("Add a filter"),
            click: () => {
               _logic.addNewFilter();
            },
         };
      };

      _logic.addNewFilter = (index, fieldId) => {
         var viewId;
         var ui = _logic.getFilterUI();

         var $viewForm = $$(ids.filterForm);
         if ($viewForm) {
            viewId = $viewForm.addView(ui, index);

            _logic.toggleAddNewButton();

            // select a option of field
            if (fieldId) _logic.selectField(fieldId, $$(viewId), true);
         }

         return viewId;
      };

      _logic.removeNewFilter = function ($viewCond) {
         var $viewForm = $$(ids.filterForm);

         $viewForm.removeView($viewCond);

         _logic.toggleAddNewButton();

         _logic.onChange();
      };

      _logic.toggleAddNewButton = function () {
         if (!$$(ids.filterForm)) return;

         // Show "Add new filter" button
         if ($$(ids.filterForm).getChildViews().length < 1) {
            $$(ids.filterForm).hide();
            $$(ids.addNewFilter).show();
         }
         // Hide "Add new filter" button
         else {
            $$(ids.filterForm).show();
            $$(ids.addNewFilter).hide();
         }
      };

      _logic.selectCombineCondition = (val, ignoreNotify) => {
         // define combine value to configuration
         this.config_settings.glue = val;

         // update value of every combine conditions
         var $viewConds = $$(ids.filterForm).getChildViews();
         $viewConds.forEach((v) => {
            if (v.$$ && v.$$(ids.glue)) v.$$(ids.glue).setValue(val);
         });

         if (!ignoreNotify) _logic.onChange();
      };

      _logic.selectField = (columnId, $viewCond, ignoreNotify) => {
         if (!this._Fields) return;

         var field = this._Fields.filter((f) => f.id == columnId)[0];
         if (!field) return;

         // switch view
         batchName = field.key;
         if (field.id == "this_object") batchName = "query";
         // Special this object query
         else if (batchName == "LongText" || batchName == "combined")
            batchName = "string";
         else if (field.key == "formula") batchName = "number";
         var isQueryField =
            this._QueryFields.filter((f) => {
               return f.id == field.id;
            }).length > 0;
         if (isQueryField) {
            // we chose a connectField which is now a Query type
            batchName = "query";
         }
         $viewCond.$$(ids.rule).showBatch(batchName);
         $viewCond.$$(ids.inputValue).showBatch(batchName);

         let options = [];
         let Queries = [];

         // populate the list of Queries for this_object:
         if (field.id == "this_object" && this._Object) {
            Queries = this.queries((q) => q.canFilterObject(this._Object));
         }
         // populate the list of Queries for a query field
         else if (isQueryField) {
            Queries = this.queries((q) => {
               return (
                  (this._Object ? this._Object.id : "") != q.id && // Prevent filter looping
                  q.canFilterObject(field.datasourceLink)
               );
            });
         }

         Queries.forEach((q) => {
            options.push({
               id: q.id,
               value: q.label,
            });
         });
         $viewCond
            .$$(ids.inputValue)
            .$$(ids.queryCombo)
            .define("options", options);
         $viewCond.$$(ids.inputValue).$$(ids.queryCombo).refresh();

         // populate options of list
         if (field.key == "list") {
            let listOptions = field.settings.options.map(function (x) {
               return {
                  id: x.id,
                  value: x.text,
               };
            });

            $viewCond
               .$$(ids.inputValue)
               .$$(ids.listOptions)
               .define("options", listOptions);
            $viewCond.$$(ids.inputValue).$$(ids.listOptions).refresh();
         }
         // set format of datepicker
         else if (field.key == "date") {
            $viewCond
               .$$(ids.inputValue)
               .$$(ids.datePicker)
               .define("format", field.getFormat());
            $viewCond.$$(ids.inputValue).$$(ids.datePicker).refresh();
         }

         var rule = null,
            ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
            $viewComparer = $viewCond
               .$$(ids.rule)
               .queryView({ id: ruleViewId });
         if ($viewComparer && $viewComparer.getList) {
            let defaultOpt = ($viewComparer.getList().config.data || [])[0];
            if (defaultOpt) {
               $viewComparer.setValue(defaultOpt.id);
            }

            // rule = $viewComparer.getValue();
            // if (rule == "in_query_field" || rule == "not_in_query_field") {
            // 	// Show the new value inputs
            // 	$viewCond.$$(ids.inputValue).showBatch("queryField");
            // } else if (rule == "same_as_field" || rule == "not_same_as_field") {
            // 	// Show the new value inputs
            // 	$viewCond.$$(ids.inputValue).showBatch("fieldMatch");
            // }
         }

         if (!ignoreNotify) _logic.onChange();
      };

      _logic.onChangeRule = (rule, $viewCond, notify = false) => {
         switch (rule) {
            case "contains":
            case "not_contains":
            case "equals":
            case "not_equal":
               // For "connect_fields" search by CUSTOM index value
               if (batchName == "query") {
                  $viewCond.$$(ids.inputValue).showBatch("string");
               }
               // If want to call notify or call .onChange(), then pass notify is true.
               // _logic.onChange();
               break;

            case "is_current_user":
            case "is_not_current_user":
            case "contain_current_user":
            case "not_contain_current_user":
            case "same_as_user":
            case "not_same_as_user":
            case "less_current":
            case "greater_current":
            case "less_or_equal_current":
            case "greater_or_equal_current":
            case "is_empty":
            case "is_not_empty":
               // clear and disable the value field
               $viewCond.$$(ids.inputValue).showBatch("empty");
               _logic.onChange();
               break;

            case "last_days":
            case "next_days":
               // Show the number input
               $viewCond.$$(ids.inputValue).showBatch("number");
               break;

            case "in_query_field":
            case "not_in_query_field":
               // populate the list of Queries for this_object:
               var options = [];

               // Get all application's queries
               this.queries(
                  (q) => this._Object == null || q.id != this._Object.id
               ).forEach((q) => {
                  options.push({
                     id: q.id,
                     value: q.label,
                  });
               });

               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.queryFieldComboQuery)
                  .define("options", options);
               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.queryFieldComboQuery)
                  .refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("queryField");
               break;

            case "same_as_field":
            case "not_same_as_field":
               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.fieldMatch)
                  .define("options", this.recordRuleFieldOptions);
               $viewCond.$$(ids.inputValue).$$(ids.fieldMatch).refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("fieldMatch");
               break;

            case "in_data_collection":
            case "not_in_data_collection": {
               let dcOptions = [];

               // pull data collection list

               // get id of the link object
               let linkObjectId,
                  columnId = $viewCond.$$(ids.field).getValue();
               if (columnId == "this_object" && this._Object) {
                  linkObjectId = this._Object.id;
               } else {
                  let field = this._Fields.filter((f) => f.id == columnId)[0];
                  if (field) linkObjectId = field.settings.linkObject;
               }

               if (this._Application && linkObjectId) {
                  this._Application
                     .datacollections(
                        (dc) =>
                           dc.datasource && dc.datasource.id == linkObjectId
                     )
                     .forEach((dc) => {
                        dcOptions.push({
                           id: dc.id,
                           value: dc.label,
                        });
                     });
               }

               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.dataCollection)
                  .define("options", dcOptions);
               $viewCond.$$(ids.inputValue).$$(ids.dataCollection).refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("dataCollection");
               break;
            }

            default:
               // Show the default value inputs
               $viewCond.$$(ids.inputValue).showBatch(batchName);

               if (notify) _logic.onChange();

               break;
         }
      };

      _logic.onChangeQueryFieldCombo = (value, $viewCond) => {
         // populate the list of Queries for this_object:
         let options = [];
         // Get all queries fields
         let Query = this.queries((q) => {
            return q.id == value;
         })[0];
         if (Query) {
            Query.fields((f) => {
               return !f.isConnection;
            }).forEach((q) => {
               options.push({
                  id: q.id,
                  value: q.object.label + "." + q.label,
               });
            });

            $viewCond
               .$$(ids.inputValue)
               .$$(ids.queryFieldComboField)
               .define("options", options);
            $viewCond.$$(ids.inputValue).$$(ids.queryFieldComboField).refresh();
         }

         // _logic.onChange();
      };

      _logic.onChange = () => {
         if (!this.__blockOnChange) {
            // refresh config settings before notify
            _logic.getValue();

            console.warn("convert RowFilter.callback.onChange() to .emit()");
            _logic.callbacks.onChange();
            this.emit("change");
         }

         return false;
      };

      _logic.blockOnChange = () => {
         this.__blockOnChange = true;
      };

      _logic.unblockOnChange = () => {
         this.__blockOnChange = false;
      };

      /**
       * @method getValue
       *
       * @return {JSON} -
       * {
       * 		glue: '', // 'and', 'or'
       *		rules: [
       *			{
       *				key:	'column name',
       *				rule:	'rule',
       *				value:	'value'
       *			}
       *		]
       * }
       */
      _logic.getValue = () => {
         let config_settings = {
            glue: "and",
            rules: [],
         };

         var $viewForm = $$(ids.filterForm);
         if ($viewForm) {
            $viewForm.getChildViews().forEach(($viewCond, index) => {
               if (index == 0) {
                  config_settings.glue = $viewCond.$$(ids.glue).getValue();
               }

               var $fieldElem = $viewCond.$$(ids.field);
               if (!$fieldElem) return;

               /* field id */
               var fieldId = $fieldElem.getValue();
               if (!fieldId) return;

               /* alias */
               var alias;
               var selectedOpt = $viewCond
                  .$$(ids.field)
                  .getPopup()
                  .config.body.data.filter((opt) => opt.id == fieldId)[0];
               if (selectedOpt) alias = selectedOpt.alias || undefined;

               /* rule */
               var rule = null,
                  ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
                  $viewComparer = $viewCond
                     .$$(ids.rule)
                     .queryView({ id: ruleViewId });
               if ($viewComparer && $viewComparer.getValue)
                  rule = $viewComparer.getValue();

               /* value */
               var value = null,
                  valueViewId = $viewCond.$$(ids.inputValue).getActiveId(),
                  $viewConditionValue = $viewCond
                     .$$(ids.inputValue)
                     .queryView({ id: valueViewId });
               if ($viewConditionValue && $viewConditionValue.getValue) {
                  value = $viewConditionValue.getValue();
               } else if (
                  $viewConditionValue &&
                  $viewConditionValue.getChildViews()
               ) {
                  var vals = [];
                  $viewConditionValue.getChildViews().forEach((element) => {
                     vals.push($$(element).getValue());
                  });
                  value = vals.join(":");
               }

               // Convert date format
               if (value instanceof Date) {
                  let dateField = this._Fields.filter(
                     (f) => f.id == fieldId
                  )[0];
                  if (dateField) {
                     value = dateField.exportValue(value);
                  } else {
                     value = value.toISOString();
                  }
               }

               config_settings.rules.push({
                  alias: alias || undefined,
                  key: fieldId,
                  rule: rule,
                  value: value,
               });
            });
         }

         this.config_settings = config_settings;

         return this.config_settings;
      };

      // webix UI definition:
      this.ui = {
         id: ids.component,
         rows: [
            {
               view: "form",
               id: ids.filterForm,
               hidden: true,
               elements: [],
            },
            _logic.getAddButtonUI(),
         ],
      };
   }

   // setting up UI
   init(options = {}) {
      super.init(options);
      let L = this.AB.Label();

      // register our callbacks:
      for (var c in this._logic.callbacks) {
         this._logic.callbacks[c] = options[c] || this._logic.callbacks[c];
      }

      if (options.showObjectName)
         this._settings.showObjectName = options.showObjectName;

      if (options.isRecordRule) {
         this.recordRuleOptions = [
            {
               value: L("Same As Field"),
               id: "same_as_field",
            },
            {
               value: L("Not Field"),
               id: "not_same_as_field",
            },
         ];
         this.recordRuleFieldOptions = options.fieldOptions;
      }
   }

   setValue(settings) {
      settings = settings || {};

      super.setValue(settings);

      let ids = this.ids;
      let logic = this._logic;

      // block .onChange event
      logic.blockOnChange();

      let config_settings = this.AB.cloneDeep(settings);
      config_settings.rules = config_settings.rules || [];

      // Redraw form with no elements
      var $viewForm = $$(ids.filterForm);
      if ($viewForm) webix.ui([], $viewForm);

      // Add "new filter" button
      if (config_settings.rules.length == 0) {
         logic.toggleAddNewButton();
      }

      config_settings.rules.forEach((f) => {
         var viewId = logic.addNewFilter(),
            $viewCond = $$(viewId);

         if ($viewCond == null) return;

         var field = this._Fields.filter((col) => col.id == f.key)[0];

         // "and" "or"
         $viewCond.$$(ids.glue).define("value", config_settings.glue);
         $viewCond.$$(ids.glue).refresh();

         // Select Field
         $viewCond.$$(ids.field).define("value", f.key);
         $viewCond.$$(ids.field).refresh();
         logic.selectField(f.key, $viewCond, true);

         // Comparer
         var ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
            $viewComparer = $viewCond
               .$$(ids.rule)
               .queryView({ id: ruleViewId });
         if ($viewComparer && $viewComparer.setValue) {
            $viewComparer.define("value", f.rule);
            $viewComparer.refresh();
         }

         // if (f.rule == "in_query_field" || f.rule == "not_in_query_field" || f.rule == "same_as_field" || f.rule == "not_same_as_field") {
         $viewCond.blockEvent();
         logic.onChangeRule(f.rule, $viewCond);
         $viewCond.unblockEvent();
         // }

         // Input
         var valueViewId = $viewCond.$$(ids.inputValue).getActiveId(),
            $viewConditionValue = $viewCond
               .$$(ids.inputValue)
               .queryView({ id: valueViewId });
         if ($viewConditionValue && $viewConditionValue.setValue) {
            // convert to Date object
            if (
               field &&
               field.key == "date" &&
               f.value &&
               (f.rule == "less" ||
                  f.rule == "greater" ||
                  f.rule == "less_or_equal" ||
                  f.rule == "greater_or_equal")
            ) {
               $viewConditionValue.define("value", new Date(f.value));
            } else {
               $viewConditionValue.define("value", f.value);
            }

            $viewConditionValue.refresh();
         } else if (
            $viewConditionValue &&
            $viewConditionValue.getChildViews()
         ) {
            let vals = (f.value || "").split(":");
            let index = 0;
            $viewConditionValue.getChildViews().forEach((element) => {
               $$(element).blockEvent();
               $$(element).setValue(vals[index]);
               if (index == 0) {
                  logic.onChangeQueryFieldCombo(vals[index], $viewCond);
               }
               $$(element).unblockEvent();
               // $$(element).refresh();
               index++;
            });
         }

         if (field && field.key == "user") {
            $viewCond.blockEvent();
            logic.onChangeRule(f.rule, $viewCond);
            $viewCond.blockEvent();
         }
      });

      // unblock .onChange event
      logic.unblockOnChange();
   }

   /**
    * @method isComplete()
    * returns a truthy value representing whether or not our current condition
    * expression is fully completed.  Then externally checks can be made to
    * verify if the data is complete.
    * @return {bool}
    */
   isComplete() {
      if (!this._completeConditions) {
         this._completeConditions = this.AB.filterComplexNew(
            `${this.ids.component}_iscomplete`
         );
      }

      return this._completeConditions.isConditionComplete(this.getValue());
   }
}


/***/ }),

/***/ 38817:
/*!**********************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABField.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABField)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldCore */ 81314);
/*
 * ABField
 *
 * An ABField defines a single unique Field/Column in a ABObject.
 *
 */



class ABField extends _core_dataFields_ABFieldCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object, fieldDefaults) {
      super(values, object, fieldDefaults);

      this.AB.on("ab.abdefinition.update", (def) => {
         if (def.id == this.id) {
            this.emit("definition.updated", this);
         }
      });

      //  	// NOTE: setup this first so later we can use .fieldType(), .fieldIcon()
      //  	this.defaults = fieldDefaults;

      // 	{
      // 		id:'uuid',					// uuid value for this obj
      // 		key:'fieldKey',				// unique key for this Field
      // 		icon:'font',				// fa-[icon] reference for an icon for this Field Type
      // 		label:'',					// pulled from translation
      // 		columnName:'column_name',	// a valid mysql table.column name
      //		settings: {					// unique settings for the type of field
      // 			showIcon:true/false,	// only useful in Object Workspace DataTable
      // 			isImported: 1/0,		// flag to mark is import from other object
      // 			required: 1/0,			// field allows does not allow NULL or it does allow NULL
      // 			width: {int}			// width of display column

      // 		// specific for dataField
      // 		},
      // 		translations:[]
      // 	}

      // 	this.fromValues(values);

      // this.object = object;
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   static editorValues(settings) {
      const obj = {
         label: settings.label,
         columnName: settings.columnName,
         settings: settings,
      };

      delete settings.label;
      delete settings.columnName;

      return obj;
   }

   addValidation(ids, settings) {
      let L = this.AB.Label();
      const App = this.object.application.App;
      const Filter = this.AB.filterComplexNew(
         `${this.id}_field_validation_rules`
      );
      $$(ids.filterComplex).addView({
         view: "form",
         css: "abValidationForm",
         cols: [
            {
               rows: [
                  {
                     view: "text",
                     name: "invalidMessage",
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     value:
                        settings && settings.invalidMessage
                           ? settings.invalidMessage
                           : "",
                     label: L("Invalid Message"),
                  },
                  Filter.ui,
               ],
            },
            {
               view: "button",
               css: "webix_danger",
               icon: "fa fa-trash",
               type: "icon",
               autowidth: true,
               click: function () {
                  const $viewCond = this.getParentView();
                  $$(ids.filterComplex).removeView($viewCond);
               },
            },
         ],
      });
      $$(Filter.ids.save).hide();
      // Filter.applicationLoad(this.object.application);
      Filter.fieldsLoad(this.object.fields());
      if (settings && settings.rules) Filter.setValue(settings.rules);
   }

   /*
    * @method isValid
    * check the current values to make sure they are valid.
    * Here we check the default values provided by ABField.
    *
    * @return null or [{OP.Validation.validator()}] objects.
    */
   isValid() {
      let L = this.AB.Label();
      const validator = this.AB.Validation.validator();

      // .columnName must be unique among fileds on the same object
      const isNameUnique =
         this.object.fields((f) => {
            return (
               f.id != this.id &&
               f.columnName.toLowerCase() == this.columnName.toLowerCase()
            );
         }).length == 0;
      if (!isNameUnique) {
         validator.addError(
            "columnName",
            L(
               "Field columnName must be unique ({0} already used in this Object)",
               [this.columnName]
            )
         );
      }

      return validator;
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   async destroy() {
      // verify we have been .save() before:
      if (!this.id) return;

      // NOTE: our .migrateXXX() routines expect the object to currently exist
      // in the DB before we perform the DB operations.  So we need to
      // .migrateDrop()  before we actually .objectDestroy() this.
      await this.migrateDrop();

      // the server still references an ABField in relationship to it's
      // ABObject, so we need to destroy the Field 1st, then remove it
      // from it's object.
      await super.destroy();

      await this.object.fieldRemove(this);
   }

   /**
    * @method save()
    *
    * persist this instance of ABField with it's parent ABObject
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   async save() {
      let isAdd = false;
      // if this is our initial save()
      if (!this.id) {
         isAdd = true;
      }

      // Whenever we update our settings, make sure any
      // existing rows that have NULL values for this field
      // are updated to have our current .default value.
      if (!isAdd && this.settings.required && this.settings.default) {
         const model = this.object.model();

         // pull rows that has null value
         const result = await model.findAll({
            where: {
               glue: "and",
               rules: [
                  {
                     key: this.id,
                     rule: "is_null",
                  },
               ],
            },
         });

         const tasks = [];

         // updating ...
         result.data.forEach((d) => {
            if (!d[this.columnName]) d[this.columnName] = this.settings.default;

            tasks.push(model.update(d.id, d));
         });

         await Promise.all(tasks);
      }

      // New ABDefinition method of saving:
      // when this is done, we now have an .id
      await super.save();

      // incase this was an ADD operation, make sure the
      // parent Obj now includes this object:
      // NOTE: must be done after the .save() so we have an .id
      await this.object.fieldAdd(this);

      // perform any server side migrations for this Field:

      // but not connectObject fields:
      // ABFieldConnect.migrateXXX() gets called from the UI popupNewDataField
      // in order to handle the timings of the 2 fields that need to be created
      if (!this.isConnection) {
         const fnMigrate = isAdd ? this.migrateCreate() : this.migrateUpdate();
         await fnMigrate;
      }

      return this;
   }

   ///
   /// DB Migrations
   ///

   migrateCreate() {
      return this.AB.Network.post({
         url: `/definition/migrate/object/${this.object.id}/field/${this.id}`,
      });
   }

   migrateUpdate() {
      return this.AB.Network.put({
         url: `/definition/migrate/object/${this.object.id}/field/${this.id}`,
      });
   }

   migrateDrop() {
      return this.AB.Network["delete"]({
         url: `/definition/migrate/object/${this.object.id}/field/${this.id}`,
      });
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @function columnHeader
    * Return the column header for a webix grid component for this specific
    * data field.
    * @param {Object} options
    * {
    *    isObjectWorkspace: {bool},  is this being used in the Object workspace.
    *    width: {int},
    *    height: {int},
    *    editable: {bool}
    * }
    * @return {obj}  configuration obj
    */
   columnHeader(options) {
      options = options || {};

      const config = {
         id: this.columnName, // this.id,
         header: this.label,
      };

      if (options.isObjectWorkspace && this.settings.showIcon) {
         config.header = `<span class="webix_icon fa fa-${this.fieldIcon()}"></span>${
            config.header
         }`;
      }

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.  If this isn't
    * a standard value display (think image, Map, graph, etc...) then use this
    * method to create the display in the table/grid cell.
    * @param {object} row
    *        is the {name=>value} hash of the current row of data.
    * @param {App} App
    *        the shared ui App object useful more making globally
    *			 unique id references.
    * @param {HtmlDOM} node
    *        the HTML Dom object for this field's display.
    * @param {object} options
    *        option of additional settings
    */
   customDisplay(row, App, node, options) {}

   /*
    * @function customEdit
    *
    *
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node) {
      return true;
   }

   /**
    * @method getValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    * @return {Object}
    */
   getValue(item, rowData) {
      return item.getValue();
   }

   /**
    * @method setValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    */
   setValue(item, rowData, defaultValue) {
      if (!item) return;

      let val;

      if (
         (rowData == null || rowData[this.columnName] == null) &&
         defaultValue != null
      ) {
         val = defaultValue;
      } else if (rowData && rowData[this.columnName] != null) {
         val = rowData[this.columnName];
      } else {
         val = rowData;
      }

      item.setValue(val);
   }

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent(formKey) {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.

      return {
         // .common() is used to create the display in the list
         common: () => {
            return {
               key: formKey,

               // // but since this is a common place holder: use the
               // // multilingual label here:
               // labelKey: 'ab.abfield.labelPlaceholder',
               // icon:  'square'
            };
         },

         // .newInstance() is used to create the view instance when the component
         // 		is dropped onto the ABView list.
         newInstance: (application, parent) => {
            application = application ?? this.AB._mockApp;

            // NOTE: in case you were wondering, the base ABField
            // 		 will just return a label with 'ABFieldPlaceholder'
            // 		 as the text.  Any sub class of ABField should overwrite
            // 		 this and return an actual Form Component.

            // store object id and field id to field component
            const values = this.formComponent().common();
            values.settings = values.settings || {};
            values.settings.objectId = this.object.id;
            values.settings.fieldId = this.id;

            const ABFieldPlaceholder = application.viewNew(
               values,
               application,
               parent
            ); // ABViewManager.newView(values, application, parent);
            // ABFieldPlaceholder.formatTitle();
            // ABFieldPlaceholder.text = "ABFieldPlaceholder";

            return ABFieldPlaceholder;
         },
      };
   }

   /**
    * @method detailComponent
    */
   detailComponent() {
      return {
         common: () => {
            return {
               icon: "square",
            };
         },

         // .newInstance() is used to create the view instance when the component
         // 		is dropped onto the ABView list.
         newInstance: (application, parent) => {
            application = application ?? this.AB._mockApp;

            // store object id and field id to field component
            const values = this.detailComponent().common();
            values.settings = values.settings || {};
            values.settings.objectId = this.object.id;
            values.settings.fieldId = this.id;

            const ABFieldPlaceholder = application.viewNew(
               values,
               application,
               parent
            ); // ABViewManager.newView(values, application, parent);

            return ABFieldPlaceholder;
         },
      };
   }

   /**
    * @method getSettings()
    * return a copy of this.settings.
    * @return {object}
    */
   getSettings() {
      return Object.assign({}, this.settings);
   }

   /**
    * @method warningsMessage()
    * generate a commonly formatted warning message for this ABField.
    * This is expected to be called from within a .warningsEval()
    * method when generating warnings.
    * @param {string} msg
    *        the warning string to display
    * @param {json} data
    *        any relevant additional information for a developer to refer to.
    */
   warningsMessage(msg, data = {}) {
      let message = `${this.fieldKey()}[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }
}


/***/ }),

/***/ 99341:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldAutoIndex.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldAutoIndex)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldAutoIndexCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldAutoIndexCore */ 97177);


class ABFieldAutoIndex extends _core_dataFields_ABFieldAutoIndexCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldAutoIndex
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         // if this isn't part of a group header display the default format
         if (!rowData.$group) {
            return this.format(rowData);
         } else {
            return "";
         }
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
}


/***/ }),

/***/ 23126:
/*!*****************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldBoolean.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldBoolean)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldBooleanCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldBooleanCore */ 96108);


class ABFieldBoolean extends _core_dataFields_ABFieldBooleanCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldBoolean
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);

      config.editor = "template";
      config.css = "center";
      config.template = (row, common, value, config) => {
         // Group header
         if (row.$group) return row[this.columnName];

         // editable
         if (options.editable) {
            return (
               '<div class="ab-boolean-display">' +
               common.checkbox(row, common, value, config) +
               "</div>"
            );
         }

         // readonly
         else {
            if (value)
               return "<div class='webix_icon fa fa-check-square-o'></div>";
            else return "<div class='webix_icon fa fa-square-o'></div>";
         }
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("checkbox");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailcheckbox",
         };
      };

      return detailComponentSetting;
   }
}


/***/ }),

/***/ 15308:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldCalculate.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldCalculate)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldCalculateCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldCalculateCore */ 69813);


class ABFieldCalculate extends _core_dataFields_ABFieldCalculateCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldCalculate
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         if (rowData.$group) return rowData[this.columnName];

         return this.format(rowData);
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
}


/***/ }),

/***/ 71331:
/*!*****************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldCombine.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldCombine)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldCombineCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldCombineCore */ 84898);


class ABFieldCombine extends _core_dataFields_ABFieldCombineCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldCombine
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         // if this isn't part of a group header display the default format
         if (!rowData.$group) {
            return this.format(rowData);
         } else {
            return "";
         }
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   warningsEval() {
      super.warningsEval();

      (this.settings.combinedFields.split(",") || []).forEach((id) => {
         var field = this.object.fieldByID(id);
         if (!field) {
            this.warningsMessage(`dependent field[${id}] not found.`, {
               fieldID: id,
               combinedFields: this.settings.combinedFields,
            });
         }
      });
   }
}


/***/ }),

/***/ 30289:
/*!*****************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldConnect.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldConnect)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldConnectCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldConnectCore */ 65129);


class ABFieldConnect extends _core_dataFields_ABFieldConnectCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object, fieldDefaults) {
      super(values, object, fieldDefaults);
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   async destroy() {
      // verify we have been .save()d before:
      if (!this.id) return Promise.resolve();

      // NOTE: our .migrateXXX() routines expect the object to currently exist
      // in the DB before we perform the DB operations.  So we need to
      // .migrateDrop()  before we actually .objectDestroy() this.
      // this.migrateDrop()
      //    // .then(() => {
      //    //    // NOTE : prevent recursive remove connected fields
      //    //    // - remove this field from JSON
      //    //    this.object._fields = this.object.fields((f) => {
      //    //       return f.id != this.id;
      //    //    });
      //    // })
      //    .then(() => {
      //       // Save JSON of the object
      //       return this.object.fieldRemove(this);
      //    })
      await super.destroy();

      // Now we need to remove our linked Object->field

      const linkObject = this.datasourceLink;
      if (!linkObject) return Promise.resolve(); // already notified

      const linkField = this.fieldLink;
      if (!linkField) return Promise.resolve(); // already notified

      // destroy linked field
      return linkField.destroy();
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method pullRelationValues
    *
    * On the Web client, we want our returned relation values to be
    * ready for Webix objects that require a .text and .value field.
    *
    * @param {*} row
    * @return {array}
    */
   pullRelationValues(row) {
      let selectedData = [];

      const data = super.pullRelationValues(row);
      const linkedObject = this.datasourceLink;

      if (data && linkedObject) {
         // if this select value is array
         if (Array.isArray(data)) {
            selectedData = data.map(function (d) {
               // display label in format
               if (d) {
                  d.text = d.text || linkedObject.displayData(d);
                  d.value = d.text;
               }

               return d;
            });
         } else if (data.id || data.uuid) {
            selectedData = data;
            selectedData.text =
               selectedData.text || linkedObject.displayData(selectedData);
            selectedData.value = selectedData.text;
         } else if (typeof data == "string") {
            selectedData = { text: data };
         }
      }

      return selectedData;
   }

   columnHeader(options) {
      options = options || {};
      const config = super.columnHeader(options);
      const field = this;
      const App = field.AB._App;

      if (options.filters == null) {
         options.filters = {};
      }

      var multiselect = this.settings.linkType == "many";

      config.editor = multiselect ? "multiselect" : "combo";
      config.editFormat = (value) => {
         return this.editFormat(value);
      };
      config.editParse = (value) => {
         return this.editParse(value);
      };
      config.template = (row) => {
         var selectedData = field.pullRelationValues(row);
         var values = [];
         values.push('<div class="badgeContainer">');
         if (
            selectedData &&
            Array.isArray(selectedData) &&
            selectedData.length
         ) {
            selectedData.forEach((val) => {
               values.push(
                  `<div class='webix_multicombo_value'><span>${val.value}</span><!-- span data-uuid="${val.id}" class="webix_multicombo_delete" role="button" aria-label="Remove item"></span --></div>`
               );
            });
            if (selectedData.length > 1) {
               values.push(
                  `<span class="webix_badge selectivityBadge">${selectedData.length}</span>`
               );
            }
         } else if (selectedData.value) {
            let clear = "";
            if (options.editable) {
               clear = `<span class="webix_multicombo_delete clear-combo-value" role="button" aria-label="Remove item"></span>`;
            }
            values.push(
               `<div class='webix_multicombo_value'>${clear}<span class="ellip">${selectedData.value}</span></div>`
            );
         } else {
            return "";
         }
         values.push("</div>");
         return values.join("");
      };

      config.suggest = {
         on: {
            onBeforeShow: function () {
               field.openOptions(this);
            },
         },

         // Support partial matches
         filter: ({ value }, search) =>
            (value ?? "").toLowerCase().includes((search ?? "").toLowerCase()),
      };

      if (multiselect) {
         config.suggest.view = "checksuggest";
         config.suggest.button = true;
      }

      return config;
   }

   openOptions($suggest) {
      // PREVENT repeatedly pull data:
      // If not a x->1 relation and the options list was populated, then skip
      const $list = $suggest.getList();
      if (this.settings.linkViaType != "one") {
         if (($list?.find({}) ?? []).length) return;
      }

      // Listen create/update events of the linked object, then clear data list to re-populate
      ["create", "update"].forEach((key) => {
         if (this[`_dc_${key}_event`]) return;

         this[`_dc_${key}_event`] = this.AB.on(
            `ab.datacollection.${key}`,
            (res) => {
               if (this.datasourceLink.id == res.objectId) $list.clearAll();
            }
         );
      });

      this.getAndPopulateOptions($suggest, null, this);
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *             unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */

   //// NOTE: why do we pass in row, App, and node?  is this something we do in our external components?
   ////       are these values present when this Object is instanciated? Can't we just pass these into the
   ////       object constructor and have it internally track these things?
   customEdit(row, /*App,*/ node) {
      // var selectedData = this.pullRelationValues(row);
      // this._selectedData = selectedData;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("connect");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailconnect",
         };
      };

      return detailComponentSetting;
   }

   /**
    * @method getOptions
    * show options list in selectivity
    *
    * @return {Promise}
    */

   initStore(store) {
      let id = this.id;
      store.state[id] = [];
      store.getters[id] = function ({ state }) {
         return state[id];
      };
   }

   options(...params) {
      return this.getOptions(...params).then((options) => {
         this.AB.$store.state[this.id] = options || [];
         return options;
      });
   }

   getOptions(whereClause, term, sort, editor) {
      const theEditor = editor;
      return new Promise((resolve, reject) => {
         let haveResolved = false;
         // {bool}
         // have we already passed back a result?

         const respond = (options) => {
            // filter the raw lookup with the provided search term
            options = options.filter((item) => {
               if (item.text.toLowerCase().includes(term.toLowerCase())) {
                  return true;
               }
            });

            if (!haveResolved) {
               haveResolved = true;
               resolve(options);
            } else {
               // if we have already resolved() then .emit() that we have
               // updated "option.data".
               this.emit("option.data", options);
            }
         };

         // Prepare Where clause

         const where = this.AB.cloneDeep(whereClause || {});
         if (!where.glue) where.glue = "and";
         if (!where.rules) where.rules = [];

         term = term || "";
         sort = sort || [];

         // check if linked object value is not define, should return a empty array
         if (!this.settings.linkObject) {
            respond([]);
            return;
         }

         // if options was cached
         // if (this._options != null) return resolve(this._options);

         const linkedObj = this.datasourceLink;

         // System could not found the linked object - It may be deleted ?
         if (linkedObj == null) throw new Error("No linked object");

         const linkedCol = this.fieldLink;

         // System could not found the linked field - It may be deleted ?
         if (linkedCol == null) throw new Error("No linked column");

         // Get linked object model
         const linkedModel = linkedObj.model();

         const linkType = this.LinkString; // `${this.settings.linkType}:${this.settings.linkViaType}`;

         // M:1 - get data that's only empty relation value
         if (
            "many:one" == linkType // && editor?.config?.showAllOptions != true
         ) {
            where.rules.push({
               key: linkedCol.id,
               rule: "is_null",
            });
            // where[linkedCol.columnName] = null;
         }
         // 1:1
         else if (
            "one:one" == linkType // && editor?.config?.showAllOptions != true
         ) {
            // 1:1 - get data is not match link id that we have
            if (this.settings.isSource == true) {
               // NOTE: make sure "haveNoRelation" shows up as an operator
               // the value ":0" doesn't matter, we just need 'haveNoRelation' as an operator.
               // newRule[linkedCol.id] = { 'haveNoRelation': 0 };
               where.rules.push({
                  key: linkedCol.id,
                  rule: "have_no_relation",
               });
            }
            // 1:1 - get data that's only empty relation value by query null value from link table
            else {
               where.rules.push({
                  key: linkedCol.id,
                  rule: "is_null",
               });
               // newRule[linkedCol.id] = 'null';
               // where[linkedCol.id] = null;
            }
         }

         const storageID = this.getStorageID(where);

         Promise.resolve()
            .then(async () => {
               // Mar 23, 2023 disabling local storage of options because users
               // were reporting not seeing the correct options list with either
               // new, updated or deleted records that should or should not appear
               return false;
               // Get Local Storage unless xxx->one connected field
               if (this?.settings?.linkViaType != "one") {
                  // We store the .findAll() results locally and return that for a
                  // quick response:
                  return await this.AB.Storage.get(storageID);
               }
            })
            .then(async (storedOptions) => {
               if (storedOptions) {
                  // immediately respond with our stored options.
                  this._options = storedOptions;
                  return respond(this._options);
               }
               // Pull linked object data
               let options = function () {
                  return linkedModel.findAll({
                     where: where,
                     sort: sort,
                     populate: false,
                  });
               };

               // placeholder for selected options
               let selected = function () {
                  return new Promise((resolve, reject) => {
                     // empty data array to pass to all()
                     resolve({ data: [] });
                  });
               };

               // we also need to get selected values of xxx->one connections
               // if we are looking at a field in a form we look at linkViaOneValues
               // if we are looking at a grid we are editing we look at theEditor?.config?.value
               if (
                  this?.settings?.linkViaType == "one" &&
                  (this?.linkViaOneValues || theEditor?.config?.value)
               ) {
                  let values = "";
                  // determine if we are looking in a grid or at a form field
                  if (
                     (theEditor?.config?.view == "multicombo" ||
                        theEditor?.config?.view == "combo") &&
                     this?.linkViaOneValues
                  ) {
                     values = this?.linkViaOneValues;
                  } else if (theEditor?.config?.value) {
                     if (Array.isArray(theEditor.config.value)) {
                        values = theEditor?.config?.value.join();
                     } else {
                        values = theEditor?.config?.value;
                     }
                  }
                  let whereRels = {};
                  let sortRels = [];

                  whereRels.glue = "or";
                  whereRels.rules = [];

                  values.split(",").forEach((v) => {
                     whereRels.rules.push({
                        key: "uuid",
                        rule: "equals",
                        value: v,
                     });
                  });
                  selected = function () {
                     return linkedModel.findAll({
                        where: whereRels,
                        sort: sortRels,
                        populate: false,
                     });
                  };
               }
               try {
                  const results = await Promise.all([options(), selected()]);

                  // combine options and selected items and
                  // put the selected options at the top of the list
                  const result = results[1].data.concat(results[0].data);

                  // store results in _options
                  this._options = result.data || result || [];

                  // populate display text
                  (this._options || []).forEach((opt) => {
                     opt.text = linkedObj.displayData(opt);
                     opt.value = opt.text;
                  });

                  // cache options if not a xxx->one connection
                  if (this?.settings?.linkViaType != "one") {
                     this.AB.Storage.set(storageID, this._options);
                  }
                  return respond(this._options);
               } catch (err) {
                  this.AB.notify.developer(err, {
                     context:
                        "ABFieldConnect:getOptions(): unable to retrieve options from server",
                     field: this.toObj(),
                     where,
                  });

                  haveResolved = true;
                  throw err;
               }
            });
      });
   }

   getStorageID(where) {
      return `${this.id}-${JSON.stringify(where)}`;
   }

   async clearStorage(where) {
      const storageID = this.getStorageID(where);
      await this.AB.Storage.set(storageID, null);
   }

   editFormat(value) {
      if (!value) return "";
      let vals = [];
      if (Array.isArray(value)) {
         value.forEach((val) => {
            if (typeof val == "object") {
               vals.push(val.id);
            } else {
               let itemObj = this.getItemFromVal(val);
               vals.push(itemObj.id);
            }
         });
      } else {
         if (typeof value == "object") {
            vals.push(value.id);
         } else {
            let itemObj = this.getItemFromVal(value);
            if (itemObj && itemObj.id) {
               vals.push(itemObj.id);
            }
         }
      }
      return vals.join();
   }

   editParse(value) {
      var multiselect = this.settings.linkType == "many";
      if (multiselect) {
         if (!value) {
            return [];
         } else {
            let returnVals = [];
            let vals = value.split(",");
            vals.forEach((val) => {
               returnVals.push(this.getItemFromVal(val));
            });
            return returnVals;
         }
      } else {
         let item = this.getItemFromVal(value);
         return item;
      }
   }

   getAndPopulateOptions(editor, options, field, form) {
      const theEditor = editor;
      // if editor has options and is xxx->one store the options on the field
      if (
         this?.settings?.linkViaType == "one" &&
         theEditor.getValue() &&
         !field.linkViaOneValues
      ) {
         field.linkViaOneValues = theEditor.getValue();
      }

      // if we are filtering based off another selectivity's value we
      // need to do it on fetch each time because the value can change
      // copy the filters so we don't add to them every time there is a change
      const combineFilters = options?.filters
         ? Object.assign({}, options.filters)
         : { glue: "and", rules: [] };

      if (options?.filterByConnectValues) {
         const parseFilterByConnectValues = (conditions, values, depth = 0) => {
            const valuesByDepth = values.filter((e) => e?.depth === depth);

            return [
               ...conditions.rules.map((e) => {
                  if (e.glue)
                     return {
                        glue: e.glue,
                        rules: parseFilterByConnectValues(e, values, depth + 1),
                     };

                  const value = valuesByDepth.filter(
                     (ef) => ef.key === e.key && ef.value === e.value
                  )[0];

                  if (!value) return e;

                  const $parentField = value?.filterValue?.config.id
                     ? $$(value.filterValue.config.id)
                     : null;

                  if (!$parentField)
                     throw Error(
                        "Some parent field's view components don't exist"
                     );

                  const parentValue = value?.filterValue
                     ? $parentField.getValue() ?? ""
                     : "";

                  let newVal = "";

                  if (parentValue) {
                     if (value.filterColumn) {
                        if (
                           field.object
                              .fieldByID(value.filterValue.config.dataFieldId)
                              .getItemFromVal(parentValue)
                        ) {
                           newVal = field.object
                              .fieldByID(value.filterValue.config.dataFieldId)
                              .getItemFromVal(parentValue)[value.filterColumn];
                        } else {
                           newVal = parentValue;
                        }
                     } else {
                        newVal = parentValue;
                     }
                  }

                  return {
                     key: e.key,
                     rule: "equals",
                     value: newVal,
                  };
               }),
            ];
         };

         combineFilters.rules = parseFilterByConnectValues(
            combineFilters,
            options.filterByConnectValues
         );
      }

      const handlerOptionData = (data) => {
         if (theEditor.$destructed) {
            this.removeListener("option.data", handlerOptionData);
            return;
         }
         this.populateOptions(theEditor, data, field, form, true);
      };

      // try to make sure we don't continually add up listeners.
      this.removeListener("option.data", handlerOptionData).once(
         "option.data",
         handlerOptionData
      );

      return new Promise((resolve, reject) => {
         this.getOptions(
            combineFilters,
            "",
            options?.sort ?? "",
            theEditor
         ).then((data) => {
            this.populateOptions(theEditor, data, field, form, true);
            resolve(data);
         });
      });
   }

   // populateOptions(theEditor, data, field, form, addCy) {
   //    if (theEditor == null || theEditor.$destructed) return;

   //    theEditor.blockEvent();
   //    theEditor.getList().clearAll();
   //    theEditor.getList().define("data", data);
   //    if (addCy) {
   //       this.populateOptionsDataCy(theEditor, field, form);
   //    }
   //    if (theEditor.getValue && theEditor.getValue()) {
   //       theEditor.setValue(theEditor.getValue());
   //       // } else if (this._selectedData && this._selectedData.length) {
   //       //    theEditor.setValue(this.editFormat(this._selectedData));
   //    }
   //    theEditor.unblockEvent();
   // }

   populateOptionsDataCy(theEditor, field, form) {
      if (theEditor?.$destructed) return;

      // Add data-cy attributes
      if (theEditor?.getList) {
         if (!theEditor.getPopup) return;
         var popup = theEditor.getPopup();
         if (!popup) return;
         theEditor.getList().data.each((option) => {
            if (!option) return;
            var node = popup.$view.querySelector(
               "[webix_l_id='" + option.id + "']"
            );
            if (!node) return;
            node.setAttribute(
               "data-cy",
               `${field.key} options ${option.id} ${field.id} ${form?.id}`
            );
         });
      }
   }

   getItemFromVal(val) {
      let item;
      let options = this._options || [];
      if (options.length > 0) {
         for (let i = 0; i < options.length; i++) {
            if (
               this.indexField &&
               options[i][this.indexField.object.PK()] == val
            ) {
               item = options[i];
               break;
            } else if (
               this.indexField2 &&
               options[i][this.indexField2.object.PK()] == val
            ) {
               item = options[i];
               break;
            } else {
               if (
                  options[i].id == val ||
                  options[i].value == val ||
                  options[i][this.indexField?.columnName ?? ""] == val ||
                  options[i][this.indexField2?.columnName ?? ""] == val
               ) {
                  item = options[i];
                  break;
               }
            }
         }
         return item;
      } else {
         return "";
      }
   }

   getValue(item) {
      var multiselect = this.settings.linkType == "many";
      if (multiselect) {
         let vals = [];
         if (item.getValue()) {
            let val = item.getValue().split(",");
            val.forEach((record) => {
               vals.push(item.getList().getItem(record));
            });
         }
         return vals;
      } else {
         if (item.getValue()) {
            return item.getList().getItem(item.getValue());
         } else {
            return "";
         }
      }
   }

   setValue(item, rowData) {
      if (!item) return;
      // if (AB.isEmpty(rowData)) return; removed because sometimes we will
      // want to set this to empty
      let val = this.pullRelationValues(rowData);
      // put in current values as options so we can display them before
      // the rest of the options are fetched when field is clicked
      if (item.getList && item.getList().count() == 0) {
         if (this.settings.linkType !== "one" && !Array.isArray(val)) {
            val = [val];
         }

         const $list = item.getList();

         $list.define("data", val);
         $list.refresh();
      }

      item.setValue(
         Array.isArray(val)
            ? val.map((e) => e.id ?? e.uuid ?? e).join(",")
            : val.id ?? val.uuid ?? val
      );
   }

   /**
    * @method pullRecordRelationValues
    *
    * On the Web client, we want our returned relation values to be
    * ready for Webix objects that require a .text and .value field.
    *
    * @param {*} row
    * @return {array}
    */
   pullRecordRelationValues(record) {
      var selectedData = [];

      var data = record;
      var linkedObject = this.datasourceLink;

      if (data && linkedObject) {
         // if this select value is array
         if (Array.isArray(data)) {
            selectedData = data.map(function (d) {
               // display label in format
               if (d) {
                  d.text = d.text || linkedObject.displayData(d);
                  d.value = d.text;
               }

               return d;
            });
         } else if (data.id || data.uuid) {
            selectedData = data;
            selectedData.text =
               selectedData.text || linkedObject.displayData(selectedData);
            selectedData.value = selectedData.text;
         }
      }

      return selectedData;
   }

   warningsEval() {
      super.warningsEval();

      var linkField = this.fieldLink;
      if (!linkField) {
         this.warningsMessage(
            `is unable to find linked field[${this.settings.linkColumn}]`,
            {
               linkColumn: this.settings.linkColumn,
            }
         );
      }

      let linkObj = this.datasourceLink;
      if (!linkObj) {
         this.warningsMessage(
            `is unable to find linked object[${this.settings.linkObject}]`,
            {
               linkObject: this.settings.linkObject,
            }
         );
      }
   }
}


/***/ }),

/***/ 42405:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldDate.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldDate)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldDateCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldDateCore */ 60437);


class ABFieldDate extends _core_dataFields_ABFieldDateCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldDate
   columnHeader(options) {
      const config = super.columnHeader(options);

      // if (this.settings.includeTime)
      // config.editor = "datetime";
      // else
      config.editor = "date";

      // allows entering characters in datepicker input, false by default
      config.editable = true;

      // NOTE: it seems that the default value is a string in ISO format.

      //// NOTE: webix seems unable to parse ISO string into => date here.
      // config.map = '(date)#'+this.columnName+'#';   // so don't use this.

      config.template = (row) => {
         if (row.$group) return row[this.columnName];

         return this.format(row);
      };

      config.format = (d) => {
         const rowData = {};
         rowData[this.columnName] = d;

         return this.format(rowData);
      };

      config.editFormat = (d) => {
         // this routine needs to return a Date() object for the editor to work with.

         if (d == "" || d == null) {
            return "";
         }

         // else retun the actual ISO string => Date() value
         return this.AB.rules.toDate(d);
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent("datepicker");

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "datepicker",
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   dateToString(dateFormat, dateData) {
      if (!dateData) return "";

      return this.AB.rules.toDateFormat(dateData, { format: dateFormat }); // webix.Date.dateToStr(dateFormat)(dateData);
   }

   // Overwrite core.format to use webix locales.
   // format(rowData) {
   //    if (!window.webixLocale) return super.format(rowData);
   //    const d = this.dataValue(rowData);

   //    if (d == "" || d == null) {
   //       return "";
   //    }
   //    const dateObj = this.AB.rules.toDate(d);

   //    const dateFormat = this.settings.dateFormat;
   //    // @const {int} dateFormat AB Date Format
   //    // 1 - ignore, 2 - dd/mm/yyyy, 3 - mm/dd/yyyy, 4 - M D, yyyy, 5 - D M, yyyy

   //    // Return longdate if option 4 or 5
   //    if (dateFormat >= 4) {
   //       return webix.i18n.longDateFormatStr(dateObj);
   //    } else {
   //       return webix.i18n.dateFormatStr(dateObj);
   //    }
   // }
}


/***/ }),

/***/ 68246:
/*!******************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldDateTime.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldDateTime)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldDateTimeCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldDateTimeCore */ 81973);


class ABFieldDateTime extends _core_dataFields_ABFieldDateTimeCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldDate
   columnHeader(options) {
      const config = super.columnHeader(options);

      // Ignore date
      if (this.settings.dateFormat == 1) {
         config.editor = "time";
      } else {
         config.editor = "datetime";
      }

      // allows entering characters in datepicker input, false by default
      config.editable = true;

      // NOTE: it seems that the default value is a string in ISO format.

      //// NOTE: webix seems unable to parse ISO string into => date here.
      // config.map = '(date)#'+this.columnName+'#';   // so don't use this.

      config.template = (row) => {
         if (row.$group) return row[this.columnName];

         return this.format(row);
      };

      config.format = (d) => {
         const rowData = {};
         rowData[this.columnName] = d;

         return this.format(rowData);
      };

      config.editFormat = (d) => {
         // this routine needs to return a Date() object for the editor to work with.

         if (d == "" || d == null) {
            return "";
         }

         // else retun the actual ISO string => Date() value
         return this.AB.rules.toDate(d);
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent("datepicker");

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "datepicker",
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   // Overwrite core.format to use webix locales.
   format(rowData) {
      if (!window.webixLocale) return super.format(rowData);
      const d = this.dataValue(rowData);

      if (d == "" || d == null) {
         return "";
      }
      const dateObj = this.AB.rules.toDate(d);

      const dateFormat = this.settings.dateFormat;
      // @const {int} dateFormat AB Date Format
      // 1 - ignore, 2 - dd/mm/yyyy, 3 - mm/dd/yyyy, 4 - M D, yyyy, 5 - D M, yyyy
      const timeToStr = webix.Date.dateToStr(this.getTimeFormat());

      if (dateFormat >= 4) {
         return `${webix.i18n.longDateFormatStr(dateObj)} ${timeToStr(
            dateObj
         )}`;
      } else {
         return `${webix.i18n.dateFormatStr(dateObj)} ${timeToStr(dateObj)}`;
      }
   }
}


/***/ }),

/***/ 19387:
/*!***************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldEmail.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldEmail)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldEmailCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldEmailCore */ 79009);


class ABFieldEmail extends _core_dataFields_ABFieldEmailCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldBoolean
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "text";

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "textbox",
            settings: {
               type: "single",
            },
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
}


/***/ }),

/***/ 5833:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldFile.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldFile)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldFileCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldFileCore */ 27007);


class ABFieldFile extends _core_dataFields_ABFieldFileCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   /**
    * @function destroy
    * On a destroy operation, ask if the user wants to keep the related file.
    */
   async destroy() {
      var L = this.AB.Label();
      return new Promise((resolve, reject) => {
         // verify we have been .save()d before:
         if (!this.id) {
            resolve();
            return;
         }

         // Ask the user what to do about the existing file:
         webix.confirm({
            title: L("Keep Files?"),
            message: L("Do you want to keep the files referenced by {0}?", [
               this.label,
            ]),
            callback: async (result) => {
               // update this setting so the server can respond correctly in
               // ABFieldFile.migrateDrop()
               this.settings.removeExistingData = result ? 0 : 1;

               try {
                  await this.save();

                  // TODO: a reminder that you still got alot on the server to do!
                  webix.alert({
                     title: "!! TODO !!",
                     text: "Tell a Developer to actually pay attention to this!",
                  });

                  // now the default .destroy()
                  await super.destroy();

                  resolve();
               } catch (err) {
                  reject(err);
               }
            },
         });
      });
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldFile
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);

      config.editor = false;

      const editable = options.editable;

      // populate our default template:
      config.template = (obj) => {
         if (obj.$group) return this.dataValue(obj);

         const fileDiv = [
            '<div class="ab-file-data-field" style="float: left;">',
            '<div class="webix_view ab-file-holder">',
            '<div class="webix_template">',
            this.fileTemplate(obj, editable),
            "</div>",
            "</div>",
            "</div>",
         ].join("");

         return fileDiv;
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }
      options = options || {};
      var L = this.AB.Label();

      let typesList = [];
      let maximumSize = 0;

      if (this.settings.limitFileType && this.settings.fileType) {
         typesList = this.settings.fileType.split(",");
      }

      if (this.settings.limitFileSize && this.settings.fileSize) {
         maximumSize = this.settings.fileSize;
      }

      // 		// safety check:
      // 		// webix seems to crash if you specify a .container that doesn't exists:
      // 		// Note: when the template is first created, we don't have App.unique()
      const parentContainer = node.querySelector(".ab-file-holder");
      if (parentContainer) {
         parentContainer.innerHTML = "";
         // parentContainer.id = idBase;	// change it to the unique one.

         // 			// use a webix component for displaying the content.
         // 			// do this so I can use the progress spinner

         const webixContainer = webix.ui({
            view: "template",
            container: parentContainer,

            template: this.fileTemplate(row, options.editable),

            borderless: true,
            width: 160,
            height: 60,
         });
         webix.extend(webixContainer, webix.ProgressBar);

         // 			////
         // 			//// Prepare the Uploader
         // 			////

         if (!options.editable) {
            const domNode = parentContainer.querySelector(".delete-image");
            if (domNode) domNode.style.display = "none";

            return;
         }

         const url = this.urlUpload(true);

         const uploader = webix.ui({
            view: "uploader",
            apiOnly: true,
            upload: url,
            inputName: "file",
            multiple: false,
            on: {
               // when a file is added to the uploader
               onBeforeFileAdd: function (item) {
                  node.classList.remove("webix_invalid");
                  node.classList.remove("webix_invalid_cell");

                  // verify file type
                  const acceptableTypes = typesList;
                  if (acceptableTypes && acceptableTypes != "") {
                     const type = item.type.toLowerCase();
                     if (acceptableTypes.indexOf(type) == -1) {
                        webix.message(
                           L("Only [{0}] files are supported", [
                              acceptableTypes.join(", "),
                           ])
                        );
                        return false;
                     }
                  }

                  //verify file size
                  //Convert to MegaBytes
                  if (maximumSize > 0) {
                     const acceptableSizes = maximumSize * 1000000;
                     if (item.size > acceptableSizes) {
                        webix.message(
                           L("Maximum file size is {0}MB", [maximumSize])
                        );
                        return false;
                     }
                  }

                  // start progress indicator
                  webixContainer.showProgress({
                     type: "icon",
                     delay: 2000,
                  });
               },

               // when upload is complete:
               onFileUpload: async (item, response) => {
                  webixContainer.hideProgress();
                  // this.showFile(idBase, response.data.uuid);

                  const values = {};
                  values[this.columnName] = {};
                  values[this.columnName].uuid = response.data.uuid;
                  values[this.columnName].filename = item.name;

                  // update just this value on our current object.model
                  if (row.id) {
                     try {
                        await this.object.model().update(row.id, values);

                        // update the client side data object as well so other data changes won't cause this save to be reverted
                        if ($$(node) && $$(node).updateItem)
                           $$(node).updateItem(row.id, values);
                     } catch (err) {
                        node.classList.add("webix_invalid");
                        node.classList.add("webix_invalid_cell");

                        this.AB.notify.developer(err, {
                           context:
                              "ABFieldFile.onFileUpload(): Error updating our entry.",
                           row: row,
                           values: values,
                        });
                     }
                  }

                  // update value in the form component
                  this.setValue($$(node), values);
               },

               // if an error was returned
               onFileUploadError: (item, response) => {
                  this.AB.notify.developer(new Error("Error loading file"), {
                     message: "Error loading file",
                     response,
                  });
                  webixContainer.hideProgress();
               },
            },
         });
         uploader.addDropZone(webixContainer.$view);

         // store upload id into html element (it will be used in .customEdit)
         node.dataset["uploaderId"] = uploader.config.id;

         // open file upload dialog when's click
         node.addEventListener("click", (e) => {
            if (e.target.className.indexOf("delete-image") > -1) {
               this.deleteFile = true;
            }
         });
      }
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node) {
      var L = this.AB.Label();
      if (this.deleteFile == true) {
         // remove the property because it is only needed to prevent the file dialog from showing
         delete this.deleteFile;

         // Ask the user if they really want to delete the photo
         webix.confirm({
            title: "",
            message: L("Are you sure you want to remove this file?"),
            callback: async (result) => {
               const confirmDelete = result ? 1 : 0;
               if (confirmDelete) {
                  // update just this value on our current object.model
                  const values = {};
                  values[this.columnName] = "";

                  if (row.id) {
                     try {
                        await this.object.model().update(row.id, values);

                        // update the client side data object as well so other data changes won't cause this save to be reverted
                        if ($$(node) && $$(node).updateItem)
                           $$(node).updateItem(row.id, values);
                     } catch (err) {
                        node.classList.add("webix_invalid");
                        node.classList.add("webix_invalid_cell");

                        this.AB.notify.developer(err, {
                           message: "Error updating our entry.",
                           row: row,
                           values: values,
                        });
                     }
                  }
                  // update value in the form component
                  else {
                     this.setValue($$(node), values);
                  }
               }
            },
         });
      } else {
         const rowData = this.dataValue(row);
         if (!rowData || !rowData.uuid) {
            const uploaderId = node.dataset["uploaderId"],
               uploader = $$(uploaderId);

            if (uploader && uploader.fileDialog)
               uploader.fileDialog({ rowid: row.id });
         }
      }

      return false;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldcustom");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailcustom",
         };
      };

      return detailComponentSetting;
   }

   //File Template

   fileTemplate(obj, editable) {
      let L = this.AB.Label();
      let iconDisplay = "";
      let fileDisplay = "display:none;";
      let fileURL = "";

      let value = "";
      let name = "";

      const rowData = this.dataValue(obj);
      if (rowData) {
         value = rowData.uuid;
         name = rowData.filename;
      }

      if (value && name) {
         iconDisplay = "display:none;";
         fileDisplay = "";
         fileURL = "/file/" + value;
      }

      const html = [
         `<div class="file-data-field-icon" style="text-align: center; height: inherit; display: table-cell; vertical-align: middle; border: 2px dotted #CCC; background: #FFF; border-radius: 10px; font-size: 11px; line-height: 13px; padding: 0 10px; ${iconDisplay}"><i class="fa fa-file fa-2x" style="opacity: 0.6; font-size: 32px; margin-top: 3px; margin-bottom: 5px;"></i>${
            editable ? `<br/>${L("Drag and drop or click here")}` : ""
         }</div>`,
         `<div class="file-data-field-name" style=" width:100%; height:100%; position:relative; "><a target="_blank" href="${fileURL}">${
            name || ""
         }</a>${
            editable
               ? `<a style="${fileDisplay}" class="ab-delete-photo" href="javascript:void(0);"><i class="fa fa-times delete-image"></i></a>`
               : ""
         }</div>`,
      ].join("");

      return html;
   }

   getValue(item, rowData) {
      const file = item.$view.querySelector(".file-data-field-name");
      const fileLink = file.querySelector("a");

      return {
         uuid: file.getAttribute("file-uuid"),
         filename: fileLink.innerHTML,
      };
   }

   setValue(item, rowData) {
      if (!item) return;

      const domNode = item.$view;
      if (!domNode) return;

      let val = null;
      if (rowData) {
         val = this.dataValue(rowData);

         // if (val == null) {
         // 	// assume they just sent us a single value
         // 	val = rowData;
         // }
      }

      const fileicon = domNode.querySelector(".file-data-field-icon");
      if (fileicon) fileicon.style.display = val && val.uuid ? "none" : "block";

      const file = domNode.querySelector(".file-data-field-name");
      if (file) {
         const fileDeleteIcon = file.querySelector(".ab-delete-photo");
         if (fileDeleteIcon)
            fileDeleteIcon.style.display = val && val.uuid ? "block" : "none";

         file.style.display = val && val.uuid ? "block" : "none";
         if (val && val.uuid) file.setAttribute("file-uuid", val.uuid);
         else file.removeAttribute("file-uuid");

         const fileLink = file.querySelector("a");
         const fileURL = "/file/" + (val ? val.uuid : "");
         fileLink.href = fileURL;
         fileLink.innerHTML = val ? val.filename : "";
      }
   }

   /**
    * @method urlUpload()
    * return the url for uploading a file.
    * When used in a webix widget, the response is different than our normal
    * API, so we can pass in a param to indicate a response compatible with
    * webix.
    * @param {bool} isWebix
    *        Is this url being used by a webix component?
    * @return {string}
    */
   urlUpload(isWebix = true) {
      return `/file/upload/${this.object.id}/${this.id}/${isWebix ? "1" : "0"}`;
   }

   /**
    * @method urlFile
    * return the url to use to reference the file by it's id.
    * @param {string} id uuid reference of this file.
    * @return {string}
    */
   urlFile(id) {
      return `/file/${id}`;
   }
}


/***/ }),

/***/ 54953:
/*!*****************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldFormula.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldFormula)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldFormulaCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldFormulaCore */ 25174);


class ABFieldFormula extends _core_dataFields_ABFieldFormulaCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldFormula
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         if (rowData.$group) return rowData[this.columnName];

         return this.format(rowData);
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // not support in the form widget
      return super.formComponent("fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
}


/***/ }),

/***/ 34688:
/*!***************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldImage.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldImage)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldImageCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldImageCore */ 33693);


class ABFieldImage extends _core_dataFields_ABFieldImageCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   /**
    * @function destroy
    * On a destroy operation, ask if the user wants to keep the related images.
    */
   async destroy() {
      var L = this.AB.Label();
      return new Promise((resolve, reject) => {
         // verify we have been .save()d before:
         if (this.id) {
            // Ask the user what to do about the existing images:
            webix.confirm({
               title: L("Keep Images?"),
               message: L("Do you want to keep the images referenced by {0}?", [
                  this.label,
               ]),
               callback: async (result) => {
                  // update this setting so the server can respond correctly in
                  // ABFieldImage.migrateDrop()
                  this.settings.removeExistingData = result ? 0 : 1;

                  try {
                     await this.save();

                     // TODO: a reminder that you still got alot on the server to do!
                     webix.alert({
                        title: "!! TODO !!",
                        text: "ABFieldImage.destroy(): Tell a Developer to actually pay attention to this!",
                     });

                     await super.destroy();

                     resolve();
                  } catch (err) {
                     reject(err);
                  }
               },
            });
         } else {
            resolve(); // nothing to do really
         }
      });
   }

   ///
   /// Working with Actual Object Values:
   ///

   idCustomContainer(obj, formId) {
      // if formId is passed the field is in a form view not a grid and
      // we won't have the obj and each time this
      // field is in a form it will conflict with the last one rendered
      if (formId) {
         return `${this.columnName.replace(/ /g, "_")}-${formId}-image`;
      } else {
         return `${this.columnName.replace(/ /g, "_")}-${obj.id}-image`;
      }
   }

   // return the grid column header definition for this instance of ABFieldImage
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);
      const field = this;

      config.editor = false; // 'text';  // '[edit_type]'   for your unique situation
      // config.sort   = 'string' // '[sort_type]'   for your unique situation

      let containerHeight = "100%";
      let imageHeight = "100%";
      let width = "100%";
      let imageSrcHeight = "100%";
      if (field.settings.useWidth) {
         config.width = field.settings.imageWidth || 100;
         const heightVal =
            field.settings.useHeight && field.settings.imageHeight
               ? field.settings.imageHeight + 20
               : 80;
         containerHeight = `${heightVal}px`;
         width = `${field.settings.imageWidth || 100}px`;
         imageHeight =
            field.settings.useHeight && field.settings.imageHeight
               ? field.settings.imageHeight
               : 80;
         imageHeight = `${imageHeight}px`;
         imageSrcHeight =
            field.settings.useHeight && field.settings.imageHeight
               ? field.settings.imageHeight
               : 60;
         imageSrcHeight = `${imageSrcHeight}px`;
      } else if (options.width) {
         config.width = options.width || 100;
         width = `${options.width || 100}px`;
         imageHeight = options.width;
         imageHeight = `${imageHeight}px`;
         imageSrcHeight = options.width;
         imageSrcHeight = `${imageSrcHeight}px`;
      }
      if (
         field.settings.useHeight &&
         field.settings.imageHeight &&
         field.settings.imageHeight != "NaN"
      ) {
         config.height = field.settings.imageHeight || 0;
         containerHeight = parseInt(config.height) + 20;
         containerHeight = `${containerHeight}px`;
         imageHeight = parseInt(config.height);
         imageHeight = `${imageHeight}px`;
         imageSrcHeight = parseInt(config.height);
         imageSrcHeight = `${imageSrcHeight}px`;
      }

      const editable = options.editable;

      // populate our default template:
      // debugger;
      config.template = (obj) => {
         if (obj.$group) return obj[this.columnName];

         const widthStyle = `width: ${width}; height: ${containerHeight}`;

         const imageStyle = `width: ${width}; height: ${imageHeight}`;

         const imgDiv = [
            `<div class="ab-image-data-field" style="float: left; ${widthStyle}">`,
            `<div class="webix_view ab-image-holder" style="${imageStyle}">`,
            '<div class="webix_template">',
            this.imageTemplate(obj, {
               editable: editable,
               height: imageSrcHeight,
               width: width,
            }),
            "</div>",
            "</div>",
            "</div>",
         ].join("");

         return imgDiv;
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    * @param {object} options - {
    * 		editable {Bool}   where or not this field is currently editable
    * 		formId {string}   the id of the presenting form if any
    * }
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }

      options = options || {};
      var L = this.AB.Label();

      // safety check:
      // webix seems to crash if you specify a .container that doesn't exists:
      // Note: when the template is first created, we don't have App.unique()
      const parentContainer = node.querySelector(".ab-image-holder");
      if (parentContainer) {
         parentContainer.innerHTML = "";
         // parentContainer.id = idBase;	// change it to the unique one.

         let imgHeight = 0;
         if (this.settings.useHeight) {
            imgHeight = parseInt(this.settings.imageHeight) || imgHeight;
         }

         let imgWidth = 0;
         if (this.settings.useWidth) {
            imgWidth = parseInt(this.settings.imageWidth) || imgWidth;
         }

         if (options.height) imgHeight = options.height;

         if (options.width) imgWidth = options.width;
         //// TODO: actually pay attention to the height and width when
         //// displaying the images.

         // use a webix component for displaying the content.
         // do this so I can use the progress spinner
         const webixContainer = webix.ui({
            view: "template",
            css: "ab-image-holder",
            // id: ids.container,
            container: parentContainer,

            template: this.imageTemplate(row, {
               editable: options.editable,
               height: imgHeight ? imgHeight + "px" : 0,
               width: imgWidth ? imgWidth + "px" : 0,
            }),

            borderless: true,
            height: imgHeight,
            width: imgWidth,
         });
         webix.extend(webixContainer, webix.ProgressBar);

         ////
         //// Prepare the Uploader
         ////

         if (!options.editable) {
            const domNode = parentContainer.querySelector(".delete-image");
            if (domNode) domNode.style.display = "none";
            return;
         }

         const url = this.urlUpload();

         const uploader = webix.ui({
            view: "uploader",
            // id:ids.uploader,
            apiOnly: true,
            upload: url,
            inputName: "file",
            multiple: false,
            // formData:{
            // 	appKey:application.name,
            // 	permission:actionKey,
            // 	isWebix:true,
            // 	imageParam:'upload'
            // },
            on: {
               // when a file is added to the uploader
               onBeforeFileAdd: function (item) {
                  node.classList.remove("webix_invalid");
                  node.classList.remove("webix_invalid_cell");

                  // verify file type
                  const acceptableTypes = [
                     "jpg",
                     "jpeg",
                     "bmp",
                     "png",
                     "gif",
                     "webp",
                  ];
                  const type = item.type.toLowerCase();
                  if (acceptableTypes.indexOf(type) == -1) {
                     webix.message(
                        L("Only [{0}] images are supported", [
                           acceptableTypes.join(", "),
                        ])
                     );
                     return false;
                  }

                  // start progress indicator
                  webixContainer.showProgress({
                     type: "icon",
                     delay: 2000,
                  });
               },

               // when upload is complete:
               onFileUpload: async (item, response) => {
                  webixContainer.hideProgress();
                  this.showImage(response.data.uuid, node);

                  // TODO: delete previous image from our OPsPortal service?

                  const values = {};
                  values[this.columnName] = response.data.uuid;

                  // update just this value on our current object.model
                  if (row.id) {
                     try {
                        await this.object.model().update(row.id, values);

                        // update the client side data object as well so other data changes won't cause this save to be reverted
                        if (
                           $$(node) &&
                           $$(node).getItem &&
                           $$(node).getItem(row.id)
                        ) {
                           $$(node).updateItem(row.id, values);
                        } else {
                           // if you scroll the table the connection to the datatable is lost so we need to find it again
                           const dataTable =
                              document.querySelector(".webix_dtable");
                           if ($$(dataTable) && $$(dataTable).getItem(row.id))
                              $$(dataTable).updateItem(row.id, values);
                        }
                     } catch (err) {
                        node.classList.add("webix_invalid");
                        node.classList.add("webix_invalid_cell");

                        this.AB.notify.developer(err, {
                           context:
                              "ABFieldImage.onFileUpload(): model.update(): error updating our entry",
                           field: this,
                           row,
                           values,
                        });
                     }
                  }

                  // update value in the form component
                  this.setValue($$(node), values);
               },

               // if an error was returned
               onFileUploadError: (item, response) => {
                  this.AB.notify.developer(new Error("Error uploading image"), {
                     context: "ABFieldImage. uploader. onFileUploadError():",
                     field: this,
                     response,
                  });
                  webixContainer.hideProgress();
               },
            },
         });
         uploader.addDropZone(webixContainer.$view);

         // store upload id into html element (it will be used in .customEdit)
         node.dataset["uploaderId"] = uploader.config.id;

         // if we are working in a datagrid we need to add a click event to
         // check if the user is clicking on the delete button
         if (node.className == "webix_cell") {
            node.addEventListener("click", (e) => {
               if (e.target.className.indexOf("delete-image") > -1) {
                  this.deleteImage = true;
               }
            });
         }
      }
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node, id, evt) {
      var L = this.AB.Label();
      if (
         (evt && evt.target.className.indexOf("delete-image") > -1) ||
         this.deleteImage
      ) {
         delete this.deleteImage;
         if (!row.removeDefaultImage) {
            row.removeDefaultImage = [];
         }
         row.removeDefaultImage[this.columnName] = true;

         // Ask the user if they really want to delete the photo
         webix.confirm({
            title: L("Are you sure you want to remove this image?"),
            callback: async (result) => {
               const confirmDelete = result ? 1 : 0;
               if (confirmDelete) {
                  // update just this value on our current object.model
                  const values = {};
                  values[this.columnName] = ""; // removing the reference to the image here

                  try {
                     await this.object.model().update(row.id, values);

                     // update the client side data object as well so other data changes won't cause this save to be reverted
                     if ($$(node) && $$(node).updateItem)
                        $$(node).updateItem(row.id, values);

                     // update value in the form component
                     this.setValue($$(node), values);
                  } catch (err) {
                     node.classList.add("webix_invalid");
                     node.classList.add("webix_invalid_cell");

                     this.AB.notify.developer(err, {
                        context:
                           "ABFieldImage: customEdit(): Error updating our entry",
                        field: this,
                        row: row,
                        values: values,
                     });
                  }
               }
            },
         });
      } else {
         const uploaderId = node.dataset["uploaderId"],
            uploader = $$(uploaderId);

         if (uploader && uploader.fileDialog)
            uploader.fileDialog({ rowid: row.id });
      }

      return false;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldcustom");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailimage",
         };
      };

      return detailComponentSetting;
   }

   imageTemplate(obj, options) {
      options = options || {};
      options.height = options.height || "100%";
      options.width = options.width || "100%";
      var L = this.AB.Label();

      // deault view is icon:
      let iconDisplay = "";
      let imageDisplay = "display:none;";
      let imageURL = "";

      let value = "";
      let isRemoveDefaultImage = false;
      if (obj[this.columnName]) {
         value = obj[this.columnName];
      }
      if (obj.removeDefaultImage) {
         if (obj.removeDefaultImage[this.columnName]) {
            isRemoveDefaultImage = obj.removeDefaultImage[this.columnName];
         }
      }

      if (value) {
         iconDisplay = "display:none;";
         imageDisplay = "";
         imageURL = `background-image:url('${this.urlImage(value)}');`;
      } else {
         if (this.settings.useDefaultImage && !isRemoveDefaultImage) {
            iconDisplay = "display:none;";
            imageDisplay = "";
            imageURL = `background-image:url('${this.urlImage(
               this.settings.defaultImageUrl
            )}');`;
         }
      }

      let html = [
         `<div class="image-data-field-icon" style="${iconDisplay}">#drag#</div>` +
            `<div class="image-data-field-image" style="${imageDisplay} width:${options.width}; height:${options.height}; ${imageURL}">#remove#</div>`,
      ].join("");

      html = html.replace(
         "#drag#",
         options.editable
            ? `<div>${L("Drag and drop or click here")}</div>`
            : ""
      );
      html = html.replace(
         "#remove#",
         options.editable
            ? `<a style="${imageDisplay}" class="ab-delete-photo" href="javascript:void(0);"><i class="fa fa-times delete-image"></i></a>`
            : ""
      );

      return html;
   }

   showImage(uuid, node) {
      const parentContainer = node.querySelector(".ab-image-holder");
      if (parentContainer) {
         parentContainer.querySelector(".image-data-field-icon").style.display =
            "none";
         const image = parentContainer.querySelector(".image-data-field-image");
         image.style.display = "";
         image.style.backgroundImage = `url('${this.urlImage(uuid)}')`;
         image.setAttribute("image-uuid", uuid);
      }
   }

   getValue(item, rowData) {
      const image = item.$view.querySelector(".image-data-field-image");
      return image.getAttribute("image-uuid");
   }

   setValue(item, rowData) {
      if (!item) return;

      const domNode = item.$view;
      if (!domNode) return;

      let val = null;
      if (rowData) {
         val = this.dataValue(rowData);

         // if (val == null) {
         // 	// assume they just sent us a single value
         // 	val = rowData;
         // }
      }

      const imageIcon = domNode.querySelector(".image-data-field-icon");
      if (imageIcon) imageIcon.style.display = val ? "none" : "";

      const image = domNode.querySelector(".image-data-field-image");
      if (image) {
         const imageDeleteIcon = image.querySelector(".ab-delete-photo");
         if (imageDeleteIcon)
            imageDeleteIcon.style.display = val ? "block" : "none";

         image.style.display = val ? "block" : "none";

         if (val) {
            image.style.backgroundImage = `url('${this.urlImage(val)}')`;
            image.setAttribute("image-uuid", val);
         } else {
            image.removeAttribute("image-uuid");
         }
      }
   }

   /**
    * @method toBase64
    *
    * @param {Object} rowData
    *
    * @return {Promise} - {
    * 		data: string,
    * 		width: number,
    * 		height: number
    * }
    */
   toBase64(rowData) {
      return new Promise((resolve, reject) => {
         if (!rowData[this.columnName]) return resolve(null);

         const img = new Image();
         img.crossOrigin = "Anonymous";
         img.onerror = function (err) {
            reject(err);
         };
         img.onload = function () {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            const dataURL = canvas.toDataURL();
            const imageData = {
               data: dataURL,
               width: img.width,
               height: img.height,
            };
            resolve(imageData);
         };

         img.src = this.urlImage(rowData[this.columnName]);
      });
   }

   /**
    * @method urlImage()
    * return the url to use to reference the image by it's id.
    * @param {string} id
    *        the file.uuid reference of this image.
    * @return {string}
    */
   urlImage(id) {
      return `/file/${id}`;
   }

   /**
    * @method urlUpload()
    * return the url for uploading a file.
    * When used in a webix widget, the response is different than our normal
    * API, so we can pass in a param to indicate a response compatible with
    * webix.
    * @param {bool} isWebix
    *        Is this url being used by a webix component?
    * @return {string}
    */
   urlUpload(isWebix = false) {
      return `/file/upload/${this.object.id}/${this.id}/${isWebix ? "1" : "0"}`;
   }
}


/***/ }),

/***/ 7101:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldJson.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldJson)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldJsonCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldJsonCore */ 23158);


class ABFieldJson extends _core_dataFields_ABFieldJsonCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldJson
   columnHeader(options) {
      const config = super.columnHeader(options);

      // config.editor = null; // read only for now
      config.editor = "text";
      config.css = "textCell";

      // when called by ABViewFormCustom, will need a .template() fn.
      // currently we don't need to return anything so ...
      config.template = () => "";

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // read-only for now
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "json",
            settings: {
               type: "string",
            },
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   setValue(item, rowData) {
      super.setValue(item, rowData, "");
      item.config.value = rowData[this.columnName];
   }
}


/***/ }),

/***/ 23122:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldList.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldList)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldListCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldListCore */ 75124);


class ABFieldList extends _core_dataFields_ABFieldListCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object);

      // this._Selectivity = new ABFieldSelectivity(values, object);
   }

   ///
   /// Instance Methods
   ///

   save() {
      return super.save().then(() => {
         // Now we want to clear out any entries that had values == to item removed from our list:
         if (this.pendingDeletions.length) {
            const model = this.object.model();

            if (this.settings.isMultiple == true) {
               // find all the entries that have one of the deleted values:
               // use Promise to prevent issues with data being loaded before it is deleted on client side
               return new Promise((resolve, reject) => {
                  let numDone = 0;
                  let numToDo = 0;

                  model
                     .findAll({})
                     .then((list) => {
                        list = list.data || list;

                        // for each list item
                        list.forEach((item) => {
                           if (Array.isArray(item[this.columnName])) {
                              // get fields not in pendingDeletions
                              let remainingFields = item[
                                 this.columnName
                              ].filter((i) => {
                                 return (
                                    this.pendingDeletions.indexOf(i.id) == -1
                                 );
                              });

                              if (
                                 remainingFields.length !=
                                 item[this.columnName].length
                              ) {
                                 numToDo++;

                                 // update value to new field list
                                 if (remainingFields.length == 0) {
                                    remainingFields = "";
                                 }
                                 const value = {};
                                 value[this.columnName] = remainingFields;
                                 model.update(item.id, value).then(() => {
                                    // if ($$(node) && $$(node).updateItem)
                                    //    $$(node).updateItem(value.id, value);
                                    numDone++;
                                    if (numDone >= numToDo) {
                                       resolve();
                                    }
                                 });
                              }
                           }
                        });
                        if (numToDo == 0) {
                           resolve();
                        }
                     })
                     .catch(reject);
               });
            } else {
               // find all the entries that have one of the deleted values:
               const where = {};
               where[this.columnName] = this.pendingDeletions;
               return new Promise((resolve, reject) => {
                  let numDone = 0;

                  model
                     .findAll(where)
                     .then((list) => {
                        // make sure we just work with the { data:[] } that was returned
                        list = list.data || list;

                        // for each one, set the value to ''
                        // NOTE: jQuery ajax routines filter out null values, so we can't
                        // set them to null. :(
                        // const numDone = 0;
                        const value = {};
                        value[this.columnName] = "";

                        list.forEach((item) => {
                           model.update(item.id, value).then(() => {
                              numDone++;
                              if (numDone >= list.length) {
                                 resolve();
                              }
                           });
                        });
                        if (list.length == 0) {
                           resolve();
                        }
                     })
                     .catch(reject);
               });
            }
         }
      });
   }

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldList
   columnHeader(options) {
      options = options || {};
      var L = this.AB.Label();

      const config = super.columnHeader(options);
      const field = this;
      const App = field.AB._App;

      var formClass = "";
      var placeHolder = "";
      if (options.editable) {
         formClass = " form-entry";
         placeHolder = `<span style='color: #CCC; padding: 0 5px;'>${L(
            "Select item"
         )}</span>`;
      }
      var isRemovable = options.editable && !this.settings.required;

      config.editFormat = (value) => {
         return this.editFormat(value);
      };
      config.editParse = (value) => {
         return this.editParse(value);
      };

      config.template = (rowData) => {
         let selectedData = rowData[this.columnName];
         if (selectedData == null) return "";
         if (this.settings.isMultiple) {
            selectedData = _getSelectedOptions(this, rowData);
         }
         var values = [];
         values.push('<div class="badgeContainer">');
         let hasCustomColor = "";
         let optionHex = "";
         if (
            selectedData &&
            Array.isArray(selectedData) &&
            selectedData.length
         ) {
            selectedData.forEach((val) => {
               if (this.settings.hasColors && val.hex) {
                  hasCustomColor = "hascustomcolor";
                  optionHex = `background: ${val.hex};`;
               }
               if (val.text) {
                  values.push(
                     `<div style="${optionHex}" class='webix_multicombo_value ${hasCustomColor}'><span>${val.text}</span><!-- span data-uuid="${val.id}" class="webix_multicombo_delete" role="button" aria-label="Remove item"></span --></div>`
                  );
               }
            });
            if (selectedData.length > 1) {
               values.push(
                  `<span class="webix_badge selectivityBadge">${selectedData.length}</span>`
               );
            }
         } else if (selectedData) {
            let selectedObj = selectedData;
            if (typeof selectedData == "string") {
               selectedObj = this.getItemFromVal(selectedData);
            }
            if (!selectedObj) return "";
            if (this.settings.hasColors && selectedObj.hex) {
               hasCustomColor = "hascustomcolor";
               optionHex = `background: ${selectedObj.hex};`;
            }
            if (selectedObj.text) {
               let clear = "";
               if (options.editable && !this.settings.required) {
                  clear = `<span class="webix_multicombo_delete clear-combo-value" role="button" aria-label="Remove item"></span>`;
               }
               values.push(
                  `<div style="${optionHex}" class='webix_multicombo_value ${hasCustomColor}'>${clear}<span class="ellip">${selectedObj.text}</span></div>`
               );
            }
         } else {
            return "";
         }
         values.push("</div>");
         return values.join("");
      };
      config.editor = this.settings.isMultiple ? "multiselect" : "combo";
      config.suggest = {
         button: true,
         data: this.settings.options.map(function (opt) {
            return {
               id: opt.id,
               value: opt.text,
               hex: opt.hex,
            };
         }),
      };
      if (this.settings.isMultiple) {
         config.suggest.view = "checksuggest";
      }

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *             unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }

      options = options || {};

      if (!node.querySelector) return;

      var clearButton = node.querySelector(
         ".selectivity-single-selected-item-remove"
      );
      if (clearButton) {
         clearButton.addEventListener("click", (e) => {
            e.stopPropagation();
            var values = {};
            values[this.columnName] = "";
            this.object
               .model()
               .update(row.id, values)
               .then(() => {
                  // update the client side data object as well so other data changes won't cause this save to be reverted
                  $$(node)?.updateItem?.(row.id, values);
               })
               .catch((err) => {
                  node.classList.add("webix_invalid");
                  node.classList.add("webix_invalid_cell");

                  this.AB.notify.developer(err, {
                     message: "Error updating our entry.",
                     row: row,
                     values: "",
                     field: this.toObj(),
                  });
               });
         });
      }
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *             unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   // customEdit(row, App, node) {
   //    return super.customEdit(row, App, node);
   // }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: this.settings.isMultiple ? "selectmultiple" : "selectsingle",
            settings: {
               options: this.settings.options.map(function (opt) {
                  return {
                     id: opt.id,
                     value: opt.text,
                     hex: opt.hex,
                  };
               }),
            },
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: this.settings.isMultiple ? "detailtext" : "detailtext",
         };
      };

      return detailComponentSetting;
   }

   editFormat(value) {
      if (!value) return "";
      let vals = [];
      if (Array.isArray(value)) {
         value.forEach((val) => {
            if (typeof val == "object") {
               vals.push(val.id);
            } else {
               let itemObj = this.getItemFromVal(val);
               vals.push(itemObj.id);
            }
         });
      } else {
         if (typeof value == "object") {
            vals.push(value.id);
         } else {
            let itemObj = this.getItemFromVal(value);
            if (itemObj && itemObj.id) {
               vals.push(itemObj.id);
            }
         }
      }
      return vals.join();
   }

   editParse(value) {
      if (this.settings.isMultiple) {
         let returnVals = [];
         let vals = value.split(",");
         vals.forEach((val) => {
            returnVals.push(this.getItemFromVal(val));
         });
         return returnVals;
      } else {
         return value;
      }
   }

   getItemFromVal(val) {
      let item;
      let options = this.options();
      if (options.length > 1) {
         options.forEach((option) => {
            if (option.id == val) {
               item = option;
               return false;
            }
         });
         return item;
      } else {
         return "";
      }
   }

   getValue(item, rowData) {
      return this.editParse(item.getValue());
   }

   getSelectedOptions(field, rowData = {}) {
      let result = [];
      if (rowData[this.columnName] != null) {
         result = rowData[this.columnName];
      } else if (rowData) {
         if (Array.isArray(rowData)) {
            result = rowData;
         } else {
            result.push(rowData);
         }
      }
      if (result.length) {
         if (typeof result == "string") result = JSON.parse(result);

         // Pull text with current language
         if (this.settings) {
            result = (this.settings.options || []).filter((opt) => {
               return (
                  (result || []).filter((v) => (opt.id || opt) == (v.id || v))
                     .length > 0
               );
            });
         }
      }

      return result;
   }

   setValue(item, rowData) {
      if (!item) return;

      if (this.settings.isMultiple) {
         // do we need anything here?
      } else {
         super.setValue(item, rowData);
      }
   }
}

// == Private methods ==
function _getSelectedOptions(field, rowData = {}) {
   let result = [];
   if (rowData[field.columnName] != null) {
      result = rowData[field.columnName];

      if (typeof result == "string") result = JSON.parse(result);

      // Pull text with current language
      if (field.settings) {
         result = (field.settings.options || []).filter((opt) => {
            return (
               (result || []).filter((v) => (opt.id || opt) == (v.id || v))
                  .length > 0
            );
         });
      }
   }

   return result;
}


/***/ }),

/***/ 33482:
/*!******************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldLongText.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldLongText)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldLongTextCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldLongTextCore */ 78557);


class ABFieldLongText extends _core_dataFields_ABFieldLongTextCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      super(values, object);

      /*
		{
			settings: {
				default: 'string',
				supportMultilingual: 1/0
			}
		}
		*/
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldLongText
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "text"; // '[edit_type]'   for your unique situation
      // config.sort = 'string' // '[sort_type]'   for your unique situation
      config.template = (obj, common, value, col, ind) => {
         return (value || "").toString().replace(/[<]/g, "&lt;");
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "textbox",
            settings: {
               type: "multiple",
            },
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   /**
    * @method setValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    * @return {Object}
    */
   setValue(item, rowData) {
      super.setValue(item, rowData, "");
   }
}


/***/ }),

/***/ 66242:
/*!****************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldNumber.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldNumber)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldNumberCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldNumberCore */ 76410);


let INIT_EDITOR = false;
// {bool} INIT_EDITOR
// Transition code between previous Framework and current.
// we now need to wait until webix is declared or accessible globally.

class ABFieldNumber extends _core_dataFields_ABFieldNumberCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object) {
      if (!INIT_EDITOR) {
         // NOTE: if you need a unique [edit_type] by your returned config.editor above:
         // webix.editors.number = webix.extend(
         //    {
         //       // TODO : Validate number only
         //    },
         //    webix.editors.text
         // );
         INIT_EDITOR = true;
      }
      super(values, object);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   // return the grid column header definition for this instance of ABFieldNumber
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "number"; // [edit_type] simple inline editing.

      config.format = (d) => {
         const rowData = {};
         rowData[this.columnName] = d;

         return this.format(rowData);
      };

      return config;
   }

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("numberbox");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
}


/***/ }),

/***/ 55522:
/*!*********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldSelectivity.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldSelectivity)
/* harmony export */ });
/* harmony import */ var _ABField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABField */ 38817);
/*
 * ABFieldSelectivity
 *
 * An ABFieldSelectivity defines a single unique Field/Column in a ABObject.
 *
 */



const defaultSettings = {
   allowClear: true,
   removeOnly: false,
   readOnly: false,
   showDropdown: true,
   placeholder: "",
   multiple: false,
};

const ABFieldSelectivityDefaults = {
   key: "selectivity",
};

class ABFieldSelectivity extends _ABField__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, object, fieldDefaults = ABFieldSelectivityDefaults) {
      super(values, object, fieldDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return {
         key: "selectivity",
         icon: "bars",
         menuName: "",
         description: "",
      };
   }

   selectivityRender(domNode, settings, App, row) {
      if (domNode == null) return;

      const cypress = settings.dataCy || "";
      domNode.setAttribute("data-cy", cypress);

      // setting up our specific settings:
      settings = settings || {};
      for (const dv in defaultSettings) {
         if (settings[dv] === null) {
            settings[dv] = null;
         } else {
            settings[dv] = settings[dv] || defaultSettings[dv];
         }
      }

      if (
         settings.multiple &&
         settings.items &&
         settings.data &&
         settings.data.length
      ) {
         settings.data.forEach(function (d) {
            settings.items.map(function (i) {
               if (i.id == d.id) d.hex = i.hex;
            });
         });
         settings["data"] = this.prepareData(
            settings["data"],
            settings.multiple
         );
      } else if (settings["data"] == null || settings["data"] == "") {
         settings["data"] = this.prepareData([], settings.multiple);
      } else {
         settings["data"] = this.prepareData(
            settings["data"],
            settings.multiple
         );
      }

      // store the field id so we can look it up on click events later
      settings["field"] = this.id;

      // Prevent render selectivity duplicate
      if (domNode.selectivity != null) {
         // Refresh selectivity settings
         domNode.selectivity.setOptions(settings);

         return;
      }

      settings.element = domNode;

      // Render selectivity
      let selectivityInput;
      if (settings.multiple) {
         if (settings.isUsers) {
            settings.templates = {
               multipleSelectedItem: function (options) {
                  return `<span class="selectivity-multiple-selected-item ${
                     options.highlighted ? " highlighted" : ""
                  }"
								style="background-color: #eee !important; color: #666 !important; box-shadow: inset 0px 1px 1px #333;"
								data-item-id="${options.uuid}" data-field-id="${settings.field}">
								<i class="fa fa-user" style="color: #666; opacity: 0.6;"></i> 
                        ${
                           settings.additionalText
                              ? settings.additionalText(options)
                              : ""
                        }
								${!settings.isLabelHidden ? options.text : ""}
								${
                           options.removable
                              ? ` <a class="selectivity-multiple-selected-item-remove" style="color: #333;"><i class="fa fa-remove"></i></a>`
                              : ""
                        }
							</span>`;
               },
            };
         } else {
            settings.templates = {
               multipleSelectedItem: function (options) {
                  return `<span class="selectivity-multiple-selected-item ${
                     options.highlighted ? " highlighted" : ""
                  }"
								style="background-color: ${options.hex} !important;"
								data-item-id="${options.uuid}" data-field-id="${settings.field}">
                        ${
                           settings.editPage
                              ? ` <a class="selectivity-multiple-selected-item-edit"><i class="fa fa-edit"></i></a>`
                              : ""
                        }
                        ${
                           settings.additionalText
                              ? settings.additionalText(options)
                              : ""
                        }
                        ${!settings.isLabelHidden ? options.text : ""}
                        ${
                           options.removable
                              ? ` <a class="selectivity-multiple-selected-item-remove"><i class="fa fa-remove"></i></a>`
                              : ""
                        }
							</span>`;
               },
            };
         }
         selectivityInput = new Selectivity.Inputs.Multiple(settings);

         domNode.selectivity = selectivityInput;
         this.selectivitySetBadge(domNode, App, row);
      } else {
         settings.templates = {
            singleSelectedItem: function (options) {
               return `<span class="selectivity-single-selected-item" data-item-id="${
                  options.uuid
               }" data-field-id="${settings.field}">
							${
                        settings.editPage
                           ? '<a class="selectivity-single-selected-item-edit"><i class="fa fa-edit"></i></a>'
                           : ""
                     }
                     ${
                        settings.additionalText
                           ? settings.additionalText(options)
                           : ""
                     }
                     ${!settings.isLabelHidden ? options.text : ""}
                     ${
                        options.removable
                           ? '<a class="selectivity-single-selected-item-remove"><i class="fa fa-remove"></i></a>'
                           : ""
                     }
						</span>`;
            },
         };

         selectivityInput = new Selectivity.Inputs.Single(settings);
         domNode.selectivity = selectivityInput;
      }

      if (settings.editPage) {
         const trigerEditPageEvent = () => {
            const instance = this;
            const editMenus = document.querySelectorAll(
               ".selectivity-single-selected-item-edit, .selectivity-multiple-selected-item-edit"
            );
            for (let i = 0; i < editMenus.length; i++) {
               const eMenu = editMenus[i];
               if (eMenu && !eMenu.__hasClickEvent) {
                  eMenu.addEventListener(
                     "click",
                     function (e) {
                        e.stopPropagation();
                        e.preventDefault();

                        const parentElm = this.parentElement;
                        if (!parentElm) return;

                        const rowId = parentElm.getAttribute("data-item-id");
                        if (!rowId) return;

                        const fieldId = parentElm.getAttribute("data-field-id");
                        if (!fieldId) return;

                        const thisField = instance.object.fieldByID(fieldId);
                        if (!thisField) return;

                        thisField.emit("editPage", rowId);
                     },
                     true
                  );
                  eMenu.__hasClickEvent = true;
               }
            }
         };

         setTimeout(() => {
            trigerEditPageEvent();

            domNode.addEventListener("change", () => {
               trigerEditPageEvent();
            });
         }, 500);
      }

      // WORKAROUND : remove caret icon of selectivity
      if (settings.readOnly) {
         const caretElems = domNode.getElementsByClassName("selectivity-caret");
         for (let i = 0; i < caretElems.length; i++) {
            const caretElm = caretElems[i];
            if (caretElm) {
               caretElm.parentNode.removeChild(caretElm);
            }
         }
      }

      // remember our settings values
      this.selectivitySettings = settings;
   }

   selectivityGet(domNode) {
      if (domNode && domNode.selectivity) {
         if (this.selectivitySettings && this.selectivitySettings.multiple) {
            // on a multiple select, return an array of results, or empty array
            return domNode.selectivity.getData() || [];
         } else {
            // if a single select, return the object or null
            return domNode.selectivity.getData() || null;
         }
      } else {
         if (this.selectivitySettings && this.selectivitySettings.multiple)
            return [];
         else return null;
      }
   }

   selectivitySet(domNode, data) {
      if (!domNode || !domNode.selectivity) return;

      data = this.prepareData(data, domNode.selectivity.options.multiple);

      if (
         (Array.isArray(data) && data[0]) || // Check Array
         (data && data.id)
      )
         // Check a object
         domNode.selectivity.setData(data);
      else domNode.selectivity.clear();
   }

   selectivityDestroy(domNode) {
      if (domNode && domNode.selectivity) {
         domNode.selectivity.destroy();

         delete domNode.selectivity;
      }
   }

   prepareData(data, multiple = true) {
      if (!data && multiple) {
         return [];
      } else if (multiple && data && Array.isArray(data) && data.length == 0) {
         return [];
      } else if (!multiple && data && Array.isArray(data) && data.length == 0) {
         return null;
      } else if (!data && !multiple) {
         return null;
      }

      if (typeof data == "string" && data.length > 0) {
         try {
            data = JSON.parse(data);
         } catch (e) {
            // not JSON parsable, so convert to
            data = { id: data, text: data };
         }
      }

      // if single select, then it should be object
      if (!multiple && Array.isArray(data)) {
         data = data[0];
      } else if (multiple && !Array.isArray(data)) {
         data = [data];
      }

      // check to see if id is present on each item
      if (multiple) {
         data.forEach((d) => {
            if (!d.id && d.uuid) {
               d.id = d.uuid;
            }
         });
      } else {
         if (!data.id && data.uuid) data.id = data.uuid;
      }

      if (data == null && multiple) {
         data = [];
      }

      return data;
   }

   selectivitySetBadge(domNode) {
      if (!domNode.clientHeight) return;
      const innerHeight = domNode.clientHeight;
      const outerHeight = domNode.parentElement.clientHeight;
      if (innerHeight - outerHeight > 5) {
         let count = 0;
         let values = [];
         if (domNode && domNode.selectivity)
            values = domNode.selectivity.getValue() || [];

         count = values.length;
         if (count > 1) {
            const badge = domNode.querySelector(
               ".webix_badge.selectivityBadge"
            );
            if (badge != null) {
               badge.innerHTML = count;
            } else {
               const anchor = document.createElement("A");
               anchor.href = "javascript:void(0);";
               // v2: this just updated the $height property for this row
               // we don't do that anymore:
               // anchor.addEventListener("click", function () {
               //    App.actions.onRowResizeAuto(row.id, innerHeight);
               // });
               const node = document.createElement("SPAN");
               const textnode = document.createTextNode(count);
               node.classList.add("webix_badge", "selectivityBadge");
               node.appendChild(textnode);
               anchor.appendChild(node);
               domNode.appendChild(anchor);
            }
         }
      }
   }
}


/***/ }),

/***/ 56675:
/*!****************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldString.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldString)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldStringCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldStringCore */ 44955);


class ABFieldString extends _core_dataFields_ABFieldStringCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, object) {
   //    super(values, object);

   // {
   //   settings: {
   // 	  default: 'string',
   // 	  supportMultilingual: 1/0
   //   }
   // }

   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldString
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "text";
      config.css = "textCell";
      // config.sort   = 'string'
      config.template = (obj, common, value /* , col, ind */) => {
         // if this isn't part of a group header display the default format
         if (!obj.$group) {
            return (value || "").toString().replace(/[<]/g, "&lt;");
         } else {
            return "";
         }
      };

      return config;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default string
         if (this.settings.default) {
            if (this.settings.default.indexOf("{uuid}") >= 0) {
               values[this.columnName] = this.AB.uuid();
            } else {
               values[this.columnName] = this.settings.default;
            }
         }
      }
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      return this.settings.supportMultilingual == 1;
   }

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   // formComponent() {
   //    // NOTE: what is being returned here needs to mimic an ABView CLASS.
   //    // primarily the .common() and .newInstance() methods.
   //    const formComponentSetting = super.formComponent();

   //    // .common() is used to create the display in the list
   //    formComponentSetting.common = () => {
   //       return {
   //          key: "textbox",
   //          settings: {
   //             type: "single",
   //          },
   //       };
   //    };

   //    return formComponentSetting;
   // }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   /**
    * @method setValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    * @return {Object}
    */
   setValue(item, rowData) {
      super.setValue(item, rowData, "");
   }
}


/***/ }),

/***/ 62817:
/*!*********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldTextFormula.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldTextFormula)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldTextFormulaCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldTextFormulaCore */ 82361);


class ABFieldTextFormula extends _core_dataFields_ABFieldTextFormulaCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldTextFormula
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         // if this isn't part of a group header display the default format
         if (!rowData.$group) {
            return this.format(rowData);
         } else {
            return "";
         }
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(/* row, App, node, options */) {}

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // not support in the form widget
      return null;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
}


/***/ }),

/***/ 32001:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldTree.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldTree)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldTreeCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldTreeCore */ 13299);


class ABFieldTree extends _core_dataFields_ABFieldTreeCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   idCustomContainer(obj) {
      return `${this.columnName.replace(/ /g, "_")}-${obj.id}-tree`;
   }

   // return the grid column header definition for this instance of ABFieldTree
   columnHeader(options) {
      options = options || {};
      const L = this.AB.Label();

      const config = super.columnHeader(options);
      const field = this;

      let formClass = "";
      let placeHolder = "";
      if (options.isForm) {
         formClass = " form-entry";
         placeHolder =
            "<span style='color: #CCC; padding: 0 5px;'>" +
            L("Select items") +
            "</span>";
      }

      const width = options.width;

      config.template = (obj) => {
         if (obj.$group) return obj[field.columnName];

         const branches = [];
         let selectOptions = this.AB.cloneDeep(field.settings.options);
         selectOptions = new webix.TreeCollection({
            data: selectOptions,
         });

         let values = obj;
         if (obj[field.columnName] != null) {
            values = obj[field.columnName];
         }

         selectOptions.data.each(function (obj) {
            if (
               typeof values.indexOf != "undefined" &&
               values.indexOf(obj.id) != -1
            ) {
               let html = "";

               let rootid = obj.id;
               while (this.getParentId(rootid)) {
                  selectOptions.data.each(function (par) {
                     if (selectOptions.data.getParentId(rootid) == par.id) {
                        html = par.text + ": " + html;
                     }
                  });
                  rootid = this.getParentId(rootid);
               }

               html += obj.text;
               branches.push(html);
            }
         });

         const myHex = "#4CAF50";
         let nodeHTML = "";
         nodeHTML += "<div class='list-data-values'>";
         if (branches.length == 0) {
            nodeHTML += placeHolder;
         } else {
            branches.forEach(function (item) {
               nodeHTML +=
                  '<span class="selectivity-multiple-selected-item rendered" style="background-color:' +
                  myHex +
                  ' !important;">' +
                  item +
                  "</span>";
            });
         }
         nodeHTML += "</div>";

         // field.setBadge(node, App, row);

         if (width) {
            return (
               '<div style="margin-left: ' +
               width +
               'px;" class="list-data-values' +
               formClass +
               '">' +
               nodeHTML +
               "</div>"
            );
         } else {
            return (
               '<div class="list-data-values' +
               formClass +
               '">' +
               nodeHTML +
               "</div>"
            );
         }
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }

      options = options || {};
      const L = this.AB.Label();

      const field = this;

      if (options.isForm) {
         if (!row || row.length == 0) {
            node.innerHTML =
               "<div class='list-data-values form-entry'><span style='color: #CCC; padding: 0 5px;'>" +
               L("Select items") +
               "</span></div>";
            return;
         }

         const branches = [];
         options = this.AB.cloneDeep(field.settings.options);
         options = new webix.TreeCollection({
            data: options,
         });

         let values = row;
         if (row[field.columnName] != null) {
            values = row[field.columnName];
         }

         options.data.each(function (obj) {
            if (
               typeof values.indexOf != "undefined" &&
               values.indexOf(obj.id) != -1
            ) {
               let html = "";

               let rootid = obj.id;
               while (this.getParentId(rootid)) {
                  options.data.each(function (par) {
                     if (options.data.getParentId(rootid) == par.id) {
                        html = par.text + ": " + html;
                     }
                  });
                  rootid = this.getParentId(rootid);
               }

               html += obj.text;
               branches.push(html);
            }
         });

         const myHex = "#4CAF50";
         let nodeHTML = "";
         nodeHTML += "<div class='list-data-values form-entry'>";
         branches.forEach(function (item) {
            nodeHTML +=
               '<span class="selectivity-multiple-selected-item rendered" style="background-color:' +
               myHex +
               ' !important;">' +
               item +
               "</span>";
         });
         nodeHTML += "</div>";

         node.innerHTML = nodeHTML;
      }

      field.setBadge(node, App, row);
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node, component) {
      const idBase = App.unique(this.idCustomContainer(row));
      const idPopup = `${idBase}-popup`;
      const idTree = `${idBase}-tree`;
      const view = $$(node);
      const field = this;
      const parentComponent = component;
      let values = {};
      let firstRender = true;

      function getValues(field, row) {
         let values = {};
         if (
            typeof field != "undefined" &&
            typeof field.columnName != "undefined" &&
            typeof row[field.columnName] != "undefined"
         ) {
            values = row[field.columnName];
         }
         return values;
      }

      function populateTree(field, vals) {
         values = getValues(field, vals);

         const $Tree = $$(idTree);
         $Tree.blockEvent(); // prevents endless loop

         const options = field.AB.cloneDeep(field.settings.options);
         $Tree.clearAll();
         $Tree.parse(options);
         $Tree.refresh();
         $Tree.uncheckAll();
         $Tree.openAll();

         if (values != null && values.length) {
            values.forEach(function (id) {
               if ($Tree.exists(id)) {
                  $Tree.checkItem(id);
                  const dom = $Tree.getItemNode(id);
                  dom.classList.add("selected");
               }
            });
         }
         $Tree.unblockEvent();
      }

      if ($$(idPopup)) {
         $$(idPopup).show();
         populateTree(this, row);
      } else {
         webix
            .ui({
               id: idPopup,
               view: "popup",
               width: 500,
               height: 400,
               on: {
                  onShow: () => {
                     if (firstRender == true) populateTree(this, row);

                     firstRender = false;
                  },
               },
               body: {
                  id: idTree,
                  view: "tree",
                  css: "ab-data-tree",
                  template: function (obj, common) {
                     return (
                        "<label>" +
                        common.checkbox(obj, common) +
                        "&nbsp;" +
                        obj.text +
                        "</label>"
                     );
                  },
                  on: {
                     onItemCheck: async function (id, value, event) {
                        const dom = this.getItemNode(id);
                        const tree = this;
                        if (value == true) {
                           dom.classList.add("selected");
                        } else {
                           dom.classList.remove("selected");
                        }
                        // works for the same-level children only
                        // except root items
                        if (this.getParentId(id)) {
                           tree.blockEvent(); // prevents endless loop

                           let rootid = id;
                           while (this.getParentId(rootid)) {
                              rootid = this.getParentId(rootid);
                              if (rootid != id) tree.uncheckItem(rootid);
                           }

                           this.data.eachSubItem(rootid, function (item) {
                              if (item.id != id) tree.uncheckItem(item.id);
                           });

                           tree.unblockEvent();
                        } else {
                           tree.blockEvent(); // prevents endless loop
                           this.data.eachSubItem(id, function (obj) {
                              if (obj.id != id) tree.uncheckItem(obj.id);
                           });
                           tree.unblockEvent();
                        }
                        const values = {};
                        values[field.columnName] = $$(idTree).getChecked();

                        if (row.id) {
                           // pass null because it could not put empty array in REST api
                           if (values[field.columnName].length == 0)
                              values[field.columnName] = "";

                           try {
                              await field.object.model().update(row.id, values);

                              // update the client side data object as well so other data changes won't cause this save to be reverted
                              if (view && view.updateItem) {
                                 view.updateItem(row.id, values);
                              }
                           } catch (err) {
                              node.classList.add("webix_invalid");
                              node.classList.add("webix_invalid_cell");

                              this.AB.notify.developer(err, {
                                 message: "Error updating our entry.",
                                 row: row,
                                 values: values,
                              });
                           }
                        } else {
                           const rowData = {};
                           rowData[field.columnName] = $$(idTree).getChecked();

                           field.setValue($$(parentComponent.ui.id), rowData);
                        }
                     },
                  },
               },
            })
            .show(node, {
               x: -7,
            });
      }
      return false;
   }

   setBadge(domNode, row) {
      const field = this;
      domNode = domNode.querySelector(".list-data-values");
      const innerHeight = domNode.scrollHeight;
      const outerHeight = domNode.parentElement.clientHeight;
      if (innerHeight - outerHeight > 5) {
         let count = 0;
         if (row[field.columnName] && row[field.columnName].length)
            count = row[field.columnName].length;
         else count = 0;

         if (count > 1) {
            const badge = domNode.querySelector(
               ".webix_badge.selectivityBadge"
            );
            if (badge != null) {
               badge.innerHTML = count;
            } else {
               const anchor = document.createElement("A");
               anchor.href = "javascript:void(0);";
               anchor.addEventListener("click", function (event) {
                  // v2: this was just saving the new height to the
                  // field properties. We don't do that anymore:
                  // App.actions.onRowResizeAuto(row.id, innerHeight);
                  event.stopPropagation();
               });
               const node = document.createElement("SPAN");
               const textnode = document.createTextNode(count);
               node.classList.add("webix_badge", "selectivityBadge");
               node.appendChild(textnode);
               anchor.appendChild(node);
               domNode.appendChild(anchor);
            }
         }
      }
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("formtree");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtree",
         };
      };

      return detailComponentSetting;
   }

   getValue(item, rowData) {
      let values = {};
      values = item.getValues();
      return values;
   }

   setValue(item, rowData) {
      if (!item) return false;

      const val = rowData[this.columnName] || [];

      item.setValues(val);
      // get dom
      const dom = item.$view.querySelector(".list-data-values");

      if (!dom) return false;

      // set value to selectivity
      this.customDisplay(val, this.App, dom, {
         editable: true,
         isForm: true,
      });

      setTimeout(function () {
         let height = 33;
         if (dom.scrollHeight > 33) {
            height = dom.scrollHeight;
         }
         item.config.height = height + 5;
         item.resize();
      }, 200);
   }
}


/***/ }),

/***/ 21391:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/platform/dataFields/ABFieldUser.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldUser)
/* harmony export */ });
/* harmony import */ var _core_dataFields_ABFieldConnectCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/dataFields/ABFieldConnectCore */ 65129);
/* harmony import */ var _core_dataFields_ABFieldUserCore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/dataFields/ABFieldUserCore */ 75498);



class ABFieldUser extends _core_dataFields_ABFieldUserCore__WEBPACK_IMPORTED_MODULE_1__["default"] {
   constructor(values, object, fieldDefaults) {
      super(values, object, fieldDefaults);
   }

   ///
   /// Working with Actual Object Values:
   ///

   async save() {
      // Add new
      if (this.id == null) {
         const SiteUser = this.AB.objectUser();
         const Defaults = _core_dataFields_ABFieldUserCore__WEBPACK_IMPORTED_MODULE_1__["default"].defaults();

         this.settings.linkObject = SiteUser.id;
         this.settings.isCustomFK = 1;

         if (this.settings.isMultiple) {
            this.settings.indexField2 = Defaults.USERNAME_FIELD_ID;
            this.settings.linkType = "many";
            this.settings.linkViaType = "many";
            this.settings.isSource = 1;
         } else {
            this.settings.indexField = Defaults.USERNAME_FIELD_ID;
            this.settings.linkType = "one";
            this.settings.linkViaType = "many";
            this.settings.isSource = 1;
         }

         // TODO: .fieldCustomNew() for saving "local" changes.
         // NOTE: The Object adding this Field sees it's data as a ABFieldUser
         //       connection.
         //       However, the SiteUser will see the data as a ABFieldConnect
         //       connection
         const linkCol = SiteUser.fieldNew({
            key: _core_dataFields_ABFieldConnectCore__WEBPACK_IMPORTED_MODULE_0__["default"].defaults().key,
            columnName: `${this.object.name}_${this.label}`,
            label: this.object.label,
            settings: {
               showIcon: this.settings.showIcon,
               linkObject: this.object.id,
               linkType: this.settings.linkViaType,
               linkViaType: this.settings.linkType,
               isCustomFK: this.settings.isCustomFK,
               indexField: this.settings.indexField,
               indexField2: this.settings.indexField2,
               isSource: 0,
            },
         });

         // // Create definitions of the connected fields
         // // NOTE: skip directly to the ABMLClass.save() to avoid the
         // // migrations caused during the ABField.save() operations.
         // await ABFieldUserCore.prototype.save.call(this);

         // linkCol.settings.linkColumn = this.id;
         // await ABFieldUserCore.prototype.save.call(linkCol);

         // // Update the id value of linked field to connect together
         // this.settings.linkColumn = linkCol.id;
         // await ABFieldUserCore.prototype.save.call(this);

         let newDef = await this.toDefinition().save();
         this.id = newDef.id;

         linkCol.settings.linkColumn = this.id;
         let newLinkDef = await linkCol.toDefinition().save();
         linkCol.id = newLinkDef.id;

         this.settings.linkColumn = linkCol.id;
         await this.toDefinition().save();

         // Add fields to Objects
         await this.object.fieldAdd(this);

         await SiteUser.fieldAdd(linkCol);

         // Create column to DB
         await this.migrateCreate();

         await linkCol.migrateCreate();

         return this;
      } else {
         return super.save();
      }
   }

   // return the grid column header definition for this instance of ABFieldUser

   columnHeader(options) {
      // debugger;
      options = this.setDisplayOptions(options);
      return super.columnHeader(options);
   }

   /**
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *             unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   // customDisplay(row, App, node, options = {}) {
   //    debugger;
   //    options = this.setDisplayOptions(options);
   //
   //    return super.customDisplay(row, App, node, options);
   // }

   setDisplayOptions(options) {
      options = options || {};
      options.editable =
         this.settings.editable != null ? this.settings.editable : true;

      options.isLabelHidden =
         this.settings.isShowUsername != null
            ? !this.settings.isShowUsername
            : false;

      options.additionalText = (opt) => {
         if (!this.settings.isShowProfileImage) return "";

         if (opt.image_id)
            return `<img src='/file/${opt.image_id}' style='border-radius:100%; object-fit: cover; margin: 0 5px 0 -10px;' width='28' height='28' />`;
         else return '<i style="opacity: 0.6;" class="fa fa-user"></i> ';
      };

      return options;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (this.settings.isCurrentUser) {
         if (this.settings.isMultiple) {
            values[this.columnName] = [
               {
                  id: this.AB.Account.username(),
                  text: this.AB.Account.username(),
               },
            ];
         } else {
            values[this.columnName] = this.AB.Account.username();
         }
      }
   }

   getValue(item) {
      let val = super.getValue(item);

      if (val) {
         if (typeof val == "string")
            val = val.replace(/ab-current-user/g, this.AB.Account.username());
         else if (Array.isArray(val))
            val = val.map((v) =>
               (v.username ?? v.uuid ?? v.id ?? v)?.replace(
                  /ab-current-user/g,
                  this.AB.Account.username()
               )
            );
      }

      return val;
   }

   setValue(item, rowData) {
      let val = rowData[this.columnName];
      // Select "[Current user]" to update
      if (val == "ab-current-user") val = this.AB.Account.username();

      rowData[this.columnName] = val;

      super.setValue(item, rowData);
   }

   getUsers() {
      return this.AB.Account.userList().map((u) => {
         const result = {
            id: u.username,
            image: u.image_id,
         };

         if (this.settings.isMultiple) {
            result.text = u.username;
         } else {
            result.value = u.username;
         }

         return result;
      });
   }

   options(...params) {
      return this.getOptions(...params).then((options) => {
         // User values need to keep the .username as the .id
         (options || []).forEach((o) => {
            o.id = o.username ?? o.text;
         });
         this.AB.$store.state[this.id] = options || [];
         return options;
      });
   }
}


/***/ }),

/***/ 77831:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobilePage.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobilePage)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobilePageCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobilePageCore */ 30654);


class ABMobilePage extends _core_mobile_ABMobilePageCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }
   // warningsEval() {
   //    super.warningsEval();
   //    let allViews = this.views();
   //    if (allViews.length == 0) {
   //       this.warningsMessage("has no sub views");
   //    }
   //    (this.pages() || []).forEach((p) => {
   //       p.warningsEval();
   //    });
   // }

   show(showBack = false) {
      // TODO: figure out the different Page display options
      // and update this call to properly intro the page:

      let route = `/${this.route}`;
      if (this.menuType == "tab") {
         route = `/tabs/${this.route}`;
      }
      this.AB.$f7.view.main.router.navigate(route, {
         props: {
            /* This shows up as [props] in our .component definition */
            showBack,
            // data: item,
            // isEditMode: true,
            // transition: "f7-fade", // Q? Should we offer transition Options on a Page?
         },
         ignoreCache: true,
      });
   }
   hide() {
      // TODO Does this need more?
      this.AB.$f7.view.main.router.back();
   }

   viewHTML($h) {
      let allResults = [];

      this.views().forEach((v) => {
         allResults.push(v.html($h));
      });

      return allResults.map((r) => r()); // render each jsx template
   }

   routeComponent() {
      return {
         path: `/${this.route}`,
         id: this.route,
         component: (props, { $, $h, $f7, $on, $store, $update }) => {
            const L = this.AB.Label();
            const title = this.label;
            let allGetters = {};

            // NOTE: this can be redundant, but on the ABDesigner we
            // will load a specific page directly and doing this will
            // make sure the ABFactory is properly populated:
            this.AB.$ = $;
            this.AB.$f7 = $f7;
            this.AB.$store = $store;

            // NOTE: Programming Quirk:
            // We seem to need to access our getters for this Page from
            // within this PageComponent definition.  (maybe) this is how
            // it registers the components that need to be redrawn when the
            // related state is updated.
            let allViews = this.views();

            allViews.forEach((v) => {
               let dc = v.datacollection;
               if (dc) {
                  dc.init();
                  allGetters[dc.id] = $store.getters[dc.id];
               }
            });

            $on("pageInit", async (e, page) => {
               const pendingInit = [];
               allViews.forEach((v) => {
                  let dc = v.datacollection;
                  // dc?.init();

                  const viewInit = async (v, callback) => {
                     await v.init();
                     callback();
                  };
                  const init = () =>
                     new Promise((resolve) => {
                        // wait for DC to be initialized before
                        // initializing the view.
                        if (dc && !dc.isDataInitialized) {
                           dc.on("initializedData", () => {
                              viewInit(v, resolve);
                           });
                           $store.dispatch("getAppBuilderData", dc.id);
                           return;
                        }

                        viewInit(v, resolve);
                     });

                  pendingInit.push(init());
               });

               await Promise.all(pendingInit);
            });

            $on("pageBeforeRemove", () => {
               allViews.forEach((v) => {
                  v.destroy();
               });
            });

            ///
            /// Add Button
            ///

            //             const viewAddButton = () => {
            //                // Decide wether or not to display the Add button.

            //                if (!widgetAdd) return ``;

            //                return $h`
            //                <div class="right">
            //                      <a
            //                         href="#"
            //                         data-panel=".panel-right"
            //                         class="link icon-only"
            //                         onclick=${() => {
            //                            // tell the widget to open it's ADD page.
            //                            widgetAdd.openAddPage();
            //                            // this.AB.$f7.view.main.router.navigate("/form", {
            //                            //    props: {
            //                            //       isEditMode: false,
            //                            //    },
            //                            //    ignoreCache: true,
            //                            // });
            //                         }}
            //                      >
            //                         <i class="icon f7-icons if-not-md">plus</i>
            //                         <i class="icon material-icons md-only">add</i>
            //                      </a>
            //                   </div>
            // `;
            //             };

            ///
            /// Tabs
            ///

            let pagesTabs = this.application.pages((p) => p.menuType == "tab");
            // {array} {ABMobilePage}
            // The pages that are defined as Tabs in this application.

            let tabContent = (p) => {
               // return the link for a Tab
               // @param {ABMobilePage} that represents the Tab Page
               return $h`<a href="/tabs/${p.route}" class="tab-link" data-route-tab-id="${p.route}">${p.name}</a>`;
            };

            let viewTabs = () => {
               // return the block of HTML for the Tabs on the bottom of a Page
               // if there are no tabs, then this is empty.
               if (pagesTabs.length == 0 || this.settings.hideTabs) return "";

               return $h`<div class="toolbar tabbar toolbar-bottom">
                   <div class="toolbar-inner">
                   ${pagesTabs.map((p) => tabContent(p))}
                   </div>
                 </div>`;
            };

            ///
            /// Menu or Back
            ///
            const menu = () => {
               if (!props.showBack) {
                  return $h`<a
                        href="#"
                        data-panel=".panel-left"
                        class="link icon-only panel-open"
                     >
                        <i class="icon material-icons">menu</i>
                     </a>`;
               }

               return $h`<a href="#" class="link back">
                        <i class="icon icon-back"></i>
                        <span class="if-not-md">${L("Back")}</span>
                     </a>`;
            };

            ///
            /// Title
            ///

            const pageTitle = () => {
               // An ABMobilePage can optionally NOT display a title.

               if (this.settings.hideTitle) {
                  return "";
               }

               return $h`<div class="title">${title}</div>
                  <div class="title-large">
                     <div class="title-large-text">${title}</div>
                  </div>`;
            };

            return () => $h`
         <div class="page" data-name="${this.route}">
            <div class="navbar">
               <div class="navbar-bg"></div>
               <div class="navbar-inner">
                  <div class="left">
                     ${menu()}
                  </div>
                  ${pageTitle()}
               </div>
            </div>
            <div class="page-content">
            ${this.viewHTML($h)}
            </div>
            ${viewTabs()}
         </div>
      `;
         },
      };
   }
}


/***/ }),

/***/ 53349:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileView.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileView)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewCore.js */ 69999);


class ABMobileView extends _core_mobile_ABMobileViewCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, application, parent) {
   //    super(attributes, application, parent);
   // }

   /**


   /*
    * @method componentList
    * return the list of components available on this view to display in the editor.
    * @param {bool} isEdited  is this component currently in the Interface Editor
    * @return {array} of ABView objects.
    */
   componentList(isEdited) {
      // views not allowed to drop onto this View:
      var viewsToIgnore = [
         // "view",
         // "page",
         // "formpanel",
         // "viewcontainer",
         // // not allowed Detail's widgets
         // "detailcheckbox",
         // "detailcustom",
         // "detailconnect",
         // "detailimage",
         // "detailselectivity",
         // "detailtext",
         // "detailtree",
         // // not allowed Form's widgets
         // "button",
         // "checkbox",
         // "connect",
         // "datepicker",
         // "fieldcustom",
         // "textbox",
         // "numberbox",
         // "selectsingle",
         // "selectmultiple",
         // "formtree",
         // "fieldreadonly",
         // // not allowed Chart's Widgets
         // "pie",
         // "bar",
         // "line",
         // "area",
         // // not allowed Report page
         // "report",
         // "reportPage",
         // "reportPanel",
      ];

      var allComponents = this.application.viewAll();
      var allowedComponents = allComponents.filter((c) => {
         return viewsToIgnore.indexOf(c.common().key) == -1;
      });

      return allowedComponents;
   }

   /**
    * @method init()
    * perform any actions to prepare a view after HTML is ready
    * happens during  $on("pageInit", ()=>{});
    */
   async init() {}

   /**
    * @method destroy()
    * perform any actions to clean up during a destroy/page removal
    * happens during $on("pageBeforeRemove", ()=>{})
    */
   destroy() {}

   warningsAll() {
      // report both OUR warnings, and any warnings from any of our sub views
      var allWarnings = super.warningsAll();
      this.views().forEach((v) => {
         allWarnings = allWarnings.concat(v.warningsAll());
      });

      (this.pages?.() || []).forEach((p) => {
         allWarnings = allWarnings.concat(p.warningsAll());
      });

      return allWarnings.filter((w) => w);
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      (this.__missingViews || []).forEach((id) => {
         this.warningsMessage(`references unknown View[${id}]`);
      });

      allViews.forEach((v) => {
         v.warningsEval();
      });

      // if a datacollection is specified, verify it can be accessed.
      if (this.settings.dataviewID) {
         let dc = this.datacollections || this.datacollection;
         if (!dc) {
            this.warningsMessage(
               `references unknown dataviewID[${this.settings.dataviewID}]`
            );
         }
      }
   }

   warningsMessage(msg, data = {}) {
      let message = `${this.key}[${this.name}]: ${msg}`;
      this._warnings.push({ message, data });
   }
}


/***/ }),

/***/ 95609:
/*!*****************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewCustom.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewCustom)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewCustomCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewCustomCore.js */ 25538);
/**
 * ABMobileViewCustom
 * This view allows a developer to create a custom view for their mobile app.
 */



class ABMobileViewCustom extends _core_mobile_ABMobileViewCustomCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(...params) {
      super(...params);

      // now make sure our custom init() and html() methods are defined
      if (this.settings.initCode) {
         this._init = new Function(
            "$AB",
            "$DC",
            `return (async () => { 
               ${this.settings.initCode}
            })()`
         );
      } else {
         this._init = new Function(
            "$AB",
            "$DC",
            `return (async () => { console.log("no initCode provided."); })()`
         );
      }

      if (this.settings.htmlCode) {
         this._html = new Function(
            "$AB",
            "$h",
            "$DC",
            `return (() => { 
               ${this.settings.htmlCode} 
            })()`
         );
      } else {
         this._html = new Function(
            "$AB",
            "$h",
            "$DC",
            `return $h\`<b>${this.label}: No HTML code provided.</b>\`;`
         );
      }

      this.$DC = {};
      Object.keys(this.settings.datacollections ?? {}).forEach((label) => {
         let id = this.settings.datacollections[label];
         let dc = this.AB.datacollectionByID(id);
         this.$DC[label] = dc;
      });
   }

   async init() {
      // prepare our DataCollections
      // For Framework7's templates to recoginze updates to the data,
      // the store.dispatch() needs to be called during the template
      // rendering process.
      // So we will do that here and make sure the DCs are loaded before
      // entering the init() routine.
      let promises = [];
      Object.keys(this.$DC).forEach((key) => {
         let dc = this.$DC[key];
         promises.push(this.AB.$store.dispatch("getAppBuilderData", dc.id));
      });
      await Promise.all(promises);

      // Call the custom init function if it exists
      if (this._init) {
         await this._init(this.AB, this.$DC);
      }
   }

   html($h) {
      // Call the custom html function if it exists
      if (this._html) {
         return () => $h`${this._html(this.AB, $h, this.$DC)}`;
      }
   }
}


/***/ }),

/***/ 55805:
/*!***************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewForm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewForm)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormCore.js */ 97835);
/**
 * ABMobileViewForm
 * The view that displays a form on the screen.
 */



class ABMobileViewForm extends _core_mobile_ABMobileViewFormCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {
      let allInits = [];
      this.views().forEach((v) => {
         allInits.push(v.init());
      });
      await Promise.all(allInits);

      const dc = this.datacollection;
      if (dc && !this.settings.clearOnLoad) {
         let rowData = dc.getCursor() || {};
         this.views().forEach((v) => {
            v.valueLoad?.(rowData);
         });
         let id = this.idID;
         this.$form.prepend(`<input
                       id="${id}"
                       name="id"
                       readonly
                       type="hidden"
                       placeholder=""
                    />`);
         let input = this.$form.find(`#${id}`);
         input.val(rowData.id);
      } else {
         // clear the form
         this.formClear();
      }
   }

   formClear() {
      const dc = this.datacollection;
      // clear the form
      dc?.setCursor(null); // clear the DC too?
      this.views().forEach((v) => {
         v.valueClear?.();
      });
   }

   /**
    * @method destroy()
    * perform any actions to clean up during a destroy/page removal
    */
   destroy() {
      this.views().forEach((v) => {
         v.destroy();
      });
   }
   buttonsNotViews(fn = () => true) {
      return this.views((v) => v.key == "mobile-button").filter(fn);
   }
   viewsNotButtons(fn = () => true) {
      return this.views((v) => v.key != "mobile-button").filter(fn);
   }

   itemsNotButtons($h) {
      let rows = [];
      this.viewsNotButtons().forEach((v) => {
         let align = "";
         // @TODO: figure out which form items need alignment:
         // if (v.key == "mobile-textbox") {
         //    align = "align-top";
         // }
         rows.push($h`<li class="${align}" >${v.html($h)}</li>`);
      });
      return rows;
   }

   buttons($h) {
      var rows = [];
      this.buttonsNotViews().forEach((v) => {
         rows.push(v.html($h));
      });
      return rows;
   }

   formItems($h) {
      // OK, we are going to align our Form Item in a <ul> list,
      // but tack on the Buttons at the bottom:
      return $h`
         <ul>
         ${this.itemsNotButtons($h)}
         </ul>
         ${this.buttons($h)}
      `;
   }

   get idID() {
      return `id_${this.id}`;
   }

   get idForm() {
      return `Form_${this.id}`;
   }

   html($h) {
      // // return () =>
      // //    $h`<div class="${this.style} ${this.alignment}">${this.text}</div>`;

      // let dc = this.datacollection;

      // if (!dc || this.AB.$store.getters[dc.id].value.length === 0)
      //    return () => $h`
      //          ${this.listTitle($h)}
      //          <div class="list links-list list-outline list-strong list-dividers skeleton-text skeleton-effect-fade">
      //             <ul>
      //                ${[...Array(20)].map(
      //                   (/* x, i */) => $h`
      //                   <li>
      //                      <a href="#">Skeleton text will go here</a>
      //                   </li>`
      //                )}
      //             </ul>
      //          </div>

      //    `;

      // return () => $h`
      //    ${this.listTitle($h)}
      //    ${this.searchBar($h)}
      //    <div
      //       class="infinite-scroll-content"
      //       onInfinite=${() => this.loadMore()}
      //    >
      //       <div class="list links-list list-outline list-strong list-dividers">
      //          <ul>${this.listItems($h)}</ul>
      //       </div>
      //       ${this.hasMore($h)}
      //    </div>`;

      return () => $h`
         <form
            class="list list-inset list-strong-ios list-dividers-ios list-outline-ios"
            id=${this.idForm}
         >
            ${this.formItems($h)}
         </form>`;
   }

   //
   // Form Actions:
   //

   busy() {
      // this.AB.$f7.preloader.show();
      this.buttonsNotViews().forEach((b) => {
         b.busy();
      });
   }

   get $form() {
      return this.AB.$(`#${this.idForm}`);
   }

   ready() {
      // this.AB.$f7.preloader.hide();

      this.buttonsNotViews().forEach((b) => {
         b.ready();
      });
   }

   // Save
   /**
    * @method saveData
    * save data in to database
    * @param $formView - webix's form element
    *
    * @return {Promise}
    */
   async save() {
      // get ABDatacollection
      const dv = this.datacollection;
      if (dv == null) return;

      // get ABObject
      const obj = dv.datasource;
      if (obj == null) return;

      // get ABModel
      const model = dv.model;
      if (model == null) return;

      // show progress icon
      this.buttonsNotViews().forEach((b) => {
         b.busy();
      });

      // give each form item a chance to Prepare their data:
      // ex: File fields need to upload their file and get back
      // their ID

      let allUpdates = [];
      (this.viewsNotButtons() || []).forEach((v) => {
         allUpdates.push(v.valuePrepare());
      });
      await Promise.all(allUpdates);

      // get update data
      const formVals = this.getFormValues(obj, dv, dv.datacollectionLink);

      // form ready function
      const formReady = (newFormVals) => {
         // clear cursor after saving.
         if (dv) {
            if (this.settings.clearOnSave) {
               // dv.setCursor(null);  // <== happens in .formClear()
               this.formClear();
            } else {
               if (newFormVals && newFormVals.id) dv.setCursor(newFormVals.id);
            }
         }

         // show progress icon

         this.ready();

         // if there was saved data pass it up to the onSaveData callback
         if (newFormVals) this.emit("saved", newFormVals);
      };

      const formError = (err) => {
         let L = this.AB.Label();

         // mark error
         if (err) {
            if (err.invalidAttributes) {
               for (const attr in err.invalidAttributes) {
                  let invalidAttrs = err.invalidAttributes[attr];
                  if (invalidAttrs && invalidAttrs[0])
                     invalidAttrs = invalidAttrs[0];

                  this.markInvalid(attr, invalidAttrs.message);
               }
            } else if (err.sqlMessage) {
               this.AB.$f7.dialog.alert(err.sqlMessage, L("Error Received:"));
            } else {
               this.AB.$f7.dialog.alert(
                  L("System could not save your data"),
                  L("Error")
               );
               this.AB.notify.developer(err, {
                  message: "Could not save your data",
                  view: this.toObj(),
               });
            }
         }

         this.buttonsNotViews().forEach((b) => {
            b.ready();
         });

         this.ready();
      };

      // wait for our Record Rules to be ready before we continue.
      await this.recordRulesReady();

      // update value from the record rule (pre-update)
      this.doRecordRulesPre(formVals);

      // validate data
      if (!this.validateData(obj, formVals)) {
         // console.warn("Data is invalid.");
         return;
      }

      let newFormVals;
      // {obj}
      // The fully populated values returned back from service call
      // We use this in our post processing Rules

      try {
         // is this an update or create?
         if (formVals.id) {
            newFormVals = await model.update(formVals.id, formVals);
         } else {
            newFormVals = await model.create(formVals);
         }
      } catch (err) {
         formError(err.data);
         throw err;
      }

      /*
      // OLD CODE:
      try {
         await this.doRecordRules(newFormVals);
         // make sure any updates from RecordRules get passed along here.
         this.doSubmitRules(newFormVals);
         formReady(newFormVals);
         return newFormVals;
      } catch (err) {
         this.AB.notify.developer(err, {
            message: "Error processing Record Rules.",
            view: this.toObj(),
            newFormVals: newFormVals,
         });
         // Question:  how do we respond to an error?
         // ?? just keep going ??
         this.doSubmitRules(newFormVals);
         formReady(newFormVals);
         return;
      }
      */

      try {
         await this.doRecordRules(newFormVals);
      } catch (err) {
         this.AB.notify.developer(err, {
            message: "Error processing Record Rules.",
            view: this.toObj(),
            newFormVals: newFormVals,
         });
      }

      // make sure any updates from RecordRules get passed along here.
      try {
         this.doSubmitRules(newFormVals);
      } catch (errs) {
         this.AB.notify.developer(errs, {
            message: "Error processing Submit Rules.",
            view: this.toObj(),
            newFormVals: newFormVals,
         });
      }

      formReady(newFormVals);
      return newFormVals;
   }

   /**
    * @method getFormValues
    *
    * @param {webix form} formView
    * @param {ABObject} obj
    * @param {ABDatacollection} dc
    * @param {ABDatacollection} dcLink [optional]
    */
   getFormValues(obj, dc, dcLink) {
      // get the fields that are on this form
      /*     const visibleFields = ["id"]; // we always want the id so we can udpate records
      formView.getValues(function (obj) {
         visibleFields.push(obj.config.name);
      });

      // only get data passed from form
      const allVals = formView.getValues();
      const formVals = {};
      visibleFields.forEach((val) => {
         formVals[val] = allVals[val];
      });
*/
      const formVals = {};
      this.viewsNotButtons().forEach((v) => {
         v.valueGet(formVals);
      });

      let input = this.$form.find(`#${this.idID}`);
      if (input) {
         formVals.id = input.val();
      }

      // get custom values
      // this.fieldComponents(
      //    (comp) =>
      //       comp instanceof ABViewFormCustom ||
      //       comp instanceof ABViewFormConnect ||
      //       comp instanceof ABViewFormDatepicker ||
      //       comp instanceof ABViewFormSelectMultiple ||
      //       (comp instanceof ABViewFormJson && comp.settings.type == "filter")
      // ).forEach((f) => {
      //    const vComponent = this.viewComponents[f.id];
      //    if (vComponent == null) return;

      //    const field = f.field();
      //    if (field) {
      //       const getValue = vComponent.getValue ?? vComponent.logic.getValue;
      //       if (getValue)
      //          formVals[field.columnName] = getValue.call(vComponent, formVals);
      //    }
      // });

      // // remove connected fields if they were not on the form and they are present in the formVals because it is a datacollection
      // obj.connectFields().forEach((f) => {
      //    if (
      //       visibleFields.indexOf(f.columnName) == -1 &&
      //       formVals[f.columnName]
      //    ) {
      //       delete formVals[f.columnName];
      //       delete formVals[f.relationName()];
      //    }
      // });

      // clear undefined values or empty arrays
      for (const prop in formVals) {
         if (
            formVals[prop] == "" ||
            formVals[prop] == null ||
            formVals[prop].length == 0
         )
            delete formVals[prop];
      }

      // Add parent's data collection cursor when a connect field does not show
      let linkValues;

      if (dcLink) {
         linkValues = dcLink.getCursor();
      }

      if (linkValues) {
         const objectLink = dcLink.datasource;

         const connectFields = obj.connectFields();
         connectFields.forEach((f) => {
            const formFieldCom = this.viewsNotButtons(
               (fComp) => fComp?.field?.()?.id === f?.id
            );

            if (
               objectLink.id == f.settings.linkObject &&
               formFieldCom.length < 1 && // check field does not show
               formVals[f.columnName] === undefined
            ) {
               const linkColName = f.indexField
                  ? f.indexField.columnName
                  : objectLink.PK();

               formVals[f.columnName] = {};
               formVals[f.columnName][linkColName] =
                  linkValues[linkColName] ?? linkValues.id;
            }
         });
      }

      // NOTE: need to pull data of current cursor to calculate Calculate & Formula fields
      // .formVals variable does not include data that does not display in the Form widget
      const cursorFormVals = Object.assign(dc.getCursor() ?? {}, formVals);

      // Set value of calculate or formula fields to use in record rule
      obj.fields((f) => f.key == "calculate" || f.key == "formula").forEach(
         (f) => {
            if (
               formVals[f.columnName] == null ||
               formVals[f.columnName] === ""
            ) {
               let reCalculate = true;

               // WORKAROUND: If "Formula" field will have Filter conditions,
               // Then it is not able to re-calculate on client side
               // because relational data is not full data so FilterComplex will not have data to check
               if (f.key == "formula" && f.settings?.where?.rules?.length > 0) {
                  reCalculate = false;
               }

               formVals[f.columnName] = f.format(cursorFormVals, reCalculate);
            }
         }
      );

      // if (allVals.translations?.length > 0)
      //    formVals.translations = allVals.translations;

      return formVals;
   }

   /**
    * @method validateData
    *
    * @param {ABObject} object
    * @param {object} formVals
    *
    * @return {boolean} isValid
    */
   validateData(object, formVals) {
      let isValid = true;

      // validate required fields
      const requiredFields = this.viewsNotButtons(
         (fComp) =>
            fComp?.field?.().settings?.required == true ||
            fComp?.settings?.required == true
      ).map((fComp) => fComp.field());

      // validate data
      // This checks to see if the Object thinks the provided
      // data is actually valid.
      let validator = object.isValidData(formVals);
      isValid = validator.pass();

      // Now make sure the form Elements think the data is valid.
      let form = document.getElementById(this.idForm);
      if (!form.checkValidity()) {
         isValid = false;
         var list = form.querySelectorAll(":invalid");
         list[0]?.focus();
      }

      // Display required messages
      // requiredFields.forEach((f) => {
      //    if (!f) return;

      //    const fieldVal = formVals[f.columnName];
      //    if (fieldVal == "" || fieldVal == null || fieldVal.length < 1) {
      //       $formView.markInvalid(f.columnName, L("This is a required field."));
      //       isValid = false;

      //       // Fix position of invalid message
      //       const $forminput = $formView.elements[f.columnName];
      //       if ($forminput) {
      //          // Y position
      //          const height = $forminput.$height;
      //          if (height < 56) {
      //             $forminput.define("height", 60);
      //             $forminput.resize();
      //          }

      //          // X position
      //          const domInvalidMessage =
      //             $forminput.$view.getElementsByClassName(
      //                "webix_inp_bottom_label"
      //             )[0];
      //          if (!domInvalidMessage?.style["margin-left"]) {
      //             domInvalidMessage.style.marginLeft = `${
      //                this.settings.labelWidth ??
      //                ABViewFormPropertyComponentDefaults.labelWidth
      //             }px`;
      //          }
      //       }
      //    }
      // });

      // if data is invalid
      // if (!isValid) {
      //    const saveButton = $formView.queryView({
      //       view: "button",
      //       type: "form",
      //    });

      //    // error message
      //    if (validator?.errors?.length) {
      //       validator.errors.forEach((err) => {
      //          $formView.markInvalid(err.name, err.message);
      //       });

      //       saveButton?.disable();
      //    } else {
      //       saveButton?.enable();
      //    }
      // }

      return isValid;
   }
}


/***/ }),

/***/ 50037:
/*!*********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormButton.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormButton)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormButtonCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormButtonCore.js */ 74455);
/**
 * ABMobileViewFormButton
 * The view that displays a row of form buttons.
 */



class ABMobileViewFormButton extends _core_mobile_ABMobileViewFormButtonCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {}

   get isSave() {
      return this.settings.includeSave;
   }

   cancel() {
      console.warn("TODO: Cancel this form.");
   }

   reset() {
      console.warn("TODO: Reset this form.");
   }

   save() {
      this.busy();
      this.parent.save();
   }

   buttonCancel($h) {
      if (!this.settings.includeCancel) return "";

      let label = this.settings.cancelLabel
         ? this.settings.cancelLabel
         : this.AB.Label()("Cancel");

      return $h`
         <a
            onClick=${() => this.cancel()}
            id=${this.idCancel}
            class="button button-small button-fill button-preloader"
            href="#"
         >
            <span class="preloader"></span>
            <span>${label}</span>
         </a>
      `;
   }

   buttonReset($h) {
      if (!this.settings.includeReset) return "";

      let label = this.settings.resetLabel
         ? this.settings.resetLabel
         : this.AB.Label()("Reset");

      return $h`
         <a
            onClick=${() => this.reset()}
            id=${this.idReset}
            class="button button-large button-fill button-preloader"
            href="#"
         >
            <span class="preloader"></span>
            <span>${label}</span>
         </a>
      `;
   }

   buttonSave($h) {
      if (!this.isSave) return "";

      let label = this.settings.saveLabel
         ? this.settings.saveLabel
         : this.AB.Label()("Save");

      return $h`
         <a
            onClick=${() => this.save()}
            id=${this.idSave}
            class="button button-large button-fill button-preloader"
            href="#"
         >
            <span class="preloader"></span>
            <span>${label}</span>
         </a>
      `;
   }

   html($h) {
      return $h`
         <div class="block">
            ${this.buttonCancel($h)}
            ${this.buttonReset($h)}
            ${this.buttonSave($h)}
         </div>
      `;
   }

   get idCancel() {
      return `Cancel_${this.id}`;
   }
   get idReset() {
      return `Reset_${this.id}`;
   }
   get idSave() {
      return `Save_${this.id}`;
   }

   busy() {
      this.AB.$(`#${this.idSave}`)
         .addClass("button-loading")
         .addClass("disabled");
   }

   ready() {
      this.AB.$(`#${this.idSave}`)
         .removeClass("button-loading")
         .removeClass("disabled");
   }
}


/***/ }),

/***/ 92092:
/*!***********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormCheckbox.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormCheckbox)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormCheckboxCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormCheckboxCore */ 52670);


class ABMobileViewFormCheckbox extends _core_mobile_ABMobileViewFormCheckboxCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   async init() {}

   valueClear() {
      const myInput = this.myField;
      if (myInput) {
         myInput.checked = false;
      }
   }

   valueLoad(rowData) {
      const myInput = this.myField;
      if (myInput) {
         let field = this.field();
         let val = rowData[field.columnName] || false;
         if (typeof val === "string") val = JSON.parse(val);
         myInput.checked = val;
      }
   }

   valueGet(rowData) {
      const myField = this.myField;
      if (myField) {
         const field = this.field();
         rowData[field.columnName] = myField.checked ? 1 : 0;
      }
   }

   inputElement($h) {
      let field = this.field();
      let $inputElement = $h`
         <input 
            id=${this.idFormElement}
            name=${field.columnName} 
            type="checkbox" 
            ${this.settings.disable ? 'disabled="disabled"' : ""}
         />
      `;
      this.updateProperties($inputElement);

      return $inputElement;
   }

   html($h) {
      return $h`
         <div class="item-content">
            <div class="item-inner">
               <div class="item-title">${this.label}</div>
               <div class="item-after">
                  <label class="toggle toggle-init">
                     ${this.inputElement($h)}
                     <i class="toggle-icon"></i>
                  </label>
               </div>
            </div>
         </div>
         `;
   }
}


/***/ }),

/***/ 2493:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormConnect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormConnect)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormConnectCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormConnectCore.js */ 55866);
/* harmony import */ var _ViewFormSelectMultiple_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ViewFormSelectMultiple.js */ 53691);
/* harmony import */ var _ViewFormSelectSingle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ViewFormSelectSingle.js */ 61554);
/**
 * ABMobileViewFormConnect
 * The view that displays a form textbox on the screen.
 */





class ABMobileViewFormConnect extends _core_mobile_ABMobileViewFormConnectCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {}

   html($h) {
      let field = this.field();
      const formComponent =
         field.settings.linkType === "one"
            ? new _ViewFormSelectSingle_js__WEBPACK_IMPORTED_MODULE_2__["default"](this.AB, field)
            : new _ViewFormSelectMultiple_js__WEBPACK_IMPORTED_MODULE_1__["default"](this.AB, field);

      return formComponent.html($h);
   }
}


/***/ }),

/***/ 88358:
/*!*********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormCustom.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormCustom)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormCustomCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormCustomCore */ 37089);

class ABMobileViewFormCustom extends _core_mobile_ABMobileViewFormCustomCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // html($h) {
   //    return "ABMobileViewFormCustom Content";
   // }
}


/***/ }),

/***/ 37272:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormDate.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormDate)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormDateCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormDateCore.js */ 30483);
/**
 * ABMobileViewFormTextbox
 * The view that displays a form textbox on the screen.
 */



class ABMobileViewFormDate extends _core_mobile_ABMobileViewFormDateCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {
      this.formDatepicker = this.AB.$f7.calendar.create({
         inputEl: `#${this.idFormElement}`, // ".form-datepicker-date",
      });
   }

   destroy() {
      this.formDatepicker?.destroy();
   }

   inputElement($h) {
      let field = this.field();
      let placeholder = this.settings.placeholder ?? "";

      let $inputElement = $h`
               <input
                  type="text"
                  id=${this.idFormElement}
                  name=${field.columnName}
                  class="form-datepicker-date"
                  placeholder=${placeholder}
                  readonly="readonly"
               />
            `;

      this.updateProperties($inputElement);

      return $inputElement;
   }
}


/***/ }),

/***/ 43717:
/*!***********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormDatetime.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormDatetime)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormDatetimeCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormDatetimeCore.js */ 41098);
/**
 * ABMobileViewFormDatetime
 * The view that displays a form textbox on the screen.
 */



class ABMobileViewFormDatetime extends _core_mobile_ABMobileViewFormDatetimeCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {
      this.formDatepicker = this.AB.$f7.calendar.create({
         inputEl: `#${this.idFormElement}`, // ".form-datepicker-datetime",
         timePicker: true,
         dateFormat: {
            month: "numeric",
            day: "numeric",
            year: "numeric",
            hour: "numeric",
            minute: "numeric",
         },
      });
   }

   destroy() {
      this.formDatepicker?.destroy();
   }

   valueLoad() {
      console.error("TODO: finish this");
   }

   inputElement($h) {
      let field = this.field();
      let placeholder = this.settings.placeholder ?? "";
      let $inputElement = $h`
         <input
            type="text"
            id=${this.idFormElement}
            name=${field.columnName}
            class="form-datepicker-datetime"
            placeholder=${placeholder}
            readonly="readonly"
         />
      `;

      this.updateProperties($inputElement);

      return $inputElement;
   }
}


/***/ }),

/***/ 46722:
/*!********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormEmail.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormEmail)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormEmailCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormEmailCore.js */ 31508);
/**
 * ABMobileViewFormEmail
 * The view that displays a form textbox on the screen.
 */



class ABMobileViewFormEmail extends _core_mobile_ABMobileViewFormEmailCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {}

   inputElement($h) {
      let field = this.field();
      let placeholder = this.settings.placeholder ?? "";
      let $inputElement = $h`
         <input
            type="email"
            id=${this.idFormElement}
            name=${field.columnName}
            placeholder=${placeholder}
         />
      `;

      this.updateProperties($inputElement);

      return $inputElement;
   }
}


/***/ }),

/***/ 94298:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormFile.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormFile)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormFileCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormFileCore.js */ 37206);
/**
 * ABMobileViewFormFile
 * The view that displays a form textbox on the screen.
 */



class ABMobileViewFormFile extends _core_mobile_ABMobileViewFormFileCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {
      const _this = this;
      const $$ = this.AB.$;

      $$(`#${this.idUpload}`).on("change", async (ev) => {
         // update the name field:
         let name = ($$(`#${this.idUpload}`).val() ?? "").split("\\").pop();
         if (name != "") {
            $$(`#${this.idFileName}`).html(`<b>${name}</b>`);
         }
      });
   }

   destroy() {}

   valueLoad() {
      console.error("TODO: finish this");
   }

   // valueGet(rowData) {
   //    const myField = this.myField;
   //    if (myField) {
   //       const field = this.field();
   //       let value = myField.value;
   //       try {
   //          value = JSON.parse(value);
   //       } catch (e) {}
   //       rowData[field.columnName] = value;
   //    }
   // }

   /**
    * @method valuePrepare()
    * Prepare our value for the Form Submission.  This means we need to
    * upload the file to the Site, and then store the .uuid with this
    * field.
    * @return {Promise}
    */
   async valuePrepare() {
      let field = this.field();
      let formElement = document.getElementById(this.idForm);
      let formData = new FormData(formElement);

      // don't upload when not selected.
      let file = formData.get("file");
      if (file == undefined || file == null) return;
      if (file.name == "" && file.size == 0) return;

      try {
         let response = await this.AB.Network.post({
            url: field.urlUpload(false),
            data: formData,
         });
         this.AB.$(`#${this.idFormElement}`).val(
            JSON.stringify({
               uuid: response.uuid,
               filename: file.name,
            })
         );
      } catch (e) {
         this.AB.notify.developer(e, {
            context:
               "ABMobileViewFormFile.value(): unable to upload File to site",
         });
         // TODO: update Visible Form Element with Validation Error.
      }
   }

   inputFormElement($h) {
      let field = this.field();

      return $h`<form 
         id=${this.idForm} 
         method="POST" 
         enctype="multipart/form-data"
      >
      ${this.inputElementUpload($h)}
      </form>`;
   }

   inputElementUpload($h) {
      let field = this.field();
      // let placeholder = this.settings.placeholder ?? "";
      let $inputElement = $h`
         <input 
            id=${this.idUpload} 
            type="file"
            name="file"
            class="upload"
         />
      `;

      this.updateProperties($inputElement);

      return $inputElement;
   }

   get idForm() {
      return `Form_${this.id}`;
   }

   get idUpload() {
      return `Upload_${this.id}`;
   }

   get idFileName() {
      return `file_${this.id}`;
   }

   html($h) {
      let field = this.field();
      return $h`
         <div class="list-block inputs-list">
            <div class="item-content">
                <div class="item-media button button-raised button-fill fileUpload">
                    <span class="ico_upload"><i class="fa fa-paperclip" aria-hidden="true"></i></span>
                    ${this.inputFormElement($h)}
                </div>
                <div class="item-inner">
                  <div class="item-title floating-label">${this.label}</div>
                  <div class="item-input">
                    <input 
                       id=${this.idFormElement} 
                       name=${field.columnName} 
                       readonly 
                       type="hidden" 
                       placeholder=""
                    />
                    <div id=${this.idFileName}></div>
                  </div>
                </div>
            </div>
         </div>`;
   }
}


/***/ }),

/***/ 92696:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormFormula.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormFormula)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormFormulaCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormFormulaCore.js */ 9462);
/**
 * ABMobileViewFormFormula
 * The view that displays a form textbox on the screen.
 */



class ABMobileViewFormFormula extends _core_mobile_ABMobileViewFormFormulaCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {}

   // destroy() {

   // }

   inputElement($h) {
      let field = this.field();
      let placeholder = this.settings.placeholder ?? "";

      let $inputElement = $h`
               <input
                  type="text"
                  id=${this.idFormElement}
                  name=${field.columnName}
                  readonly="readonly"
                  disabled="disabled"
               />
            `;

      // this.updateProperties($inputElement);

      return $inputElement;
   }
}


/***/ }),

/***/ 14241:
/*!********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormImage.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormImage)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormImageCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormImageCore.js */ 37238);
/**
 * ABMobileViewFormImage
 * The view that displays a form textbox on the screen.
 */



class ABMobileViewFormImage extends _core_mobile_ABMobileViewFormImageCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {}

   /**
    * @method valuePrepare()
    * Prepare our value for the Form Submission.  This means we need to
    * upload the file to the Site, and then store the .uuid with this
    * field.
    * @return {Promise}
    */
   // async valuePrepare() {
   //    let field = this.field();
   //    let formElement = document.getElementById(this.id);
   //    let formData = new FormData(formElement);

   //    try {
   //       let response = await this.AB.Network.post({
   //          url: field.urlUpload(false),
   //          data: formData,
   //       });
   //       this.AB.$(`#${this.idFileID}`).val(response.uuid);
   //    } catch (e) {
   //       this.AB.notify.developer(e, {
   //          context:
   //             "ABMobileViewFormFile.value(): unable to upload File to site",
   //       });
   //       // TODO: update Visible Form Element with Validation Error.
   //    }
   // }

   valueGet(rowData) {
      super.valueGet(rowData);

      // Images just store .uuid, so pull out the file.uuid info
      // and return that.
      const field = this.field();
      if (rowData[field.columnName]) {
         try {
            let val = JSON.parse(rowData[field.columnName]);
            val = val?.uuid ?? val;
            rowData[field.columnName] = val;
         } catch (e) {}
      }
   }

   inputElementUpload($h) {
      let $inputElement = $h`
      <input 
         id=${this.idUpload} 
         name="file"
         accept="image/*"
         type="file"
         placeholder=""
      />`;

      this.updateProperties($inputElement);

      return $inputElement;
   }
}


/***/ }),

/***/ 3199:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormItem.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormItem)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormItemCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormItemCore */ 95927);


class ABMobileViewFormItem extends _core_mobile_ABMobileViewFormItemCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }
   // warningsEval() {
   //    super.warningsEval();
   //    let allViews = this.views();
   //    if (allViews.length == 0) {
   //       this.warningsMessage("has no sub views");
   //    }
   //    (this.pages() || []).forEach((p) => {
   //       p.warningsEval();
   //    });
   // }

   get idFormElement() {
      return `F${this.id}`;
   }

   get myField() {
      return document.getElementById(this.idFormElement);
   }

   valueClear() {
      const myField = this.myField;
      if (myField) {
         myField.value = "";
      }
   }

   valueLoad(rowData) {
      const myField = this.myField;
      if (myField) {
         const field = this.field();
         myField.value = rowData[field.columnName] || "";
      }
   }

   valueGet(rowData) {
      const myField = this.myField;
      if (myField) {
         const field = this.field();
         rowData[field.columnName] = myField.value;
      }
   }

   updateProperties($inputElement) {
      // NOTE: the $h returns an object that we can update with
      // the properties.
      // I have been unable to get the following approach to work:
      // $inputElement = $h`
      //    <input
      //       name=${field.columnName}
      //       placeholder=${placeholder}
      //       type="text"
      //       ${ this.settings.required: "required" : "" }
      //       ${ this.settings.required: "validate" : "" }
      //       ${ this.settings.disable: `disabled="disabled"` : "" }
      //    />
      // `;
      // So I am updating the object directly:
      // $inputElement.props[]

      if (this.settings.required) {
         $inputElement.props["required"] = "";
         $inputElement.props["validate"] = "";
      }

      if (this.settings.disable) {
         $inputElement.props["disabled"] = "disabled";
      }
   }

   /**
    * @method valuePrepare()
    * Before a Form reads in it's values, we will first allow any FormItem to
    * prepare it's data for submit.
    * @return {Promise}
    */
   async valuePrepare() {}

   html($h) {
      return $h`
         <div class="item-content item-input">
            <div class="item-inner">
               <div class="item-title item-label">${this.label}</div>
               <div class="item-input-wrap">${this.inputElement($h)}</div>
            </div>
         </div>`;
   }
}


/***/ }),

/***/ 95729:
/*!*********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormNumber.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormNumber)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormNumberCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormNumberCore.js */ 75410);
/**
 * ABMobileViewFormTextbox
 * The view that displays a form textbox on the screen.
 */



class ABMobileViewFormNumber extends _core_mobile_ABMobileViewFormNumberCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   // async init() {
   //    this.formDatepicker = this.AB.$f7.calendar.create({
   //       inputEl: `#${this.id}`, // ".form-datepicker-date",
   //    });
   // }

   // destroy() {
   //    this.formDatepicker?.destroy();
   // }

   inputElement($h) {
      let field = this.field();
      let placeholder = this.settings.placeholder ?? "";
      const errorMessage = this.AB.Label()("Only numbers please.");

      let $inputElement = $h`
               <input
                  type="number"
                  id=${this.idFormElement}
                  name=${field.columnName}
                  placeholder=${placeholder}
                  pattern="[0-9]*"
                  data-error-message=${errorMessage}
               />
            `;

      this.updateProperties($inputElement);

      return $inputElement;
   }
}


/***/ }),

/***/ 95620:
/*!***********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormReadonly.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormReadonly)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormReadonlyCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormReadonlyCore */ 43002);


class ABMobileViewFormReadonly extends _core_mobile_ABMobileViewFormReadonlyCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   inputElement($h) {
      let field = this.field();
      let placeholder = this.settings.placeholder ?? "";

      let $inputElement = $h`
               <input
                  type="text"
                  id=${this.idFormElement}
                  name=${field.columnName}
                  placeholder=${placeholder}
                  disabled="disabled"
               />
            `;

      // this.updateProperties($inputElement);

      return $inputElement;
   }
}


/***/ }),

/***/ 77614:
/*!*****************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormSelectMultiple.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormSelectMultiple)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormSelectMultipleCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormSelectMultipleCore.js */ 18061);
/**
 * ABMobileViewFormSelectMultiple
 * The view that displays a list that can only have 1 selection.
 */



class ABMobileViewFormSelectMultiple extends _core_mobile_ABMobileViewFormSelectMultipleCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);

   //    this.options = [
   //       /* {id, text} */
   //       // { id: 1, text: "one" },
   //       // { id: 2, text: "two" },
   //       // { id: 3, text: "three" },
   //    ];

   //    this.field.options().forEach((opt) => {
   //       // opt = { id, text, hex, translations }
   //       this.options.push({ id: opt.id, text: opt.text });
   //    });
   //    this.value = null;
   // }

   // setOptions(values, k = "id", t = "text") {
   //    this.options = [];
   //    (values || []).forEach((v) => {
   //       this.options.push({ id: v[k], text: v[t] });
   //    });
   // }

   // setValue(vid) {
   //    this.value = vid;
   // }

   // inputElement($h, item) {
   //    let $inputElement = $h`<option value=${item.id}>${item.text}</option>`;
   //    if (this.value == item.id) {
   //       $inputElement.props.selected = "";
   //    }
   //    return $inputElement;
   // }

   valueGet(rowData) {
      const myField = this.myField;
      if (myField) {
         const field = this.field();
         rowData[field.columnName] = this.AB.$(`#${this.idFormElement}`).val();
      }
   }

   html($h) {
      let value = this.options.find((o) => o.id == this.value)?.text;
      let field = this.field();
      return $h`
         <a href="#" class="item-link smart-select smart-select-init">
            <select
               id=${this.idFormElement} 
               name=${field?.columnName}
               multiple
            >
               ${this.options.map((item) => this.inputElement($h, item))}
            </select>
            <div class="item-content">
               <div class="item-inner">
                  <div class="item-title">${field?.label}</div>
                  <div class="item-after">${value || "Value"}</div>
               </div>
            </div>
         </a>
         `;
   }
}


/***/ }),

/***/ 88001:
/*!***************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormSelectSingle.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormSelectSingle)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormSelectSingleCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormSelectSingleCore.js */ 10807);
/**
 * ABMobileViewFormSelectSingle
 * The view that displays a list that can only have 1 selection.
 */



class ABMobileViewFormSelectSingle extends _core_mobile_ABMobileViewFormSelectSingleCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(...params) {
      super(...params);

      this.options = [
         /* {id, text} */
         // { id: 1, text: "one" },
         // { id: 2, text: "two" },
         // { id: 3, text: "three" },
      ];

      this.value = null;
   }

   async init() {
      this.options = [];
      await this.optionsLoad();
   }

   idState() {
      return this.id;
   }

   async optionsLoad() {
      let field = this.field();
      if (field) {
         // We can support different types of fields: Connections and Lists
         if (field.isConnection) {
            let options = await field.options();
            this.options = [];
            options.forEach((o) => {
               this.options.push({
                  id: o.id,
                  text: o.text,
                  value: field.getRelationValue(o),
               });
            });
            // let obj = field.datasourceLink;
            // if (obj) {
            //    let PK = obj.PK();
            //    let response = await obj.model().findAll();
            //    (response.data || []).forEach((d) => {
            //       this.options.push({
            //          id: d[PK],
            //          text: obj.displayData(d),
            //       });
            //    });
            // this.AB.$store.state[field.id] = this.options || []; // response.data || [];
            // }
            return;
         }

         // List fields:
         field.options().forEach((opt) => {
            // opt = { id, text, hex, translations }
            this.options.push({ id: opt.id, text: opt.text });
         });
      }
   }
   // setOptions(values, k = "id", t = "text") {
   //    this.options = [];
   //    (values || []).forEach((v) => {
   //       this.options.push({ id: v[k], text: v[t] });
   //    });
   // }
   valueClear() {
      const mySelect = this.myField;
      if (mySelect) {
         mySelect.selectedIndex = 0;
      }
      this.options.forEach((o) => {
         this.AB.$(`#${this.idOption(o)}`)?.prop("selected", "");
      });
   }

   valueLoad() {
      console.error("TODO: finish this");
   }

   setValue(vid) {
      this.value = vid;
   }

   idOption(o) {
      return `O${o.id.replaceAll(" ", "_")}`;
   }

   inputElement($h, item) {
      let $inputElement = $h`<option id=${this.idOption(item)} value=${
         item.value ?? item.id
      }>${item.text}</option>`;
      if (this.value == item.id) {
         $inputElement.props.selected = "";
      }
      return $inputElement;
   }

   html($h) {
      // NOTE: Async/$store lookups need to be initiated WITHIN the html()
      // action for Framework7 to register the UI to update once the data is
      // updated.
      let field = this.field();
      if (field.isConnection) {
         let myVal = this.AB.$store.getters[field.id]?.value;
      }

      return $h`
         <div class="item-content item-input">
            <div class="item-inner">
               <div class="item-title item-label">${field?.label}</div>
               <div class="item-input-wrap">
                  <select id=${this.idFormElement} name=${field?.columnName}>
                     ${this.options.map((item) => this.inputElement($h, item))}
                  </select>
               </div>
            </div>
         </div>
         `;
   }
}


/***/ }),

/***/ 36959:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewFormTextbox.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewFormTextbox)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewFormTextboxCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormTextboxCore.js */ 10048);
/**
 * ABMobileViewFormTextbox
 * The view that displays a form textbox on the screen.
 */



class ABMobileViewFormTextbox extends _core_mobile_ABMobileViewFormTextboxCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {}

   inputElement($h) {
      let $inputElement = "";
      let field = this.field();
      let placeholder = this.settings.placeholder ?? "";

      switch (this.settings.type) {
         case "multiple":
            $inputElement = $h`
               <textarea
                  id=${this.idFormElement}
                  name=${field.columnName}
                  placeholder=${placeholder}
                  class="resizable"
               ></textarea>
            `;
            break;

         // case "email":
         //    $inputElement =
         //       definition.settings.required === 1 ? (
         //          <input
         //             type="email"
         //             name={definition.field}
         //             placeholder={definition.placeholder}
         //             required
         //             validate
         //          ></input>
         //       ) : (
         //          <input
         //             type="email"
         //             name={definition.field}
         //             placeholder={definition.placeholder}
         //             required
         //             validate
         //          ></input>
         //       );

         //    break;

         default:
            // "single"
            // "rich"
            $inputElement = $h`
               <input
                  id=${this.idFormElement}
                  name=${field.columnName}
                  placeholder=${placeholder}
                  type="text"
               />
            `;
            break;
      }

      this.updateProperties($inputElement);

      return $inputElement;
   }
}


/***/ }),

/***/ 84205:
/*!****************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewLabel.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewLabel)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewLabelCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewLabelCore.js */ 35272);
/**
 * ABMobileViewLabel
 * The view that displays a label on the screen.
 */



class ABMobileViewLabel extends _core_mobile_ABMobileViewLabelCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {}

   get style() {
      let style = "";
      switch (this.settings.format) {
         case 0:
         case "0": // normal
            style = "";
            break;

         case 1:
         case "1": // title
            style = "title-large-text";
            break;

         case 2:
         case "2": // description
            style = "description";
            break;
      }
      return style;
   }

   get alignment() {
      let align = "";
      switch (this.settings.alignment) {
         case "left":
            align = "text-align-left";
            break;

         case "right":
            align = "text-align-right";
            break;

         case "center":
            align = "text-align-center";
            break;
      }
      return align;
   }

   html($h) {
      return () =>
         $h`<div class="${this.style} ${this.alignment}">${this.text}</div>`;
   }
}


/***/ }),

/***/ 78261:
/*!***************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewList.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewList)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewListCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewListCore.js */ 26218);
/**
 * ABMobileViewList
 * The view that displays a list on the screen.
 */



class ABMobileViewList extends _core_mobile_ABMobileViewListCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {
      this.isSwipeout = {};
      // {hash} { item.uuid : bool }
      // keeps track of which item was in the process of a swipeout.
      // This prevents the click events from triggering an .itemSelected()
      // during a swipeout event.

      this.AB.$(`#${this.idList}`)
         .find(".swipeout")
         .on("swipeout:open", (e) => {
            let id = this.AB.$(e.target).data("id");
            this.isSwipeout[id] = true;
         });

      this.AB.$(`#${this.idList}`)
         .find(".swipeout")
         .on("swipeout:closed", (e) => {
            let id = this.AB.$(e.target).data("id");
            this.isSwipeout[id] = false;
         });

      this.AB.$(`#${this.idList}`)
         .find(".swipeout")
         .on("swipeout:delete", async (e) => {
            let id = this.AB.$(e.target).data("id");
            this.isSwipeout[id] = false;

            let success = await this.itemDeleted(id);
            if (!success) {
               e.preventDefault();
            }
         });

      setTimeout(() => {
         let dc = this.datacollection;
         let allVals = dc.$state[dc.id];
         dc.$state[dc.id] = allVals;
      }, 30);

      // let dc = this.datacollection;
      // dc.once("initializedData", () => {
      //    // this triggers a change in the F7 store and updates the display
      //    // hopefully this gets rid of that lingering progress indicator
      //    let allVals = dc.$state[dc.id];
      //    dc.$state[dc.id] = allVals;
      // });
   }

   async itemDeleted(id) {
      let CurrentObject = this.datacollection.datasource;
      try {
         let response = await CurrentObject.model().delete(id);

         if (response) {
            // there should have been an ab.datacollection.delete trigger
            // that takes care of removing the item from the DC.
            // this.datacollection.
            return true;
         } else {
            let L = this.AB.Label();
            this.AB.$f7.dialog.alert(
               L("No rows were effected.  This does not seem right."),
               L("Error")
            );
            return false;
         }
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABMobileViewList.itemDeleted()",
            message: "Error deleting item",
            obj: CurrentObject.toObj(),
            id,
         });
         return false;
      }
   }

   itemSelected(item) {
      // prevent random clicks when processing a swipeout
      if (this.isSwipeout[item.uuid]) return;

      // Make sure our DC registers which item was just selected.
      const dc = this.datacollection;

      if (dc) {
         dc.setCursor(item[dc.datasource.PK()] || item.id || item.uuid);
      }

      // if there is a detailPage set, then transition there:
      if (this.settings.linkPageDetail) {
         const DetailPage = this.application.pageByID(
            this.settings.linkPageDetail
         );

         DetailPage.show(true);
         // .show(showBack = true)
      }
   }

   openAddPage() {
      if (this.settings.linkPageAdd) {
         const addPage = this.application.pageByID(this.settings.linkPageAdd);
         if (addPage) {
            addPage.show(true);
            // .show(true) => show back button
         }
      }
   }

   loadMore() {
      // if (this.$store.getters[this.#settings.dcID].value.hasMore) {
      let dc = this.datacollection;
      if (dc && dc.hasMore()) {
         this.AB.$store.dispatch("getAppBuilderData", dc.id);
      }
   }

   hasMore($h) {
      if (this.datacollection.hasMore()) {
         return $h`<div class="preloader infinite-scroll-preloader"></div>`;
      }
   }

   template(item) {
      let field = this.field();
      if (field) {
         return field.format(item);
      }
      return "";
   }

   get idList() {
      return `L${this.id}`;
   }
   idItem(item) {
      return `I${item.uuid}`;
   }

   listItems($h) {
      const L = this.AB.Label();

      return this.AB.$store.getters[this.datacollection.id].value.map(
         (item) => $h`
         <li id=${this.idItem(item)} data-id=${
            item.uuid
         } class="swipeout deleted-callback">
            <div class="swipeout-content" >
               <div 
                  class="item-content"
                  onClick=${() => this.itemSelected(item)}
               >
                  <div class="item-inner">
                     <div class="item-title">${this.template(item)}</div>
                  </div>
               </div>
            </div>
            <div class="swipeout-actions-right">
               <a
                  href="#"
                  class="swipeout-delete"
                  data-confirm=${L("Are you sure want to delete this item?")}
                  data-confirm-title=${L("Delete?")}
               >
                  ${L("Delete")}
               </a>
            </div>
         </li>`
      );
   }

   addButton($h) {
      if (!this.settings.linkPageAdd) return "";

      return $h`
<div class="float-right">
   <a 
       href="#" 
       class="link icon-only"
       onclick=${() => {
          this.openAddPage();
       }}
   >
   <i class="icon f7-icons if-not-md">plus</i>
   <i class="icon material-icons md-only">add</i>
   </a>
</div>`;
   }

   listTitle($h) {
      // hide Title bar if nothing to display:
      if (this.settings.hideTitle && !this.settings.linkPageAdd) {
         return "";
      }

      return $h`
<div class="block-title block-title-medium no-margin-after">
  ${!this.settings.hideTitle ? this.label : ""}
  ${this.addButton($h)}
</div>
      `;
   }

   /**
    * @method searchBar()
    * return the DOM for adding a searchbar
    * @param {$h} $h
    *        Framework7 Template tool
    * @return $h Template
    */
   searchBar($h) {
      return "";

      // @TODO:
      // - create a SearchFilterSort Bar Widget
      // - check if this.settings.includeSearchBar is set
      // - return the this.SearchFilterSort.html($h)

      // Questions:
      // does the SearchFilterSortBar update the data in the DC
      // directly?  This seems how F7 will update the display.
      // But it will effect anything that uses the same DC.
   }

   html($h) {
      // return () =>
      //    $h`<div class="${this.style} ${this.alignment}">${this.text}</div>`;

      let dc = this.datacollection;

      if (!dc || this.AB.$store.getters[dc.id].value.length === 0)
         return () => $h`
               ${this.listTitle($h)}
               <div class="list links-list list-outline list-strong list-dividers skeleton-text skeleton-effect-fade">
                  <ul>
                     ${[...Array(20)].map(
                        (/* x, i */) => $h`
                        <li>
                           <a href="#">Skeleton text will go here</a>
                        </li>`
                     )}
                  </ul>
               </div>
           
         `;

      return () => $h`
         ${this.listTitle($h)}
         ${this.searchBar($h)}
         <div
            id=${this.idList}
            class="infinite-scroll-content"
            onInfinite=${() => this.loadMore()}
         >
            <div class="list links-list list-outline list-strong list-dividers">
               <ul>${this.listItems($h)}</ul>
            </div>
            ${this.hasMore($h)}
         </div>`;
   }
}


/***/ }),

/***/ 15103:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileViewTimeline.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewTimeline)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewTimelineCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewTimelineCore.js */ 63445);
/**
 * ABMobileViewTimeline
 * The view that displays a timeline on the screen.
 */


class ABMobileViewTimeline extends _core_mobile_ABMobileViewTimelineCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(...params) {
   //    super(...params);
   // }

   async init() {
      this.isSwipeout = {};
      // {hash} { item.uuid : bool }
      // keeps track of which item was in the process of a swipeout.
      // This prevents the click events from triggering an .itemSelected()
      // during a swipeout event.
      this.AB.$(`#${this.idList}`)
         .find(".swipeout")
         .on("swipeout:open", (e) => {
            let id = this.AB.$(e.target).data("id");
            this.isSwipeout[id] = true;
         });
      this.AB.$(`#${this.idList}`)
         .find(".swipeout")
         .on("swipeout:closed", (e) => {
            let id = this.AB.$(e.target).data("id");
            this.isSwipeout[id] = false;
         });
      this.AB.$(`#${this.idList}`)
         .find(".swipeout")
         .on("swipeout:delete", async (e) => {
            let id = this.AB.$(e.target).data("id");
            this.isSwipeout[id] = false;
            let success = await this.itemDeleted(id);
            if (!success) {
               e.preventDefault();
            }
         });
      // this triggers a change in the F7 store and updates the display
      // hopefully this gets rid of that lingering progress indicator
      setTimeout(() => {
         let dc = this.datacollection;
         let allVals = dc.$state[dc.id];
         dc.$state[dc.id] = allVals;
      }, 30);
      // let dc = this.datacollection;
      // dc.once("initializedData", () => {
      //    // this triggers a change in the F7 store and updates the display
      //    // hopefully this gets rid of that lingering progress indicator
      //    let allVals = dc.$state[dc.id];
      //    dc.$state[dc.id] = allVals;
      // });
   }

   async itemDeleted(id) {
      let CurrentObject = this.datacollection.datasource;
      try {
         let response = await CurrentObject.model().delete(id);

         if (response) {
            // there should have been an ab.datacollection.delete trigger
            // that takes care of removing the item from the DC.
            // this.datacollection.
            return true;
         } else {
            let L = this.AB.Label();
            this.AB.$f7.dialog.alert(
               L("No rows were effected.  This does not seem right."),
               L("Error")
            );
            return false;
         }
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABMobileViewList.itemDeleted()",
            message: "Error deleting item",
            obj: CurrentObject.toObj(),
            id,
         });
         return false;
      }
   }

   itemSelected(item) {
      // prevent random clicks when processing a swipeout
      if ( (typeof(this.isSwipeout) != "undefined") && this.isSwipeout[item.uuid]) return;

      // Make sure our DC registers which item was just selected.
      const dc = this.datacollection;

      if (dc) {
         dc.setCursor(item[dc.datasource.PK()] || item.id || item.uuid);
      }

      // if there is a detailPage set, then transition there:
      if (this.settings.linkPageDetail) {
         const DetailPage = this.application.pageByID(
            this.settings.linkPageDetail
         );

         DetailPage.show(true);
         // .show(showBack = true)
      }
   }

   openAddPage() {
      if (this.settings.linkPageAdd) {
         const addPage = this.application.pageByID(this.settings.linkPageAdd);
         if (addPage) {
            addPage.show(true);
            // .show(true) => show back button
         }
      }
   }

   loadMore() {
      // if (this.$store.getters[this.#settings.dcID].value.hasMore) {
      let dc = this.datacollection;
      if (dc && dc.hasMore()) {
         this.AB.$store.dispatch("getAppBuilderData", dc.id);
      }
   }

   hasMore($h) {
      if (this.datacollection.hasMore()) {
         return $h`<div class="preloader infinite-scroll-preloader"></div>`;
      }
   }

   template($h, item) {
      var dv = this.datacollection;
      if (!dv) return null;

      var object = dv.datasource;
      if (!object) return null;

      let template = this.AB.cloneDeep(this.settings.templateItem);
      if (template) {
         object.fields().forEach((field) => {
            let key = `{${field.id}}`;

            template = template.replace(key, field.format(item));
         });
      }

      template = `$h\`${template}\``;
      return eval(template);
   }

   get idList() {
      return `L${this.id}`;
   }
   idItem(item) {
      return `I${item.uuid}`;
   }

   listItemDate($h, listItems) {
      let L = this.AB.Label();

      return listItems.map((item) => {
         return $h`
         <li id=${this.idItem(item)} data-id=${
            item.uuid
         } class="swipeout deleted-callback">

            <div class="swipeout-content" >
               <div 
                  class="timeline-item-content"
                  onClick=${() => this.itemSelected(item)}
               >
                  <div class="timeline-item-inner">
                     ${this.template($h, item)}
                  </div>
               </div>
            </div>
            <div class="swipeout-actions-right">
               <a
                  href="#"
                  class="swipeout-delete"
                  data-confirm=${L("Are you sure want to delete this item?")}
                  data-confirm-title=${L("Delete?")}
               >
                  <i class="fa fa-trash"></i>
               </a>
            </div>
         </li>`;
      });
   }

   listItems($h, dateHash) {
      const L = this.AB.Label();

      let keys = Object.keys(dateHash).sort();

      return keys.map((date) => {
         let dates = date.split(":");
         let showDate = $h`${dates[1]} <small> ${dates[0]} </small>`;
         return $h`
            <div class="timeline-item">
              <div class="timeline-item-date">${showDate}</div>
              <div class="timeline-item-divider"></div>
              <div class="timeline-item-content" list inset no-ios-edges>
               <ul>
                ${this.listItemDate($h, dateHash[date])}
                </ul>
              </div>
            </div>`;
      });
   }

   addButton($h) {
      if (!this.settings.linkPageAdd) return "";

      return $h`
<div class="float-right">
   <a 
       href="#" 
       class="link icon-only"
       onclick=${() => {
          this.openAddPage();
       }}
   >
   <i class="icon f7-icons if-not-md">plus</i>
   <i class="icon material-icons md-only">add</i>
   </a>
</div>`;
   }

   listTitle($h) {
      // hide Title bar if nothing to display:
      if (this.settings.hideTitle && !this.settings.linkPageAdd) {
         return "";
      }

      return $h`
<div class="block-title block-title-medium no-margin-after">
  ${!this.settings.hideTitle ? this.label : ""}
  ${this.addButton($h)}
</div>
      `;
   }

   /**
    * @method searchBar()
    * return the DOM for adding a searchbar
    * @param {$h} $h
    *        Framework7 Template tool
    * @return $h Template
    */
   searchBar($h) {
      return "";

      // @TODO:
      // - create a SearchFilterSort Bar Widget
      // - check if this.settings.includeSearchBar is set
      // - return the this.SearchFilterSort.html($h)

      // Questions:
      // does the SearchFilterSortBar update the data in the DC
      // directly?  This seems how F7 will update the display.
      // But it will effect anything that uses the same DC.
   }

   html($h) {
      // return () =>
      //    $h`<div class="${this.style} ${this.alignment}">${this.text}</div>`;

      let dc = this.datacollection;

      if (!dc || this.AB.$store.getters[dc.id].value.length === 0)
         return () => $h`
               ${this.listTitle($h)}
               <div class="list links-list list-outline list-strong list-dividers skeleton-text skeleton-effect-fade">
                  <ul>
                     ${[...Array(20)].map(
                        (/* x, i */) => $h`
                        <li>
                           <a href="#">Skeleton text will go here</a>
                        </li>`
                     )}
                  </ul>
               </div>
           
         `;

      // build a date/hash of our current values
      let dateHash = {
         /* date : [ entries for this date ] */
      };

      let dateField = dc.datasource.fields(
         (f) => f.id == this.settings.dateField
      )[0];
      if (dateField) {
         let values = this.AB.$store.getters[dc.id].value;
         values.forEach((row) => {
            let date = row[dateField.columnName];
            if (date) {
               date = this.AB.rules.toDateFormat(date, {
                  format: "MMM:DD:YYYY",
               });
               if (!dateHash[date]) {
                  dateHash[date] = [];
               }
               dateHash[date].push(row);
            }
         });
      }

      return () => $h`
         ${this.listTitle($h)}
         ${this.searchBar($h)}
         <div 
            id=${this.idList}
            class="timeline"
         >
            ${this.listItems($h, dateHash)}
         </div>`;
   }
}


/***/ }),

/***/ 53691:
/*!*********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ViewFormSelectMultiple.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ViewFormSelectMultiple)
/* harmony export */ });
/* harmony import */ var _ViewFormSelectSingle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewFormSelectSingle */ 61554);


class ViewFormSelectMultiple extends _ViewFormSelectSingle__WEBPACK_IMPORTED_MODULE_0__["default"] {
   html($h) {
      let value = this.options.find((o) => o.id == this.value)?.text;
      return $h`
         <a href="#" class="item-link smart-select smart-select-init">
            <select
               name=${this.field.columnName}
               multiple
            >
               ${this.options.map((item) => this.inputElement($h, item))}
            </select>
            <div class="item-content">
               <div class="item-inner">
                  <div class="item-title">${this.field.label}</div>
                  <div class="item-after">${value || "Value"}</div>
               </div>
            </div>
         </a>
         `;
   }
}


/***/ }),

/***/ 61554:
/*!*******************************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ViewFormSelectSingle.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ViewFormSelectSingle)
/* harmony export */ });
class ViewFormSelectSingle {
   constructor(AB, field, value = null) {
      this.AB = AB;
      this.field = field;

      this.options = [
         /* {id, text} */
         // { id: 1, text: "one" },
         // { id: 2, text: "two" },
         // { id: 3, text: "three" },
      ];

      this.value = value;
   }

   setOptions(values, k = "id", t = "text") {
      this.options = [];
      (values || []).forEach((v) => {
         this.options.push({ id: v[k], text: v[t] });
      });
   }

   setValue(vid) {
      this.value = vid;
   }

   inputElement($h, item) {
      let $inputElement = $h`<option value=${item.id}>${item.text}</option>`;
      if (this.value == item.id) {
         $inputElement.props.selected = "";
      }
      return $inputElement;
   }

   html($h) {
      return $h`
         <div class="item-content item-input">
            <div class="item-inner">
               <div class="item-title item-label">${this.field.label}</div>
               <div class="item-input-wrap">
                  <select name=${this.field.columnName}>
                     ${this.options.map((item) => this.inputElement($h, item))}
                  </select>
               </div>
            </div>
         </div>
         `;
   }
}


/***/ }),

/***/ 23479:
/*!*************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/ABProcessLane.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessLane)
/* harmony export */ });
/* harmony import */ var _core_process_ABProcessLaneCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/process/ABProcessLaneCore */ 46446);
/**
 * ABProcessLane
 * manages a lane in a Process Diagram.
 *
 * Lanes manage users in the system, and provide a way to lookup a SiteUser.
 */


class ABProcessLane extends _core_process_ABProcessLaneCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, process, application) {
   //    super(attributes, process, application);
   // }

   ////
   //// Modeler Instance Methods
   ////

   transferParticipantWhereToMe(id) {
      var myParticipant = this.process.elementForDiagramID(id);
      if (myParticipant) {
         // if I haven't already set my where clause, and my Participant
         // has one, then take it:
         if (!this.stashed && myParticipant.stashed) {
            var copyParams = [
               "stashed",
               "useRole",
               "role",
               "useAccount",
               "account",
            ];
            copyParams.forEach((p) => {
               var swap = this[p];
               this[p] = myParticipant[p];
               myParticipant[p] = swap; // ?? do this ??
            });
         }
      }
   }

   /**
    * fromElement()
    * initialize this Lane's values from the given BPMN:Lane
    * @param {BPMNParticipant}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;

      // on creation, if I have child objects, then move the .where definition
      // from my parent Participant to ME
      if (element.children && element.children.length > 0) {
         if (element.parent && element.parent.type == "bpmn:Participant") {
            this.transferParticipantWhereToMe(element.parent.id);
         }
      } else {
         // this info might just reside in the .parent.children[]
         if (
            element.parent &&
            element.parent.children &&
            element.parent.children.length > 0
         ) {
            element.parent.children.forEach((child) => {
               if (child.type != "bpmn:Lane") {
                  // if child has lanes
                  if (
                     child.businessObject.lanes &&
                     child.businessObject.lanes.length > 0
                  ) {
                     // if lane is me
                     var myLane = child.businessObject.lanes.find((l) => {
                        return l.id == this.diagramID;
                     });
                     if (myLane) {
                        this.transferParticipantWhereToMe(element.parent.id);

                        // tell child I'm it's lane:
                        var objChild = this.process.elementForDiagramID(
                           child.id
                        );
                        if (objChild) {
                           objChild.setLane(this);
                        }
                     }
                  }
               }
            });
         }
      }

      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Lane with information that was relevant
    * from the provided BPMN:Lane
    * @param {BPMNParticipant}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Participant_185ljkg",
                "width": 958,
                "height": 240,
                "type": "bpmn:Participant",
                "x": -810,
                "y": -2010,
                "order": {
                    "level": -2
                },
               "businessObject": {
                    "$type": "bpmn:Participant",
                    "id": "Participant_185ljkg",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": -810,
                            "y": -2010,
                            "width": 958,
                            "height": 240
                        },
                        "id": "Participant_185ljkg_di",
                        "isHorizontal": true
                    },
                    "processRef": {
                        "$type": "bpmn:Process",
                        "id": "Process_0x3sul5"
                    }
                }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      // if I picked up a new task, inform it I am it's lane:
   }
}


/***/ }),

/***/ 74843:
/*!********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/ABProcessParticipant.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessParticipant)
/* harmony export */ });
/* harmony import */ var _core_process_ABProcessParticipantCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/process/ABProcessParticipantCore */ 71206);
/**
 * ABProcessParticipant
 * manages the participant lanes in a Process Diagram.
 *
 * Participants manage users in the system (when there are no lanes defined)
 * and provide a way to lookup a SiteUser.
 */


class ABProcessParticipant extends _core_process_ABProcessParticipantCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, process, AB) {
   //    super(attributes, process, AB);
   // }

   ////
   //// Modeler Instance Methods
   ////

   /**
    * fromElement()
    * initialize this Participant's values from the given BPMN:Participant
    * @param {BPMNParticipant}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;
      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Participant with information that was relevant
    * from the provided BPMN:Participant
    * @param {BPMNParticipant}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Participant_185ljkg",
                "width": 958,
                "height": 240,
                "type": "bpmn:Participant",
                "x": -810,
                "y": -2010,
                "order": {
                    "level": -2
                },
               "businessObject": {
                    "$type": "bpmn:Participant",
                    "id": "Participant_185ljkg",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": -810,
                            "y": -2010,
                            "width": 958,
                            "height": 240
                        },
                        "id": "Participant_185ljkg_di",
                        "isHorizontal": true
                    },
                    "processRef": {
                        "$type": "bpmn:Process",
                        "id": "Process_0x3sul5"
                    }
                }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      if (defElement.children) {
         var laneIDs = [];
         defElement.children.forEach((c) => {
            if (c.type == "bpmn:Lane") {
               laneIDs.push(c.id);
            }
         });
         this.laneIDs = laneIDs;
      }
   }

   /**
    * diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this objec.
    * @return {json}
    */
   diagramProperties() {
      return [
         {
            id: this.diagramID,
            def: {
               name: this.name,
            },
         },
      ];
   }
}


/***/ }),

/***/ 50138:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessElement.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessElement)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessElementCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessElementCore.js */ 72935);


class ABProcessElement extends _core_process_tasks_ABProcessElementCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, process, AB, defaultValues) {
   //    super(attributes, process, AB, defaultValues);

   //    // listen
   // }

   /**
    * @method destroy()
    * remove this task definition.
    * @return {Promise}
    */
   destroy() {
      ////
      //// TODO: once our core conversion is complete, this .save() can be
      //// moved to ABProcessTaskCore, and our ABDefinition.save() can take
      //// care of the proper method to save depending on the current Platform.
      ////
      // return this.toDefinition()
      //     .destroy()

      return super.destroy().then(() => {
         return this.process.elementRemove(this);
      });
   }

   isValid() {
      /*
        var validator = OP.Validation.validator();

        // label/name must be unique:
        var isNameUnique =
            this.AB.processes((o) => {
                return o.name.toLowerCase() == this.name.toLowerCase();
            }).length == 0;
        if (!isNameUnique) {
            validator.addError(
                "name",
                L(
                    "ab.validation.object.name.unique",
                    `Process name must be unique ("${this.name}"" already used in this Application)`
                )
            );
        }

        return validator;
        */

      // var isValid =
      //     this.AB.processes((o) => {
      //         return o.name.toLowerCase() == this.name.toLowerCase();
      //     }).length == 0;
      // return isValid;

      return true;
   }

   ////
   //// Modeler Instance Methods
   ////

   findLane(curr, cb) {
      if (!curr) {
         cb(null, null);
         return;
      }

      // if current object has a LANE definition, use that one:
      if (curr.lanes && curr.lanes.length > 0) {
         cb(null, curr.lanes[0]);
      } else if (curr.$type == "bpmn:Participant") {
         // if the current is a Participant, take that one
         cb(null, curr);
      } else {
         // else move upwards and check again:
         curr = curr.$parent;
         this.findLane(curr, cb);
      }
   }

   setLane(Lane) {
      this.laneDiagramID = Lane.diagramID;
   }

   /**
    * fromElement()
    * initialize this Task's values from the given BPMN:Element
    * @param {BPMNElement}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;
      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Task with information that was relevant
    * from the provided BPMN:Element
    * @param {BPMNElement}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Task_08j07ni",
                "width": 100,
                "height": 80,
                "type": "bpmn:SendTask",
                "x": 20,
                "y": -2130,
                "order": {
                    "level": 5
                },
                "businessObject": {
                    "$type": "bpmn:SendTask",
                    "id": "Task_08j07ni",
                    "name": "ffff",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": 20,
                            "y": -2130,
                            "width": 100,
                            "height": 80
                        },
                        "id": "SendTask_0iidv6o_di"
                    }

                    // Some elements (like EndEvents) have:
                    .eventDefinitions: [
                        {
                            $type: "actual bpmn:ElementType",
                            ...
                        }
                    ]
                },
                "incoming":[],
                "outgoing":[]
            }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      // our lane may have changed:
      var currObj = defElement.businessObject;
      this.findLane(currObj, (err, obj) => {
         if (obj) {
            this.laneDiagramID = obj.id;
         } else {
            // if my parent shape is a Participant, then use that:
            if (
               defElement.parent &&
               defElement.parent.type == "bpmn:Participant"
            ) {
               this.laneDiagramID = defElement.parent.id;
            } else {
               this.laneDiagramID = null;
            }
         }
      });
   }

   /**
    * diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this object.
    * @return {json}
    */
   diagramProperties() {
      const warnings = this.warnings();
      return [
         {
            id: this.diagramID,
            def: {
               name: this.name,
            },
            warn: warnings.length ? warnings : null,
         },
      ];
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      let L = this.AB.Label();
      var ui = {
         id: id,
         view: "label",
         label: L("this task has not implement properties yet..."),
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {}

   /**
    * property()
    * return the specific property value if it exists.
    * @return {mixed} | undefined
    */
   property(id) {
      if ($$(id)) {
         return $$(id).getValue();
      }
   }

   /**
    * switchTo()
    * replace this object with an instance of one of our child classes:
    * @param {ABProcessTask*} child
    *        an instance of the new Process Task we are replaced with.
    * @param {string} propertiesID
    *        the webix ui.id container for the properties panel.
    */
   switchTo(child, propertiesID) {
      // remove myself from our containing process's elements
      this.process.elementRemove(this);

      // add the new Process WITH the same id
      this.process.elementAdd(child);

      // show the child properties:
      child.propertiesShow(propertiesID);

      this.emit("switchTo", child);
   }

   /**
    * @method warningsEval()
    * re-evaluate our warnings for this Process Task.
    * Most of our ProcessTasks need to also verify data related to
    * other available tasks, so we need to call the onProcessReady()
    * so we can access those values.
    */
   warningsEval() {
      super.warningsEval();
      this.onProcessReady();

      // if this isn't an end type of task, then there must be
      // > 0 next tasks
      if (!this.isEndTask()) {
         const myOutgoingConnections = this.process.connectionsOutgoing(
            this.diagramID
         );
         if (myOutgoingConnections.length < 1) {
            this.warningMessage("should have another task after this one");
         }
      }
   }

   /**
    * @method warningMessage(message)
    * Save a warning message in a common format for our ProcessTasks.
    */
   warningMessage(msg, data = {}) {
      let message = `${this.defaults.key}[${
         this.label ? this.label : this.name
      }]: ${msg}`;
      this._warnings.push({ message, data });
   }
}


/***/ }),

/***/ 76975:
/*!******************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessEnd.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessEnd)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessEndCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessEndCore.js */ 15728);


class ABProcessEnd extends _core_process_tasks_ABProcessEndCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // An End Event doesn't perform any other actions
   //         // than to signal it has successfully completed.
   //         // But it provides no Additional Tasks to work on.
   //         // for testing:
   //         this.stateCompleted(instance);
   //         this.log(instance, "End Event Reached");
   //         resolve(true);
   //     });
   // }
}


/***/ }),

/***/ 33401:
/*!*******************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessGatewayExclusive.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessGatewayExclusive)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessGatewayExclusiveCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessGatewayExclusiveCore.js */ 89670);


class ABProcessGatewayExclusive extends _core_process_tasks_ABProcessGatewayExclusiveCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ////
   //// Process Instance Methods
   ////

   /**
    * diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this object.
    * @return {json}
    */
   diagramProperties() {
      // the first entry is for the gateway element itself
      var properties = super.diagramProperties();
      /*[
         {
            id: this.diagramID,
            def: {
               name: this.name,
            },
         },
      ];
      */

      // now add any additional updates for each of our connections:
      var myOutgoingConnections = this.process.connectionsOutgoing(
         this.diagramID
      );
      myOutgoingConnections.forEach((conn) => {
         properties.push({
            id: conn.id,
            def: {
               name: this.conditions[conn.id]?.label ?? "",
            },
         });
      });
      return properties;
   }

   warningsEval() {
      super.warningsEval();

      // make sure we have > 1 connection.
      const myOutgoingConnections = this.process.connectionsOutgoing(
         this.diagramID
      );
      if (myOutgoingConnections.length < 2) {
         this.warningMessage("should have multiple outgoing connections");
      }

      // make sure there is no more then 1 connection that doesn't have
      // a condition:
      let numCondWithOne = 0;
      myOutgoingConnections.forEach((c) => {
         if ((this.conditions[c.id]?.filterValue.rules?.length ?? 0) == 0) {
            numCondWithOne++;
         }
      });

      if (numCondWithOne > 1) {
         this.warningMessage(
            "should not have more than 1 unfiltered connection."
         );
      }
   }
}


/***/ }),

/***/ 21297:
/*!************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskEmail.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskEmail)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskEmailCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskEmailCore.js */ 95316);
// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()


class ABProcessTaskEmail extends _core_process_tasks_ABProcessTaskEmailCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ////
   //// Process Instance Methods
   ////

   warningsEval() {
      super.warningsEval();

      // check for warnings:

      if (!this.subject) {
         this.warningMessage("is missing a subject");
      }

      if (!this.message) {
         this.warningMessage("is missing a message");
      }

      this.verifySetting("to");
      this.verifySetting("from");
      this.verifyNextLane("to");
      if (this.from == "0") {
         let thisLane = this.myLane();
         if (!thisLane) {
            this.warningMessage(
               "can not resolve the lane participant for [.from] field."
            );
         }
      }
      this.verifyRoleAccount("to", "toUsers");
      this.verifyRoleAccount("from", "fromUsers");
   }

   /**
    * @method verifySetting()
    * make sure the given field key has a value assigned.
    * @param {string} key
    *        the property of this object to check. (to, from)
    */
   verifySetting(key) {
      if (this[key] == "") {
         this.warningMessage(`does not have a [${key}] setting.`);
      }
   }

   /**
    * @method verifyNextLane()
    * make sure we can access a Lane for the given property key.
    * The "to" field can reference the "Next Participant". This checks to
    * see if we can reference a lane for the next task.
    * @param {string} key
    *        the property that has the value for Next Participant. [to]
    */
   verifyNextLane(key) {
      if (this[key] === "0") {
         // Next Participant
         // we need to resolve our next task and see if we can pull the participant info from it.

         let nextTasks = this.process.connectionNextTask(this);
         let nextLanesResolved = true;
         nextTasks.forEach((t) => {
            let lane = t.myLane();
            if (!lane) {
               nextLanesResolved = false;
            }
         });
         if (!nextLanesResolved || nextTasks.length == 0) {
            this.warningMessage(
               `can not resolve next lane participant for [${key}] field.`
            );
         }
      }
   }

   /**
    * @method verifyRoleAccount()
    * Check to see if the provided property is set to use a Role/Account for
    * the email, and make sure there are values set for what is chosen.
    * @param {string} key
    *        the property we are currently validating.
    * @param {string} valKey
    *        the property that contains the specific value object.
    */
   verifyRoleAccount(key, valKey) {
      if (this[key] == "1") {
         if (this[valKey]) {
            if (this[valKey].useRole) {
               if (this[valKey].role.length == 0) {
                  this.warningMessage(`can not resolve [${key}] Role setting.`);
               }
            }
            if (this[valKey].useAccount) {
               if (this[valKey].account.length == 0) {
                  this.warningMessage(
                     `can not resolve [${key}] Account setting.`
                  );
               }
            }
            // TODO:
            // if (this[valKey].userFields.length > 0) {
            //    // how to know if this is a problem?
            // }
         }
      }
   }
}


/***/ }),

/***/ 66859:
/*!**************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskService.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskService)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskServiceCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceCore.js */ 74351);


class ABProcessTaskService extends _core_process_tasks_ABProcessTaskServiceCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 55048:
/*!***************************************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingBatchProcessing.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AccountingBatchProcessing)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskServiceAccountingBatchProcessingCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingBatchProcessingCore.js */ 80281);


class AccountingBatchProcessing extends _core_process_tasks_ABProcessTaskServiceAccountingBatchProcessingCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processBatchValue: `${id}_processBatchValue`,
         objectBatch: `${id}_objectBatch`,
         fieldBatchEntries: `${id}_fieldBatchEntries`,
         fieldBatchFinancialPeriod: `${id}_fieldBatchFinancialPeriod`,
         objectJE: `${id}_objectJE`,
         fieldJEAccount: `${id}_fieldJEAccount`,
         fieldJERC: `${id}_fieldJERC`,
         fieldJEStatus: `${id}_fieldJEStatus`,
         fieldJEStatusComplete: `${id}_fieldJEStatusComplete`,
         objectBR: `${id}_objectBR`,
         fieldBRFinancialPeriod: `${id}_fieldBRFinancialPeriod`,
         fieldBRAccount: `${id}_fieldBRAccount`,
         fieldBRRC: `${id}_fieldBRRC`,
         fieldBREntries: `${id}_fieldBREntries`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);
      var L = this.AB.Label();

      var processValues = [{ id: 0, value: L("Select a Process Value") }];
      var processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      var objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });
      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      //
      // set up field settings:
      //

      var blankField = {
         id: 0,
         value: L("Select a Field"),
      };
      // blankField : generic Select a field entry

      function defaultFields(objID) {
         // create a new options array of Field Choices for the given obj.id

         var fields = [blankField];
         if (objID) {
            var entry = objectList.find((o) => o.id == objID);
            if (entry && entry.object) {
               entry.object.fields().forEach((f) => {
                  fields.push({ id: f.id, value: f.label, field: f });
               });
            }
         }
         return fields;
      }

      function updateFields(fieldPickers, fieldValues, defaultValue) {
         // update the list of field select choices with the new field choices

         fieldPickers.forEach((fp) => {
            var picker = $$(fp);
            if (picker) {
               picker.define("options", fieldValues);
               // if (defaultValue) {
               //    picker.define("value", defaultValue);
               // } else {
               //    picker.define("value", fieldValues[0].value);
               // }
               picker.refresh();
               picker.show();
            }
         });
      }

      var batchFields = defaultFields(this.objectBatch);
      // batchFields : the default list of fields for the Batch Object

      var fieldPickersBatch = [
         ids.fieldBatchEntries,
         ids.fieldBatchFinancialPeriod,
      ];
      // fieldPickersBatch : the list of field selects to update for the Batch
      //      object.

      var jeFields = defaultFields(this.objectJE);
      // jeFields : the default list of fields for the Journal Entry Object

      var fieldPickersJE = [
         ids.fieldJEAccount,
         ids.fieldJERC,
         ids.fieldJEStatus,
      ];
      // fieldPickersJE : the list of field selects to update for the Journal Entry
      //      object.

      function compileStatusValues(statusField) {
         var values = [{ id: 0, value: L("Select the Complete Value") }];
         if (statusField && statusField.options) {
            statusField.options().forEach((o) => {
               values.push({ id: o.id, value: o.text });
            });
         }
         return values;
      }

      function updatePickerStatusComplete(values) {
         var wbxComplete = $$(ids.fieldJEStatusComplete);
         if (wbxComplete) {
            // update fieldJEStatusComplete options
            wbxComplete.define("options", values);
            wbxComplete.refresh();
            // show fieldJEStatusComplete
            wbxComplete.show();
         }
      }

      function onStatusComplete(newVal) {
         // pull the ABField object from newValue
         var jeEntryID = $$(ids.objectJE).getValue();
         var jeEntry = objectList.find((o) => o.id == jeEntryID);
         if (jeEntry && jeEntry.object) {
            var statusField = jeEntry.object.fieldByID(newVal);
            if (statusField && statusField.options) {
               // get the options as an []
               jeFieldStatusValues = compileStatusValues(statusField);

               updatePickerStatusComplete(jeFieldStatusValues);
            }
         }
      }

      var jeFieldStatusValues = compileStatusValues();
      // jeFieldStatusValues : the list of status options from the fieldJEStatus
      //      selected entry.

      var brFields = defaultFields(this.objectBR);
      // jeFields : the default list of fields for the Journal Entry Object

      var fieldPickersBR = [
         ids.fieldBRFinancialPeriod,
         ids.fieldBRAccount,
         ids.fieldBRRC,
         ids.fieldBREntries,
      ];
      // fieldPickersBR : the list of field selects to update for the Balance Record
      //      object.

      var ui = {
         id: id,
         view: "form",
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processBatchValue,
               view: "select",
               label: L("Process Batch Value"),
               value: this.processBatchValue,
               name: "processBatchValue",
               options: processValues,
            },
            {
               id: ids.objectBatch,
               view: "select",
               label: L("Batch Object"),
               value: this.objectBatch,
               name: "objectBatch",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of batchFields
                        batchFields = defaultFields(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFields(fieldPickersBatch, batchFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldBatchEntries,
               view: "select",
               label: L("Batch->JE[]"),
               value: this.fieldBatchEntries,
               name: "fieldBatchEntries",
               options: batchFields,
               hidden: true,
            },
            {
               id: ids.fieldBatchFinancialPeriod,
               view: "select",
               label: L("Batch->FinancialPeriod"),
               value: this.fieldBatchFinancialPeriod,
               name: "fieldBatchFinancialPeriod",
               options: batchFields,
               hidden: true,
            },
            {
               id: ids.objectJE,
               view: "select",
               label: L("Journal Entry Object"),
               value: this.objectJE,
               name: "objectJE",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of jeFields
                        jeFields = defaultFields(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFields(fieldPickersJE, jeFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldJEAccount,
               view: "select",
               label: L("JE->Account"),
               value: this.fieldJEAccount,
               name: "fieldJEAccount",
               options: jeFields,
               hidden: true,
            },
            {
               id: ids.fieldJERC,
               view: "select",
               label: L("JE->RC"),
               value: this.fieldJERC,
               name: "fieldJERC",
               options: jeFields,
               hidden: true,
            },
            {
               id: ids.fieldJEStatus,
               view: "select",
               label: L("JE->Status"),
               value: this.fieldJEStatus,
               name: "fieldJEStatus",
               options: jeFields,
               hidden: true,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        onStatusComplete(newVal);
                     }
                  },
               },
            },
            {
               id: ids.fieldJEStatusComplete,
               view: "select",
               label: L("JE->Status->Complete"),
               value: this.fieldJEStatusComplete,
               name: "fieldJEStatusComplete",
               options: jeFieldStatusValues,
               hidden: true,
            },
            {
               id: ids.objectBR,
               view: "select",
               label: L("Balance Record"),
               value: this.objectBR,
               name: "objectBR",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of jeFields
                        brFields = defaultFields(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFields(fieldPickersBR, brFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldBRFinancialPeriod,
               view: "select",
               label: L("BR->FP"),
               value: this.fieldBRFinancialPeriod,
               name: "fieldBRFinancialPeriod",
               options: brFields,
               hidden: true,
            },
            {
               id: ids.fieldBRAccount,
               view: "select",
               label: L("BR->Account"),
               value: this.fieldBRAccount,
               name: "fieldBRAccount",
               options: brFields,
               hidden: true,
            },
            {
               id: ids.fieldBRRC,
               view: "select",
               label: L("BR->RC"),
               value: this.fieldBRRC,
               name: "fieldBRRC",
               options: brFields,
               hidden: true,
            },
            {
               id: ids.fieldBREntries,
               view: "select",
               label: L("BR->Entries"),
               value: this.fieldBREntries,
               name: "fieldBREntries",
               options: brFields,
               hidden: true,
            },
         ],
      };

      webix.ui(ui, $$(id));

      // if there are already default values for our Objects,
      // unhide the field selectors:
      if (this.objectBatch && this.objectBatch != 0) {
         updateFields(fieldPickersBatch, batchFields);
      }

      if (this.objectJE && this.objectJE != 0) {
         updateFields(fieldPickersJE, jeFields);
      }

      if (this.fieldJEStatus) {
         onStatusComplete(this.fieldJEStatus);
      }

      if (this.objectBR && this.objectBR != 0) {
         updateFields(fieldPickersBR, brFields);
      }

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      this.defaults.settings.forEach((s) => {
         this[s] = this.property(ids[s]);
      });
   }
}


/***/ }),

/***/ 29084:
/*!*******************************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingFPClose.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AccountingFPClose)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskServiceAccountingFPCloseCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingFPCloseCore.js */ 35137);


class AccountingFPClose extends _core_process_tasks_ABProcessTaskServiceAccountingFPCloseCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processFPValue: `${id}_processFPValue`,
         objectFP: `${id}_objectFP`,
         objectGL: `${id}_objectGL`,
         objectAcc: `${id}_objectAcc`,
         fieldFPStart: `${id}_fieldFPStart`,
         fieldFPOpen: `${id}_fieldFPOpen`,
         fieldFPStatus: `${id}_fieldFPStatus`,
         fieldFPActive: `${id}_fieldFPActive`,
         fieldGLStarting: `${id}_fieldGLStarting`,
         fieldGLRunning: `${id}_fieldGLRunning`,
         fieldGLAccount: `${id}_fieldGLAccount`,
         fieldGLRc: `${id}_fieldGLRc`,
         fieldGLDebit: `${id}fieldGLDebit`,
         fieldGLCredit: `${id}_fieldGLCredit`,
         fieldAccType: `${id}_fieldAccType`,
         fieldAccAsset: `${id}_fieldAccAsset`,
         fieldAccExpense: `${id}_fieldAccExpense`,
         fieldAccLiabilities: `${id}_fieldAccLiabilities`,
         fieldAccEquity: `${id}_fieldAccEquity`,
         fieldAccIncome: `${id}_fieldAccIncome`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);
      var L = this.AB.Label();

      var processValues = [{ id: 0, value: L("Select a Process Value") }];
      var processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      var objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });
      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      let getFieldOptions = (objID) => {
         let fields = [
            {
               id: 0,
               value: L("Select a Field"),
            },
         ];

         if (objID) {
            var entry = objectList.find((o) => o.id == objID);
            if (entry && entry.object) {
               entry.object.fields().forEach((f) => {
                  fields.push({ id: f.id, value: f.label, field: f });
               });
            }
         }
         return fields;
      };

      let getStatusFieldOptions = (statusFieldId) => {
         let result = [];
         let fpObject = this.AB.objectByID(this.objectFP);
         if (!fpObject) return result;

         let fpStatusField = fpObject.fieldByID(statusFieldId);
         if (
            !fpStatusField ||
            !fpStatusField.settings ||
            !fpStatusField.settings.options
         )
            return result;

         result = (fpStatusField.settings.options || []).map((opt) => {
            return {
               id: opt.id,
               value: opt.text,
            };
         });

         return result;
      };

      let updateFPFields = (fpFields) => {
         [ids.fieldFPStart, ids.fieldFPOpen, ids.fieldFPStatus].forEach(
            (fieldGLElem) => {
               $$(fieldGLElem).define("options", fpFields);
               $$(fieldGLElem).refresh();
            }
         );
      };

      let updateFPStatusFields = (fpStatusOptions) => {
         $$(ids.fieldFPActive).define("options", fpStatusOptions);
         $$(ids.fieldFPActive).refresh();
      };

      let updateGLFields = (glFields) => {
         [
            ids.fieldGLRunning,
            ids.fieldGLAccount,
            ids.fieldGLRc,
            ids.fieldGLDebit,
            ids.fieldGLCredit,
         ].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", glFields);
            $$(fieldGLElem).refresh();
         });
      };

      let updateAccFields = (accFields) => {
         $$(ids.fieldAccType).define("options", accFields);
         $$(ids.fieldAccType).refresh();
      };

      let updateAccTypeOptions = (accTypeOptions) => {
         [
            ids.fieldAccAsset,
            ids.fieldAccExpense,
            ids.fieldAccLiabilities,
            ids.fieldAccEquity,
            ids.fieldAccIncome,
         ].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", accTypeOptions);
            $$(fieldGLElem).refresh();
         });
      };

      let getListOptions = (objectId, fieldId) => {
         let result = [];
         let object = this.AB.objectByID(objectId);
         if (!object) return result;

         let fpStatusField = object.fieldByID(fieldId);
         if (
            !fpStatusField ||
            !fpStatusField.settings ||
            !fpStatusField.settings.options
         )
            return result;

         result = (fpStatusField.settings.options || []).map((opt) => {
            return {
               id: opt.id,
               value: opt.text,
            };
         });

         return result;
      };

      let fpFields = getFieldOptions(this.objectFP);
      let glFields = getFieldOptions(this.objectGL);
      let accFields = getFieldOptions(this.objectAcc);
      let fpStatusFields = getStatusFieldOptions(this.fieldFPStatus);
      let accTypeOptions = getListOptions(this.objectAcc, this.fieldAccType);

      var ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 200,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processFPValue,
               view: "select",
               label: L("Process Fiscal Period Value"),
               value: this.processFPValue,
               name: "processFPValue",
               options: processValues,
            },
            {
               id: ids.objectFP,
               view: "select",
               label: L("FP Object"),
               value: this.objectFP,
               name: "objectFP",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of batchFields
                        fpFields = getFieldOptions(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFPFields(fpFields);
                     }
                  },
               },
            },
            {
               id: ids.objectGL,
               view: "select",
               label: L("GL Object"),
               value: this.objectGL,
               name: "objectGL",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of batchFields
                        glFields = getFieldOptions(newVal);
                        // rebuild the associated list of Fields to pick
                        updateGLFields(glFields);
                     }
                  },
               },
            },
            {
               id: ids.objectAcc,
               view: "select",
               label: L("Account Object"),
               value: this.objectAcc,
               name: "objectAcc",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        accFields = getFieldOptions(newVal);
                        updateAccFields(accFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldFPStart,
               view: "select",
               label: L("FP -> Start"),
               value: this.fieldFPStart,
               name: "fieldFPStart",
               options: fpFields,
            },
            {
               id: ids.fieldFPOpen,
               view: "select",
               label: L("FP -> Open"),
               value: this.fieldFPOpen,
               name: "fieldFPOpen",
               options: fpFields,
            },
            {
               id: ids.fieldFPStatus,
               view: "select",
               label: L("FP -> Status"),
               value: this.fieldFPStatus,
               name: "fieldFPStatus",
               options: fpFields,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        fpStatusFields = getStatusFieldOptions(newVal);
                        updateFPStatusFields(fpStatusFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldFPActive,
               view: "select",
               label: L("FP -> Active"),
               value: this.fieldFPActive,
               name: "fieldFPActive",
               options: fpStatusFields,
            },
            {
               id: ids.fieldGLStarting,
               view: "select",
               label: L("GL -> Starting BL"),
               value: this.fieldGLStarting,
               name: "fieldGLStarting",
               options: glFields,
            },
            {
               id: ids.fieldGLRunning,
               view: "select",
               label: L("GL -> Running BL"),
               value: this.fieldGLRunning,
               name: "fieldGLRunning",
               options: glFields,
            },
            {
               id: ids.fieldGLAccount,
               view: "select",
               label: L("GL -> Account"),
               value: this.fieldGLAccount,
               name: "fieldGLAccount",
               options: glFields,
            },
            {
               id: ids.fieldGLRc,
               view: "select",
               label: L("GL -> RC"),
               value: this.fieldGLRc,
               name: "fieldGLRc",
               options: glFields,
            },
            {
               id: ids.fieldGLDebit,
               view: "select",
               label: L("GL -> Debit"),
               value: this.fieldGLDebit,
               name: "fieldGLDebit",
               options: glFields,
            },
            {
               id: ids.fieldGLCredit,
               view: "select",
               label: L("GL -> Credit"),
               value: this.fieldGLCredit,
               name: "fieldGLCredit",
               options: glFields,
            },
            {
               id: ids.fieldAccType,
               view: "select",
               label: L("Acc -> Type"),
               value: this.fieldAccType,
               name: "fieldAccType",
               options: accFields,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        accTypeOptions = getListOptions(
                           this.objectAcc || $$(ids.objectAcc).getValue(),
                           newVal
                        );
                        updateAccTypeOptions(accTypeOptions);
                     }
                  },
               },
            },
            {
               id: ids.fieldAccAsset,
               view: "select",
               label: L("Acc -> Asset"),
               value: this.fieldAccAsset,
               name: "fieldAccAsset",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccExpense,
               view: "select",
               label: L("Acc -> Expense"),
               value: this.fieldAccExpense,
               name: "fieldAccExpense",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccLiabilities,
               view: "select",
               label: L("Acc -> Liabilities"),
               value: this.fieldAccLiabilities,
               name: "fieldAccLiabilities",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccEquity,
               view: "select",
               label: L("Acc -> Equity"),
               value: this.fieldAccEquity,
               name: "fieldAccEquity",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccIncome,
               view: "select",
               label: L("Acc -> Income"),
               value: this.fieldAccIncome,
               name: "fieldAccIncome",
               options: accTypeOptions,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      // TIP: keep the .settings entries == ids[s] keys and this will
      // remain simple:
      this.defaults.settings.forEach((s) => {
         this[s] = this.property(ids[s]);
      });
   }
}


/***/ }),

/***/ 26575:
/*!***********************************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingFPYearClose.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AccountingFPYearClose)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskServiceAccountingFPYearCloseCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingFPYearCloseCore.js */ 41211);


class AccountingFPYearClose extends _core_process_tasks_ABProcessTaskServiceAccountingFPYearCloseCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ////
   //// Process Instance Methods
   ////
   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processFPYearValue: `${id}_processFPYearValue`,
         objectFPYear: `${id}_objectFPYear`,
         objectFPMonth: `${id}_objectFPMonth`,
         objectGL: `${id}_objectGL`,
         objectAccount: `${id}_objectAccount`,
         valueFundBalances: `${id}_valueFundBalances`,
         valueNetIncome: `${id}_valueNetIncome`,
         fieldFPYearStart: `${id}_fieldFPYearStart`,
         fieldFPYearEnd: `${id}_fieldFPYearEnd`,
         fieldFPYearStatus: `${id}_fieldFPYearStatus`,
         fieldFPYearActive: `${id}_fieldFPYearActive`,
         fieldFPMonthStart: `${id}_fieldFPMonthStart`,
         fieldFPMonthEnd: `${id}_fieldFPMonthEnd`,
         fieldGLStartBalance: `${id}_fieldGLStartBalance`,
         fieldGLRunningBalance: `${id}_fieldGLRunningBalance`,
         fieldGLrc: `${id}_fieldGLrc`,
         fieldAccNumber: `${id}_fieldAccNumber`,
         fieldAccType: `${id}_fieldAccType`,
         fieldAccTypeIncome: `${id}_fieldAccTypeIncome`,
         fieldAccTypeExpense: `${id}_fieldAccTypeExpense`,
         fieldAccTypeEquity: `${id}_fieldAccTypeEquity`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);
      var L = this.AB.Label();

      var processValues = [{ id: 0, value: L("Select a Process Value") }];
      var processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      var objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });
      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      let getFieldOptions = (objID, fieldKey) => {
         let fields = [
            {
               id: 0,
               value: L("Select a Field"),
            },
         ];

         if (objID) {
            var entry = objectList.find((o) => o.id == objID);
            if (entry && entry.object) {
               entry.object
                  .fields((f) => f.key == fieldKey)
                  .forEach((f) => {
                     fields.push({ id: f.id, value: f.label, field: f });
                  });
            }
         }
         return fields;
      };

      let getListOptions = (objectId, fieldId) => {
         let result = [];
         let object = this.AB.objectByID(objectId);
         if (!object) return result;

         let fpStatusField = object.fieldByID(fieldId);
         if (
            !fpStatusField ||
            !fpStatusField.settings ||
            !fpStatusField.settings.options
         )
            return result;

         result = (fpStatusField.settings.options || []).map((opt) => {
            return {
               id: opt.id,
               value: opt.text,
            };
         });

         return result;
      };

      let updateAccNumberFields = (accNumberFields) => {
         $$(ids.fieldAccNumber).define("options", accNumberFields);
         $$(ids.fieldAccNumber).refresh();
      };

      let updateAccFields = (accFields) => {
         $$(ids.fieldAccType).define("options", accFields);
         $$(ids.fieldAccType).refresh();
      };

      let updateAccTypeOptions = (accTypeOptions) => {
         [
            ids.fieldAccTypeIncome,
            ids.fieldAccTypeExpense,
            ids.fieldAccTypeEquity,
         ].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", accTypeOptions);
            $$(fieldGLElem).refresh();
         });
      };

      let updateFPYearDateOptions = (fpYearDateOptions) => {
         [ids.fieldFPYearStart, ids.fieldFPYearEnd].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", fpYearDateOptions);
            $$(fieldGLElem).refresh();
         });
      };

      let updateFPYearStatusOptions = (fpYearStatusFields) => {
         $$(ids.fieldFPYearStatus).define("options", fpYearStatusFields);
         $$(ids.fieldFPYearStatus).refresh();
      };

      let updateFPYearActiveOptions = (fpYearStatusOptions) => {
         $$(ids.fieldFPYearActive).define("options", fpYearStatusOptions);
         $$(ids.fieldFPYearActive).refresh();
      };

      let updateFPMonthDateFields = (fpMonthDateOpts) => {
         [ids.fieldFPMonthStart, ids.fieldFPMonthEnd].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", fpMonthDateOpts);
            $$(fieldGLElem).refresh();
         });
      };

      let updateGlNumberFields = (glNumberOptions) => {
         [ids.fieldGLStartBalance, ids.fieldGLRunningBalance].forEach(
            (fieldGLElem) => {
               $$(fieldGLElem).define("options", glNumberOptions);
               $$(fieldGLElem).refresh();
            }
         );
      };

      let updateGlConnectFields = (glRcOptions) => {
         $$(ids.fieldGLrc).define("options", glRcOptions);
         $$(ids.fieldGLrc).refresh();
      };

      let fpYearDateFields = getFieldOptions(this.objectFPYear, "date");
      let fpYearStatusFields = getFieldOptions(this.objectFPYear, "list");
      let fpYearStatusOptions = getListOptions(
         this.objectFPYear,
         this.fieldFPYearStatus
      );
      let fpMonthDateFields = getFieldOptions(this.objectFPMonth, "date");
      let glNumberFields = getFieldOptions(this.objectGL, "number");
      let glRcFields = getFieldOptions(this.objectGL, "connectObject");
      let accNumberFields = getFieldOptions(this.objectAccount, "number");
      let accTypeFields = getFieldOptions(this.objectAccount, "list");
      let accTypeOptions = getListOptions(
         this.objectAccount,
         this.fieldAccType
      );

      var ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 200,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processFPYearValue,
               view: "select",
               label: L("Process Fiscal Period Year Value"),
               value: this.processFPYearValue,
               name: "processFPYearValue",
               options: processValues,
            },
            {
               id: ids.objectFPYear,
               view: "select",
               label: L("FP Year Object"),
               value: this.objectFPYear,
               name: "objectFPYear",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        fpYearDateFields = getFieldOptions(newVal, "date");
                        updateFPYearDateOptions(fpYearDateFields);

                        accTypeFields = getFieldOptions(newVal, "list");
                        updateFPYearStatusOptions(accTypeFields);
                     }
                  },
               },
            },
            {
               id: ids.objectFPMonth,
               view: "select",
               label: L("FP Month Object"),
               value: this.objectFPMonth,
               name: "objectFPMonth",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        fpMonthDateFields = getFieldOptions(newVal, "date");
                        updateFPMonthDateFields(fpMonthDateFields);
                     }
                  },
               },
            },
            {
               id: ids.objectGL,
               view: "select",
               label: L("Balance Object"),
               value: this.objectGL,
               name: "objectGL",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        glNumberFields = getFieldOptions(newVal, "number");
                        updateGlNumberFields(glNumberFields);

                        glRcFields = getFieldOptions(newVal, "connectObject");
                        updateGlConnectFields(glRcFields);
                     }
                  },
               },
            },
            {
               id: ids.objectAccount,
               view: "select",
               label: L("Account Object"),
               value: this.objectAccount,
               name: "objectAccount",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        accTypeFields = getFieldOptions(newVal, "list");
                        updateAccFields(accTypeFields);

                        accNumberFields = getFieldOptions(newVal, "number");
                        updateAccNumberFields(accNumberFields);
                     }
                  },
               },
            },
            {
               id: ids.valueFundBalances,
               view: "text",
               label: L("Fund Balances Code"),
               value: this.valueFundBalances,
               name: "valueFundBalances",
            },
            {
               id: ids.valueNetIncome,
               view: "text",
               label: L("Net Income Code"),
               value: this.valueNetIncome,
               name: "valueNetIncome",
            },
            {
               id: ids.fieldFPYearStart,
               view: "select",
               label: L("FP Year -> Start"),
               value: this.fieldFPYearStart,
               name: "fieldFPYearStart",
               options: fpYearDateFields,
            },
            {
               id: ids.fieldFPYearEnd,
               view: "select",
               label: L("FP Year -> End"),
               value: this.fieldFPYearEnd,
               name: "fieldFPYearEnd",
               options: fpYearDateFields,
            },
            {
               id: ids.fieldFPYearStatus,
               view: "select",
               label: L("FP Year -> Status"),
               value: this.fieldFPYearStatus,
               name: "fieldFPYearStatus",
               options: fpYearStatusFields,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        fpYearStatusOptions = getListOptions(
                           this.objectFPYear || $$(ids.objectFPYear).getValue(),
                           newVal
                        );
                        updateFPYearActiveOptions(fpYearStatusOptions);
                     }
                  },
               },
            },
            {
               id: ids.fieldFPYearActive,
               view: "select",
               label: L("FP Year -> Active"),
               value: this.fieldFPYearActive,
               name: "fieldFPYearActive",
               options: fpYearStatusOptions,
            },
            {
               id: ids.fieldFPMonthStart,
               view: "select",
               label: L("FP Month -> Start"),
               value: this.fieldFPMonthStart,
               name: "fieldFPMonthStart",
               options: fpMonthDateFields,
            },
            {
               id: ids.fieldFPMonthEnd,
               view: "select",
               label: L("FP Month -> End"),
               value: this.fieldFPMonthEnd,
               name: "fieldFPMonthEnd",
               options: fpMonthDateFields,
            },
            {
               id: ids.fieldGLStartBalance,
               view: "select",
               label: L("GL -> Start Balance"),
               value: this.fieldGLStartBalance,
               name: "fieldGLStartBalance",
               options: glNumberFields,
            },
            {
               id: ids.fieldGLRunningBalance,
               view: "select",
               label: L("GL -> Running Balance"),
               value: this.fieldGLRunningBalance,
               name: "fieldGLRunningBalance",
               options: glNumberFields,
            },
            {
               id: ids.fieldGLrc,
               view: "select",
               label: L("GL -> RC"),
               value: this.fieldGLrc,
               name: "fieldGLrc",
               options: glRcFields,
            },
            {
               id: ids.fieldAccNumber,
               view: "select",
               label: L("Acc -> Account Number"),
               value: this.fieldAccNumber,
               name: "fieldAccNumber",
               options: accNumberFields,
            },
            {
               id: ids.fieldAccType,
               view: "select",
               label: L("Acc -> Type"),
               value: this.fieldAccType,
               name: "fieldAccType",
               options: accTypeFields,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        accTypeOptions = getListOptions(
                           this.objectAccount ||
                              $$(ids.objectAccount).getValue(),
                           newVal
                        );
                        updateAccTypeOptions(accTypeOptions);
                     }
                  },
               },
            },
            {
               id: ids.fieldAccTypeIncome,
               view: "select",
               label: L("Acc -> Income"),
               value: this.fieldAccTypeIncome,
               name: "fieldAccTypeIncome",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccTypeExpense,
               view: "select",
               label: L("Acc -> Expense"),
               value: this.fieldAccTypeExpense,
               name: "fieldAccTypeExpense",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccTypeEquity,
               view: "select",
               label: L("Acc -> Equity"),
               value: this.fieldAccTypeEquity,
               name: "fieldAccTypeEquity",
               options: accTypeOptions,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      // TIP: keep the .settings entries == ids[s] keys and this will
      // remain simple:
      this.defaults.settings.forEach((s) => {
         this[s] = this.property(ids[s]);
      });
   }
}


/***/ }),

/***/ 87512:
/*!*********************************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingJEArchive.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AccountingJEArchive)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskServiceAccountingJEArchiveCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingJEArchiveCore.js */ 96974);


class AccountingJEArchive extends _core_process_tasks_ABProcessTaskServiceAccountingJEArchiveCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processBatchValue: `${id}_processBatchValue`,
         objectBatch: `${id}_objectBatch`,
         objectBalance: `${id}_objectBalance`,
         objectJE: `${id}_objectJE`,
         objectJEArchive: `${id}_objectJEArchive`,

         fieldBatchFiscalMonth: `${id}_fieldBatchFiscalMonth`,
         fieldJeAccount: `${id}_fieldJeAccount`,
         fieldJeRC: `${id}_fieldJeRC`,
         fieldJeArchiveBalance: `${id}_fieldJeArchiveBalance`,
         fieldBrFiscalMonth: `${id}_fieldBrFiscalMonth`,
         fieldBrAccount: `${id}_fieldBrAccount`,
         fieldBrRC: `${id}_fieldBrRC`,

         fieldsMatch: `${id}_fieldsMatch`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      let ids = this.propertyIDs(id);
      var L = this.AB.Label();

      let processValues = [{ id: 0, value: L("Select a Process Value") }];
      let processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      let objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });

      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      let getConnectFieldOptions = (objectId) => {
         let object = this.AB.objectByID(objectId);
         if (!object) return [];

         let options = object
            .fields((f) => f.isConnection)
            .map((f) => {
               return {
                  id: f.id,
                  value: f.label,
               };
            });

         options.unshift({
            id: 0,
            value: L("Select a Field"),
         });

         return options;
      };

      let updateFields = (fieldPickers, fieldValues) => {
         fieldPickers.forEach((fp) => {
            var picker = $$(fp);
            if (picker) {
               picker.define("options", fieldValues);
               picker.refresh();
               picker.show();
            }
         });
      };

      let refreshBatchFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields([ids.fieldBatchFiscalMonth], options);
      };

      let refreshBRFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields(
            [ids.fieldBrAccount, ids.fieldBrFiscalMonth, ids.fieldBrRC],
            options
         );
      };

      let refreshJeFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields([ids.fieldJeAccount, ids.fieldJeRC], options);
      };

      let refreshJeArchiveFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields([ids.fieldJeArchiveBalance], options);
      };

      let refreshFieldsMatch = () => {
         let $fieldsMatch = $$(ids.fieldsMatch);
         if (!$fieldsMatch) return;

         // clear form
         webix.ui([], $fieldsMatch);

         let JEObj = this.AB.objectByID(this.objectJE);
         if (!JEObj) return;

         let JEArchiveObj = this.AB.objectByID(this.objectJEArchive);
         if (!JEArchiveObj) return;

         // create JE acrhive field options to the form
         JEArchiveObj.fields().forEach((f) => {
            let jeFields = [];

            if (f.isConnection) {
               jeFields = JEObj.fields((fJe) => {
                  return (
                     fJe.isConnection &&
                     fJe.settings &&
                     f.settings &&
                     fJe.settings.linkObject == f.settings.linkObject &&
                     fJe.settings.linkType == f.settings.linkType &&
                     fJe.settings.linkViaType == f.settings.linkViaType &&
                     fJe.settings.isCustomFK == f.settings.isCustomFK
                  );
               });
            } else {
               jeFields = JEObj.fields((fJe) => fJe.key == f.key);
            }

            jeFields = jeFields.map((fJe) => {
               return {
                  id: fJe.id,
                  value: fJe.label,
               };
            });

            $fieldsMatch.addView({
               view: "select",
               name: f.id,
               label: f.label,
               options: jeFields,
            });
         });

         $fieldsMatch.setValues(this.fieldsMatch || {});
      };

      let fieldBatchList = getConnectFieldOptions(this.objectBatch);
      let fieldBalanceList = getConnectFieldOptions(this.objectBalance);
      let fieldJeList = getConnectFieldOptions(this.objectJE);
      let fieldJeArchiveList = getConnectFieldOptions(this.objectJEArchive);

      let ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 180,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processBatchValue,
               view: "select",
               label: L("Process Batch Value"),
               value: this.processBatchValue,
               name: "processBatchValue",
               options: processValues,
            },
            {
               id: ids.objectBatch,
               view: "select",
               label: L("Batch Object"),
               value: this.objectBatch,
               name: "objectBatch",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectBatch = newVal;
                     refreshBatchFields(newVal);
                  },
               },
            },
            {
               id: ids.fieldBatchFiscalMonth,
               view: "select",
               label: L("Batch -> Fiscal Month"),
               value: this.fieldBatchFiscalMonth,
               name: "fieldBatchFiscalMonth",
               options: fieldBatchList,
            },
            {
               id: ids.objectBalance,
               view: "select",
               label: L("BR Object"),
               value: this.objectBalance,
               name: "objectBalance",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectBalance = newVal;
                     refreshBRFields(newVal);
                  },
               },
            },
            {
               id: ids.fieldBrFiscalMonth,
               view: "select",
               label: L("BR -> Fiscal Month"),
               value: this.fieldBrFiscalMonth,
               name: "fieldBrFiscalMonth",
               options: fieldBalanceList,
            },
            {
               id: ids.fieldBrAccount,
               view: "select",
               label: L("BR -> Account"),
               value: this.fieldBrAccount,
               name: "fieldBrAccount",
               options: fieldBalanceList,
            },
            {
               id: ids.fieldBrRC,
               view: "select",
               label: L("BR -> RC"),
               value: this.fieldBrRC,
               name: "fieldBrRC",
               options: fieldBalanceList,
            },
            {
               id: ids.objectJE,
               view: "select",
               label: L("JE Object"),
               value: this.objectJE,
               name: "objectJE",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectJE = newVal;
                     refreshJeFields(newVal);
                     refreshFieldsMatch();
                  },
               },
            },
            {
               id: ids.fieldJeAccount,
               view: "select",
               label: L("JE -> Account"),
               value: this.fieldJeAccount,
               name: "fieldJeAccount",
               options: fieldJeList,
            },
            {
               id: ids.fieldJeRC,
               view: "select",
               label: L("JE -> RC"),
               value: this.fieldJeRC,
               name: "fieldJeRC",
               options: fieldJeList,
            },
            {
               id: ids.objectJEArchive,
               view: "select",
               label: L("JE Archive Object"),
               value: this.objectJEArchive,
               name: "objectJEArchive",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectJEArchive = newVal;
                     refreshJeArchiveFields(newVal);
                     refreshFieldsMatch();
                  },
               },
            },
            {
               id: ids.fieldJeArchiveBalance,
               view: "select",
               label: L("JE Archive -> BR"),
               value: this.fieldJeArchiveBalance,
               name: "fieldJeArchiveBalance",
               options: fieldJeArchiveList,
            },
            {
               view: "fieldset",
               label: "Fields Matching",
               body: {
                  id: ids.fieldsMatch,
                  view: "form",
                  borderless: true,
                  elements: [],
               },
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();

      refreshFieldsMatch();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      let ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      // TIP: keep the .settings entries == ids[s] keys and this will
      // remain simple:
      this.defaults.settings.forEach((s) => {
         if (s === "fieldsMatch") {
            this[s] = $$(ids.fieldsMatch).getValues();
         } else {
            this[s] = this.property(ids[s]);
         }
      });
   }
}


/***/ }),

/***/ 77855:
/*!***********************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskServiceCalculate.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CalculateTask)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskServiceCalculateCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceCalculateCore.js */ 97286);


class CalculateTask extends _core_process_tasks_ABProcessTaskServiceCalculateCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ////
   //// Process Instance Methods
   ////

   warningsEval() {
      super.warningsEval();

      if (!this.formulaText) {
         this.warningMessage("is missing a formula.");
      }

      if (this.formulaText) {
         const hash = {};
         (this.process.processDataFields(this) || []).forEach((item) => {
            hash[`{${item.label}}`] = item;
         });

         let exp = new RegExp(`{[^}]*}`, "g");
         let entries = this.formulaText.match(exp) || [];
         entries.forEach((entry) => {
            if (!hash[entry]) {
               this.warningMessage(
                  `could not resolve process value [${entry}]`
               );
            }
         });
      }
   }
}


/***/ }),

/***/ 47995:
/*!*********************************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskServiceGetResetPasswordUrl.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskServiceGetResetPasswordUrl)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskServiceGetResetPasswordUrlCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceGetResetPasswordUrlCore.js */ 25418);
// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()


class ABProcessTaskServiceGetResetPasswordUrl extends _core_process_tasks_ABProcessTaskServiceGetResetPasswordUrlCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   warningsEval() {
      super.warningsEval();

      if (!this.email) {
         this.warningMessage("is missing the email address.");
      }

      const processData = (this.process.processDataFields(this) ?? [])
         .filter((item) => item.field?.key == "email")
         .map((item) => {
            return {
               id: item.key,
               value: item.label,
            };
         });

      if (processData.length == 0) {
         this.warningMessage("has no previous tasks exporting email fields.");
      }
   }
}


/***/ }),

/***/ 22641:
/*!**************************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskServiceInsertRecord.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ InsertRecordTask)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskServiceInsertRecordCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceInsertRecordCore.js */ 45136);


class InsertRecordTask extends _core_process_tasks_ABProcessTaskServiceInsertRecordCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   warningsEval() {
      super.warningsEval();

      if (!this.objectID) {
         this.warningMessage("has no Object set.");
      }

      const fv = Object.keys(this.fieldValues || {}) || [];
      if (fv.length == 0) {
         this.warningMessage("has no fields set");
      } else {
         let isSet = false;
         fv.forEach((f) => {
            if (
               this.fieldValues[f]?.set != "0" &&
               this.fieldValues[f]?.value != null
            ) {
               isSet = true;
            }
         });
         if (!isSet) {
            this.warningMessage("has no fields set");
         }
      }
   }
}


/***/ }),

/***/ 76061:
/*!*******************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskServiceQuery.js ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskServiceQuery)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskServiceQueryCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceQueryCore.js */ 79078);
/* harmony import */ var _ql_ABQLManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ql/ABQLManager.js */ 66586);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_process_tasks_ABProcessTaskServiceQueryCore_js__WEBPACK_IMPORTED_MODULE_0__, _ql_ABQLManager_js__WEBPACK_IMPORTED_MODULE_1__]);
([_core_process_tasks_ABProcessTaskServiceQueryCore_js__WEBPACK_IMPORTED_MODULE_0__, _ql_ABQLManager_js__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);




class ABProcessTaskServiceQuery extends _core_process_tasks_ABProcessTaskServiceQueryCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      super(attributes, process, AB);

      this.attributes = attributes;
   }

   ABQLManager() {
      return _ql_ABQLManager_js__WEBPACK_IMPORTED_MODULE_1__["default"];
   }

   warnings() {
      // first get all our embedded QL Command warnings
      let qlWarnings = [];
      if (this.qlObj) {
         qlWarnings = qlWarnings.concat(this.qlObj.warnings());
      }
      // run the QL Warnings through our .warningMessage() to get a message
      // that includes this task's name:
      qlWarnings.forEach((w) => {
         if (w?.message) this.warningMessage(w.message);
      });
      let myWarnings = super.warnings();
      return myWarnings.filter((w) => w); // filter out any undefined.
   }

   warningsEval() {
      super.warningsEval();
      if (this.qlObj) {
         this.qlObj.warningsEval();
      } else {
         this.warningMessage(`has no Query defined.`);
      }

      if (!this.name) {
         this.warningMessage("does not have a name.", {
            attributes: this.attributes,
         });
      }

      let hasSave = false;
      let curr = this.qlObj;
      while (curr) {
         if (curr.key === "row_save" || curr.key === "set_save") {
            hasSave = true;
            curr = null; // just stop here.
         } else {
            curr = curr.next;
         }
      }

      if (!hasSave) {
         this.warningMessage("requires at least one Save operation.");
      }
   }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 75175:
/*!*****************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskSubProcess.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SubProcess)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskSubProcessCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskSubProcessCore.js */ 76987);


class SubProcess extends _core_process_tasks_ABProcessTaskSubProcessCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ////
   //// Process Instance Methods
   ////

   /*
   propertyIDs(id) {
      return {
         name: `${id}_name`,
         isEnable: `${id}_isEnable`,
         parameterId: `${id}_parameterId`,
      };
   }

   /**
    * @method propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    * /
   propertiesShow(id) {
      let ids = this.propertyIDs(id);

      // Pull query tasks option list
      let parameterOptions = (this.process.processDataFields(this) || []).map(
         (item) => {
            return {
               id: item.key,
               value: item.label,
            };
         }
      );

      let ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 120,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.isEnable,
               view: "switch",
               label: L("Enable"),
               value: this.isEnable,
            },
            {
               id: ids.parameterId,
               view: "richselect",
               label: L("Repeat for"),
               options: parameterOptions,
               value: this.parameterId,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * @method propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    * /
   propertiesStash(id) {
      let ids = this.propertyIDs(id);
      this.name = this.property(ids.name);
      this.isEnable = this.property(ids.isEnable);
      this.parameterId = this.property(ids.parameterId);
   }
   */

   /**
    * @method diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this object.
    * @return {json}
    */
   diagramProperties(bpmnModeler) {
      let props = super.diagramProperties();
      props = props || [{}];
      props[0].def = props[0].def || {};

      if (this.parameterId != null) {
         props[0].def = props[0].def || {};
         props[0].def.loopCharacteristics = bpmnModeler
            .get("moddle")
            .create("bpmn:MultiInstanceLoopCharacteristics");
         props[0].def.loopCharacteristics.isSequential = true;
      }

      return props;
   }

   /**
    * @method onChange()
    * update the current Task with information that was relevant
    * from the provided BPMN:Element
    * @param {BPMNElement}
    */
   onChange(defElement) {
      let loopCharacteristics =
         defElement.loopCharacteristics ||
         defElement.businessObject.loopCharacteristics ||
         {};

      switch (loopCharacteristics.$type) {
         case "bpmn:MultiInstanceLoopCharacteristics":
            this.loopType = loopCharacteristics.isSequential
               ? "sequential"
               : "parallel";
            break;
         case "bpmn:StandardLoopCharacteristics":
            this.loopType = "looping";
            break;
      }
   }

   /**
    * @method destroy()
    * destroy this sub process and inside tasks
    *
    * @return {Promise}
    */
   destroy() {
      // reuse .destroy function of ABProcess
      // to clear tasks within this sub process
      return this.process.destroy.call(this);
   }

   /**
    * @method save()
    * persist this sub process
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   save() {
      // reuse .save function of ABProcess
      // to update tasks within this sub process
      return this.process.save.call(this);
   }

   /**
    * @method elementNewForModelDefinition()
    * create a new process element defined by the given BPMN:Element
    *
    * the BPMN:Element definition comes from the BPMN Modeler when a new
    * diagram element is created.
    *
    * @param {BPMN:Element} element
    *        the BPMN modeler diagram element definition
    * @return {ABProcessParticipant|ABProcessLane|ABProcessElement}
    *
    */
   elementNewForModelDefinition(element) {
      let task = this.AB.processElementNewForModelDefinition(element, this);

      // Add a new task to this sub process
      if (task) {
         this.elementAdd(task);
      }
      return task;
   }

   warningsEval() {
      super.warningsEval();

      (this._unknownElementIDs || []).forEach((eID) => {
         this.warningMessage(
            `is referencing an unknown process element id[${eID}]`,
            { process: this.id, eID }
         );
      });
   }
}


/***/ }),

/***/ 67429:
/*!***********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskUser.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskUser)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskUserCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskUserCore.js */ 29564);


class ABProcessTaskUser extends _core_process_tasks_ABProcessTaskUserCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 70852:
/*!*******************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskUserApproval.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskUserApproval)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskUserApprovalCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskUserApprovalCore.js */ 45383);


class ABProcessTaskUserApproval extends _core_process_tasks_ABProcessTaskUserApprovalCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 82659:
/*!*******************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskUserExternal.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskUserExternal)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskUserExternalCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskUserExternalCore.js */ 9879);
// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()


class ABProcessTaskUserExternal extends _core_process_tasks_ABProcessTaskUserExternalCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 89476:
/*!***************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskUserForm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskUserForm)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskUserFormCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskUserFormCore.js */ 53205);


class ABProcessTaskUserForm extends _core_process_tasks_ABProcessTaskUserFormCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 50135:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTrigger.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTrigger)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTriggerCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTriggerCore.js */ 63438);
// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()


class ABProcessTrigger extends _core_process_tasks_ABProcessTriggerCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 82712:
/*!*******************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTriggerLifecycle.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTriggerLifecycle)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTriggerLifecycleCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTriggerLifecycleCore.js */ 58448);


class ABProcessTriggerLifecycle extends _core_process_tasks_ABProcessTriggerLifecycleCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 63807:
/*!***************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTriggerTimer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTriggerTimer)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTriggerTimerCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTriggerTimerCore.js */ 14570);


const START_URL = "/process/timer/#id#/start";
const STOP_URL = "/process/timer/#id#/stop";

class ABProcessTriggerTimer extends _core_process_tasks_ABProcessTriggerTimerCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @method save()
    * persist this instance of ABObject with it's parent ABApplication
    * @return {Promise}
    */
   save() {
      return (
         Promise.resolve()
            .then(() => super.save())
            // Restart the timer
            .then((result) => {
               return this.AB.Network.put({
                  url: (this.isEnabled ? START_URL : STOP_URL).replace(
                     "#id#",
                     this.id
                  ),
               });
            })
      );
   }
}


/***/ }),

/***/ 33262:
/*!***********************************************!*\
  !*** ./src/js/AppBuilder/platform/ql/ABQL.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ql_ABQLCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ql/ABQLCore.js */ 95223);
/*
 * ABQL
 *
 * An ABQL defines the base class for our AB Query Language Objects.
 * These classes share a common way to
 *   - parse input strings for commands
 *
 *
 */

// import RowUpdater from "../RowUpdater.js";

class ABQL extends _core_ql_ABQLCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, parameterDefinitions, prevOP, task, AB) {
      super(attributes, parameterDefinitions, prevOP, task, AB);

      this.on("warning", (message, data) => {
         this._warnings.push({ message, data });
      });
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method parseRow()
    * When it is time to pull the information from the properties panel,
    * use this fn to get the current Row of data.
    *
    * This fn() will populate the this.params with the values for each
    * of our .parameterDefinitions.
    *
    * @param {webixNode} row
    *        the current webix node that contains the ROW defining the
    *        operation and it's parameters.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    */
   parseRow(row, id) {
      // const allColumns = row.getChildViews();
      // allColumns.shift(); // remove selector
      this.parameterDefinitions.forEach((pDef) => {
         // const col = allColumns.shift();
         const myID = this.uiID(id);

         this.ids = this.toIDs(myID);
         this.params = this.params ?? {};

         let $uiCondition = null;

         switch (pDef.type) {
            case "objectFields":
               this.params[pDef.name] = $$(this.ids.objectfields).getValue();

               break;

            case "objectName":
               this.params[pDef.name] = $$(this.ids.objectname).getValue();

               break;

            case "objectConditions":
            case "objectValues":
               $uiCondition = $$(this.ids.condition);

               if ($uiCondition) {
                  const condition = $uiCondition.getValue();

                  if (condition && condition !== "") {
                     this.params[pDef.name] = JSON.parse(condition);
                  }
               }

               break;

            case "taskParam":
               this.params[pDef.name] = $$(this.ids.taskparam).getValue();

               break;
         }
      });
   }

   /*
    * @method toIDs()
    * generate a set of unique webix ids to use for our UI.
    * @param {string} myID
    *        the unique id generated by .uiID()
    */
   toIDs(myID) {
      return {
         condition: `${myID}_condition`,
         objectfields: `${myID}_objectfields`,
         objectname: `${myID}_objname`,
         popup: `${myID}_popup`,
         select: `${myID}_select`,
         shorthand: `${myID}_shorthand`,
         taskparam: `${myID}_taskparam`,
         spacer: `${myID}_spacer`,
      };
   }

   /**
    * @method uiAddParamForDef()
    * Add an operation parameter for each parameterDefinition we have defined.
    * @param {obj} pDef
    *        the current parameterDefinition entry we are creating the UI
    *        for.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddParamForDef(pDef, id, ui) {
      // params are added to a .col[] definition.
      // if our ui isn't down to the current .col element, then drill down
      if (!ui.cols) {
         if (ui.rows) {
            for (let i = 0; i < ui.rows.length; i++)
               if (ui.rows[i].cols) {
                  this.uiAddParamForDef(pDef, id, ui.rows[i]);

                  break;
               }
         } else throw new Error("provided ui is not able to add a parameter!");

         return;
      }

      const paramUI = this.uiParamUI(pDef, id);

      if (paramUI) {
         // if we only have 1 param
         if (this.parameterDefinitions.length === 1) {
            ui.cols.pop();
            ui.cols.push(paramUI);
         }
         // if we haven't already added a parameter
         else {
            // create a row stack of parameters:
            if (ui.cols.length < 3)
               ui.cols.push({
                  rows: [paramUI],
               });
            // add to the current stack of parameters
            else ui.cols[2].rows.push(paramUI);
         }
      }
   }

   /**
    * @method uiAddNext()
    * Add the next row selector for this operation:
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddNext(id, ui) {
      const uiRow = this.uiNextRow(id);

      // if we have a next operation defined, then add on the ui definitions
      // for that operation:
      if (this.next) {
         this.next.uiAddParams(id, uiRow);
         ui.rows.push(uiRow);
         this.next.uiAddNext(id, ui);
      }
      // otherwise we just leave the selector:
      else ui.rows.push(uiRow);
   }

   /**
    * @method uiAddParams()
    * Add operation parameter(s) for each parameterDefinition we have defined.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddParams(id, ui) {
      this.parameterDefinitions.forEach((pDef) => {
         this.uiAddParamForDef(pDef, id, ui);
      });
   }

   /*
    * @method uiID()
    * generate a unique webix id for this operation.
    * @param {string} id
    *        the webix id of the base property.query holder
    */
   uiID(id) {
      if (this.prevOP) return `${this.prevOP.uiID(id)}_${this.constructor.key}`;

      return `${id}_${this.constructor.key}`;
   }

   /*
    * uiXXX Operations:
    * are UI building operations that are performed BEFORE the webix UI
    * is generated.  They work by filling out a {ui} object definition
    * that webix will eventually create into the DOM.
    *
    * viewXXX Operations:
    * are UI building operations that are performed AFTER the webix UI
    * is generated. They work by adding in child views to an existing
    * DOM.
    */

   /**
    * @method uiNextRow()
    * return the webix UI definition for the next of UI chaining.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @return {obj}
    */
   uiNextRow(id) {
      const options = this.constructor.NextQLOps.map((op) => {
         return { id: op.key, value: op.label };
      });
      var L = this.AB.Label();

      options.unshift({ id: 0, value: L("choose next operation") });

      const myID = this.uiID(id);
      const ids = this.toIDs(myID);

      const uiRow = {
         cols: [
            {
               id: ids.select,
               view: "select",
               value: this.next ? this.next.constructor.key : 0,
               options: options,
               on: {
                  onChange: (newValue, oldValue) => {
                     const resetValue = () => {
                        const select = $$(ids.select);

                        select.blockEvent();
                        select.setValue(oldValue);
                        select.unblockEvent();
                     };

                     if (newValue === oldValue) return;

                     const newOP = this.constructor.NextQLOps.find(
                        (op) => op.key === newValue
                     );

                     if (!newOP) {
                        resetValue();

                        return;
                     }

                     const thisRow = $$(ids.select).getParentView();
                     const thisQuery = thisRow.getParentView();
                     const addOP = () => {
                        if (newOP) {
                           const nextOP = new newOP(
                              {},
                              this,
                              this.task,
                              this.AB
                           );

                           this.next = nextOP;

                           nextOP.viewAddParams(id, thisRow);
                           nextOP.viewAddNext(id, thisQuery);
                        }
                     };

                     // if there are rows after this one, then warn
                     // about changing
                     const allRows = thisQuery.getChildViews();

                     if (allRows.length - 1 > allRows.indexOf(thisRow))
                        webix.confirm({
                           title: L("continue?"),
                           text: L(
                              "changing this rule will reset any following rules."
                           ),
                           ok: L("Yes"),
                           cancel: L("No"),
                           callback: (result) => {
                              if (result) {
                                 // remove the current additional Rows:
                                 let ir = allRows.length - 1;

                                 while (
                                    allRows[ir].config.id !== thisRow.config.id
                                 ) {
                                    thisQuery.removeView(allRows[ir]);
                                    ir--;
                                 }

                                 // now remove the parameters
                                 const allCols = thisRow.getChildViews();

                                 let ic = allCols.length;

                                 while (ic > 1) {
                                    thisRow.removeView(allCols[ic - 1]);
                                    ic--;
                                 }

                                 addOP();
                              } else resetValue();
                           },
                        });
                     else addOP();
                  },
               },
            },
            {
               id: ids.spacer,
            },
         ],
      };

      return uiRow;
   }

   uiNextRowSelectorRefresh(id) {
      const $select = $$(this.ids.select);

      if (!$select) return;

      const uiNextRow = this.uiNextRow(id);

      const uiNextCol =
         uiNextRow.cols.filter((c) => c.id == $select.config.id)[0] ??
         uiNextRow.cols[1];

      if (uiNextCol) AB.Webix.ui(uiNextCol, $select);
   }

   /**
    * @method uiParamUI()
    * return the webix UI definition for the parameter entry of this current
    * operation.
    * @param {obj} pDef
    *        the current parameterDefinition entry we are creating the UI
    *        for.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @return {obj}
    */
   uiParamUI(pDef, id) {
      const uiConfig = AB.Config.uiSettings();
      var L = this.AB.Label();

      let myID = this.uiID(id);

      this.ids = this.toIDs(myID);

      let paramUI = null;
      let options = null;
      let Filter = null;
      let hashFieldIDs = null;
      let initialCond = null;
      let displayLabel = null;
      let initialValue = null;
      let Updater = null;
      let popUp = null;

      // now add the parameter
      switch (pDef.type) {
         case "objectFields":
            // an objectFields parameter returns a select list of fields
            // available on an Object.
            if (this.object)
               options = this.object.fields().map((f) => {
                  return { id: f.id, value: f.label, icon: `fa fa-${f.icon}` };
               });

            options.unshift({
               id: "_PK",
               value: "[PK]",
            });

            // if not set, default .fieldID to the 1st entry in options
            // so we will have a default.  In use, if a user sees the
            // 1st item and continues on, then we will have chosen it.
            if (!this.fieldID && options.length > 0) {
               // act like it was selected:
               this.params[pDef.name] = options[0].id;
               this.paramChanged(pDef, id);
            }

            paramUI = {
               id: this.ids.objectfields,
               view: "richselect",
               label: L("Field"),
               labelWidth: 70,
               value: this.fieldID,
               options: options,
               on: {
                  onChange: (newValue, oldValue) => {
                     // this.params = this.params ?? {};
                     if (newValue !== this.params[pDef.name]) {
                        this.params[pDef.name] = newValue;
                        this.paramChanged(pDef, id);
                     }
                  },
               },
            };

            break;

         case "objectName":
            // an objectName parameter returns a select list of available
            // objects in this ABFactory.
            options = this.AB.objects().map((o) => {
               return { id: o.id, value: o.label };
            });

            if (!this.objectID && options.length > 0) {
               this.objectID = options[0].id;
               this.params[pDef.name] = this.objectID;
               this.paramChanged(pDef);
            }

            paramUI = {
               id: this.ids.objectname,
               view: "select",
               label: L("Data Source"),
               labelWidth: uiConfig.labelWidthLarge,
               value: this.objectID,
               options: options,
               on: {
                  onChange: (newValue /*, oldValue */) => {
                     this.params = this.params ?? {};

                     if (newValue !== this.params[pDef.name]) {
                        this.params[pDef.name] = newValue;
                        this.paramChanged(pDef);
                     }
                  },
               },
            };

            break;

         case "objectConditions":
            // objectConditions: returns a filter text summary, that when
            // clicked, pops up a Filter Entry Popup.
            // the actual value is stored in a hidden field.

            // we will create a new FilterComplex() object to use for our
            // filtering.
            // Our goal is to create a special filter entry for each avaiable
            // process data value that is available.
            // A filter entry needs to look like:
            // {
            //     id: `{string}`,      // A unique id selector for this filter
            //     name: `{string}`,    // the operation name displayed
            //     type, {obj}          // an object defining the editor to show
            //     fn: ()=>{}           // a function used for filtering elements
            // }
            //
            // In our filters, we are assigning filters to EACH field by the
            // field.id.  So the type definition needs to look like:
            // {
            //     "uniqueID of the field (field.id)" : {webixUI definition}
            // }

            Filter = this.AB.filterComplexNew(id);
            hashFieldIDs = this.availableProcessDataFieldsHash();

            if (this.object) {
               Filter.fieldsLoad(this.object.fields(), this.object);
               // NOTE: this will create default filters based upon the
               // object fields() and their types

               // Now we need to add in the Process Data Fields:
               // for each Process Data Field that matches our same object
               const foundFields = Object.keys(hashFieldIDs).map(
                  (f) => hashFieldIDs[f]
               );

               Filter.processFieldsLoad(foundFields);
               /*
               (foundFields ?? []).forEach((processField) => {
                  const type = {};
                  if (processField.field) {
                     type[processField.field.id] = {
                        view: "select",
                        options: [
                           {
                              id: "empty",
                              value: "choose option"
                           },
                           {
                              id: processField.key,
                              value: `context(${processField.label})`
                           }
                        ]
                     };
                  } else {
                     // if there is no .field, it is probably an embedded special field
                     // like: .uuid
                     const key = processField.key.split(".").pop();
                     type[key] = {
                        view: "select",
                        options: [
                           {
                              id: "empty",
                              value: "choose option"
                           },
                           {
                              id: processField.key,
                              value: `context(${processField.label})`
                           }
                        ]
                     };
                  }

                  // add an "equals" and "not equals" filter for each:
                  Filter.filterAdd([
                     {
                        id: `context_equals`,
                        name: `equals`,
                        type,
                        fn: (a, b) => {
                           return a === b;
                        }
                     },
                     {
                        id: `context_not_equal`,
                        name: `not equals`,
                        type,
                        fn: (a, b) => {
                           return a !== b;
                        }
                     }
                  ]);
                  
               }); */
            }

            // every time the Filter "saves" it's data, it emits this event:
            // take the given condition and store it in our hidden element.
            Filter.on("save", (condition) => {
               // @param {obj} condition an object describing the filter
               // condition.

               this.params = this.params ?? {};
               this.params[pDef.name] = condition;

               const shortHand = $$(this.ids.shorthand);

               shortHand.define({
                  label: Filter.toShortHand(),
               });
               shortHand.refresh();

               // NOTE: the hidden element is a text field, so convert the
               // {condition object} => a string
               const elCondition = $$(this.ids.condition);

               elCondition.define({
                  value: JSON.stringify(this.params[pDef.name]),
               });
               elCondition.refresh();
            });

            // create the initial condition value from our inputs.
            initialCond = "";

            if (this.params && this.params[pDef.name]) {
               Filter.setValue(this.params[pDef.name]);
               initialCond = JSON.stringify(this.params[pDef.name]);
            }

            // what we show on the panel, is a text representation
            // of the current condition.
            displayLabel = Filter.toShortHand();

            paramUI = {
               rows: [
                  {
                     id: this.ids.shorthand,
                     view: "button",
                     label: displayLabel,
                     on: {
                        onItemClick: () => {
                           Filter.popUp($$(this.ids.shorthand), null, {
                              pos: "center",
                           });
                        },
                     },
                  },
                  // have a hidden field to contain the condition
                  // value we will parse out later
                  {
                     id: this.ids.condition,
                     view: "text",
                     value: initialCond,
                     hidden: true,
                  },
               ],
            };

            break;

         case "objectValues":
            // objectValues : shows a condenced textual representation of the
            // field => value changes.  Clicking on the text will show a popup
            // that allows you to add/remove additional field updates for
            // the current object.

            initialValue = "";
            Updater = new RowUpdater(myID, this.AB);

            if (this.object) Updater.objectLoad(this.object);

            // Set processed data key to value options
            Updater.setExtendedOptions(
               (this.task.process.processDataFields(this.task) ?? []).map(
                  (item) => {
                     return {
                        id: item.key,
                        value: item.label,
                     };
                  }
               )
            );

            // NOTE: .setValue() must be called once the RowUpdater is already
            // displayed.  See the end of popUp() below:
            if (this.params && this.params[pDef.name]) {
               Updater.setValue(this.params[pDef.name]);
               initialValue = JSON.stringify(this.params[pDef.name]);
            }

            popUp = () => {
               // show the RowUpdater in a popup:
               const ui = {
                  id: this.ids.popup,
                  view: "popup",
                  position: "center",
                  minWidth: 700,
                  modal: true,
                  resize: true,
                  body: {
                     rows: [
                        {
                           height: 30,
                           borderless: true,
                           cols: [
                              { fillspace: true },
                              {
                                 view: "button",
                                 value: "X",
                                 width: 30,
                                 click: () => {
                                    $$(this.ids.popup).hide();
                                 },
                              },
                           ],
                        },
                        Updater.ui(),
                        {
                           view: "button",
                           value: L("Save"),
                           css: "webix_primary",
                           click: () => {
                              this.params = this.params ?? {};
                              this.params[pDef.name] = Updater.getValue();
                              const sh = $$(this.ids.shorthand);

                              sh.define({
                                 badge: this.params[pDef.name].length,
                              });
                              sh.refresh();

                              const cond = $$(this.ids.condition);

                              cond.define({
                                 value: JSON.stringify(this.params[pDef.name]),
                              });
                              cond.refresh();

                              $$(this.ids.popup).hide();
                           },
                        },
                     ],
                  },
               };

               // create and show the popup
               this._myPopup = webix.ui(ui);
               this._myPopup.show();

               // NOTE: on a RowUpdater, the values need to be set
               // AFTER it is displayed:
               if (this.params && this.params[pDef.name])
                  Updater.setValue(this.params[pDef.name]);
            };

            paramUI = {
               rows: [
                  // the textual shorthand for these values
                  {
                     id: this.ids.shorthand,
                     view: "button",
                     label: L("Update Popout"),
                     badge: this.params[pDef.name]?.length,
                     on: {
                        onItemClick: () => {
                           popUp();
                        },
                     },
                  },
                  // the hidden field that contains the results
                  {
                     id: this.ids.condition,
                     view: "text",
                     value: initialValue,
                     hidden: true,
                  },
               ],
            };

            break;

         case "taskParam":
            paramUI = {
               id: this.ids.taskparam,
               view: "text",
               label: L("Variable"),
               labelWidth: 70,
               value: this.params[pDef.name],
               placeholder: L("Enter parameter name"),
               on: {
                  onChange: (newValue, oldValue) => {
                     // this.params = this.params ?? {};
                     if (newValue !== this.params[pDef.name]) {
                        this.params[pDef.name] = newValue;
                        this.paramChanged(pDef, id);
                     }
                  },
               },
            };

            break;
      }

      return paramUI;
   }

   /**
    * @method viewAddNext()
    * Add the next selector row After this Operation:
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {webixNode} topView
    *        the current webix node that needs this view added to
    *        NOTE: this should be the top container that is adding a new
    *        row for each operation.
    */
   viewAddNext(id, topView) {
      const uiRow = this.uiNextRow(id);

      topView.addView(uiRow);
   }

   /**
    * @method viewAddParams()
    * Add operation parameter(s) for each parameterDefinition we have defined.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {webixNode} rowView
    *        the current webix node that needs this view added to
    *        NOTE: this should be the ROW that the parameters are added to
    */
   viewAddParams(id, rowView) {
      const params = [];

      this.parameterDefinitions.forEach((pDef) => {
         // get the definition from .uiParamUI()
         params.push(this.uiParamUI(pDef, id));
      });

      let toInsert = null;

      // stack parameters in a row if there are more than 1
      if (params.length > 1)
         toInsert = {
            rows: params,
         };
      else toInsert = params.pop();

      if (toInsert) {
         rowView.removeView(rowView.getChildViews()[1]);
         rowView.addView(toInsert);
      }
   }

   warnings() {
      let myWarnings = this._warnings || [];
      if (this.next)
         myWarnings = myWarnings.concat(this.next.warnings()).filter((w) => w);
      return this.AB.uniq(myWarnings);
   }

   warningsEval() {
      this._warnings = [];
      if (this.next) this.next.warningsEval();
   }

   // warningsAll() {
   //    let myWarnings = this.warnings();
   //    if (this.next) {
   //       myWarnings = myWarnings.concat(this.next.warningsAll());
   //    }
   //    return myWarnings;
   // }

   /**
    * @method warningMessage(message)
    * Save a warning message in a common format for our ProcessTasks.
    */
   warningMessage(message) {
      // this.emit("warning", `${this.key}: ${message}`);
      this._warnings = this._warnings || [];
      this._warnings.push({ message: `${this.key}: ${message}` });
   }

   ////
   //// QueryString Parser routines:
   ////
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQL);


/***/ }),

/***/ 88794:
/*!***************************************************!*\
  !*** ./src/js/AppBuilder/platform/ql/ABQLFind.js ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ql_ABQLFindCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ql/ABQLFindCore.js */ 83854);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_ql_ABQLFindCore_js__WEBPACK_IMPORTED_MODULE_0__]);
_core_ql_ABQLFindCore_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
/*
 * ABQLFind
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */


class ABQLFind extends _core_ql_ABQLFindCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, ParameterDefinitions, prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLFind);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 66586:
/*!******************************************************!*\
  !*** ./src/js/AppBuilder/platform/ql/ABQLManager.js ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ql_ABQLManagerCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ql/ABQLManagerCore.js */ 43455);
/* harmony import */ var _ABQLRootObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ABQLRootObject.js */ 93556);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_ql_ABQLManagerCore_js__WEBPACK_IMPORTED_MODULE_0__, _ABQLRootObject_js__WEBPACK_IMPORTED_MODULE_1__]);
([_core_ql_ABQLManagerCore_js__WEBPACK_IMPORTED_MODULE_0__, _ABQLRootObject_js__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/*
 * ABQLManager
 *
 * An interface for managing the different ABQL Operations available in our
 * AppBuilder.
 *
 */




const ABQLManager = {
   /**
    * @method fromAttributes()
    * return an {ABQL} object that represents the given attributes that
    * were saved from the previous .toObj()
    * @param {object} attributes
    *		  the values returned from the previous .toObj() call
    * @param {ABProcessTask***} task
    *		  the current ABProcessTaskServiceQuery that contains this QL
    * @param {ABFactory} AB
    *		  the current {ABFactory} active for this interface.
    * @return {ABQL} | null
    */
   fromAttributes: _core_ql_ABQLManagerCore_js__WEBPACK_IMPORTED_MODULE_0__["default"].fromAttributes,

   /**
    * @method ids()
    * return a set of unique webix ids for the ui portions of this object.
    * @param {string} id
    *		  the webix base id of the parameters panel.
    * @return {object}
    */
   ids: (id) => {
      return {
         root: `${id}_root`,
         select: `${id}_root_select`,
         options: `${id}_root_options`,
      };
   },

   /**
    * @method builder
    * return a UI component like object that will display the QL builder.
    * The component will support:
    *		.ui(id) : returns a webix ui definition for the current builder
    *		.init(id) : performs any special actions to prepare the webix ui
    * @param {object} rootOP
    *		  the root ABQLxxxx operation
    * @param {ABProcessTask***} task
    *		  the current Process Task that is requesting the data.
    * @param {ABFactory} AB
    *		  the {ABFactory} active for this display.
    * @return {object}
    */
   builder: (rootOP, task, AB) => {
      // const rootOP = this.fromAttributes(attributes, task, AB);
      // const L = (...params) => AB.Multilingual.label(...params);

      return {
         ui: (id) => {
            rootOP = rootOP ?? new _ABQLRootObject_js__WEBPACK_IMPORTED_MODULE_1__["default"]({}, task, AB);

            const ids = ABQLManager.ids(id);
            const ui = {
               rows: [
                  {
                     id: ids.root,
                     cols: [],
                  },
               ],
            };

            rootOP.uiAddParams(id, ui);
            rootOP.uiAddNext(id, ui);

            return ui;
         },
         init: (id) => {},
      };
   },

   /**
    * @method parse
    * step through the current properties panel and decode the QL objects
    * and their parameters.
    * Return the .toOBJ() attributes definition as a result.
    * @param {string} id
    *		  the webix base id of the parameters panel.
    * @param {ABProcessTask***} task
    *		  the current Process Task that is requesting the data.
    * @param {ABFactory} AB
    *		  the {ABFactory} object that is currently active.
    * @return {object}
    */
   parse: (id, task, AB) => {
      const ids = ABQLManager.ids(id);
      const root = $$(ids.root);

      if (!root) {
         console.warn("ABQLManager.parse(): unable to find root element");

         return;
      }

      // get all the input rows
      const rows = root.getParentView().getChildViews();

      const parseCurrent = (rows, options, prevOP) => {
         if (rows.length === 0) return null;

         const row = rows.shift();

         // get which operation was selected
         // find the operation selector (skip any indents)
         const views = row.getChildViews();

         let selector = views.shift();

         while (!selector?.getValue) selector = views.shift();

         const value = selector.getValue();

         // figure out the QLOP object
         const OP = options.find((o) => {
            return o.key === value || o.key === _ABQLRootObject_js__WEBPACK_IMPORTED_MODULE_1__["default"].key;
         });

         if (OP) {
            let currOP = null;

            if (prevOP) currOP = new OP({}, prevOP, task, AB);
            else currOP = new OP({}, task, AB);

            // now get currOP to initialize from it's parameters:
            currOP.parseRow(row, id);

            // carry forward any .object info if not already established
            // by the .parseRow():
            if (!currOP.object && prevOP) {
               currOP.object = prevOP.object;
               currOP.objectID = currOP.object?.id ?? null;
            }

            const nextRow = parseCurrent(
               rows,
               currOP.constructor.NextQLOps,
               currOP
            );

            currOP.next = nextRow;

            return currOP;
         }

         return null;
      };

      const operation = parseCurrent(rows, _core_ql_ABQLManagerCore_js__WEBPACK_IMPORTED_MODULE_0__["default"].QLOps, null);

      return operation;
   },
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLManager);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 93556:
/*!*********************************************************!*\
  !*** ./src/js/AppBuilder/platform/ql/ABQLRootObject.js ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ql_ABQLRootObjectCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ql/ABQLRootObjectCore.js */ 24325);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_ql_ABQLRootObjectCore_js__WEBPACK_IMPORTED_MODULE_0__]);
_core_ql_ABQLRootObjectCore_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
/*
 * ABQLRootObject
 *
 * An ABQL defines a Query Language Operation. A QL Operation
 * is intended to be evaluated at run time and return a value that can be
 * assigned to form value or an object.
 *
 *
 */



class ABQLObject extends _core_ql_ABQLRootObjectCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, task, application) {
   //     // NOTE: keep this so we can insert the prevOp === null
   //     super(attributes, ParameterDefinitions, null, task, application);
   // }

   ///
   /// Instance Methods
   ///

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {
      if (pDef.name === "name") {
         this.objectID = this.params[pDef.name];
         this.object = this.objectLookup(this.objectID);

         // ?? is this correct?
         // if we already have created a .next operation, and we have
         // just changed our .object, pass that information forward.
         if (this.next) this.next.object = this.object;
      }
   }

   /**
    * @method parseRow()
    * When it is time to pull the information from the properties panel,
    * use this fn to get the current Row of data.
    *
    * This fn() will populate the this.params with the values for each
    * of our .parameterDefinitions.
    *
    * @param {webixNode} row
    *        the current webix node that contains the ROW defining the
    *        operation and it's parameters.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    */
   parseRow(row, id) {
      super.parseRow(row, id);

      // for an Object operation, we need to set our .objectID after
      // the values are parsed.

      if (this.params.name) {
         this.objectID = this.params.name;
         this.object = this.objectLookup(this.params.name);
      }
   }

   warningsEval() {
      super.warningsEval();
      if (!this.object) {
         this.warningMessage("has no object set.", {
            objectID: this.objectID,
         });
      }
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLObject);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 87215:
/*!*******************************************************!*\
  !*** ./src/js/AppBuilder/platform/ql/ABQLRowPluck.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ql_ABQLRowPluckCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ql/ABQLRowPluckCore.js */ 95285);


class ABQLRowPluck extends _core_ql_ABQLRowPluckCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef, id) {
      super.paramChanged(pDef);

      // Re-generate next select options
      if (pDef.name === "fieldID") this.uiNextRowSelectorRefresh(id);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLRowPluck);


/***/ }),

/***/ 83937:
/*!******************************************************!*\
  !*** ./src/js/AppBuilder/platform/ql/ABQLRowSave.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ql_ABQLRowSaveCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ql/ABQLRowSaveCore.js */ 18844);
/*
 * ABQLRowSave
 *
 * An ABQLRowSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */



class ABQLRowSave extends _core_ql_ABQLRowSaveCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   paramChanged(pDef, id) {
      super.paramChanged(pDef);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLRowSave);


/***/ }),

/***/ 35011:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/platform/ql/ABQLRowUpdate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ql_ABQLRowUpdateCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ql/ABQLRowUpdateCore.js */ 58910);
/*
 * ABQLRowUpdate
 *
 * An ABQLRow Update allows you to update the values on the current
 * Row of data.
 *
 */



class ABQLRowUpdate extends _core_ql_ABQLRowUpdateCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, ParameterDefinitions, prevOP, task, application);
   //     // #Hack! : when an Operation provides the same .NextQlOps that it
   //     // was defined in, we can't require it again ==> circular dependency.
   //     // so we manually set it here from the operation that created us:
   //     this.constructor.NextQLOps = prevOP.constructor.NextQLOps;
   // }
   ///
   /// Instance Methods
   ///
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLRowUpdate);


/***/ }),

/***/ 1454:
/*!*******************************************************!*\
  !*** ./src/js/AppBuilder/platform/ql/ABQLSetFirst.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ql_ABQLSetFirstCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ql/ABQLSetFirstCore.js */ 31663);
/*
 * ABQLSetFirst
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */



class ABQLSetFirst extends _core_ql_ABQLSetFirstCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, [], prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLSetFirst);


/***/ }),

/***/ 66966:
/*!*******************************************************!*\
  !*** ./src/js/AppBuilder/platform/ql/ABQLSetPluck.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ql_ABQLSetPluckCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ql/ABQLSetPluckCore.js */ 14154);
/*
 * ABQLSetPluck
 *
 * An ABQLSetPluck can process a set (array) of data and pluck out a specified
 * field from each row to then make an array of values that only contain that 
 * field.
 * 
 * Example: 
array = [
 {
	name: "Neo",
	email: "neo@thematrix.com",
	relationships: [ { morpheous}, {trinity} ]
 },
 {
	name: "trinity",
	email: "trinity@thematrix.com",
	relationships: [ {neo}, {morpheous} ]
 },
 {
	name: "morpheous",
	email: "morpheous@thematrix.com",
	relationships: [ {neo}, {trinity}]
 }

]

pluck("email") :
	[
		"neo@thematrix.com",
		"trinity@thematrix.com",
		"morpheous@thematrix.com"
	]

pluck("relationships"):
	[
		{neo},
		{trinity},
		{morpheous}
	]
 *
 */



class ABQLSetPluck extends _core_ql_ABQLSetPluckCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, [], prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {
      if (pDef.name === "fieldID") {
         // debugger;
         this.fieldID = this.params[pDef.name];
         // v2 method:
         // this.field = this.object.fieldByID(this.fieldID);
         this.field = this.object.fieldByID(this.fieldID);

         // v2 method:
         // if (this.field && this.field.isConnected) {
         if (this.field && this.field.key === "connectObject") {
            this.objectOut = this.field.datasourceLink;
            this.objectOutID = this.objectOut.id;

            // ?? is this correct?
            // if we already have created a .next operation, and we have
            // just changed our .object, pass that information forward.
            if (this.next) this.next.object = this.objectOut;
         }
      }
   }

   /**
    * @method parseRow()
    * When it is time to pull the information from the properties panel,
    * use this fn to get the current Row of data.
    *
    * This fn() will populate the this.params with the values for each
    * of our .parameterDefinitions.
    *
    * NOTE: in this process our .object and .objectOut isn't as simple
    * as the other QL node types.  We'll have to interpolate our values
    * from the given fieldID in our property panel.
    *
    * @param {webixNode} row
    *        the current webix node that contains the ROW defining the
    *        operation and it's parameters.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    */
   parseRow(row, id) {
      super.parseRow(row, id);

      this.fieldID = this.params.fieldID;

      // we now have to build backwards from the current fieldID to set our
      // relevant .object and .objectOut
      this.AB.objects((o) => {
         if (!this.field) {
            // const field = o.fieldByID(this.fieldID);
            const field = o.fieldByID(this.fieldID);

            if (field) this.field = field;
         }
      });

      if (this.field) {
         this.object = this.field.object;

         // v2 method:
         // if (this.field.isConnected) {
         if (this.field && this.field.key === "connectObject") {
            this.objectOut = this.field.datasourceLink;
            this.objectOutID = this.objectOut.id;
         }
      }
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLSetPluck);


/***/ }),

/***/ 68879:
/*!******************************************************!*\
  !*** ./src/js/AppBuilder/platform/ql/ABQLSetSave.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ql_ABQLSetSaveCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ql/ABQLSetSaveCore.js */ 83044);
/*
 * ABQLSetSave
 *
 * An ABQLSetSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */



class ABQLSetSave extends _core_ql_ABQLSetSaveCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, [], prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {
      if (pDef.name === "task_param") {
         this.taskParam = this.params[pDef.name];
      }
   }

   parseRow(row, id) {
      super.parseRow(row, id);

      this.taskParam = this.params["task_param"];

      if (!this.registered) {
         this.task.registerDatasource(this);
         this.registered = true;
      }
   }

   warningsEval() {
      super.warningsEval();
      if (!this.taskParam || this.taskParam === "") {
         this.warningMessage("requires a name to save our data as.");
      }
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABQLSetSave);


/***/ }),

/***/ 69459:
/*!****************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABView.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABView)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewCore.js */ 7852);
/* harmony import */ var _viewComponent_ABViewComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewComponent/ABViewComponent */ 9162);



class ABView extends _core_views_ABViewCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, application, parent) {
   //    super(attributes, application, parent);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new _viewComponent_ABViewComponent__WEBPACK_IMPORTED_MODULE_1__["default"](this);
   }

   /*
    * @method componentList
    * return the list of components available on this view to display in the editor.
    * @param {bool} isEdited  is this component currently in the Interface Editor
    * @return {array} of ABView objects.
    */
   componentList(isEdited) {
      // views not allowed to drop onto this View:
      var viewsToIgnore = [
         "view",
         "page",
         "formpanel",
         "viewcontainer",
         // not allowed Detail's widgets
         "detailcheckbox",
         "detailcustom",
         "detailconnect",
         "detailimage",
         "detailselectivity",
         "detailtext",
         "detailtree",
         // not allowed Form's widgets
         "button",
         "checkbox",
         "connect",
         "datepicker",
         "fieldcustom",
         "textbox",
         "numberbox",
         "selectsingle",
         "selectmultiple",
         "formtree",
         "fieldreadonly",
         // not allowed Chart's Widgets
         "pie",
         "bar",
         "line",
         "area",
         // not allowed Report page
         "report",
         "reportPage",
         "reportPanel",
      ];

      var allComponents = this.application.viewAll(); // ABViewManager.allViews();
      var allowedComponents = allComponents.filter((c) => {
         return viewsToIgnore.indexOf(c.common().key) == -1;
      });

      return allowedComponents;
   }

   changePage(pageId) {
      this.emit("changePage", pageId);
   }

   warningsAll() {
      // report both OUR warnings, and any warnings from any of our fields
      var allWarnings = super.warningsAll();
      this.views().forEach((v) => {
         allWarnings = allWarnings.concat(v.warningsAll());
      });

      (this.pages?.() || []).forEach((p) => {
         allWarnings = allWarnings.concat(p.warningsAll());
      });

      return allWarnings.filter((w) => w);
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      (this.__missingViews || []).forEach((id) => {
         this.warningsMessage(`references unknown View[${id}]`);
      });

      allViews.forEach((v) => {
         v.warningsEval();
      });

      // if a datacollection is specified, verify it can be accessed.
      if (this.settings.dataviewID) {
         let dc = this.datacollections || this.datacollection;
         if (!dc) {
            this.warningsMessage(
               `references unknown dataviewID[${this.settings.dataviewID}]`
            );
         }
      }
   }

   warningsMessage(msg, data = {}) {
      let message = `${this.key}[${this.name}]: ${msg}`;
      this._warnings.push({ message, data });
   }
}


/***/ }),

/***/ 90669:
/*!*************************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABViewContainer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewContainer)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewContainerCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewContainerCore */ 93997);
/* harmony import */ var _viewComponent_ABViewContainerComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewComponent/ABViewContainerComponent */ 77191);



class ABViewContainer extends _core_views_ABViewContainerCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new _viewComponent_ABViewContainerComponent__WEBPACK_IMPORTED_MODULE_1__["default"](this);
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      if (allViews.length == 0) {
         this.warningsMessage("has no content");
      }

      // NOTE: this is done in ABView:
      // (allViews || []).forEach((v) => {
      //    v.warningsEval();
      // });
   }
}


/***/ }),

/***/ 48172:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABViewDetailItem.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewDetailItem)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewDetailItemCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewDetailItemCore */ 63255);

// const ABViewDetailItemComponent = require("./viewComponent/ABViewDetailItemComponent");

class ABViewDetailItem extends _core_views_ABViewDetailItemCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      console.error(
         "DEPRECIATED: ABViewDetailItem.component():  Who is calling this?"
      );
      return null;
      // return new ABViewDetailItemComponent(this);
   }
}


/***/ }),

/***/ 9247:
/*!************************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABViewFormItem.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewFormItem)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewFormItemCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewFormItemCore */ 95484);

// const ABViewFormItemComponent = require("./viewComponent/ABViewFormItemComponent");

// const ABViewFormFieldPropertyComponentDefaults =
//    ABViewFormItemCore.defaultValues();

class ABViewFormItem extends _core_views_ABViewFormItemCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   static get componentUI() {
      console.error(
         "DEPRECIATED: ABViewFormItem.componentUI(): who is calling this?"
      );
      return null;

      // return ABViewFormItemComponent;
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      console.error(
         "DEPRECIATED: ABViewFormItem.component(): who is calling this?"
      );
      return null;

      // return new ABViewFormItemComponent(this);
   }

   /**
    * @method parentFormUniqueID
    * return a unique ID based upon the closest form object this component is on.
    * @param {string} key  The basic id string we will try to make unique
    * @return {string}
    */
   parentFormUniqueID(key) {
      var form = this.parentFormComponent();
      var uniqueInstanceID;
      if (form) {
         uniqueInstanceID = form.uniqueInstanceID;
      } else {
         uniqueInstanceID = webix.uid();
      }

      return key + uniqueInstanceID;
   }
}


/***/ }),

/***/ 22305:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABViewPage.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPage)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewPageCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewPageCore */ 16605);


const ABPropertyComponentDefaults = _core_views_ABViewPageCore__WEBPACK_IMPORTED_MODULE_0__["default"].defaultValues();

class ABViewPage extends _core_views_ABViewPageCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @function component()
    * return a UI component based upon this view.
    * @param {obj} v1App
    * @return {obj} UI component
    */
   component(v1App = false) {
      var component = super.component();

      component._ui = component.ui();

      // wrap our ABViewContainer in our Page scrollview
      component.ui = () => {
         return {
            view: "scrollview",
            borderless: true,
            css:
               this.settings.pageBackground ||
               ABPropertyComponentDefaults.pageBackground,
            body: component._ui,
         };
      };

      // if this is our v1Interface
      if (v1App) {
         var newComponent = component;
         component = {
            ui: component.ui(),
            init: (options, accessLevel) => {
               accessLevel = accessLevel ?? this.getUserAccess();
               return newComponent.init(this.AB, accessLevel, options);
            },
            onShow: (...params) => {
               return newComponent.onShow?.(...params);
            },
         };
      }

      return component;
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      if (allViews.length == 0) {
         this.warningsMessage("has no sub views");
      }

      (this.pages() || []).forEach((p) => {
         p.warningsEval();
      });
   }
}


/***/ }),

/***/ 79562:
/*!**********************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABViewWidget.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewWidget)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewWidgetCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewWidgetCore */ 82218);


const ABPropertyComponentDefaults = _core_views_ABViewWidgetCore__WEBPACK_IMPORTED_MODULE_0__["default"].defaultValues();

class ABViewWidget extends _core_views_ABViewWidgetCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @function component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      let base = super.component(App);

      base.onShow = (viewId) => {
         let dv = this.datacollection; // get from a function or a (get) property
         if (dv && dv.dataStatus == dv.dataStatusFlag.notInitial) {
            // load data when a widget is showing
            dv.loadData();
         }
      };

      return base;
   }
}


/***/ }),

/***/ 9162:
/*!***************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/viewComponent/ABViewComponent.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewComponent)
/* harmony export */ });
/**
 * ABViewComponent
 * A common UI component class for our UI widgets.
 */
// import ClassUI from "../../../../ui/ClassUI";

class ABViewComponent /* extends ClassUI */ {
   constructor(baseView, idBase, ids) {
      // super(idBase || `ABView_${baseView.id}`, ids);

      this.view = baseView;
      this.settings = baseView.settings;
      this.AB = baseView.AB;
      this.datacollection = baseView.datacollections || baseView.datacollection;

      this.__events = [];
      // {array}
      // A collection of any listeners we are managing.
      // {
      //   emitter:   {EventEmitter} the object we are listening on
      //   eventName: {string} the event key we are listening for
      //   listener:  {fn} the function to call on
      // }

      this.CurrentObjectID = null;
      // {string}
      // the ABObject.id of the object we are working with.

      this.CurrentDatacollectionID = null;
      // {string}
      // the ABDataCollection.id of the DC we are working with
   }

   /**
    * @method CurrentObject()
    * A helper to return the current ABObject we are working with.
    * @return {ABObject}
    */
   get CurrentObject() {
      return this.AB.objectByID(this.CurrentObjectID);
   }
   /**
    * @method CurrentDatacollection()
    * A helper to return the current ABDataCollection we are working with.
    * @return {ABDataCollection}
    */
   get CurrentDatacollection() {
      return this.AB.datacollectionByID(this.CurrentDatacollectionID);
   }

   ui(uiComponents = []) {
      // an ABView is a collection of rows:
      const _ui = {
         id: this.ids.component,
         view: "layout",
         type: "space",
         rows: uiComponents,
      };

      // if this form is empty, then force a minimal row height
      // so the component isn't completely hidden on the screen.
      // (important in the editor so we don't loose the ability to edit the
      // component)
      if (!_ui.rows.length) _ui.height = 30;

      return _ui;
   }

   async init(AB) {
      this.AB = AB;
   }

   /**
    * @method datacollectionLoad
    *
    * @param datacollection {ABDatacollection}
    */
   datacollectionLoad(datacollection) {
      this.CurrentDatacollectionID = datacollection?.id;
   }

   objectLoad(object) {
      this.CurrentObjectID = object?.id;
   }

   /**
    * @method eventAdd()
    * Create a new listener on an object. Note, this will prevent multiple
    * listeners being applied to the same Object.
    * @param {object} evt
    *        The definition of the event we are adding:
    *        {
    *           emitter:   {EventEmitter} the object we are listening on
    *           eventName: {string} the event key we are listening for
    *           listener:   {fn} the function to call on
    *        }
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      // make sure we haven't done this before:
      const __events = this.__events;
      const exists = __events.filter(
         (e) => e.emitter === evt.emitter && e.eventName === evt.eventName
         // && e.listener === evt.listener
      );

      if (!exists.length) {
         // add to array
         __events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventsClear()
    * Remove all the attached event listeners and reset our tracking.
    */
   eventsClear() {
      this.__events.forEach((evt) => {
         evt.emitter.removeListener(evt.eventName, evt.listener);
      });

      this.__events = [];
   }

   /**
    * @method onShow()
    * perform any preparations necessary when showing this component.
    */
   onShow() {
      // check if tab has a hint
      if (this?.view?.settings?.hintID) {
         // fetch the steps for the hint
         let hint = this.AB.hintID(this.view.settings.hintID);
         if (hint.settings.active) {
            hint.createHintUI();
         }
      }
      // if we manage a datacollection, then make sure it has started
      // loading it's data when we are showing our component.
      const dc = this.datacollection;

      if (!dc) return;

      if (dc.dataStatus === dc.dataStatusFlag.notInitial)
         // load data when a widget is showing
         dc.loadData();
   }
}


/***/ }),

/***/ 77191:
/*!************************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/viewComponent/ABViewContainerComponent.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewContainerComponent)
/* harmony export */ });
/* harmony import */ var _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewComponent */ 9162);


class ABViewContainerComponent extends _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewContainer_${baseView.id}`, ids);

      this.options = null;

      this.viewComponents = {
         /* view.id : {viewComponent} */
      };
      // {hash}
      // a reference of all our child views that we manage

      this.viewComponentIDs = {
         /* view.id : {viewComponent} */
      };
      // {hash}
      // a reference of all our child.ui().ids of the views we manage

      this._handlerChangePage = (pageId) => {
         baseView.changePage(pageId);
      };
   }

   ui(uiComponents) {
      // Generate rows & cols of views to .layout
      const views = this.view.viewsSortByPosition();
      const rowViews = this.getElements(views);
      const _ui = super.ui(uiComponents || rowViews);

      delete _ui.type;

      return _ui;
   }

   // make sure each of our child views get .init() called
   async init(AB, accessLevel = 0, options = {}) {
      await super.init(AB);

      this.options = options;

      const allInits = [];

      // // register our callbacks:
      // if (options) {
      //    for (var c in _logic.callbacks) {
      //       _logic.callbacks[c] = options[c] || _logic.callbacks[c];
      //    }
      // }

      // see access by CSS class
      $$(this.ids.component)?.define("css", `accessLevel-${accessLevel}`);

      const viewComponents = this.viewComponents;

      // attach all the .UI views:
      for (const key in viewComponents) {
         // skip when the view is removed.
         if (
            !viewComponents[key] ??
            !this.view.views((v) => v.id === key).length
         )
            continue;

         // Initial component along with options in case there are callbacks we need to listen for
         if (accessLevel) {
            allInits.push(viewComponents[key].init(AB, accessLevel, options));

            continue;
         }

         $$(this.viewComponentIDs[key]).hide();
      }

      await Promise.all(allInits);
   }

   getElements(views) {
      const rows = [];
      const componentMap = {};

      let curRowIndex;
      let curColIndex;

      const settings = this.settings;
      const defaultSettings = this.view.constructor.defaultValues();

      views.forEach((v) => {
         // let component = v.component(/* App, idPrefix */);
         // NOTE: PONG - Just temporary to be compatible old & new versions
         let component;

         try {
            component = v.component();
            // make sure any existing handlers for changePage are removed.
            v.removeAllListeners("changePage");
         } catch (err) {
            component = v.component(this.AB._App);

            const ui = component.ui;

            component.ui = (() => ui).bind(component);
         }

         this.viewComponents[v.id] = component;

         ////
         //// TODO: figure out the embedded Callbacks => emit()
         ////
         // if key == "form" or "button" register the callbacks to the parent
         // NOTE this will only work on the last form of a page!
         // if (v.key == "form" && v._logic.callbacks) {
         //    _logic.callbacks = v._logic.callbacks;
         // }

         // Create a new row
         if (v.position.y == null || v.position.y !== curRowIndex) {
            curRowIndex = v.position.y || rows.length;
            curColIndex = 0;

            const rowNew = {
               cols: [],
            };

            // Create columns following setting value
            const colNumber = settings.columns || defaultSettings.columns;

            for (let i = 0; i < colNumber; i++)
               rowNew.cols.push({
                  gravity: settings.gravity?.[i]
                     ? parseInt(settings.gravity[i])
                     : defaultSettings.gravity,
               });

            rows.push(rowNew);
         }

         // Get the last row
         const rowIndx = rows.length - 1;
         const curRow = rows[rowIndx];
         const newPos = v.position.x ?? 0;
         const mapKey = `${rowIndx}-${newPos}`;

         let getGrav = 1;

         if (componentMap[mapKey])
            console.error(
               `Component[${component?.ids?.component}] is overwriting component[${componentMap[mapKey].ids?.component}]. <-- Reorder them to fix.`
            );

         componentMap[mapKey] = component;

         if (curRow.cols[newPos]?.gravity)
            getGrav = curRow.cols[newPos].gravity;

         const _ui = component.ui();

         this.viewComponentIDs[v.id] = _ui.id;
         _ui.gravity = getGrav;

         // Add ui of sub-view to column
         curRow.cols[newPos] = _ui;

         // Trigger 'changePage' event to parent
         this.eventAdd({
            emitter: v,
            eventName: "changePage",
            listener: this._handlerChangePage,
         });

         curColIndex++;
      });

      return rows;
   }

   onShow() {
      super.onShow();

      // calll .onShow in child components
      Object.values(this.viewComponents).forEach((val) => {
         val.onShow?.();
      });
   }
}


/***/ }),

/***/ 26778:
/*!***********************************************!*\
  !*** ./src/js/AppBuilder/rules/ABViewRule.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRule)
/* harmony export */ });
//
// ABViewRule
//
// A component that manages an individual Rule in a Rule list.
//
// Each rule can manage a set of given Actions.  For each Rule, one Action
// can be chosen, A condition for when that action is executed, and then
// inputs for any additional data required by that action.
//
// In live apps, Rules are used when processing events and determining if an
// action is to be performed:
//
//
//
// A Rule needs to save it's current state to an objects settings, and to
// initialize itself from those settings.
//
// import ObjectQueryBuilder from "./ABViewQueryBuilderObjectFieldConditions";

class ABViewRule {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(listActions) {
      this.listActions = listActions || []; // the list of Actions this Rule manages

      // this.actionDropList = []; // the Webix UI droplist
      // this.listActions.forEach((a) => {
      //    this.actionDropList.push({ id: a.key, value: a.label });
      // });

      this.selectedAction = null; // the currently selected Action.key
      // if (this.actionDropList.length > 0) {
      //    this.selectedAction = this.actionDropList[0].id;
      // }

      // this.removable = true; // can I delete this rule?

      this.currentObject = null; // What ABObject is this associated with
      // NOTE: this is important for Actions.

      // this.objectQB = null; // The QueryBuilder (QB) object

      // this.currentForm = null;
   }

   // component(App, idBase) {
   //    this.App = App;
   //    this.idBase = idBase;

   //    // this is different because multiple instances of this View can be displayed
   //    // at the same time.  So make each instance Unique:
   //    var uniqueInstanceID = webix.uid();
   //    var myUnique = (key) => {
   //       // return this.unique(idBase + key ) + '_' + uniqueInstanceID;
   //       return `${idBase}_${key}_${uniqueInstanceID}`;
   //    };

   //    // internal list of Webix IDs to reference our UI components.
   //    var ids = (this.ids = {
   //       // each instance must be unique
   //       component: myUnique("component"),

   //       selectAction: myUnique("chooseAction"),

   //       queryBuilder: myUnique("queryBuilder"),

   //       valueDisplay: myUnique("valueArea"),
   //    });

   //    this.objectQB.label = L("When");
   //    this.objectQB.component(this.App, this.idBase);
   //    this.ui = this._generateUI();

   //    // for setting up UI
   //    this.init = (options) => {
   //       // register callbacks:
   //       for (var c in _logic.callbacks) {
   //          _logic.callbacks[c] = options[c] || _logic.callbacks[c];
   //       }

   //       this.objectQB.init();

   //       // make sure the current Action's value display is initialized:
   //       var Action = this.currentAction();
   //       if (Action) {
   //          Action.component(this.App, this.idBase);
   //          var comp = Action.valueDisplay(ids.valueDisplay);

   //          _logic.replaceValueDisplay(comp);

   //          // webix.ui(comp.ui, $$(this.ids.valueDisplay));
   //          comp.init();
   //       }
   //    };

   //    // internal business logic
   //    var _logic = (this._logic = {
   //       callbacks: {
   //          onDelete: function () {
   //             console.warn("NO onDelete()!");
   //          },
   //          onSave: function (field) {
   //             console.warn("NO onSave()!");
   //          },
   //       },

   //       replaceValueDisplay: (component) => {
   //          // remove current content area:
   //          var $ValueDisplay = $$(this.ids.valueDisplay);
   //          if (!$ValueDisplay) return;

   //          var children = $ValueDisplay.getChildViews();
   //          var cloneChildren = [];
   //          children.forEach((c) => {
   //             cloneChildren.push(c);
   //          });
   //          cloneChildren.forEach((c) => {
   //             $ValueDisplay.removeView(c);
   //          });

   //          $ValueDisplay.addView(component.ui);
   //       },

   //       selectAction: (newValue, oldVal) => {
   //          if (newValue) {
   //             $$(this.ids.component)
   //                .getChildViews()
   //                .forEach((views) => {
   //                   views.show();
   //                });
   //          }
   //          // bonus:  save current state of previous Action
   //          var prevAction = this.getAction(oldVal);
   //          if (prevAction) {
   //             prevAction.stashCondition(this.objectQB.getValue());
   //          }

   //          // now switch to the new Action
   //          this.selectedAction = newValue;
   //          var currAction = this.currentAction();
   //          if (currAction) {
   //             // reset Condition filters.
   //             this.objectQB.setValue(currAction.condition());

   //             // have Action display it's values form
   //             currAction.component(this.App, this.idBase);
   //             var component = currAction.valueDisplay(ids.valueDisplay);
   //             _logic.replaceValueDisplay(component);
   //             component.init();
   //             // currAction.valueDisplay(ids.valueDisplay);
   //          }
   //       },
   //    });
   // }

   // // not intended to be called externally
   // _generateUI() {
   //    return {
   //       id: this.ids.component,
   //       view: "layout",
   //       css: "ab-component-form-rules",
   //       padding: 20,
   //       // margin: 10,

   //       // this should be a CSS setting: this.AB.Config.xxxx
   //       // width: 680,
   //       type: "line",
   //       rows: [
   //          {
   //             view: "template",
   //             css: "ab-component-form-rules-delete",
   //             template: '<i class="fa fa-trash ab-component-remove"></i>',
   //             height: 30,
   //             borderless: true,
   //             hidddatasourceen: this.removable == false,
   //             onClick: {
   //                "ab-component-remove": (e, id, trg) => {
   //                   this._logic.callbacks.onDelete(this);
   //                },
   //             },
   //          },
   //          // Action
   //          {
   //             id: this.ids.selectAction,
   //             view: "richselect",
   //             label: L("Action"),
   //             placeholder: L("Choose an action"),
   //             labelWidth: this.AB.UISettings.config().labelWidthLarge,
   //             options: this.actionDropList,
   //             on: {
   //                onChange: (newVal, oldVal) => {
   //                   this._logic.selectAction(newVal, oldVal);
   //                },
   //             },
   //          },

   //          // Values
   //          {
   //             for: "values",
   //             hidden: true,
   //             cells: [
   //                {
   //                   view: "layout",
   //                   cols: [
   //                      {
   //                         view: "label",
   //                         label: L("Values"),
   //                         css: "ab-text-bold",
   //                         width: this.AB.UISettings.config().labelWidthLarge,
   //                      },
   //                      {
   //                         id: this.ids.valueDisplay,
   //                         view: "layout",
   //                         rows: [
   //                            {
   //                               label: L(
   //                                  " ABViewRule: This should be the Set Area"
   //                               ),
   //                               css: "ab-text-bold",
   //                               height: 30,
   //                            },
   //                         ],
   //                      },
   //                   ],
   //                },
   //             ],
   //          },

   //          // When
   //          this.objectQB.ui,
   //       ],
   //    };
   // }

   // return the QueryBuilder fields data for the currently selected Action.
   conditionFields() {
      var fields = [];

      var selectedAction = this.currentAction();
      if (selectedAction) {
         fields = selectedAction.conditionFields();
      }

      return fields;
   }

   currentAction() {
      return this.getAction(this.selectedAction);
   }

   getAction(key) {
      return this.listActions.filter((a) => {
         return a.key == key;
      })[0];
   }

   objectLoad(object) {
      console.assert(object, "objectLoad(): object is required.");
      this.currentObject = object;
      this.listActions.forEach((a) => {
         a.objectLoad(object);
      });

      // var label = L("When");

      // this.objectQB = new ObjectQueryBuilder(label);
      // this.objectQB.objectLoad(object);

      // // regenerate our UI when a new object is loaded.
      // if (this.ids) {
      //    this.ui = this._generateUI();
      // }
      this.AB = object.AB;
   }

   formLoad(form) {
      this.currentForm = form;
      this.listActions.forEach((a) => {
         a.formLoad(form);
      });
   }

   processPre(options = {}) {
      let isValid = this.isValid(options.data);
      if (!isValid) return;

      let currentAction = this.currentAction();
      if (!currentAction) return;

      currentAction.processUpdateObject({}, options.data);
   }

   // process
   // Take the provided data and process this rule
   // @param {obj} options
   // @return {Promise}
   process(options) {
      var currentAction = this.currentAction();
      if (!currentAction) return Promise.resolve();

      let isValid = this.isValid(options.data);
      if (isValid) {
         return currentAction.process(options);
      } else {
         // else just resolve and continue on
         return new Promise((resolve, reject) => {
            resolve();
         });
      }
   }

   fromSettings(settings) {
      settings = settings || {};

      if (settings.selectedAction) {
         // store our Query Rules
         this.selectedAction = settings.selectedAction;
         var selectedAction = this.currentAction();
         if (!selectedAction) return;
         selectedAction.stashCondition(settings.queryRules || {});

         // // if our UI components are present, populate them properly:
         // if (this.ids) {
         //    // Trigger our UI to refresh with this selected Action:
         //    // NOTE: this also populates the QueryBuilder
         //    $$(this.ids.selectAction).setValue(this.selectedAction);
         //    // this._logic.selectAction(this.selectedAction);
         // }

         // now continue with setting up our settings:
         selectedAction.fromSettings(settings.actionSettings);
      }
   }

   toSettings() {
      console.error("ABViewRule should not be calling toSettings()");
      var settings = {};

      if (this.selectedAction) {
         settings.selectedAction = this.selectedAction;
         // settings.queryRules = this.objectQB.getValue();
         let currentAction = this.currentAction();
         if (currentAction) {
            settings.actionSettings = currentAction.toSettings();
         }
      }

      return settings;
   }

   // // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // // choosers properly if it hasn't been shown before the .setValue() call.
   // // so this work around allows us to refresh the display after the .show()
   // // on the popup.
   // // When they've fixed the bug, we'll remove this workaround:
   // qbFixAfterShow() {
   //    var currAction = this.currentAction();
   //    if (currAction && this.objectQB) {
   //       this.objectQB.setValue(currAction.condition());
   //       currAction.qbFixAfterShow();
   //    }
   // }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * @return {Promise}
    */
   async isReady() {
      let currentAction = this.currentAction();
      if (currentAction) {
         return currentAction.isReady();
      }
      return Promise.resolve();
   }

   isValid(data = {}) {
      const fields = this.currentObject.fields(),
         currentAction = this.currentAction(),
         QBCondition = currentAction.condition(),
         query = QBCondition[0] ?? {};

      const convertToNumber = (text = "") => {
         // if we have multiple rules we need to check if value is already a number before converting.
         if (typeof text == "number") return text;

         return parseFloat(text.replace(/[^-0-9.]/g, ""));
      };

      // Fix string data in number type
      // NOTE: "1000" > "99" = false    >_<!
      fields
         .filter(
            (f) =>
               f.key == "number" || f.key == "calculate" || f.key == "formula"
         )
         .forEach((f) => {
            try {
               // filter conditions
               if (Array.isArray(query?.rules)) {
                  query.rules.forEach((r) => {
                     // NOTE: compatible with old settings
                     if (r.key == f.id || r.key == f.columnName)
                        r.value = convertToNumber(r.value);
                  });
               }

               // row data
               if (
                  data[f.columnName] &&
                  typeof data[f.columnName] === "string"
               ) {
                  data[f.columnName] = convertToNumber(data[f.columnName]);
               }
            } catch (e) {
               // continue regardless of error
            }
         });

      const hiddenFilter = (this.AB ?? AB).filterComplexNew(
         `${this.idBase}_filter_complex`
      );
      hiddenFilter.fieldsLoad(fields, this.currentObject);
      hiddenFilter.setValue(query);
      hiddenFilter.init();

      return hiddenFilter.isValid(data);

      // var id = "hiddenQB_" + webix.uid();

      // // if our data passes the QueryRules then tell Action to process
      // var ui = {
      //    id: id,
      //    hidden: true,
      //    view: "querybuilder",
      // };
      // var hiddenQB = webix.ui(ui);

      // let currentAction = this.currentAction();
      // var QBCondition = currentAction.condition();

      // if (this.objectQB) {
      //    this.objectQB.cleanRules(QBCondition[0], QBCondition[1], false);
      // }

      // let query = QBCondition[0] || {},
      //    fields = QBCondition[1] || [];

      // // hiddenQB.setValue(QBCondition);
      // hiddenQB.setValue({
      //    query: query,
      //    fields: fields,
      // });

      // var QBHelper = hiddenQB.getFilterHelper();
      // var isValid = QBHelper(data);

      // hiddenQB.destructor(); // remove the QB

      // return isValid;
   }

   get isPreProcess() {
      let currentAction = this.currentAction();
      return currentAction.isPreProcess || false;
   }
}


/***/ }),

/***/ 40804:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/rules/ABViewRuleAction.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleAction)
/* harmony export */ });
//
// ABViewRuleAction
//
// A component that manages an individual Action in a Rule.
//
// Each Action is responsible for figuring out when it can run, and what to do.
//
// In live apps, Actions are used when processing events and determining if an
// if and what is to be performed:
//
//
//
// An Action needs to save it's current state to an objects settings, and to
// initialize itself from those settings.
//

class ABViewRuleAction {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    * @param {ABViewForm} currentForm	the current form this Action is associated with.
    */
   constructor(App, idBase, currentForm) {
      this.key = "ABViewRuleAction";

      this.queryObject = null; // the current ABObject we use to create QueryBuilder information.

      this.currentForm = null;

      this.queryRules = {}; // default set of rules for the Query Builder condition

      this.valueRules = {}; // the initial Value Rules for this Action
      // The Action Subclass defines what this {} is.

      this.currentForm = currentForm; // the ABViewForm object that this rule Action is tied to.
   }
   /*
   component(App, idBase) {
      this.App = App;
      this.idBase = idBase;

      this.label = L("generic abviewruleaction");

      function myUnique(key) {
         return App.unique(`${idBase}_${key}`);
      }

      // internal list of Webix IDs to reference our UI components.
      var ids = (this.ids = {
         // each instance must be unique
         component: `${myUnique("component")}_${webix.uid()}`,
      });

      this._ui = null; // internally track our UI Component value Rules

      // for setting up UI
      this.init = (options) => {
         // register callbacks:
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }
      };

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onDelete: function () {
               console.warn("NO onDelete()!");
            },
            onSave: function (field) {
               console.warn("NO onSave()!");
            },
         },
      });
   }
*/
   // condition
   // Return the querybuilder setup structure for this Action.
   // @return {array}  of querybuilder setup
   //					[
   //						{rules},
   //						[fields]
   //					]
   condition() {
      return [this.conditionRules(), this.conditionFields()];
   }

   // stashCondition
   // capture the current set of rules provided by the QB object.
   // This doesn't guarantee these will be saved to the App settings.
   // Instead it is a temporary stash. Only the selected Action's
   // values will be persisited to the App settings.
   // @param {obj/Array} rules  The QueryBuilder rule value returned from
   //							 .getValue()
   //							 note: it is the first entry .getValue()[0]
   //
   stashCondition(rules) {
      // check to see if they sent us the raw QueryBuilder values and only
      // pull off the rules if they did
      if (Array.isArray(rules)) {
         rules = rules[0];
      }

      // sanity check on glue value: don't update if null or not given.
      if (rules) {
         // sometimes .glue is undefined  so default to 'and'
         if (rules.glue != "or") rules.glue = "and";

         this.queryRules = rules;
      }
   }

   // conditionFields()
   // Return the list of fields we are able to update.
   // @return {array} of querybuilder field definitions:
   //					[
   // 						{ id:"fname",   value:"First Name", type:"string" },
   //					    { id:"lname",   value:"Last Name",  type:"string" },
   //					    { id:"age",     value:"Age",        type:"number" },
   //					    { id:"bdate",   value:"Birth Date", type:"date" }
   //					]
   conditionFields() {
      var fieldTypes = ["string", "number", "date", "formula", "calculate"];

      var currFields = [];

      if (this.queryObject) {
         this.queryObject.fields().forEach((f) => {
            if (fieldTypes.indexOf(f.key) != -1) {
               // NOTE: the .id value must match the obj[.id]  in the data set
               // so if your object data looks like:
               // 	{
               //		name_first:'Neo',
               //		name_last: 'The One'
               //  },
               // then the ids should be:
               // { id:'name_first', value:'xxx', type:'string' }
               currFields.push({
                  id: f.columnName,
                  value: f.label,
                  type: f.key,
               });
            }
         });
      }

      return currFields;
   }

   // conditionRules()
   // Return the current rule definition object for this Action.
   // @return {obj}
   conditionRules() {
      return this.queryRules;
   }

   // objectLoad
   // save the current object this Action is associated with.
   objectLoad(object) {
      // this.currentObject = object;				// DO WE NEED THIS?
      this.queryObjectLoad(object);
   }

   // queryObjectLoad
   // save the current object this Action is using to build query rules.
   queryObjectLoad(object) {
      this.queryObject = object;
   }

   formLoad(form) {
      this.currentForm = form;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   // @return {Promise}
   process(options) {
      console.error(
         "!!! ABViewRuleAction.process() should be overridden by its child class."
      );
      return new Promise((resolve, reject) => {
         reject(
            new Error(
               "ABViewRuleAction.process() should be overridden by its child class."
            )
         );
      });
   }

   // // valueDisplay
   // // create the form to collect the specific data this Action needs to function.
   // // @param {string} webixID  the $$(webixID) of the area to insert our display.
   // valueDisplay(webixID) {
   //    return this.valueDisplayComponent(webixID);
   // }

   // // valueDisplayComponent
   // // Return an ABView to display our values form.
   // //
   // valueDisplayComponent(idBase) {
   //    return (this._ui = {
   //       ui: {
   //          template: "ABViewRuleAction.valueDisplayComponent",
   //       },
   //       init: (data) => {
   //          console.error(
   //             "!!! ABViewRuleAction.valueDisplayComponent() should be overridden."
   //          );
   //          console.warn(" --> passed in data:", data);
   //       },
   //    });
   // }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      // settings: {
      //	valueRules:{}
      // }
      settings = settings ?? {};
      this.valueRules = settings.valueRules ?? settings;
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      var settings = {};

      // require the child to insert the valueRules
      return settings;
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * @return {Promise}
    */
   isReady() {
      return Promise.resolve();
   }

   // // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // // choosers properly if it hasn't been shown before the .setValue() call.
   // // so this work around allows us to refresh the display after the .show()
   // // on the popup.
   // // When they've fixed the bug, we'll remove this workaround:
   // qbFixAfterShow() {
   //    // our child classes can implement this if needed.
   //    // 	- ABViewRuleActionFormRecordRuleUpdateConnected
   // }
}


/***/ }),

/***/ 55795:
/*!***************************************************!*\
  !*** ./src/js/AppBuilder/rules/ABViewRuleList.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleList)
/* harmony export */ });
//
// ABViewRuleList
//
// A UI component that is responsible for displaying a list of current "Rules"
// for a given purpose.  Some examples are the
//		Form -> Submit Rules,
//		Form -> Display Rules
// 		Form -> Record Rules.
//

// ABViewRuleList is the parent object that manages displaying the common popup,
// list, adding a rule, removing rules, etc...
//
// It is intending to be subclassed by a Specific List object that will load
// up a given set of Actions for their list.
//
// When using it in the AppBuilder Interface Builder, this object provides:
// 	var PopupRecordList = new ABViewRuleList(App, idBase);
//  PopupRecordList.fromSettings(CurrentObjectDefinition.rules); // populates List with current settings defined in CurrentObjectDefinition
//  PopupRecordList.init({ onSave:()=>{}})	// displays the popup for IB
//  CurrentObjectDefinition.rules = PopupRecordList.toSettings(); // save the settings to store in json config
//
// When using on a live running App:
//  PopupRecordList = new ABViewRuleList();
//  PopupRecordList.fromSettings();
//
//  onFormSubmit(data) {
//		// note: this automatically validates and runs each rule:
//		PopupRecordList.process({data:data, view:{ current ABViewForm object }})
//		.then()
//		.catch();
//  }

class ABViewRuleList {
   /**
    */
   constructor(childSettings) {
      this.listRules = [];
      this.currentObject = null;

      // ensure required values:
      childSettings = childSettings || {};
      childSettings.labels = childSettings.labels || {};
      childSettings.labels.header =
         childSettings.labels.header || "ab.components.form.ruleList";
      childSettings.labels.headerDefault =
         childSettings.labels.headerDefault || "*Rule List";
      this.childSettings = childSettings;
   }

   // /**
   //  * @method component
   //  * initialize the UI display for this popup editor.
   //  * @param {obj} App  The common UI App object shared among our UI components
   //  * @param {string} idBase A unique Key used the the base of our unique ids
   //  */
   // component(App, idBase) {
   //    this.App = this.App || App;
   //    this.idBase = idBase;

   //    App = App || this.App;

   //    this.currentForm = null;

   //    // internal list of Webix IDs to reference our UI components.
   //    var ids = (this.ids = {
   //       component: `${idBase}_component`,
   //       rules: `${idBase}_rules`,
   //       rulesScrollview: `${idBase}_rulesScrollview`,

   //       action: `${idBase}_action`,
   //       when: `${idBase}_when`,

   //       values: `${idBase}_values`,
   //       set: `${idBase}_set`,
   //    });

   //    // webix UI definition:
   //    this.ui = {
   //       view: "window",
   //       id: ids.component,
   //       modal: true,
   //       position: "center",
   //       resize: true,
   //       width: 700,
   //       height: 450,
   //       css: "ab-main-container",
   //       head: {
   //          view: "toolbar",
   //          css: "webix_dark",
   //          cols: [
   //             {
   //                view: "label",
   //                label: this.childSettings.labels.headerDefault,
   //             },
   //             {
   //                view: "button",
   //                css: "webix_primary",
   //                icon: "fa fa-plus",
   //                type: "iconButton",
   //                label: L("Add new rule"),
   //                width: 150,
   //                click: () => {
   //                   this.addRule();
   //                   console.log($$(ids.rules).$height);
   //                   $$(ids.rulesScrollview).scrollTo(0, $$(ids.rules).$height);
   //                },
   //             },
   //          ],
   //       },
   //       body: {
   //          type: "form",
   //          rows: [
   //             {
   //                view: "scrollview",
   //                id: ids.rulesScrollview,
   //                scroll: "xy",
   //                body: {
   //                   view: "layout",
   //                   id: ids.rules,
   //                   margin: 20,
   //                   padding: 10,
   //                   rows: [],
   //                },
   //             },
   //             // {
   //             // 	css: { 'background-color': '#fff' },
   //             // 	cols: [
   //             // 		{
   //             // 			view: "button",
   //             // 			icon: "plus",
   //             // 			type: "iconButton",
   //             // 			label: labels.component.addNewRule,
   //             // 			width: 150,
   //             // 			click: () => {
   //             // 				this.addRule();
   //             // 			}
   //             // 		},
   //             // 		{ fillspace: true }
   //             // 	]
   //             // },
   //             {
   //                css: { "background-color": "#fff" },
   //                cols: [
   //                   { fillspace: true },
   //                   {
   //                      view: "button",
   //                      name: "cancel",
   //                      value: L("Cancel"),
   //                      css: "ab-cancel-button",
   //                      autowidth: true,
   //                      click: function () {
   //                         _logic.buttonCancel();
   //                      },
   //                   },
   //                   {
   //                      view: "button",
   //                      css: "webix_primary",
   //                      name: "save",
   //                      label: L("Save"),
   //                      type: "form",
   //                      autowidth: true,
   //                      click: function () {
   //                         _logic.buttonSave();
   //                      },
   //                   },
   //                   { fillspace: true },
   //                ],
   //             },
   //          ],
   //       },
   //    };

   //    // var _currentObject = null;
   //    var _rules = [];

   //    // for setting up UI
   //    this.init = (options) => {
   //       // register callbacks:
   //       for (var c in _logic.callbacks) {
   //          _logic.callbacks[c] = options[c] || _logic.callbacks[c];
   //       }

   //       webix.ui(this.ui);
   //    };

   //    // internal business logic
   //    var _logic = (this._logic = {
   //       buttonCancel: function () {
   //          $$(ids.component).hide();
   //       },

   //       buttonSave: () => {
   //          var results = this.toSettings();

   //          _logic.callbacks.onSave(results);
   //          _logic.hide();
   //       },

   //       callbacks: {
   //          onCancel: function () {
   //             console.warn("NO onCancel()!");
   //          },
   //          onSave: function (field) {
   //             console.warn("NO onSave()!");
   //          },
   //       },

   //       hide: function () {
   //          $$(ids.component).hide();
   //       },

   //       show: function () {
   //          $$(ids.component).show();
   //       },
   //    });

   //    this.show = _logic.show;
   //    this.setValue = _logic.setValue;
   // }

   /**
    * @method addRule
    * Instantiate a new Rule in our list.
    * @param {obj} settings  The settings object from the Rule we created in .toSettings()
    */
   addRule(settings) {
      var Rule = this.getRule();
      if (!Rule) return;

      this.listRules.push(Rule);

      // // if we have tried to create our component:
      // if (this.ids) {
      //    // if our actually exists, then populate it:
      //    var RulesUI = $$(this.ids.rules);
      //    if (RulesUI) {
      //       // make sure Rule.ui is created before calling .init()
      //       Rule.component(this.App, this.idBase); // prepare the UI component
      //       var viewId = RulesUI.addView(Rule.ui);

      //       Rule.init({
      //          onDelete: (deletedRule) => {
      //             $$(this.ids.rules).removeView(Rule.ids.component);

      //             var index = this.listRules.indexOf(deletedRule);
      //             if (index !== -1) {
      //                this.listRules.splice(index, 1);
      //             }
      //          },
      //       });
      //    }
      // }

      if (settings) {
         Rule.fromSettings(settings);
      }
   }

   /**
    * @method fromSettings
    * Create an initial set of default values based upon our settings object.
    * @param {obj} settings  The settings object we created in .toSettings()
    */
   fromSettings(settings) {
      // settings: [
      //  { rule.settings },
      //  { rule.settings }
      // ]

      // clear any existing Rules:
      this.listRules = [];

      if (settings) {
         settings.forEach((ruleSettings) => {
            this.addRule(ruleSettings);
         });
      }
   }

   /**
    * @method objectLoad
    * A rule is based upon a Form that was working with an Object.
    * .objectLoad() is how we specify which object we are working with.
    *
    * @param {ABObject} The object that will be used to evaluate the Rules
    */
   objectLoad(object) {
      this.currentObject = object;

      // tell each of our rules about our object
      this.listRules.forEach((r) => {
         r.objectLoad(object);
      });
   }

   processPre(options) {
      (this.listRules || [])
         .filter((rule) => rule.isPreProcess == true)
         .forEach((rule) => {
            rule.processPre(options, options.data);
         });
   }

   /**
    * @method process
    * Take the provided data and process each of our rules.
    * @param {obj} options
    * @return {promise}
    */
   process(options) {
      return new Promise((resolve, reject) => {
         let listRules = (this.listRules || []).filter(
            (rule) => !rule.isPreProcess
         );

         var numDone = 0;
         var onDone = () => {
            numDone++;
            if (numDone >= listRules.length) {
               resolve();
            }
         };

         listRules.forEach((rule) => {
            rule
               .process(options)
               .then(function () {
                  onDone();
               })
               .catch((err) => {
                  reject(err);
               });
         });

         if (listRules.length == 0) {
            resolve();
         }
      });
   }

   /**
    * @method toSettings
    * create a settings object to be persisted with the application.
    * @return {array} of rule settings.
    */
   toSettings() {
      var settings = [];
      this.listRules.forEach((r) => {
         settings.push(r.toSettings());
      });
      return settings;
   }

   getRule() {
      console.error(
         "!!! ABViewRuleList.getRule() should be overridded by a child object."
      );
      return null;
   }

   formLoad(form) {
      this.currentForm = form;
      this.App = this.App || form.App;
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * @return {Promise}
    */
   rulesReady() {
      // This base class should be overwritten by any subclass that needs
      // to prepare:
      return Promise.resolve();
   }

   // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // choosers properly if it hasn't been shown before the .setValue() call.
   // so this work around allows us to refresh the display after the .show()
   // on the popup.
   // When they've fixed the bug, we'll remove this workaround:
   qbFixAfterShow() {
      this.listRules.forEach((r) => {
         r.qbFixAfterShow();
      });
   }
}


/***/ }),

/***/ 35924:
/*!******************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ABViewRuleListFormRecordRules.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleListFormRecordRules)
/* harmony export */ });
/* harmony import */ var _ABViewRuleList__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewRuleList */ 55795);
/* harmony import */ var _ABViewRule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ABViewRule */ 26778);
/* harmony import */ var _ruleActions_ABViewRuleActionFormRecordRuleUpdate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleUpdate */ 39218);
/* harmony import */ var _ruleActions_ABViewRuleActionFormRecordRuleInsertConnected__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleInsertConnected */ 41294);
/* harmony import */ var _ruleActions_ABViewRuleActionFormRecordRuleUpdateConnected__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleUpdateConnected */ 71820);
/* harmony import */ var _ruleActions_ABViewRuleActionFormRecordRuleRemoveConnected__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleRemoveConnected */ 27645);
/**
 * @Class ABViewRuleListFormRecordRules
 * On the ab_platform_service platform, the ABRecordRule is just
 * a blank stub. These only operate on the WEB platform, but are
 * referenced by our FORM components.
 */








class ABViewRuleListFormRecordRules extends _ABViewRuleList__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      var settings = {
         labels: {
            header: "ab.components.form.recordRules",
            headerDefault: "Record Rules",
         },
      };
      super(settings);
   }

   // warningsEval() {
   //    super.warningsEval();
   //    let allViews = this.views();
   //    if (allViews.length == 0) {
   //       this.warningsMessage("has no sub views");
   //    }
   //    (this.pages() || []).forEach((p) => {
   //       p.warningsEval();
   //    });
   // }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our list of Rules is
    * ready to work.
    * @return {Promise}
    */
   async rulesReady() {
      var allReady = (this.listRules || []).map((r) => r.isReady());
      await Promise.all(allReady);
   }

   // must return the actual Rule object.
   getRule() {
      var listActions = [
         new _ruleActions_ABViewRuleActionFormRecordRuleUpdate__WEBPACK_IMPORTED_MODULE_2__["default"](
            this.App,
            `${this.idBase}_ruleActionUpdate`,
            this.currentForm
         ),
         new _ruleActions_ABViewRuleActionFormRecordRuleInsertConnected__WEBPACK_IMPORTED_MODULE_3__["default"](
            this.App,
            `${this.idBase}_ruleActionInsert`,
            this.currentForm
         ),
         new _ruleActions_ABViewRuleActionFormRecordRuleUpdateConnected__WEBPACK_IMPORTED_MODULE_4__["default"](
            this.App,
            `${this.idBase}_ruleActionUpdateConnected`,
            this.currentForm
         ),
         new _ruleActions_ABViewRuleActionFormRecordRuleRemoveConnected__WEBPACK_IMPORTED_MODULE_5__["default"](
            this.App,
            `${this.idBase}_ruleActionRemoveConnected`,
            this.currentForm
         ),
      ];

      var Rule = new _ABViewRule__WEBPACK_IMPORTED_MODULE_1__["default"](listActions);
      if (this.currentObject) {
         Rule.objectLoad(this.currentObject);
      }
      return Rule;
   }
}


/***/ }),

/***/ 48828:
/*!******************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ABViewRuleListFormSubmitRules.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleListFormSubmitRules)
/* harmony export */ });
/* harmony import */ var _ABViewRuleList__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewRuleList */ 55795);
/* harmony import */ var _ABViewRule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ABViewRule */ 26778);
/* harmony import */ var _ruleActions_ABViewRuleActionFormSubmitRuleConfirmMessage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleConfirmMessage */ 91538);
/* harmony import */ var _ruleActions_ABViewRuleActionFormSubmitRuleExistPage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleExistPage */ 90786);
/* harmony import */ var _ruleActions_ABViewRuleActionFormSubmitRuleParentPage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleParentPage */ 57973);
/* harmony import */ var _ruleActions_ABViewRuleActionFormSubmitRuleClosePopup__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleClosePopup */ 98674);
/* harmony import */ var _ruleActions_ABViewRuleActionFormSubmitRuleWebsite__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleWebsite */ 19679);
/* harmony import */ var _ruleActions_ABViewRuleActionFormSubmitRuleEmail__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleEmail */ 87278);
/**
 * @Class ABViewRuleListFormSubmitRules
 * On the ab_platform_service platform, the ABRecordRule is just
 * a blank stub. These only operate on the WEB platform, but are
 * referenced by our FORM components.
 */










class ABViewRuleListFormSubmitRules extends _ABViewRuleList__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      var settings = {
         labels: {
            header: "ab.component.form.submitRule",
            headerDefault: "Submit Rules",
         },
      };
      super(settings);
   }

   // must return the actual Rule object.
   getRule() {
      var listActions = [
         new _ruleActions_ABViewRuleActionFormSubmitRuleConfirmMessage__WEBPACK_IMPORTED_MODULE_2__["default"](
            this.App,
            `${this.idBase}_ruleActionConfirmMessage`
         ),
         new _ruleActions_ABViewRuleActionFormSubmitRuleExistPage__WEBPACK_IMPORTED_MODULE_3__["default"](this.App, `${this.idBase}_ruleActionExistPage`),
         new _ruleActions_ABViewRuleActionFormSubmitRuleParentPage__WEBPACK_IMPORTED_MODULE_4__["default"](this.App, `${this.idBase}_ruleActionParentPage`),
         new _ruleActions_ABViewRuleActionFormSubmitRuleClosePopup__WEBPACK_IMPORTED_MODULE_5__["default"](this.App, `${this.idBase}_ruleActionClosePopup`),
         new _ruleActions_ABViewRuleActionFormSubmitRuleWebsite__WEBPACK_IMPORTED_MODULE_6__["default"](this.App, `${this.idBase}_ruleActionWebsite`),
         new _ruleActions_ABViewRuleActionFormSubmitRuleEmail__WEBPACK_IMPORTED_MODULE_7__["default"](this.App, `${this.idBase}_ruleActionEmail`),
      ];

      var Rule = new _ABViewRule__WEBPACK_IMPORTED_MODULE_1__["default"](listActions);
      console.assert(this.objectLoad, "this.objectLoad is not defined");
      if (this.currentObject) {
         Rule.objectLoad(this.currentObject);
      }
      Rule.formLoad(this.currentForm);
      return Rule;
   }
}


/***/ }),

/***/ 41294:
/*!**********************************************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleInsertConnected.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleActionFormRecordRuleInsertConnected)
/* harmony export */ });
/* harmony import */ var _ABViewRuleActionFormRecordRuleUpdateConnected__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewRuleActionFormRecordRuleUpdateConnected */ 71820);
//
// ABViewRuleActionFormRecordRuleInsertConnected
//
// An action that allows you to insert a connected object.
//
// NOTE: this is very similar to the Update Connected Rule, so we subclass that one and
// modify it to only Insert data.
//
//


class ABViewRuleActionFormRecordRuleInsertConnected extends _ABViewRuleActionFormRecordRuleUpdateConnected__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleInsertConnected";
      this.label = "Insert Connected Object";
   }

   /**
    * valueDisplayChooser
    * Our Values Display is a Select Box with a choice of connected fields.
    * Once a field is chosen, then we display the Updater form.
    * @param {string}  idBase  a unique webix id to base our sub components on.
    */
   // valueDisplayChooser(idBase) {
   //    var Component = super.valueDisplayChooser(idBase);

   //    // in our case, there are no additional QB conditions:
   //    // so overwrite the .showQBIfNeeded() routine to not show anything:
   //    Component._logic.showQBIfNeeded = function () {};

   //    return Component;
   // }

   /**
    * queryBuilderDisplay
    * override our parent .queryBuilderDisplay to not create a new .objectQB
    * @return {null}
    */
   queryBuilderDisplay() {
      return null;
   }

   /**
    * process
    * gets called when a form is submitted and the data passes the Query Builder Rules.
    * @param {obj} options
    *				options.data : {obj} the key=>value of the data just entered by the form
    *				options.form : {ABViewForm} the Form object that is processing this rule
    * @return {Promise}
    */
   process(options) {
      // get connected object
      var connObj = this.connectedObject();
      var model = connObj.model();

      var connectionField = this.selectedField();

      // var condition = null; // our lookup condition

      // we are going to create a new instance of the connected object
      // and make sure our .id is in the connected object's connectionField
      // the server side will take care of making the proper relationship.

      // first, create a new set of values:
      var newObjectValues = {};

      // update them according to our rules
      this.processUpdateObject({}, newObjectValues);

      if (newObjectValues.newRecords) {
         // now add our .id to the proper field in newObjectValues
         let connectedObjectField = connObj.fieldByID(
            connectionField.settings.linkColumn
         );

         if (!connectedObjectField)
            return Promise.reject("No connected object field");

         newObjectValues.newRecords.forEach((r) => {
            r[connectedObjectField.columnName] = options.data.id;
            // perform the update/insert
            return model.create(r);
         });
      } else {
         // now add our .id to the proper field in newObjectValues
         let connectedObjectField = connObj.fieldByID(
            connectionField.settings.linkColumn
         );

         if (!connectedObjectField)
            return Promise.reject("No connected object field");

         newObjectValues[connectedObjectField.columnName] = options.data.id;

         // perform the update/insert
         return model.create(newObjectValues);
      }
   }

   /**
    * toSettings
    * return an object that represents the current state of this Action
    * @return {obj}
    */
   toSettings() {
      // settings: {
      // 	selectedFieldID: 'guid',
      //	valueRules:{}		// from ABViewRuleActionObjectUpdater
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      // we don't use .qpCondition
      delete settings.qbCondition;

      return settings;
   }
}


/***/ }),

/***/ 27645:
/*!**********************************************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleRemoveConnected.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleActionFormRecordRuleRemoveConnected)
/* harmony export */ });
/* harmony import */ var _ABViewRuleActionFormRecordRuleUpdateConnected__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewRuleActionFormRecordRuleUpdateConnected */ 71820);
//
// ABViewRuleActionFormRecordRuleRemoveConnected
//
// An action that allows you to update fields on an object that is connected to
// the current object we just Added/Updated
//
//


class ABViewRuleActionFormRecordRuleRemoveConnected extends _ABViewRuleActionFormRecordRuleUpdateConnected__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleRemoveConnected";
      this.label = "Remove Connected Record";

      this.isUpdateValueDisabled = true; // disable update data of each fields
   }

   /**
    * process
    * gets called when a form is submitted and the data passes the Query Builder Rules.
    * @param {obj} options
    *				options.data : {obj} the key=>value of the data just entered by the form
    *				options.form : {ABViewForm} the Form object that is processing this rule
    * @return {Promise}
    */
   process(options) {
      let selectedField = this.selectedField();
      this._formData = options.data;

      return new Promise((resolve, reject) => {
         // get the model from the provided Form Obj:
         let dc = options.form.datacollection;
         if (!dc) return resolve();

         let model = dc.model;
         if (!model) return resolve();

         let updatedVals = {};
         updatedVals[selectedField.columnName] = "";

         model
            .update(options.data.id, updatedVals)
            .then(resolve)
            .catch((err) => {
               this.AB.notify.developer(err, {
                  message:
                     "!!! ABViewRuleActionFormRecordRuleUpdate.process(): update error:",
                  data: options.data,
               });
               reject(err);
            });
      });
   }
}


/***/ }),

/***/ 39218:
/*!*************************************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleUpdate.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleActionFormRecordRuleUpdate)
/* harmony export */ });
/* harmony import */ var _ABViewRuleActionObjectUpdater__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewRuleActionObjectUpdater */ 94109);
//
// ABViewRuleActionFormRecordRuleUpdate
//
// An action that allows you to update fields on an object that was currently
// Added/Updated.
//
//


class ABViewRuleActionFormRecordRuleUpdate extends _ABViewRuleActionObjectUpdater__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleUpdate";
      this.label = "Update Record";
   }

   get isPreProcess() {
      return true;
   }
}


/***/ }),

/***/ 71820:
/*!**********************************************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleUpdateConnected.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleActionFormRecordRuleUpdateConnected)
/* harmony export */ });
/* harmony import */ var _ABViewRuleActionObjectUpdater__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewRuleActionObjectUpdater */ 94109);
/* harmony import */ var _platform_dataFields_ABFieldConnect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/dataFields/ABFieldConnect */ 30289);
//
// ABViewRuleActionFormRecordRuleUpdateConnected
//
// An action that allows you to update fields on an object that is connected to
// the current object we just Added/Updated
//
//


// import ObjectQueryBuilder from "../ABViewQueryBuilderObjectFieldConditions";

class ABViewRuleActionFormRecordRuleUpdateConnected extends _ABViewRuleActionObjectUpdater__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleUpdateConnected";
      this.label = "Update Connected Record";

      this.baseObject = null; // the object the current form is working with.
      // Use this to find our connected fields.

      this.selectedFieldID = null; // the selected field ID in the .baseObject that is
      // used for updating.  This should be one of the connection Fields.

      this.fieldDropList = []; // the list of fields to offer based upon the current .baseObject.

      this.objectQB = null; // the QueryBuilder used for offering conditions based upon our connected Object.
      this.qbCondition = null; // the QB condition entered for selecting which remote object.
   }

   // field

   /**
    * objectLoad
    * save the current object this Action is associated with.
    * in the case of the UpdateConnected Action, assigning us
    * this object only impacts the queryObject.
    *
    * The Updater form will use another object we select in
    * the form dropdown.
    *
    * @param {object} object
    *
    */
   objectLoad(object) {
      this.queryObjectLoad(object);
      this.baseObject = object;

      // // now build our fieldDropList for the select
      // var connectionFields = this.connectedFieldList();
      // connectionFields.forEach((cf) => {
      //    this.fieldDropList.push({
      //       id: cf.id,
      //       value: cf.label,
      //    });
      // });
   }

   /**
    * connectedFieldList
    * return the fields in our .baseObject that are connections to other objects.
    * @return {array} of {ABField}
    */
   connectedFieldList() {
      var connectKey = _platform_dataFields_ABFieldConnect__WEBPACK_IMPORTED_MODULE_1__["default"].defaults().key;
      if (this.baseObject && this.baseObject.fields) {
         return this.baseObject.fields((f) => {
            return f.key == connectKey;
         });
      } else {
         return [];
      }
   }

   /**
    * connectedObject
    * return the ABObject associated with the selected connection field.
    * @return {ABObject}
    */
   connectedObject() {
      if (this.selectedFieldID) {
         var selectedField = this.selectedField();
         if (selectedField) {
            return selectedField.datasourceLink;
         }
      }

      return null;
   }

   /**
    * selectedField
    * return the selected {ABField} object.
    * @return {ABField}
    */
   selectedField() {
      return this.connectedFieldList().filter((f) => {
         return f.id == this.selectedFieldID;
      })[0];
   }

   /**
    * valueDisplayComponent
    * Return an ABView to display our values form.
    * @param {string}  idBase  a unique webix id to base our sub components on.
    */
   valueDisplayComponent(idBase) {
      if (this._uiChooser == null) {
         this._uiChooser = this.valueDisplayChooser(idBase);
      }

      return this._uiChooser;
   }

   /**
    * valueDisplayChooser
    * Our Values Display is a Select Box with a choice of connected fields.
    * Once a field is chosen, then we display the Updater form.
    * @param {string}  idBase  a unique webix id to base our sub components on.
    */
   // valueDisplayChooser(idBase) {
   //    var uniqueInstanceID = webix.uid();
   //    var myUnique = (key) => {
   //       // return idBase + '_' + key  + '_' + uniqueInstanceID;
   //       return key + "_" + uniqueInstanceID;
   //    };

   //    var ids = {
   //       component: myUnique("updateConnectedValues"),
   //       updateForm: myUnique("updateChooser"),
   //       selectConnectedField: myUnique("updateSelect"),
   //       updateFieldsForm: myUnique("updateForm"),
   //    };

   //    var _ui = {
   //       id: ids.component,
   //       view: "layout",
   //       css: "ab-component-form-rule",
   //       rows: [
   //          {
   //             id: ids.selectConnectedField,
   //             view: "richselect",
   //             label: L("Select which connected object to update."),
   //             labelWidth: 300,
   //             value: this.selectedField,
   //             options: this.fieldDropList,
   //             on: {
   //                onChange: (newVal, oldVal) => {
   //                   _logic.selectAction(newVal, oldVal);
   //                },
   //             },
   //          },
   //       ],
   //    };

   //    var init = (valueRules) => {
   //       valueRules = valueRules || this.valueRules;

   //       // make sure our currently selected field is selected.
   //       if (this.selectedFieldID) {
   //          var select = $$(ids.selectConnectedField);
   //          if (select) {
   //             select.setValue(this.selectedFieldID);
   //          }
   //       }
   //    };

   //    var _logic = (this._logic = {
   //       addDisplay: (view) => {
   //          $$(ids.component).addView(view);
   //       },

   //       // removePreviousDisplays
   //       // remove the previous components that reflected the conditions and
   //       // update values of the previously selected field.
   //       removePreviousDisplays: () => {
   //          var allViews = $$(ids.component).getChildViews();
   //          var cloneAllViews = [];
   //          allViews.forEach((v) => {
   //             cloneAllViews.push(v);
   //          });
   //          cloneAllViews.forEach((v) => {
   //             // don't remove the field picker
   //             if (v.config.id != ids.selectConnectedField) {
   //                $$(ids.component).removeView(v);
   //             }
   //          });
   //       },

   //       selectAction: (newVal, oldVal) => {
   //          _logic.removePreviousDisplays(); // of the Query Builder and Update form for old selection:

   //          this.selectedFieldID = newVal;
   //          var connectedObject = this.connectedObject();

   //          if (connectedObject) {
   //             // it is the remote object that we are allowed to Update fields on.
   //             this.updateObjectLoad(connectedObject);
   //             ///// NOTE: important to call super.valueDisplayComponent()
   //             this.updateComponent = super.valueDisplayComponent(
   //                ids.updateFieldsForm
   //             ); // parent obj

   //             _logic.showQBIfNeeded();

   //             // create a new blank update form
   //             _logic.addDisplay(this.updateComponent.ui);
   //             this.updateComponent.init();

   //             if (this.isUpdateValueDisabled) {
   //                let $updateForm = $$(this.updateComponent.ui.id);
   //                if ($updateForm) {
   //                   $updateForm.disable();
   //                   $updateForm.hide();
   //                }
   //             }
   //          } else {
   //             this.AB.notify.builder(new Error("No connectedObject found."), {
   //                fieldID: this.selectedFieldID,
   //             });
   //          }
   //       },

   //       showQBIfNeeded: () => {
   //          //// NOTE: we decided to go ahead and display the QB in ALL situations to give
   //          //// the user the ability to set a condition on the update even if the field
   //          //// is only a one to one.
   //          //// If we want to remove the filter in case of a "one" linkType, then put
   //          //// these conditions back in:

   //          // var field = this.selectedField();

   //          // // we don't need the QB if the destination object link type if 'one'.
   //          // // there will only be one to get back, so no conditions needed.
   //          // if (field.settings.linkType != 'one') {

   //          var qbComponent = this.queryBuilderDisplay();

   //          qbComponent.component(this.App, this.idBase);
   //          _logic.addDisplay(qbComponent.ui);
   //          qbComponent.init({});

   //          // }
   //       },

   //       fromSettings: (settings) => {
   //          // // first time through, be sure to set the connectedObject first
   //          // this.selectedFieldID = settings.selectedFieldID;
   //          // var connectedObject = this.connectedObject();

   //          // this triggers the update of the display, creation of QB,
   //          $$(ids.selectConnectedField).setValue(settings.selectedFieldID);

   //          if (this.objectQB) {
   //             this.objectQB.setValue(this.qbCondition);
   //          }

   //          if (this.updateComponent) {
   //             this.updateComponent.fromSettings(settings);
   //          }
   //       },

   //       toSettings: () => {
   //          // valueRules = {
   //          //	fieldOperations:[
   //          //		{ fieldID:xxx, value:yyyy, type:zzz, op:aaa }
   //          //	]
   //          // }
   //          var settings = { fieldOperations: [] };

   //          // for each of our formRows, decode the propery {}
   //          this.formRows.forEach((fr) => {
   //             var rowSettings = fr.toSettings();
   //             if (rowSettings) {
   //                settings.fieldOperations.push(rowSettings);
   //             }
   //          });

   //          return settings;
   //       },
   //    });

   //    return {
   //       ui: _ui,
   //       init: init,
   //       fromSettings: (settings) => {
   //          _logic.fromSettings(settings);
   //       },
   //       toSettings: () => {
   //          return _logic.toSettings();
   //       },
   //       _logic: _logic,
   //    };
   // }

   /**
    * queryBuilderDisplay
    * returns our Query Builder object used in our display.
    * It is called by the .showQBIfNeeded() method.
    * @return {ABViewQueryBuilderObjectFieldConditions}
    */
   // queryBuilderDisplay() {
   //    if (!this.objectQB) {
   //       this.objectQB = new ObjectQueryBuilder(
   //          "How to choose which object:"
   //       );

   //       var connObj = this.connectedObject();
   //       if (connObj) this.objectQB.objectLoad(connObj);
   //    }
   //    return this.objectQB;
   // }

   /**
    * process
    * gets called when a form is submitted and the data passes the Query Builder Rules.
    * @param {obj} options
    *				options.data : {obj} the key=>value of the data just entered by the form
    *				options.form : {ABViewForm} the Form object that is processing this rule
    * @return {Promise}
    */
   process(options) {
      this._formData = options.data;

      // get connected object
      var connObj = this.connectedObject();
      var model = connObj.model();

      var connectionField = this.selectedField();

      var condition = null; // our lookup condition

      // modifyCondition
      // async fn() to fill out what the condition should be for limiting the remote
      // objects to values in use by the current object.
      // @param {fn} cb  the callback to use when we are finished:
      //					cb(err, )
      var modifyCondition = (cb) => {
         // So, let's get a copy of our current data, with all it's connected items
         // attached.
         var thisModel = this.baseObject.model();
         thisModel
            .findConnected(connectionField.columnName, options.data)
            .then((items) => {
               // if we didn't get any results, then simply return
               // NOTE: this will leave condition == null and cancel this update.
               if (!items || items.length == 0) {
                  cb();
                  return;
               }

               // then use these to limit the connected data of our Action:

               // get all the ids
               var ids = items.map((i) => {
                  return i.id;
               });

               // resulting condition: { id in [listIDs]} AND { QB Condition }
               condition = {
                  glue: "and",
                  rules: [
                     {
                        key: `${connObj.tableName}.${connObj.PK()}`,
                        rule: "in",
                        value: ids,
                     },
                  ],
               };

               // check to make sure qbCondition actually has a condition before adding it
               // to our condition:
               if (Object.keys(this.qbCondition).length > 0) {
                  condition.rules.push(this.qbCondition);
               }

               cb();
            })
            .catch(cb);
      };

      // .process() returns a Promise
      return new Promise((resolve, reject) => {
         // upateIt()
         // updates a given item with our changes.
         // @param {obj} item  the item to update
         // @param {fn}  cb    a callback function when update is complete.
         var updateIt = (item, cb) => {
            let isUpdated = this.processUpdateObject({}, item);
            if (!isUpdated) {
               cb();
            } else {
               model
                  .update(item.id, item)
                  .then(() => {
                     cb();
                  })
                  .catch((err) => {
                     this.AB.notify.developer(err, {
                        message:
                           "!!! ABViewRuleActionFormRecordRuleUpdateConnected.process(): update error:",
                        data: options.data,
                     });
                     cb(err);
                  });
            }
         };

         // now figure out which elements belong to this object
         // done in modifyCondition()
         modifyCondition((err) => {
            if (err) {
               AB.notify.developer(err, {
                  message:
                     "!!! ABViewRuleActionFormRecordRuleUpdateConnected.modifyCondition: error:",
                  data: options.data,
               });
               reject(err);
               return;
            }

            if (condition === null) {
               // this is the case where we didn't have the proper data to complete our
               // update.  So let's just fail gracefully, and continue on.

               // QUESTION: is this the right way to handle it?
               resolve();
            } else {
               // get all the entries that match our condition:
               model
                  .findAll({ where: condition })
                  .then((list) => {
                     var done = 0;

                     // list : {data: Array(4), total_count: 4, pos: null, offset: null, limit: null}
                     if (list && list.data) {
                        list = list.data;
                     }

                     // for each entry, update it with our values:
                     list.forEach((item) => {
                        updateIt(item, (err) => {
                           if (err) {
                              return reject(err);
                           }
                           done++;
                           if (done >= list.length) {
                              // now they are all updated, so continue.
                              resolve();
                           }
                        });
                     });

                     // if there were no entries to update -> continue
                     if (list.length == 0) {
                        resolve();
                     }
                  })
                  .catch(reject);
            }
         }); // end modifyCondition()
      }); // end Promise()
   }

   /**
    * fromSettings
    * initialize this Action = require(a given set of setting values.
    * @param {obj} settings  the settings {} returned = require(toSettings()
    */
   fromSettings(settings) {
      settings = settings || {};

      this.selectedFieldID = settings.selectedFieldID || null;
      this.qbCondition = settings.qbCondition || {};

      super.fromSettings(settings);

      // // if we have a display component, then populate it:
      // if (this._uiChooser) {
      //    this._logic.fromSettings(settings);
      // }
   }

   /**
    * toSettings
    * return an object that represents the current state of this Action
    * @return {obj}
    */
   toSettings() {
      // settings: {
      // 	selectedFieldID: 'guid',
      //  qbCondition: [],
      //	valueRules:{}		// = require(ABViewRuleActionObjectUpdater
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.selectedFieldID = this.selectedFieldID;

      var qbCond = null;
      if (this.objectQB) {
         qbCond = this.objectQB.getValue();
         if (Array.isArray(qbCond)) {
            qbCond = qbCond[0];
         }

         // FIX: make sure qbCond root element has a 'glue'
         if (qbCond) {
            qbCond.glue = qbCond?.glue || "and";
         }
      }
      settings.qbCondition = qbCond;

      // // if we have a display component, then request our details = require(it:
      // if (this._uiChooser) {
      //    settings.valueRules = this._logic.toSettings();
      // }

      return settings;
   }

   // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // choosers properly if it hasn't been shown before the .setValue() call.
   // so this work around allows us to refresh the display after the .show()
   // on the popup.
   // When they've fixed the bug, we'll remove this workaround:
   // qbFixAfterShow() {
   //    if (this.objectQB) {
   //       this.objectQB.setValue(this.qbCondition);
   //    }
   // }
}


/***/ }),

/***/ 98674:
/*!*****************************************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleClosePopup.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleActionFormSubmitRuleClosePopup)
/* harmony export */ });
/* harmony import */ var _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ABViewRuleAction */ 40804);
//
// ABViewRuleActionFormSubmitRuleClosePopup
//
//
//


class ABViewRuleActionFormSubmitRuleClosePopup extends _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleClosePopup";
      this.label = "Close the current popup";

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // // valueDisplayComponent
   // // Return an ABView to display our values form.
   // //
   // valueDisplayComponent(idBase) {
   //    this._ui = {
   //       ui: {
   //          view: "layout",
   //          rows: [],
   //       },

   //       init: () => {},
   //    };

   //    return this._ui;
   // }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         let form = options.form;
         if (!form) return;

         let popup = form.pageParent((p) => p.settings.type == "popup");
         if (!popup) return;

         // get the dom id of page. it is dom id that is generated in ABLiveTool.js
         // let pageDomId = ["ab_live_page", popup.application.id, popup.id].join(
         //    "_"
         // );

         // close current popup
         popup.hide();

         // this clears the UI's record of the current form.
         options.form.changePage(null);

         resolve();
      });
   }
}


/***/ }),

/***/ 91538:
/*!*********************************************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleConfirmMessage.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleActionFormSubmitRuleConfirmMessage)
/* harmony export */ });
/* harmony import */ var _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ABViewRuleAction */ 40804);
//
// ABViewRuleActionFormSubmitRuleConfirmMessage
//
//
//


class ABViewRuleActionFormSubmitRuleConfirmMessage extends _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleConfirmMessage";
      this.label = "Show a confirmation message";

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   // valueDisplayComponent(idBase) {
   //    var ids = {
   //       message: `${idBase}_message`,
   //    };

   //    this._ui = {
   //       ui: {
   //          id: ids.message,
   //          view: "textarea",
   //          // label: this.labels.component.message,
   //          // labelWidth: this.AB.UISettings.config().labelWidthLarge,
   //          height: 130,
   //       },

   //       init: () => {},

   //       _logic: _logic,

   //       fromSettings: (valueRules) => {
   //          _logic.fromSettings(valueRules);
   //       },
   //       toSettings: () => {
   //          return _logic.toSettings();
   //       },
   //    };

   //    var _logic = {
   //       fromSettings: (valueRules) => {
   //          valueRules = valueRules || {};

   //          $$(ids.message).setValue(valueRules.message || "");
   //       },

   //       toSettings: () => {
   //          // return the confirm message
   //          return {
   //             message: $$(ids.message).getValue() || "",
   //          };
   //       },
   //    };

   //    return this._ui;
   // }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         var confirmMessage = this.valueRules.message || "";

         this.AB.$f7.dialog.create({
            text: confirmMessage,
         });
         // webix.message({
         //    text: confirmMessage,
         //    type: "info",
         // });

         resolve();
      });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings = {}) {
      super.fromSettings(settings); // let the parent handle the QB

      // // if we have a display component, then populate it:
      // if (this._ui) {
      //    // now we handle our valueRules:{} object settings.
      //    // pass the settings off to our DisplayList component:
      //    this._ui.fromSettings(settings.valueRules);
      // }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   // toSettings() {
   //    // settings: {
   //    //	message:''
   //    // }

   //    // let our parent store our QB settings
   //    var settings = super.toSettings();

   //    // settings.valueRules = this._ui.toSettings();

   //    return settings;
   // }
}


/***/ }),

/***/ 87278:
/*!************************************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleEmail.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleActionFormSubmitRuleEmail)
/* harmony export */ });
/* harmony import */ var _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ABViewRuleAction */ 40804);
/* harmony import */ var _platform_dataFields_ABFieldConnect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/dataFields/ABFieldConnect */ 30289);
/* harmony import */ var _platform_dataFields_ABFieldEmail__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/dataFields/ABFieldEmail */ 19387);
//
// ABViewRuleActionFormSubmitRuleWebsite
//
//
//




class ABViewRuleActionFormSubmitRuleEmail extends _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleEmail";
      this.label = "Send a custom email";

      this.queryObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.queryObject) {
   //       this.queryObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options - {
   //							data: {obj} rowData,
   //							form: {ABViewForm}
   //						}
   process(options) {
      // validate sender's email is invalid
      if (!this.AB.isEmail(this.valueRules.fromEmail)) {
         return Promise.resolve();
      }

      var recipients = [];

      return Promise.resolve()
         .then(() => {
            // Pull recipients data
            return new Promise((resolve, reject) => {
               var tasks = [];

               this.valueRules.toEmails.forEach((rec) => {
                  tasks.push(
                     new Promise((next, err) => {
                        // TODO: Cc, Bcc

                        // field
                        if (rec.emailType == "field") {
                           var emailFieldUrl = rec.value.split("|")[1]; // linkFieldId|emailFieldUrl

                           if (emailFieldUrl) {
                              console.error(
                                 "@TODO: SubmitRuleEmail: why are we using a URL to find a field? Tell Designer to stop storing that!"
                              );
                           }
                           var emailField =
                              this.queryObject.application.urlResolve(
                                 emailFieldUrl
                              );
                           if (emailField) {
                              // Pull email source object
                              if (emailField.object.id == this.queryObject.id) {
                                 var emailData =
                                    options.data[emailField.columnName];
                                 if (emailData)
                                    recipients = recipients.concat(emailData);
                              }
                              // Pull emails from link object
                              else {
                                 let linkFieldId = rec.value.split("|")[0];
                                 let linkFields = this.queryObject.fields(
                                    (f) =>
                                       f instanceof _platform_dataFields_ABFieldConnect__WEBPACK_IMPORTED_MODULE_1__["default"] &&
                                       f.id == linkFieldId
                                 );
                                 linkFields.forEach((f) => {
                                    var linkedData =
                                       options.data[f.relationName()] || [];

                                    // convert to an array
                                    if (
                                       linkedData &&
                                       !Array.isArray(linkedData)
                                    )
                                       linkedData = [linkedData];

                                    // pull email address
                                    linkedData.forEach((d) => {
                                       var email = d[emailField.columnName];
                                       if (email)
                                          recipients = recipients.concat(email);
                                    });
                                 });
                              }

                              next();
                           } else {
                              next();
                           }
                        }

                        // query
                        else if (rec.emailType == "query") {
                           var dvIdAndFieldId = rec.value; // ABDatacollectionId|fieldId
                           if (!dvIdAndFieldId) return next();

                           var dcId = dvIdAndFieldId.split("|")[0];
                           var fieldId = dvIdAndFieldId.split("|")[1];

                           var dcQuery =
                              this.currentForm.AB.datacollectionByID(dcId);
                           if (!dcQuery) return next();

                           var field = dcQuery.datasource.fieldByID(fieldId);
                           if (!field) return next();

                           // get data of data collection
                           dcQuery.getData().forEach((data) => {
                              var emailAddr = data[field.columnName];
                              if (emailAddr) recipients.push(emailAddr);
                           });

                           next();
                        }

                        // email
                        else {
                           recipients.push(rec.value);
                           next();
                        }
                     })
                  );
               });

               Promise.all(tasks).catch(reject).then(resolve);
            });
         })
         .then(() => {
            // send out
            return new Promise((resolve, reject) => {
               recipients = this.AB.uniq(recipients).filter((r) => r);

               if (!recipients || recipients.length < 1) return resolve();

               // replace form value to template
               var fromName = this.valueRules.fromName,
                  subject = this.valueRules.subject,
                  message = this.valueRules.message;

               this.queryObject
                  .fields((f) => f.fieldUseAsLabel())
                  .forEach((f) => {
                     var template = new RegExp(`{${f.label}}`, "g"),
                        data = f.format(options.data);

                     fromName = fromName.replace(template, data);
                     subject = subject.replace(template, data);
                     message = message.replace(template, data);
                  });

               // send a email
               this.AB.Network.post({
                  url: "/app_builder/email",
                  params: {
                     fromName: fromName,
                     fromEmail: this.valueRules.fromEmail,
                     subject: subject,
                     message: message,
                     recipients: this.AB.uniq(recipients),
                  },
               })
                  .then(() => {
                     resolve();
                  })
                  .catch(reject);
            });
         });
   }

   // // fromSettings
   // // initialize this Action from a given set of setting values.
   // // @param {obj}  settings
   // fromSettings(settings) {
   //    settings = settings || {};
   //    super.fromSettings(settings); // let the parent handle the QB

   //    // if we have a display component, then populate it:
   //    if (this._ui) {
   //       // now we handle our valueRules:{} object settings.
   //       // pass the settings off to our DisplayList component:
   //       this._ui.fromSettings(settings.valueRules);
   //    }
   // }

   // // toSettings
   // // return an object that represents the current state of this Action
   // // @return {obj}
   // toSettings() {
   //    // settings: {
   //    //	message:''
   //    // }

   //    // let our parent store our QB settings
   //    var settings = super.toSettings();

   //    settings.valueRules = this._ui.toSettings();

   //    return settings;
   // }
}


/***/ }),

/***/ 90786:
/*!****************************************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleExistPage.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleActionFormSubmitRuleExistPage)
/* harmony export */ });
/* harmony import */ var _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ABViewRuleAction */ 40804);
//
// ABViewRuleActionFormSubmitRuleExistPage
//
//
//


class ABViewRuleActionFormSubmitRuleExistPage extends _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleExistPage";
      this.label = "Redirect to an existing page";

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   // valueDisplayComponent(idBase) {
   //    var ids = {
   //       pagesAndTabs: `${idBase}_PagesAndTabs`,
   //    };

   //    this._ui = {
   //       ui: { id: ids.pagesAndTabs, view: "richselect", options: [] },

   //       init: () => {
   //          _logic.populateOptions();
   //       },

   //       _logic: _logic,

   //       fromSettings: (valueRules) => {
   //          _logic.fromSettings(valueRules);
   //       },
   //       toSettings: () => {
   //          return _logic.toSettings();
   //       },
   //    };

   //    var _logic = {
   //       populateOptions: () => {
   //          // Pull page list to "Redirect to an existing page"
   //          var _pageOptions = [];

   //          /**
   //           * @param pageOrTab	{Object}	- ABViewPage or ABViewTab
   //           * @param indent	{integer}
   //           * @param type		{string}	- 'page' or 'tab'
   //           * @param pageId	{uuid}		- the id of page (only tab)
   //           */
   //          var addPage = (pageOrTab, indent, type, pageId) => {
   //             indent = indent || "";

   //             let icon = "fa fa-file-o";
   //             if (type == "tab") icon = "fa fa-window-maximize";

   //             let pageParent = pageOrTab.pageParent();

   //             _pageOptions.push({
   //                id: pageOrTab.id,
   //                value: indent + pageOrTab.label,
   //                type: type,
   //                pageId: pageParent ? pageParent.id : null,

   //                icon: icon,
   //             });

   //             if (type == "page" || type == "tab") {
   //                if (pageOrTab.pages) {
   //                   pageOrTab.pages().forEach(function (p) {
   //                      addPage(p, indent + "-", "page");
   //                   });
   //                }

   //                // add 'tab' options
   //                if (pageOrTab.views) {
   //                   pageOrTab
   //                      .views((v) => v.key == "tab")
   //                      .forEach((tab) => {
   //                         // add 'tab view' to options
   //                         tab.views().forEach((tabView) => {
   //                            addPage(
   //                               tabView,
   //                               indent + "-",
   //                               "tab",
   //                               pageOrTab.id
   //                            );
   //                         });
   //                      });
   //                }
   //             }
   //          };

   //          addPage(this.currentForm.pageRoot(), "", "page");

   //          $$(ids.pagesAndTabs).define("options", _pageOptions);
   //          $$(ids.pagesAndTabs).refresh();
   //       },

   //       fromSettings: (valueRules) => {
   //          valueRules = valueRules || {};

   //          $$(ids.pagesAndTabs).setValue(
   //             valueRules.tabId || valueRules.pageId || ""
   //          );
   //       },

   //       toSettings: () => {
   //          var result = {};

   //          var selectedId = $$(ids.pagesAndTabs).getValue();
   //          var selectedItem = $$(ids.pagesAndTabs)
   //             .getPopup()
   //             .getList()
   //             .config.data.filter((opt) => opt.id == selectedId)[0];
   //          if (selectedItem) {
   //             if (selectedItem.type == "tab") {
   //                // store page id and tab id
   //                result = {
   //                   pageId: selectedItem.pageId,
   //                   tabId: selectedId,
   //                };
   //             } else {
   //                // store only page id
   //                result = {
   //                   pageId: selectedId,
   //                };
   //             }
   //          }

   //          // return the confirm message
   //          return result;
   //       },
   //    };

   //    return this._ui;
   // }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         // redirect page
         if (this.valueRules.pageId) {
            options.form.changePage(this.valueRules.pageId);

            if (this.valueRules.tabId) {
               var curPage = options.form.application.pages(
                  (p) => p.id == this.valueRules.pageId,
                  true
               )[0];
               if (!curPage) return resolve();

               // switch tab
               var tabView = curPage.views(
                  (v) => v.id == this.valueRules.tabId,
                  true
               )[0];
               if (!tabView) return resolve();

               var tab = tabView.parent;
               if (!tab) return resolve();

               var toggleParent = (element) => {
                  if (!element.parent) return false;
                  var parentElem = element.parent;
                  if (!parentElem.parent) return false;
                  parentElem.parent.emit("changeTab", parentElem.id);
                  toggleParent(parentElem.parent);
               };

               toggleParent(tab);

               tab.emit("changeTab", tabView.id);
               // // @TODO: refactor this to move to Framework7
               // let showIt = setInterval(function () {
               //    console.error("REFACTOR FOR FRAMEWORK7");
               //    // if ($$(tabView.id) && $$(tabView.id).isVisible()) {
               //    //    clearInterval(showIt);
               //    //    return;
               //    // }
               //    tab.emit("changeTab", tabView.id);
               // }, 100);
            }
         }

         resolve();
      });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};
      super.fromSettings(settings); // let the parent handle the QB

      // if we have a display component, then populate it:
      if (this._ui) {
         // now we handle our valueRules:{} object settings.
         // pass the settings off to our DisplayList component:
         this._ui.fromSettings(settings.valueRules);
      }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	message:''
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._ui.toSettings();

      return settings;
   }
}


/***/ }),

/***/ 57973:
/*!*****************************************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleParentPage.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleActionFormSubmitRuleParentPage)
/* harmony export */ });
/* harmony import */ var _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ABViewRuleAction */ 40804);
//
// ABViewRuleActionFormSubmitRuleParentPage
//
//
//


class ABViewRuleActionFormSubmitRuleParentPage extends _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleParentPage";
      this.label = "Redirect to the parent page";

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // // valueDisplayComponent
   // // Return an ABView to display our values form.
   // //
   // valueDisplayComponent(idBase) {
   //    this._ui = {
   //       ui: {
   //          view: "label",
   //          label: this.label,
   //       },

   //       init: () => {},

   //       _logic: _logic,
   //    };

   //    var _logic = {};

   //    return this._ui;
   // }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         var pageCurrent = options.form.pageParent();
         var pageParent = pageCurrent.pageParent();

         // redirect page
         // options.form.changePage(pageParent);
         pageParent.show();

         resolve();
      });
   }
}


/***/ }),

/***/ 19679:
/*!**************************************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleWebsite.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleActionFormSubmitRuleWebsite)
/* harmony export */ });
/* harmony import */ var _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ABViewRuleAction */ 40804);
//
// ABViewRuleActionFormSubmitRuleWebsite
//
//
//


class ABViewRuleActionFormSubmitRuleWebsite extends _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleWebsite";
      this.label = "Redirect to another website URL";

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // // valueDisplayComponent
   // // Return an ABView to display our values form.
   // //
   // valueDisplayComponent(idBase) {
   //    var ids = {
   //       website: `${idBase}_website`,
   //    };

   //    this._ui = {
   //       ui: {
   //          id: ids.website,
   //          view: "text",
   //       },

   //       init: () => {},

   //       _logic: _logic,

   //       fromSettings: (valueRules) => {
   //          _logic.fromSettings(valueRules);
   //       },
   //       toSettings: () => {
   //          return _logic.toSettings();
   //       },
   //    };

   //    var _logic = {
   //       fromSettings: (valueRules) => {
   //          valueRules = valueRules || {};

   //          $$(ids.website).setValue(valueRules.website || "");
   //       },

   //       toSettings: () => {
   //          // return the confirm message
   //          return {
   //             website: $$(ids.website).getValue() || "",
   //          };
   //       },
   //    };

   //    return this._ui;
   // }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         // redirect to website
         if (this.valueRules.website)
            window.open(
               `http://${this.valueRules.website.replace("http://", "")}`,
               "_blank"
            );

         resolve();
      });
   }

   // // fromSettings
   // // initialize this Action from a given set of setting values.
   // // @param {obj}  settings
   // fromSettings(settings) {
   //    settings = settings || {};
   //    super.fromSettings(settings); // let the parent handle the QB

   //    // if we have a display component, then populate it:
   //    if (this._ui) {
   //       // now we handle our valueRules:{} object settings.
   //       // pass the settings off to our DisplayList component:
   //       this._ui.fromSettings(settings.valueRules);
   //    }
   // }

   // // toSettings
   // // return an object that represents the current state of this Action
   // // @return {obj}
   // toSettings() {
   //    // settings: {
   //    //	message:''
   //    // }

   //    // let our parent store our QB settings
   //    var settings = super.toSettings();

   //    settings.valueRules = this._ui.toSettings();

   //    return settings;
   // }
}


/***/ }),

/***/ 94109:
/*!******************************************************************************!*\
  !*** ./src/js/AppBuilder/rules/ruleActions/ABViewRuleActionObjectUpdater.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewRuleActionObjectUpdater)
/* harmony export */ });
/* harmony import */ var _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ABViewRuleAction */ 40804);
// ABViewRuleActionObjectUpdater
//
// An action that allows you to update fields on an object.
//
//


var ABViewRuleActionObjectUpdaterDefaults = {
   filterConditions: {
      // array of filters to apply to the data table
      glue: "and",
      rules: [],
   },
};

class ABViewRuleActionObjectUpdater extends _ABViewRuleAction__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleUpdate";
      this.label = "Update Record";

      this.updateObject = null; // the object this Action will Update.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]

      this.stashRules = {}; // keep track of rule settings among our selected objects.
   }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      if (this._uiUpdater == null) {
         this._uiUpdater = this.valueDisplayList(idBase);
      }

      return this._uiUpdater;
   }

   // Our Values Display is a List of ValueRows
   // Each ValueRow will display an additional set of [add] [delete] buttons.

   // valueDisplayList(idBase) {
   //    var uniqueInstanceID = webix.uid();
   //    var myUnique = (key) => {
   //       // return idBase + '_' + key  + '_' + uniqueInstanceID;
   //       return `${idBase}_${key}_${uniqueInstanceID}`;
   //    };
   //    var ids = {
   //       updateForm: myUnique("updateForm"),
   //    };

   //    var _ui = {
   //       view: "form",
   //       id: ids.updateForm,
   //       elements: [],
   //    };

   //    var init = (valueRules) => {
   //       valueRules = valueRules || this.valueRules;
   //       _logic.setValues(valueRules);
   //    };

   //    var _logic = {
   //       removeAddRow: () => {
   //          // get our Form
   //          var UpdateForm = _logic.formGet();
   //          if (!UpdateForm) return;

   //          // check row that's unselect a field
   //          var rows = UpdateForm.getChildViews();

   //          var addRow = rows.filter((r) => {
   //             return r.queryView(function (view) {
   //                return view.config.name == "field" && !view.getValue();
   //             });
   //          })[0];
   //          if (!addRow) return;

   //          UpdateForm.removeView(addRow);
   //       },

   //       // addRow
   //       // add a new data entry to this form.
   //       // @param {obj} data  (optional) initial values for this row.
   //       addRow: (data) => {
   //          // get our Form
   //          var UpdateForm = _logic.formGet();
   //          if (!UpdateForm) return;

   //          // check row that's unselect a field
   //          var rows = UpdateForm.getChildViews();
   //          if (
   //             data == null &&
   //             rows.filter((r) => {
   //                return r.queryView(function (view) {
   //                   return view.config.name == "field" && !view.getValue();
   //                });
   //             }).length > 0
   //          )
   //             return;

   //          // get a new Row Component
   //          var row = this.valueDisplayRow(idBase);

   //          // add row to Form
   //          UpdateForm.addView(row.ui);

   //          // initialize row with any provided data:
   //          row.init({
   //             onAdd: () => {
   //                // add a new Row
   //                _logic.addRow();
   //             },
   //             onDelete: (rowId) => {
   //                // remove a row
   //                _logic.delRow(rowId);
   //             },
   //             data: data,
   //          });

   //          // store this row
   //          this.formRows.push(row);
   //       },

   //       delRow: (rowId) => {
   //          // store this row
   //          this.formRows.forEach((r, index) => {
   //             if (r.ui.id == rowId) this.formRows.splice(index, 0);
   //          });

   //          // get our Form
   //          var UpdateForm = _logic.formGet();
   //          if (!UpdateForm) return;

   //          // remove UI
   //          UpdateForm.removeView($$(rowId));
   //       },

   //       formClear: () => {
   //          var UpdateForm = _logic.formGet();
   //          if (!UpdateForm) return;

   //          var children = UpdateForm.getChildViews();

   //          // NOTE: need to clone this array, because it is connected with the UpdatForm's
   //          // internal array of items.  Once we start .removeView() the element actually
   //          // is removed from the internal array, which then upset's the .forEach() from
   //          // properly iterating through the structure.  It results in missed items from
   //          // being sent to the .forEach().
   //          // So Clone it and use that for .forEach()
   //          var cloneChildren = [];
   //          children.forEach((c) => {
   //             cloneChildren.push(c);
   //          });
   //          cloneChildren.forEach((c) => {
   //             UpdateForm.removeView(c);
   //          });

   //          // clear our stored .formRows
   //          this.formRows = [];
   //       },

   //       formGet: () => {
   //          var UpdateForm = $$(ids.updateForm);
   //          if (!UpdateForm) {
   //             // this is a problem!
   //             this.currentForm.AB.notify.developer(
   //                new Error("no webix form"),
   //                {
   //                   context:
   //                      "ABViewRuleActionObjectUpdater:formGet  could not find webix form",
   //                   id: ids.updateForm,
   //                }
   //             );
   //             return null;
   //          }

   //          return UpdateForm;
   //       },

   //       setValues: (valueRules) => {
   //          // valueRules = {
   //          //	fieldOperations:[
   //          //		{ fieldID:xxx, value:yyyy, type:zzz, op:aaa }
   //          //	]
   //          // }

   //          valueRules = valueRules || {};
   //          valueRules.fieldOperations = valueRules.fieldOperations || [];

   //          // find the form
   //          var UpdateForm = _logic.formGet();
   //          if (!UpdateForm) return;

   //          // clear form:
   //          _logic.formClear();

   //          // if there are values to
   //          if (valueRules.fieldOperations.length > 0) {
   //             valueRules.fieldOperations.forEach((r) => {
   //                _logic.addRow(r);
   //             });
   //          }

   //          // our default operation will cause an empty row to
   //          // appear after our first value entry.
   //          // let's remove that one, and then add a new one
   //          // at the end:
   //          _logic.removeAddRow();

   //          // display an empty row
   //          _logic.addRow();
   //       },

   //       fromSettings: (settings) => {
   //          // Note: we just want the { valueRules:[] } here:
   //          var mySettings = settings.valueRules || settings;

   //          _logic.setValues(mySettings);
   //       },

   //       toSettings: () => {
   //          // valueRules = {
   //          //	fieldOperations:[
   //          //		{ fieldID:xxx, value:yyyy, type:zzz, op:aaa }
   //          //	]
   //          // }
   //          var settings = { fieldOperations: [] };

   //          // for each of our formRows, decode the propery {}
   //          this.formRows.forEach((fr) => {
   //             var rowSettings = fr.toSettings();
   //             if (rowSettings) {
   //                settings.fieldOperations.push(fr.toSettings());
   //             }
   //          });

   //          return settings;
   //       },
   //    };

   //    return {
   //       ui: _ui,
   //       init: init,
   //       fromSettings: (settings) => {
   //          _logic.fromSettings(settings);
   //       },
   //       toSettings: () => {
   //          return _logic.toSettings();
   //       },
   //       _logic: _logic,
   //    };
   // }

   // valueDisplayRow(idBase) {
   //    var uniqueInstanceID = webix.uid();
   //    var myUnique = (key) => {
   //       // return idBase + '_' + key  + '_' + uniqueInstanceID;
   //       return key + "_" + uniqueInstanceID;
   //    };

   //    var ids = {
   //       row: myUnique("row"),
   //       updateForm: myUnique("updateFormRow"),
   //       field: myUnique("field"),
   //       value: myUnique("value"),
   //       selectDc: myUnique("selectDc"),
   //       selectBy: myUnique("selectBy"),
   //       queryField: myUnique("queryField"),
   //       multiview: myUnique("multiview"),
   //       buttonAdd: myUnique("add"),
   //       buttonDelete: myUnique("delete"),
   //    };

   //    var FilterComponent;

   //    var _logic = {
   //       callbacks: {
   //          onAdd: () => {},
   //          onDelete: () => {},
   //       },

   //       buttonsToggle: () => {
   //          $$(ids.row).getChildViews()[0].getChildViews()[4].hide();
   //          $$(ids.row).getChildViews()[0].getChildViews()[5].show();
   //       },

   //       getFieldList: (shouldFilter) => {
   //          var options = [];
   //          if (this.updateObject) {
   //             options = (this.updateObject.fields() || []).map((f) => {
   //                return {
   //                   id: f.id,
   //                   value: f.label,
   //                };
   //             });

   //             // options = (this.updateObject.fields() || [])
   //             // .filter(f => {
   //             //
   //             // 	if (f.key != 'connectObject') {
   //             // 		return true;
   //             // 	} else {
   //             // 		// if this is a connection field, only return
   //             // 		// fields that are 1:x  where this field is the
   //             // 		// source:
   //             // 		// return ((f.linkType() == 'one') && (f.isSource()))
   //             //
   //             // 		// 6-14-2018 Changing from only 1:x to support many
   //             // 		// if this is a connected field, only return
   //             // 		// fields that this is the source
   //             // 		return (f.isSource())
   //             // 	}
   //             // })
   //             // .map(f => {
   //             // 	return {
   //             // 		id: f.id,
   //             // 		value: f.label
   //             // 	};
   //             // });

   //             // Remove fields who are selected
   //             if (shouldFilter) {
   //                // store this row
   //                var usedHash = {};
   //                this.formRows.forEach((row) => {
   //                   var rowView = $$(row.ui.id);
   //                   if (rowView) {
   //                      var field = rowView
   //                         .getChildViews()[0]
   //                         .getChildViews()[1];
   //                      usedHash[field.getValue()] = true;
   //                   }
   //                });
   //                options = options.filter((o) => {
   //                   return !usedHash[o.id];
   //                });
   //             }
   //          }
   //          return options;
   //       },

   //       isValid: () => {
   //          var validator = this.currentForm.AB.Validation.validator();
   //          var valueField = $$(ids.row).getChildViews()[0].getChildViews()[3];
   //          var FormView = valueField.getParentView().getParentView();

   //          var field = this.getUpdateObjectField($$(ids.field).getValue());
   //          if (field) {
   //             var value = field.getValue(valueField, {});

   //             // // if a standard component that supports .getValue()
   //             // if (valueField.getValue) {
   //             // 	value = valueField.getValue();
   //             // } else {
   //             // 	// else use for field.getValue();
   //             // 	value = field.getValue(valueField, {});
   //             // }

   //             // our .isValidData() wants value in an object:
   //             var obj = {};
   //             obj[field.columnName] = value;

   //             field.isValidData(obj, validator);

   //             // if value is empty, this is also an error:
   //             if (
   //                value == "" ||
   //                value == null ||
   //                (Array.isArray(value) && value.length == 0)
   //             ) {
   //                validator.addError(
   //                   field.columnName,
   //                   L("A value is required")
   //                );
   //             }

   //             // field.getParentView()  ->  row
   //             // row.getParentView()  -> Form
   //             FormView.clearValidation();
   //             validator.updateForm(FormView);

   //             return validator.pass();
   //          } else {
   //             // if we didn't find an associated field ... then this isn't good
   //             // data.

   //             //// TODO: display error for our field picker.  Note, it doesn't have a unique .name
   //             // field.
   //             var fieldField = $$(ids.row)
   //                .getChildViews()[0]
   //                .getChildViews()[1];
   //             fieldField.define("invalidMessage", L("A value is required"));
   //             fieldField.define("invalid", true);
   //             fieldField.refresh();
   //             // fieldField.markInvalid(this.labels.component.errorRequired);
   //             return false;
   //          }
   //       },

   //       selectField: (columnID) => {
   //          var field = this.getUpdateObjectField(columnID);
   //          if (!field) return;

   //          var fieldComponent = field.formComponent(),
   //             abView = fieldComponent.newInstance(field.object.application),
   //             formFieldComponent = abView.component(this.App),
   //             $componentView = formFieldComponent.ui,
   //             $inputView;

   //          $componentView.id = ids.value; // set our expected id

   //          // find all the DataSources
   //          var datasources = this.currentForm.AB.datacollections(
   //             (dc) => dc.datasource
   //          );

   //          // create a droplist with those dataSources
   //          var optionsDataSources = [];
   //          datasources.forEach((dc) => {
   //             optionsDataSources.push({ id: dc.id, value: dc.label });
   //          });

   //          // create a droplist with select options
   //          var optionsSelectBy = [
   //             { id: "select-one", value: L("Current selection") },
   //             {
   //                id: "filter-select-one",
   //                value: L("Select first after filter by..."),
   //             },
   //          ];

   //          var $optionUpdateExsits = {
   //             type: "clean",
   //             rows: [
   //                {
   //                   cols: [
   //                      {
   //                         id: ids.selectDc,
   //                         view: "combo",
   //                         options: optionsDataSources,
   //                         placeholder: L("Choose a data source"),
   //                         on: {
   //                            onChange: (newv, oldv) => {
   //                               var selectedDC =
   //                                  this.currentForm.AB.datacollectionByID(
   //                                     newv
   //                                  );
   //                               if (
   //                                  selectedDC &&
   //                                  (selectedDC.sourceType == "query" ||
   //                                     !field.isConnection)
   //                               ) {
   //                                  var queryFieldOptions = [];
   //                                  selectedDC.datasource
   //                                     .fields()
   //                                     .forEach((f) => {
   //                                        queryFieldOptions.push({
   //                                           id: f.id,
   //                                           value: f.label,
   //                                        });
   //                                     });
   //                                  $$(ids.queryField).define(
   //                                     "options",
   //                                     queryFieldOptions
   //                                  );
   //                                  $$(ids.queryField).refresh();
   //                                  $$(ids.queryField).show();
   //                               } else {
   //                                  $$(ids.queryField).hide();
   //                               }
   //                            },
   //                         },
   //                      },
   //                      // we will place a list of query fields if you choose a datasource that has a query source type
   //                      {
   //                         id: ids.queryField,
   //                         view: "combo",
   //                         hidden: true,
   //                         placeholder: L("Choose value from..."),
   //                         options: [{ id: 1, value: "figure this out" }],
   //                      },
   //                   ],
   //                },
   //                {
   //                   id: ids.selectBy,
   //                   view: "combo",
   //                   options: optionsSelectBy,
   //                   placeholder: L("Choose select option"),
   //                   on: {
   //                      onChange: (newv, oldv) => {
   //                         var $row = $$(ids.row);
   //                         $row.removeView($row.getChildViews()[1]);
   //                         if (newv == "select-one") {
   //                            $row.addView({}, 1);
   //                         } else {
   //                            var options =
   //                               this.currentForm.datacollection.datasource
   //                                  .fields()
   //                                  .map(function (f) {
   //                                     return {
   //                                        id: f.id,
   //                                        value: f.label,
   //                                     };
   //                                  });

   //                            FilterComponent = this.AB.filterComplexNew(
   //                               `${idBase}_filter`
   //                            );
   //                            // FilterComponent.applicationLoad(
   //                            //    this.currentForm.application
   //                            // );
   //                            FilterComponent.init({
   //                               isRecordRule: true,
   //                               recordRuleFieldOptions: options,
   //                            });
   //                            FilterComponent.on("change", (val) => {
   //                               _logic.onFilterChange(val);
   //                            });

   //                            $row.addView(FilterComponent.ui, 1);

   //                            var dcId = $$(ids.selectDc).getValue();
   //                            var dataCollection =
   //                               this.currentForm.AB.datacollectionByID(dcId);
   //                            if (dataCollection) {
   //                               _logic.populateFilters(dataCollection);
   //                            }
   //                         }
   //                      },
   //                   },
   //                },
   //             ],
   //          };

   //          // WORKAROUND: add '[Current User]' option to the user data field
   //          if (field.key == "user") {
   //             $componentView.options = $componentView.options || [];
   //             $componentView.options.unshift({
   //                id: "ab-current-user",
   //                value: L("[Current User]"),
   //             });
   //          }

   //          // UPDATE: ok, in practice we have not had any use cases where
   //          // we want individual values on connectedObject fields, but
   //          // instead we want to insert the current selected element from
   //          // a relevant data view.  So, replace the fieldComponet
   //          // from a connectedObject field with a list of data views that
   //          // are based upon the same object we are connected to:
   //          if (field.isConnection) {
   //             // find the ABObject this field connects to
   //             var connectedObject = field.datasourceLink;

   //             // find all the DataSources that are based upon this ABObject
   //             // to do this, we find the root Page we are on, then ask that Page for datasources:
   //             datasources = datasources.filter((dc) => {
   //                return dc.datasource.id == connectedObject.id;
   //             });

   //             var dcQueries = this.currentForm.AB.datacollections((dc) => {
   //                return (
   //                   dc.sourceType == "query" &&
   //                   dc.datasource &&
   //                   dc.datasource.canFilterObject(connectedObject)
   //                );
   //                // return dc.datasource.id == connectedObject.id;
   //             });

   //             datasources = datasources.concat(dcQueries);

   //             // refresh a droplist with those dataSources
   //             optionsDataSources = [];
   //             datasources.forEach((dc) => {
   //                optionsDataSources.push({ id: dc.id, value: dc.label });
   //             });

   //             // add select an array value option
   //             optionsSelectBy.push({
   //                id: "filter-select-all",
   //                value: L("Select all after filter by..."),
   //             });

   //             $inputView = $optionUpdateExsits;

   //             // and the upcoming formFieldComponent.init()
   //             // doesn't need to do anything:
   //             formFieldComponent = {
   //                init: function () {},
   //             };

   //             // and we reset field so it's customDisplay isn't called:
   //             // field = {};
   //          } else {
   //             $inputView = {
   //                id: ids.multiview,
   //                view: "multiview",
   //                cells: [
   //                   {
   //                      batch: "custom",
   //                      rows: [
   //                         $componentView,
   //                         {
   //                            view: "label",
   //                            label: `<a>${L("Or exists value")}</a>`,
   //                            on: {
   //                               onItemClick: function () {
   //                                  var $container = this.getParentView(),
   //                                     $multiview = $container.getParentView();

   //                                  $multiview.showBatch("exist");
   //                               },
   //                            },
   //                         },
   //                      ],
   //                   },
   //                   {
   //                      // Update value from exists object
   //                      batch: "exist",
   //                      rows: [
   //                         $optionUpdateExsits,
   //                         {
   //                            view: "label",
   //                            label: `<a>${L("Or custom value")}</a>`,
   //                            on: {
   //                               onItemClick: function () {
   //                                  var $container = this.getParentView(),
   //                                     $multiview = $container.getParentView();

   //                                  // clear filter view
   //                                  $$(ids.selectBy).setValue("select-one");

   //                                  $multiview.showBatch("custom");
   //                               },
   //                            },
   //                         },
   //                      ],
   //                   },
   //                ],
   //             };
   //          }

   //          // Change component to display this field's form input
   //          var $row = $$(ids.row).getChildViews()[0];
   //          $row.removeView($row.getChildViews()[3]);
   //          $row.addView($inputView, 3);

   //          formFieldComponent.init();

   //          // Show custom display of data field
   //          if (!field.isConnection && field.customDisplay) {
   //             // field.customDisplay(field, this.App, $row.getChildViews()[3].$view, {

   //             var compNodeView = $$($componentView.id).$view;

   //             // wait until render UI complete
   //             setTimeout(() => {
   //                field.customDisplay(field, this.App, compNodeView, {
   //                   editable: true,

   //                   // tree
   //                   isForm: true,
   //                });
   //             }, 50);
   //          }

   //          // Show the remove button
   //          var $buttonRemove = $row.getChildViews()[4];
   //          $buttonRemove.show();

   //          // Add a new row
   //          if (columnID) _logic.callbacks.onAdd();
   //       },

   //       setValue: (data) => {
   //          $$(ids.field).setValue(data.fieldID);
   //          // note: this triggers our _logic.selectField() fn.
   //          var field = this.getUpdateObjectField(data.fieldID);
   //          if (field) {
   //             var setValueFn = () => {
   //                $$(ids.selectDc).setValue(data.value);
   //                if (data.queryField) {
   //                   $$(ids.queryField).setValue(data.queryField);
   //                }
   //                var selectBy = data.selectBy || "select-one";
   //                $$(ids.selectBy).setValue(selectBy);

   //                if (selectBy != "select-one") {
   //                   var collectionId = data.value;
   //                   var dataCollection =
   //                      this.currentForm.AB.datacollectionByID(collectionId);
   //                   if (dataCollection && data.filterConditions) {
   //                      _logic.populateFilters(
   //                         dataCollection,
   //                         data.filterConditions
   //                      );
   //                   }
   //                }
   //             };

   //             // now handle our special connectedObject case:
   //             if (field.isConnection) {
   //                setValueFn();
   //             } else {
   //                if (data.valueType == "exist") {
   //                   $$(ids.multiview).showBatch("exist");

   //                   setValueFn();
   //                } else {
   //                   $$(ids.multiview).showBatch("custom");

   //                   // wait until render UI complete
   //                   setTimeout(function () {
   //                      // set value to custom field
   //                      var rowData = {};
   //                      rowData[field.columnName] = data.value;
   //                      field.setValue($$(ids.value), rowData);
   //                   }, 50);
   //                }
   //             }
   //          }
   //       },

   //       populateFilters: (dataView, filterConditions) => {
   //          filterConditions =
   //             filterConditions ||
   //             ABViewRuleActionObjectUpdaterDefaults.filterConditions;

   //          // Populate data to popups
   //          // FilterComponent.objectLoad(objectCopy);
   //          FilterComponent.fieldsLoad(
   //             dataView.datasource ? dataView.datasource.fields() : []
   //          );
   //          FilterComponent.setValue(filterConditions);
   //       },

   //       toSettings: () => {
   //          // if this isn't the last entry row
   //          // * a row with valid data has the [delete] button showing.
   //          var buttonDelete = $$(ids.buttonDelete);
   //          if (buttonDelete && buttonDelete.isVisible()) {
   //             var data = {};
   //             data.fieldID = $$(ids.field).getValue();

   //             var $valueField = $$(ids.value);
   //             var field = this.getUpdateObjectField(data.fieldID);

   //             var getValueFn = () => {
   //                data.value = $$(ids.selectDc).getValue();
   //                data.queryField = $$(ids.queryField).getValue();
   //                data.op = "set"; // possible to create other types of operations.
   //                data.type = field.key;
   //                data.selectBy = $$(ids.selectBy).getValue();
   //                data.valueType = "exist";
   //                if (FilterComponent) {
   //                   data.filterConditions = FilterComponent.getValue();
   //                }
   //             };

   //             // now handle our special connectedObject case:
   //             if (field.isConnection) {
   //                getValueFn();
   //             } else {
   //                if ($$(ids.multiview).config.visibleBatch == "exist") {
   //                   getValueFn();
   //                } else {
   //                   data.value = field.getValue($valueField, {});
   //                   data.op = "set"; // possible to create other types of operations.
   //                   data.type = field.key;
   //                   data.valueType = "custom";
   //                }
   //             }

   //             return data;
   //          } else {
   //             return null;
   //          }
   //       },
   //    };

   //    var _ui = {
   //       id: ids.row,
   //       view: "layout",
   //       rows: [
   //          {
   //             cols: [
   //                {
   //                   // Label
   //                   view: "label",
   //                   width: this.currentForm.AB.Config.labelWidthSmall,
   //                   label: L("Set"),
   //                },
   //                {
   //                   // Field list
   //                   view: "combo",
   //                   name: "field",
   //                   placeholder: L("Choose a field"),
   //                   id: ids.field,
   //                   height: 32,
   //                   options: _logic.getFieldList(true),
   //                   on: {
   //                      onChange: function (columnId) {
   //                         _logic.selectField(columnId);
   //                      },
   //                   },
   //                },
   //                {
   //                   // Label
   //                   view: "label",
   //                   width: this.currentForm.AB.Config.labelWidthSmall,
   //                   label: L("To"),
   //                },

   //                // Field value
   //                // NOTE: this view gets replaced each time a field is selected.
   //                // We replace it with a component associated with the Field
   //                {},

   //                {
   //                   // "Remove" button
   //                   view: "button",
   //                   css: "webix_danger",
   //                   id: ids.buttonDelete,
   //                   icon: "fa fa-trash",
   //                   type: "icon",
   //                   width: 30,
   //                   hidden: true,
   //                   click: function () {
   //                      _logic.callbacks.onDelete(ids.row);
   //                   },
   //                },
   //             ],
   //          },
   //          {}, // we will add filters here if we need them
   //       ],
   //    };

   //    var init = (options) => {
   //       for (var c in _logic.callbacks) {
   //          _logic.callbacks[c] = options[c] || _logic.callbacks[c];
   //       }

   //       if (options.data) {
   //          // options.data = { formID:xxx, value:yyy,  type:zzzz }
   //          _logic.setValue(options.data);

   //          // _logic.buttonsToggle();
   //       }
   //    };

   //    return {
   //       ui: _ui,
   //       init: init,
   //       toSettings: () => {
   //          return _logic.toSettings();
   //       },
   //       _logic: _logic,
   //    };
   // }

   getUpdateObjectField(fieldID) {
      return (
         this.queryObject?.fieldByID(fieldID) ??
         this.updateObject?.fieldByID(fieldID) ??
         this.currentForm.AB.fieldNew(
            this.currentForm.AB.definitionByID(fieldID) ?? {},
            this.currentForm.AB.objectNew({})
         )
      );
   }

   /**
    * @method processUpdateObject
    * Perform the specified update actions on the provided objectToUpdate
    * @param {obj} options  Additional information required to make updates.
    * @param {obj} objectToUpdate  The object to make the updates on.
    * @return {boolean}   true if an update took place, false if no updates.
    */
   processUpdateObject(options, objectToUpdate) {
      this._formData = objectToUpdate;
      // return new Promise((resolve, reject) => {
      var isUpdated = false;

      this.valueRules = this.valueRules || {};
      this.valueRules.fieldOperations = this.valueRules.fieldOperations || [];

      // var allPromises = [];

      // for each of our operations
      this.valueRules.fieldOperations.forEach((op) => {
         // op = {
         // 	fieldID:'zzzzz',
         //	value: 'xxx',
         //	op: 'set',
         //  type:'',
         //  queryField: '', // id of ABField
         //  selectBy:'',   ['select-one', 'filter-select-one', 'filter-select-all']
         //  valueType: "", ['custom', 'exist']
         // 	filterConditions: { // array of filters to apply to the data table
         //		glue: 'and',
         // 		rules: []
         //  }
         // }

         var field = this.getUpdateObjectField(op.fieldID);
         if (!field) return;

         let value = op?.value?.id ?? op?.value;

         switch (value) {
            case "ab-current-user":
               value = this.currentForm.AB.Account.username();
               break;
            case "ab-current-date":
               value = new Date();
               break;
         }

         // in the case of a connected Field, we use op.value to get the
         // datacollection, and find it's currently selected value:
         if ((field.isConnection && !field.isUser) || op.valueType == "exist") {
            // NOTE: 30 May 2018 :current decision from Ric is to limit this
            // to only handle 1:x connections where we update the current obj
            // with the PK of the value from the DC.
            //
            // In the future, if we want to handle the other options,
            // we need to modify this to handle the M:x connections where
            // we insert our PK into the value from the DC.

            // op.value is the ABDatacollection.id we need to find
            const dataCollection = this.currentForm.AB.datacollectionByID(
               op.value
            );
            if (!dataCollection) {
               isUpdated = false;
               return;
            }

            // we don't want to mess with the dataView directly since it might
            // be used by other parts of the system and this refresh might reset
            // it's cursor.
            // var clonedDataCollection = dataView.filteredClone(op.filterConditions);

            // loop through rules to find "same-as-field" or "not-same-as-field"
            // adjust operator and switch key value to actual value when found
            var filterConditions = this.currentForm.AB.cloneDeep(
               op.filterConditions
            );
            if (filterConditions && filterConditions.rules) {
               filterConditions.rules
                  .filter((r) => {
                     return (
                        r.rule == "same_as_field" ||
                        r.rule == "not_same_as_field"
                     );
                  })
                  .forEach((item) => {
                     var valueField =
                        this.currentForm.datacollection.datasource.fieldByID(
                           item.value
                        );
                     if (valueField.isConnection) {
                        item.value = valueField.format(this._formData);
                     } else {
                        item.value = this._formData[valueField.columnName];
                     }

                     if (item.rule == "not_same_as_field") {
                        item.rule = "not equals";
                     } else {
                        item.rule = "equals";
                     }
                  });
            }

            let clonedDataCollection =
               dataCollection.filteredClone(filterConditions);

            switch (op.selectBy) {
               // the 'select-one' is getting the currently set cursor on this data collection
               // and using that value.
               // TODO: rename to 'select-cursor'
               case "select-one":
               default: // dataView.getItem(dataView.getCursor());
                  value = clonedDataCollection.getCursor();

                  if (value) {
                     // NOTE: webix documentation issue: .getCursor() is supposed to return
                     // the .id of the item.  However it seems to be returning the {obj}

                     if (op.valueType == "exist") {
                        let fieldWithValue =
                           clonedDataCollection.datasource.fieldByID(
                              op.queryField
                           );

                        if (fieldWithValue)
                           value = value[fieldWithValue.columnName];
                     } else if (value.id) {
                        value = value.id;
                     }
                  }

                  // QUESTION: if value returns undefined should we do something else?
                  switch (op.op) {
                     case "set":
                        if (!value) break;

                        if (field.isConnection) {
                           // if we are setting a connection we do not want to pass the full object because
                           // batch creates payload gets too large
                           objectToUpdate[field.columnName] = {};
                           objectToUpdate[field.columnName].id =
                              value[field.datasourceLink.PK()];
                           objectToUpdate[field.columnName][
                              field.datasourceLink.PK()
                           ] = value[field.datasourceLink.PK()];

                           // If the connect field use the custom FK, then it requires to pass value of the custom FK.
                           if (field.settings.isCustomFK) {
                              if (field.indexField) {
                                 objectToUpdate[field.columnName][
                                    field.indexField.columnName
                                 ] = value[field.indexField.columnName];
                              }
                              if (field.indexField2) {
                                 objectToUpdate[field.columnName][
                                    field.indexField2.columnName
                                 ] = value[field.indexField2.columnName];
                              }
                           }

                           field.datasourceLink
                              .fields(
                                 (f) =>
                                    f.key == "combined" || f.key == "AutoIndex"
                              )
                              .forEach((f) => {
                                 objectToUpdate[field.columnName][
                                    f.columnName
                                 ] = value[f.columnName];
                              });
                        } else {
                           objectToUpdate[field.columnName] = value;
                        }

                        break;
                  }
                  break;

               // attempt to filter this data collection by the given filterConditions
               case "filter-select-all":
                  var newValues = [];

                  var currRow = clonedDataCollection.getFirstRecord();
                  while (currRow) {
                     // do something there

                     switch (clonedDataCollection.sourceType) {
                        // case: datacollection is an object
                        // we want to set our field to this values
                        case "object":
                           newValues.push(currRow.id);
                           break;

                        // case: datacollection is a query
                        // our field is a pointer to an object. we want to pull out that object
                        // from the query data.
                        case "query": {
                           let fieldWithValue =
                              clonedDataCollection.datasource.fieldByID(
                                 op.queryField
                              );

                           var newValue = currRow[fieldWithValue.columnName];

                           if (typeof newValue == "undefined") {
                              newValue = currRow[fieldWithValue.relationName()];

                              if (Array.isArray(newValue)) {
                                 newValue = newValue.map((v) => {
                                    return v.id ? v.id : v;
                                 });
                              } else if (newValue.id) {
                                 newValue = newValue.id;
                              }
                           }

                           newValues = this.currentForm.AB.uniq(
                              newValues.concat(newValue)
                           );

                           break;
                        }
                     }

                     currRow = clonedDataCollection.getNextRecord(currRow);
                  }

                  // QUESTION: if value returns undefined should we do something else?
                  switch (op.op) {
                     case "set":
                        if (field.linkType() == "one") {
                           var updates = [];
                           newValues.forEach((v) => {
                              var objectToUpdateClone =
                                 this.currentForm.AB.cloneDeep(objectToUpdate);
                              objectToUpdateClone[field.columnName] = v;
                              updates.push(objectToUpdateClone);
                           });
                           objectToUpdate.newRecords = updates;
                        } else {
                           objectToUpdate[field.columnName] = newValues;
                        }
                        break;
                  }
                  break;

               case "filter-select-one":
                  newValues = [];

                  value = clonedDataCollection.getFirstRecord();

                  if (value) {
                     // case: datacollection is a query
                     // our field is a pointer to an object. we want to pull out that object
                     // from the query data.
                     if (
                        clonedDataCollection.sourceType == "query" ||
                        (op.valueType == "exist" && op.queryField)
                     ) {
                        let fieldWithValue =
                           clonedDataCollection.datasource.fieldByID(
                              op.queryField
                           );

                        newValue = value[fieldWithValue.columnName];

                        if (typeof newValue == "undefined") {
                           newValue = value[fieldWithValue.relationName()];
                           if (Array.isArray(newValue)) {
                              newValue = newValue[0];
                           }
                           if (newValue.id) newValue = newValue.id;
                        }

                        value = newValue;
                     }
                     // case: datacollection is an object
                     // we want to set our field to this values
                     else if (clonedDataCollection.sourceType == "object") {
                        // NOTE: webix documentation issue: .getCursor() is supposed to return
                        // the .id of the item.  However it seems to be returning the {obj}

                        // we need to use the objects indexField(2) if there is one
                        // otherwise default to the id
                        var lookup;
                        if (field.indexField) {
                           lookup = field.indexField.columnName;
                        } else if (field.indexField2) {
                           lookup = field.indexField2.columnName;
                        }
                        if (lookup && value[lookup]) {
                           value = value[lookup];
                        } else if (value.id) {
                           value = value.id;
                        }
                     }
                  }

                  // QUESTION: if value returns undefined should we do something else?
                  switch (op.op) {
                     case "set":
                        objectToUpdate[field.columnName] = value;
                        break;
                  }
                  break;
            }

            isUpdated = true;

            // allPromises.push(connectedPromise);
         } else {
            // var setPromise = new Promise((resolve, reject) => {
            switch (op.op) {
               case "set":
                  objectToUpdate[field.columnName] = value;
                  break;
            }

            isUpdated = true;

            //    resolve(isUpdated);
            // });

            // allPromises.push(setPromise);

            // console.log("finished");
         }
      });

      return isUpdated;
      // Promise.all(allPromises).then(() => {
      //    resolve(isUpdated);
      // });
      // });
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   // @return {Promise}
   process(options) {
      this._formData = options.data;

      return new Promise((resolve, reject) => {
         let isUpdated = this.processUpdateObject({}, options.data);
         if (!isUpdated) {
            resolve();
         } else {
            // get the model from the provided Form Obj:
            var dv = options.form.datacollection;
            if (!dv) return resolve();

            var model = dv.model;
            model
               .update(options.data.id, options.data)
               .then(resolve)
               .catch((err) => {
                  this.currentForm.AB.notify.developer(err, {
                     context:
                        "ABViewRuleActionObjectUpdater:process  update error",
                     id: options.data.id,
                     data: options.data,
                  });
                  reject(err);
               });
         }
      });
   }

   // objectLoad
   // save the current object this Action is associated with.
   objectLoad(object) {
      super.objectLoad(object);
      this.updateObjectLoad(object);
   }

   // updateObjectLoad
   // save the given object as the object we will update.
   updateObjectLoad(object) {
      // stash rules for old object
      if (this.updateObject) {
         this.stashRules[this.updateObject.id] = this.valueRules;
      }

      this.updateObject = object;

      // with a new updateObject, then reset our UI
      // this._uiUpdater = null;

      // reload any stashed rules, or set to {}
      this.valueRules = this.stashRules[this.updateObject.id] || {};
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};

      super.fromSettings(settings); // let the parent handle the QB

      // make sure UI is updated:
      // set our updateObject
      if (settings.updateObjectID) {
         this.updateObject = this.currentForm.AB.objectByID(
            settings.updateObjectID
         );
      } else {
         // DEPRECIATED method of resolving objects .urlResolve()
         if (settings.updateObjectURL) {
            var updateObject = this.currentForm.application.urlResolve(
               settings.updateObjectURL
            );
            this.updateObject = updateObject;
         }
      }

      // // if we have a display component, then populate it:
      // if (this._uiUpdater) {
      //    // now we handle our valueRules:{} object settings.
      //    // pass the settings off to our DisplayList component:
      //    this._uiUpdater.fromSettings(settings);
      // }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	valueRules:{}
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._uiUpdater.toSettings();
      settings.updateObjectURL = this.updateObject.urlPointer();

      return settings;
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * Here we need to scan each of our field operations, and verify all
    * related data collections are initialized before we can continue.
    * @return {Promise}
    */
   isReady() {
      var allReady = [];
      let fieldOps = this.valueRules?.fieldOperations ?? [];
      fieldOps.forEach((op) => {
         let field = this.getUpdateObjectField(op.fieldID);
         if (!field) return;
         if (!field.isConnection && op.valueType !== "exist") return;

         // this references a DC
         let DC = this.currentForm.AB.datacollectionByID(op.value);
         if (DC?.dataStatus === DC?.dataStatusFlag.initialized) return;

         // not ready yet, so wait until the 'initializedData' event
         allReady.push(
            new Promise((resolve /*, reject */) => {
               DC.on("initializedData", () => {
                  resolve();
               });
            })
         );
      });
      return Promise.all(allReady);
   }
}


/***/ }),

/***/ 62107:
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var framework7_bundle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! framework7/bundle */ 17942);
/* harmony import */ var framework7_css_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7/css/bundle */ 81565);
/* harmony import */ var _css_icons_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css/icons.css */ 22254);
/* harmony import */ var _css_app_less__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css/app.less */ 6120);
/* harmony import */ var _routes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./routes.js */ 43183);
/* harmony import */ var _store_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./store.js */ 40659);
/* harmony import */ var _pages_app_f7_jsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../pages/app.f7.jsx */ 18388);
/* harmony import */ var _AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AppBuilder/ABFactory */ 63133);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__]);
_AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];



// Import Global Resources
// import "./atomic.polyfills.min.js";
var atomic = __webpack_require__(/*! ./atomic.js */ 21935);
// var atomic = require("./atomic.polyfills.min.js");
var sails = __webpack_require__(/*! ./sails.io.js */ 55730);
Window.atomic = atomic;

// Import F7 Styles


// Import Icons and App Custom Styles



// Import Routes

// Import Store


// Import main app component


// AB Factory


let version = "0.0.9";

var app = new framework7_bundle__WEBPACK_IMPORTED_MODULE_7__["default"]({
   name: "AppBuilder PWA", // App name
   theme: "auto", // Automatic theme detection
   darkMode: "auto",
   colors: {
      primary: "#366989",
   },

   el: "#app", // App root element
   component: (0,_pages_app_f7_jsx__WEBPACK_IMPORTED_MODULE_5__["default"])(_AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__["default"]), // App main component
   // App store
   store: (0,_store_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__["default"]),
   // App routes
   routes: (0,_routes_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__["default"]),
   version: version,

   // Register service worker (only on production build)
   serviceWorker:
       false
         ? 0
         : {},
});

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 21935:
/*!**************************!*\
  !*** ./src/js/atomic.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return factory(root);
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
})(typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof window !== 'undefined' ? window : this, function (window) {

	'use strict';

	//
	// Variables
	//

	var settings;

	// Default settings
	var defaults = {
		method: 'GET',
		username: null,
		password: null,
		data: {},
		headers: {
			'Content-type': 'application/x-www-form-urlencoded'
		},
		responseType: 'text',
		timeout: null,
		withCredentials: false
	};


	//
	// Methods
	//

	/**
	 * Feature test
	 * @return {Boolean} If true, required methods and APIs are supported
	 */
	var supports = function () {
		return 'XMLHttpRequest' in window && 'JSON' in window && 'Promise' in window;
	};

	/**
	 * Merge two or more objects together.
	 * @param   {Object}   objects  The objects to merge together
	 * @returns {Object}            Merged values of defaults and options
	 */
	var extend = function () {

		// Variables
		var extended = {};

		// Merge the object into the extended object
		var merge = function (obj) {
			for (var prop in obj) {
				if (obj.hasOwnProperty(prop)) {
					if (Object.prototype.toString.call(obj[prop]) === '[object Object]') {
						extended[prop] = extend(extended[prop], obj[prop]);
					} else {
						extended[prop] = obj[prop];
					}
				}
			}
		};

		// Loop through each object and conduct a merge
		for (var i = 0; i < arguments.length; i++) {
			var obj = arguments[i];
			merge(obj);
		}

		return extended;

	};

	/**
	 * Parse text response into JSON
	 * @private
	 * @param  {String} req The response
	 * @return {Array}      A JSON Object of the responseText, plus the orginal response
	 */
	var parse = function (req) {
		var result;
		if (settings.responseType !== 'text' && settings.responseType !== '') {
			return {data: req.response, xhr: req};
		}
		try {
			result = JSON.parse(req.responseText);
		} catch (e) {
			result = req.responseText;
		}
		return {data: result, xhr: req};
	};

	var isFormData = function(obj) {
		return Object.prototype.toString.call(obj) === '[object FormData]';
	}

	/**
	 * Convert an object into a query string
	 * @link   https://blog.garstasio.com/you-dont-need-jquery/ajax/
	 * @param  {Object|Array|String} obj The object
	 * @return {String}                  The query string
	 */
	var param = function (obj) {

		// If already a string, or if a FormData object, return it as-is
		if (typeof (obj) === 'string' || isFormData(obj)) return obj;

		// If the content-type is set to JSON, stringify the JSON object
		if (/application\/json/i.test(settings.headers['Content-type']) || Object.prototype.toString.call(obj) === '[object Array]') return JSON.stringify(obj);

		// Otherwise, convert object to a serialized string
		var encoded = [];
		for (var prop in obj) {
			if (obj.hasOwnProperty(prop)) {
				encoded.push(encodeURIComponent(prop) + '=' + encodeURIComponent(obj[prop]));
			}
		}
		return encoded.join('&');

	};

	/**
	 * Make an XHR request, returned as a Promise
	 * @param  {String} url The request URL
	 * @return {Promise}    The XHR request Promise
	 */
	var makeRequest = function (url) {

		// Create the XHR request
		var request = new XMLHttpRequest();

		// Setup the Promise
		var xhrPromise = new Promise(function (resolve, reject) {

			// Setup our listener to process completed requests
			request.onreadystatechange = function () {

				// Only run if the request is complete
				if (request.readyState !== 4) return;

				// Prevent timeout errors from being processed
				if (!request.status) return;

				// Process the response
				if (request.status >= 200 && request.status < 300) {
					// If successful
					resolve(parse(request));
				} else {
					// If failed
					reject({
						status: request.status,
						statusText: request.statusText,
						responseText : request.responseText
					});
				}

			};

			// Setup our HTTP request
			request.open(settings.method, url, true, settings.username, settings.password);
			request.responseType = settings.responseType;

			// Add headers
			for (var header in settings.headers) {
				if (settings.headers.hasOwnProperty(header)) {
					request.setRequestHeader(header, settings.headers[header]);
				}
			}

			// Set timeout
			if (settings.timeout) {
				request.timeout = settings.timeout;
				request.ontimeout = function (e) {
					reject({
						status: 408,
						statusText: 'Request timeout'
					});
				};
			}

			// Add withCredentials
			if (settings.withCredentials) {
				request.withCredentials = true;
			}

			// Send the request
			request.send(param(settings.data));

		});

		// Cancel the XHR request
		xhrPromise.cancel = function () {
			request.abort();
		};

		// Return the request as a Promise
		return xhrPromise;

	};

	/**
	 * Instatiate Atomic
	 * @param {String} url      The request URL
	 * @param {Object} options  A set of options for the request [optional]
	 */
	var Atomic = function (url, options) {

		// Check browser support
		if (!supports()) throw 'Atomic: This browser does not support the methods used in this plugin.';

		// Merge options into defaults
		settings = extend(defaults, options || {});

		// clear Content-Type if provided data is FormData
		if (isFormData(settings.data)) {
			delete settings.headers['Content-type'];
		}

		// Make request
		return makeRequest(url);

	};


	//
	// Public Methods
	//

	return Atomic;

});


/***/ }),

/***/ 49670:
/*!*******************************!*\
  !*** ./src/js/definitions.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
	abVersion: "0.0.0",
	filename: "app_AppBuilder_PWA_20230519",
	date: "20230519",
	definitions: [
		{
			id: "4b7a489a-5fe5-4044-8565-aaa3654300f2",
			name: "AppBuilder PWA",
			type: "application",
			json: {
				id: "4b7a489a-5fe5-4044-8565-aaa3654300f2",
				type: "application",
				name: "AppBuilder PWA",
				icon: "fa-android",
				isSystemObject: 0,
				json: {
					translations: [
						{
							language_code: "en",
							label: "AppBuilder PWA",
							description:
								"Application to test new AppBuilder PWA framework.",
						},
					],
					name: "AppBuilder PWA",
					versionData: {
						versionNumber: "1.0.0",
						changeLog: {
							"1.0.0": {
								author: "N/A",
								version: "1.0.0",
								keepVersion: 0,
								commitMessage: "Initial Version",
								timestamp: "2023-05-18T09:55:09.456Z",
								versionNumber: "1.0.0",
							},
						},
					},
					objectIDs: ["faa9905e-dea8-4c7f-8eb4-98f1e6e66506"],
					objectListSettings: {
						isOpen: false,
						searchText: "",
						sortDirection: "asc",
						isGroup: false,
					},
					hintIDs: [],
					queryIDs: [],
					datacollectionIDs: ["0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"],
					pageIDs: [],
					processIDs: [],
				},
				roleAccess: [
					"dd6c2d34-0982-48b7-bc44-2456474edbea",
					"e1be4d22-1d00-4c34-b205-ef84b8334b19",
					"6cc04894-a61b-4fb5-b3e5-b8c3f78bd331",
				],
				translations: [
					{
						language_code: "en",
						label: "AppBuilder PWA",
						description:
							"Application to test new AppBuilder PWA framework.",
					},
				],
				isAccessManaged: false,
				isTranslationManaged: false,
				isTutorialManaged: false,
				accessManagers: {
					useRole: 0,
					role: null,
					useAccount: 0,
					account: null,
				},
				translationManagers: {
					useRole: 0,
					role: null,
					useAccount: 0,
					account: null,
				},
			},
			createdAt: "2023-05-18T09:55:09.000Z",
			updatedAt: "2023-05-18T10:18:01.000Z",
		},
		{
			id: "faa9905e-dea8-4c7f-8eb4-98f1e6e66506",
			name: "Person - PWA",
			type: "object",
			json: {
				id: "faa9905e-dea8-4c7f-8eb4-98f1e6e66506",
				type: "object",
				name: "Person - PWA",
				labelFormat: "",
				labelSettings: { isNoLabelDisplay: 0 },
				isImported: 0,
				isExternal: 0,
				tableName: "AB_AppBuilderPWA_PersonPWA",
				primaryColumnName: "uuid",
				transColumnName: "",
				urlPath: "",
				objectWorkspace: {
					sortFields: [],
					filterConditions: [],
					frozenColumnID: "",
					hiddenFields: [],
				},
				isSystemObject: 0,
				translations: [{ language_code: "en", label: "Person - PWA" }],
				fieldIDs: [
					"c6268631-bc80-4a72-a3f2-55e5721f47a2",
					"657ca7ef-75ce-4b07-a7d5-5b95ad775767",
					"3a212114-385d-40bf-bf7e-a24b7da0c7e7",
					"2d08298f-cfda-44d2-aa19-683316f578a9",
					"4998a2eb-b04b-4a8b-9d1d-f3d839c9e920",
					"b83daff6-8624-469b-9a30-d02f68be9e29",
					"2bfc9604-8011-41ef-9985-a22de0258413",
					"032f3208-4ae8-400e-8bbe-3edde4dae5d7",
					"0b52730f-1e1e-476a-95ef-2824ed87da13",
				],
				importedFieldIDs: [],
				indexIDs: [],
				createdInAppID: "4b7a489a-5fe5-4044-8565-aaa3654300f2",
				objectWorkspaceViews: {
					currentViewID: "bdcf1b76-9684-4349-8a07-588da87287cf",
					list: [
						{
							id: "bdcf1b76-9684-4349-8a07-588da87287cf",
							translations: [
								{ language_code: "en", label: "grid" },
							],
							isDefaultView: true,
							name: "Default Grid",
							sortFields: [],
							filterConditions: [],
							frozenColumnID: "",
							hiddenFields: ["salt", "password"],
							type: "grid",
						},
					],
				},
			},
			createdAt: "2023-05-18T09:56:18.000Z",
			updatedAt: "2023-05-18T10:06:58.000Z",
		},
		{
			id: "c6268631-bc80-4a72-a3f2-55e5721f47a2",
			name: "Person - PWA->Name",
			type: "field",
			json: {
				id: "c6268631-bc80-4a72-a3f2-55e5721f47a2",
				type: "field",
				key: "string",
				icon: "font",
				isImported: 0,
				columnName: "Name",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "",
					supportMultilingual: 0,
					width: 100,
				},
				translations: [{ language_code: "en", label: "Name" }],
			},
			createdAt: "2023-05-18T09:56:32.000Z",
			updatedAt: "2023-05-18T09:56:32.000Z",
		},
		{
			id: "657ca7ef-75ce-4b07-a7d5-5b95ad775767",
			name: "Person - PWA->Email",
			type: "field",
			json: {
				id: "657ca7ef-75ce-4b07-a7d5-5b95ad775767",
				type: "field",
				key: "email",
				icon: "envelope",
				isImported: 0,
				columnName: "Email",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "",
					width: 100,
					defaultCheckbox: 0,
				},
				translations: [{ language_code: "en", label: "Email" }],
			},
			createdAt: "2023-05-18T09:56:40.000Z",
			updatedAt: "2023-05-18T09:56:40.000Z",
		},
		{
			id: "3a212114-385d-40bf-bf7e-a24b7da0c7e7",
			name: "Person - PWA->URL",
			type: "field",
			json: {
				id: "3a212114-385d-40bf-bf7e-a24b7da0c7e7",
				type: "field",
				key: "string",
				icon: "font",
				isImported: 0,
				columnName: "URL",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "",
					supportMultilingual: 0,
					width: 100,
				},
				translations: [{ language_code: "en", label: "URL" }],
			},
			createdAt: "2023-05-18T09:56:59.000Z",
			updatedAt: "2023-05-18T09:56:59.000Z",
		},
		{
			id: "2d08298f-cfda-44d2-aa19-683316f578a9",
			name: "Person - PWA->Phone",
			type: "field",
			json: {
				id: "2d08298f-cfda-44d2-aa19-683316f578a9",
				type: "field",
				key: "string",
				icon: "font",
				isImported: 0,
				columnName: "Phone",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "",
					supportMultilingual: 0,
					width: 100,
				},
				translations: [{ language_code: "en", label: "Phone" }],
			},
			createdAt: "2023-05-18T09:57:25.000Z",
			updatedAt: "2023-05-18T09:57:25.000Z",
		},
		{
			id: "4998a2eb-b04b-4a8b-9d1d-f3d839c9e920",
			name: "Person - PWA->Gender",
			type: "field",
			json: {
				id: "4998a2eb-b04b-4a8b-9d1d-f3d839c9e920",
				type: "field",
				key: "list",
				icon: "th-list",
				isImported: 0,
				columnName: "Gender",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					isMultiple: 0,
					hasColors: 1,
					default: "1684401575798",
					multipleDefault: [],
					options: [
						{
							id: "Male",
							text: "Male",
							hex: "#03A9F4",
							translations: [
								{ language_code: "en", text: "Male" },
							],
						},
						{
							id: "Female",
							text: "Female",
							hex: "#E91E63",
							translations: [
								{ language_code: "en", text: "Female" },
							],
						},
					],
					width: 100,
				},
				translations: [{ language_code: "en", label: "Gender" }],
			},
			createdAt: "2023-05-18T09:58:24.000Z",
			updatedAt: "2023-05-18T10:08:39.000Z",
		},
		{
			id: "b83daff6-8624-469b-9a30-d02f68be9e29",
			name: "Person - PWA->Birthday",
			type: "field",
			json: {
				id: "b83daff6-8624-469b-9a30-d02f68be9e29",
				type: "field",
				key: "date",
				icon: "calendar",
				isImported: 0,
				columnName: "Birthday",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					dateFormat: 2,
					defaultDate: 1,
					defaultDateValue: null,
					validateCondition: "none",
					validateRangeUnit: "",
					validateRangeBefore: 0,
					validateRangeAfter: 0,
					validateStartDate: null,
					validateEndDate: null,
					width: 120,
					timeFormat: 2,
					defaultTime: 1,
					defaultTimeValue: null,
				},
				translations: [{ language_code: "en", label: "Birthday" }],
			},
			createdAt: "2023-05-18T09:58:55.000Z",
			updatedAt: "2023-05-18T09:58:55.000Z",
		},
		{
			id: "2bfc9604-8011-41ef-9985-a22de0258413",
			name: "Person - PWA->Toggle",
			type: "field",
			json: {
				id: "2bfc9604-8011-41ef-9985-a22de0258413",
				type: "field",
				key: "boolean",
				icon: "check-square-o",
				isImported: 0,
				columnName: "Toggle",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: 0,
					width: 100,
				},
				translations: [{ language_code: "en", label: "Toggle" }],
			},
			createdAt: "2023-05-18T09:59:14.000Z",
			updatedAt: "2023-05-18T09:59:14.000Z",
		},
		{
			id: "032f3208-4ae8-400e-8bbe-3edde4dae5d7",
			name: "Person - PWA->Slider",
			type: "field",
			json: {
				id: "032f3208-4ae8-400e-8bbe-3edde4dae5d7",
				type: "field",
				key: "number",
				icon: "hashtag",
				isImported: 0,
				columnName: "Slider",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "50",
					typeFormat: "none",
					typeDecimals: "none",
					typeDecimalPlaces: 0,
					typeRounding: "none",
					typeThousands: "none",
					validation: 0,
					validateMinimum: "",
					validateMaximum: "",
					width: 100,
				},
				translations: [{ language_code: "en", label: "Slider" }],
			},
			createdAt: "2023-05-18T09:59:51.000Z",
			updatedAt: "2023-05-18T09:59:51.000Z",
		},
		{
			id: "0b52730f-1e1e-476a-95ef-2824ed87da13",
			name: "Person - PWA->Bio",
			type: "field",
			json: {
				id: "0b52730f-1e1e-476a-95ef-2824ed87da13",
				type: "field",
				key: "LongText",
				icon: "align-right",
				isImported: 0,
				columnName: "Bio",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "",
					supportMultilingual: 0,
					width: 100,
				},
				translations: [{ language_code: "en", label: "Bio" }],
			},
			createdAt: "2023-05-18T10:06:57.000Z",
			updatedAt: "2023-05-18T10:06:57.000Z",
		},
		{
			id: "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322",
			name: "Person",
			type: "datacollection",
			json: {
				id: "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322",
				name: "Person",
				type: "datacollection",
				settings: {
					linkDatacollectionID: "",
					linkFieldID: "",
					followDatacollectionID: "",
					objectWorkspace: {
						filterConditions: { glue: "and", rules: [] },
						sortFields: [],
					},
					loadAll: false,
					isQuery: false,
					populate: true,
					syncType: 1,
					datasourceID: "faa9905e-dea8-4c7f-8eb4-98f1e6e66506",
				},
				translations: [{ language_code: "en", label: "Person" }],
			},
			createdAt: "2023-05-18T10:18:01.000Z",
			updatedAt: "2023-05-18T10:18:01.000Z",
		},
	],
	siteObjectConnections: {},
	roles: [],
});


/***/ }),

/***/ 12968:
/*!*************************************!*\
  !*** ./src/js/resources/Account.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
// var EventEmitter = require("events").EventEmitter;
// import { EventEmitter } from "events";


class Account extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super();

      this.isAuthenticated = false;
      this._config = null;

      this._listRoles = null;
      // {array}
      // a list of all the Defined Roles in the Tenant's system.

      this._listScopes = null;
      // {array | null}
      // a list of all the Defined Scopes in the Tenant's sytem.

      this._listUsers = null;
      // {array | null}
      // a list of all the Defined Users in the Tenant's system.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      var UserConfig = this.AB.Config.userConfig();
      if (UserConfig) {
         this.isAuthenticated = true;
         this._config = UserConfig;
      } else {
         let tenantConfig = this.AB?.Config?.tenantConfig?.()?.options ?? {};
         tenantConfig =
            typeof tenantConfig === "string"
               ? JSON.parse(tenantConfig)
               : tenantConfig;
         // If no user and tenant isn't using local auth start
         // the external auth workflow:
         if (tenantConfig.authType !== "login") {
            window.location.assign("/auth/login");
         }
         // Keep going if the tenant is using local auth
      }

      var MetaConfig = this.AB.Config.metaConfig();
      if (MetaConfig) {
         this._listRoles = MetaConfig.roles || [];
         this._listScopes = MetaConfig.scopes || [];
         this._listUsers = MetaConfig.users || [];
      }

      this.AB.Network.on("account.logout", (context, err, data) => {
         if (err) {
            console.error(err);
            return;
         }
         this.emit("logout", data);
      });

      return Promise.resolve();
   }

   canSwitcheroo() {
      return (
         this.roles((r) => r.uuid === "320ef94a-73b5-476e-9db4-c08130c64bb8")
            .length > 0
      );
   }

   isSwitcherood() {
      return this.AB.Config.userReal();
   }

   isSystemDesigner() {
      return (
         this.roles((r) => r.uuid === "6cc04894-a61b-4fb5-b3e5-b8c3f78bd331")
            .length > 0
      );
   }

   email() {
      return this._config?.email ?? "";
   }

   language() {
      return this._config?.languageCode ?? "en";
   }

   logout() {
      return this.AB.Network.post(
         {
            url: "/auth/logout",
            data: { tenantUrl: this.AB.Tenant.setting("url") },
         },
         {
            key: "account.logout",
            context: {},
         }
      );
   }

   roles(fn = () => true) {
      return (this._config?.roles || []).filter(fn);
   }
   rolesAll() {
      return this._listRoles;
   }

   scopes() {
      return this._listScopes;
   }

   username() {
      return this._config?.username;
   }

   userList() {
      return this._listUsers;
   }

   uuid() {
      return this._config?.uuid;
   }

   imageID() {
      return this._config?.image_id;
   }

   sendEmailNotifications() {
      return this._config?.sendEmailNotifications;
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Account());


/***/ }),

/***/ 77269:
/*!************************************!*\
  !*** ./src/js/resources/Config.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ 96486);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
// import ConfigDesktop from "./configDesktop";
// import ConfigMobile from "./configMobile";

// var EventEmitter = require("events").EventEmitter;


const settingsDefault = {
   "appbuilder-portal-autoenter": true,
   // {bool} autoenter
   // open up the portal as soon as we load.
   //   false : just displays a link that will load the portal

   "appbuilder-portal-fullscreen": true,
   // {bool} fullscreen
   // take up the full browser window?
   //   false : only take up the area the current div is

   "appbuilder-tenant": null,
   // {string} tenant
   // the tenant uuid for this AppBuilder instance.

   "appbuilder-view": "work",
   // {string} view
   // the default view to display to the current user.

   "appbuilder-tenant-prefix": null,
   // TESTING! Remove this
};

const configDefaults = {
   site: {
      appbuilder: {
         networkType: "rest", // "socket",
         // options: ["rest", "relay", "socket"]
         // Note: "socket" is required for realtime updates across devices.

         networkNumRetries: 3,
         // the number of times we will retry sending a network request
         // when we receive a timeout error.

         urlCoreServer: window.location.origin,
         // on the web client, just record the current URL by default.
         // the site config can override this if they want.
      },
      storage: {
         encrypted: false,
         // {bool} should we encrypt our data in the local browser storage?
      },
   },
};
class Config {
   constructor() {
      // this.setMaxListeners(0);
      this._config = null;
      // {obj} _config
      // these are the configuration settings returned from the server. These
      // are more detailed configuration settings for the running of the site.

      this._settings = {};
      // {obj} _settings
      // settings are the configuration parameters found on the base <div>
      // these settings are the minimum needed to successfully pull up the
      // portal popup and perform the initial config request
   }

   /**
    * Sets the configuration
    * @param {Config} json - Configuration object
    */
   config(json) {
      if (!json || typeof json !== "object") {
         throw new Error("Invalid configuration object");
      }

      this._config = json;
      /*
         this._config = {
            labels: {  label configuration  },
            languages: { language configuration },
            meta: { meta configuration  },
            plugins: [ array of plugins  ],
         +   inbox: { inbox configuration  },
         +   inboxMeta: { inbox meta configuration },
            site: { site configuration },
            tenant: { tenant configuration },
            user: { user configuration  },
            userReal: {bool} true/false
            version: {string} "1.0.0"
         };

         + = not pulled in by preloader. Instead a separate request is made.
      */

      // Move site and version to the top level
      const { settings } = json;
      ["site", "version"].forEach((key) => {
         if (!this._config[key]) {
            this._config[key] = settings[key];
         }
      });
      delete this._config.settings;

      this._config.userReal = window.__AB_Config_User_Real ?? false;

      (0,lodash__WEBPACK_IMPORTED_MODULE_0__.defaultsDeep)(this._config, configDefaults);
   }

   /**
    * Gets or sets a setting
    * @param {string} key - Setting key
    * @param {*} [value] - Setting value
    * @returns {*} - Setting value if no value is provided
    */
   setting(key, value) {
      if (value !== undefined) {
         this._settings[key] = value;
         return;
      }
      return this._settings[key];
   }

   /**
    * Loads settings from a div element
    * @param {HTMLElement} div - Div element
    */
   settingsFromDiv(div) {
      Object.keys(settingsDefault).forEach((d) => {
         var val = div.getAttribute(d);
         if (!val) {
            val = settingsDefault[d];
         }
         if (val === "false") val = false;
         if (val === "true") val = true;

         var key = d.split("-").pop();
         this.setting(key, val);
      });
   }

   settings(json = {}) {
      for (let key in settingsDefault) {
         const val = json[key] ?? settingsDefault[key];
         this.setting(key.split("-").pop(), val);
      }
   }

   /**
    * definitions()
    * return the ABDefinition(s) required to manage the interface.
    * @return {obj}
    *          { ABDefinition.id : {ABDefinition} }  hash of definitions.
    */
   // definitions() {
   //    debugger;
   //    return window.definitions;
   // }

   error(/* ...args */) {
      console.error("Who is calling this? -> move to AB.error() instead.");
      // this.emit("ab.error", args);
   }

   labelConfig() {
      if (this._config && this._config.labels) {
         return this._config.labels;
      }
      console.error("No Label config found.");
      return {};
   }

   languageConfig() {
      if (this._config && this._config.languages) {
         return this._config.languages;
      }
      console.error("No Language config found.");
      return {};
   }

   metaConfig() {
      if (this._config && this._config.meta) {
         return this._config.meta;
      }
      console.error("No Meta config found.");
      return {};
   }

   plugins() {
      // TODO: Pull from this._config.plugins
      return ["ABDesigner.js"];
      // return [];
   }

   inboxConfig() {
      if (this._config && this._config.inbox) {
         return this._config.inbox;
      }
      return null;
   }

   inboxMetaConfig() {
      if (this._config && this._config.inboxMeta) {
         return this._config.inboxMeta;
      }
      return null;
   }

   siteConfig() {
      if (this._config && this._config.site) {
         return this._config.site;
      }
      return configDefaults.site;
   }

   tenantConfig() {
      if (this._config && this._config.tenant) {
         return this._config.tenant;
      }
      return null;
   }

   // uiSettings() {
   //    if (window.innerWidth < 768) {
   //       return ConfigMobile;
   //    }
   //    return ConfigDesktop;
   // }

   userConfig() {
      if (this._config && this._config.user) {
         return this._config.user;
      }
      return null;
   }

   userReal() {
      return this._config?.userReal ?? false;
   }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Config());


/***/ }),

/***/ 28917:
/*!******************************************!*\
  !*** ./src/js/resources/Multilingual.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABMLClass */ 46148);
/*
 * Multilingual
 * manage our multilingual Translations/Labels/etc.
 */



class Multilingual extends _AppBuilder_platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super([], {});
      // super()
      //    [] = no labels
      //    {} = placeholder ABFactory entry until .init() is called.

      this.isAuthenticated = false;
      this._config = null;

      this._missingLabelID = false;
      this._missingLabels = {};
      this._pluginLabelsMissing = {};
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;

      this.labels = this.AB.Config.labelConfig();
      this._languages = this.AB.Config.languageConfig();

      this.pluginLabels = {};

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   currentLanguage() {
      return this.AB.Account.language();
   }

   label(key, altText, values = [], postMissing = true) {
      // part of our transition: L("single string") should start to work:
      if (typeof altText == "undefined" && key) {
         altText = key;
      }

      // other case: L("single string {0}", [])
      if (arguments.length == 2 && Array.isArray(altText)) {
         values = altText;
         altText = key;
      }

      // We need to escape " characters or else they will get added to the the lang.js
      // then we get errors next time we try to parse it as JSON (see appbuilder.label-missing)
      altText = altText.replace(/"/g, '\\"');
      key = key.replace(/"/g, '\\"');

      // NOTE: transition to new Labels
      // currently our code still uses the L(key, altText, values) format, but
      // the labels we get back are in L(altText, values) format.
      //
      // we are going to keep this like this until we have a well functioning
      // UI display of our Apps, which should flesh out most of the missing
      // labels to our files.
      //
      // After that, convert our L(k, t, v) to L(t, v)

      var newKey = altText;
      if (newKey[0] == "*") {
         newKey = newKey.slice(1);
      }
      var label = this.labels[newKey];
      if (!label) {
         if (postMissing) {
            this.postMissingLabel(key, altText);
         }
         label = altText;
      }

      values.forEach((v, i) => {
         var sub = `{${i}}`;
         label = label.replaceAll(sub, v);
      });
      label = label.replace(/\\"/g, '"'); // unescape " in the label
      return label;
   }

   labelPlugin(plugin, altText, values = []) {
      // 1st check to see if it is a common label from platform:
      var label = this.label(altText, altText, values, false);
      if (!label) {
         // ok, so check to see if it is a Plugin Label:
         label = this.pluginLabels[plugin][altText];
      }
      if (!label) {
         // !! record it missing.
         this._pluginLabelsMissing[plugin] =
            this._pluginLabelsMissing[plugin] || {};
         this._pluginLabelsMissing[plugin][altText] = altText;
         label = altText;
      }
      values.forEach((v, i) => {
         var sub = `{${i}}`;
         label = label.replaceAll(sub, v);
      });
      return label;
   }

   languages() {
      return this._languages;

      // console.error(
      //    "Multilingual:languages(): Implement Language Storage/Retrieval."
      // );
      // return [];
   }

   pluginLoadLabels(key, labels) {
      this.pluginLabels[key] = labels;
   }
   pluginLabelReport(key) {
      console.warn("missing labels for plugin: ", key);
      console.warn("current language:", this.currentLanguage());
      var labels = JSON.stringify(this._pluginLabelsMissing[key], null, 3);
      console.warn(labels);
   }

   postMissingLabel(key, altText) {
      if (this._missingLabelID) {
         clearTimeout(this._missingLabelID);
      }
      var batchLength = 50;
      var sendBatch = () => {
         var batchLabels = [];
         let missingLabels = Object.keys(this._missingLabels).map(
            (k) => this._missingLabels[k]
         );
         if (missingLabels.length <= batchLength) {
            batchLabels = missingLabels;
            this._missingLabels = {};
         } else {
            for (var i = 0; i <= batchLength; i++) {
               var l = missingLabels.shift();
               batchLabels.push(l);
               delete this._missingLabels[l.key];
            }
         }
         this.AB.Network.post({
            url: "/multilingual/label-missing",
            data: { labels: JSON.stringify(batchLabels) },
         })
            .then(() => {
               if (Object.keys(this._missingLabels).length > 0) {
                  sendBatch();
               }
            })
            .catch((err) => {
               const strErr = err.toString();
               if (strErr.indexOf("unable to get") > -1) {
                  console.error(
                     "Missing language file for :" + this.currentLanguage()
                  );
               }
            });
      };
      this._missingLabelID = setTimeout(() => {
         sendBatch();
      }, 1000);

      this._missingLabels[key] = { key, altText };
   }
   ///
   /// Disable un-needed ABMLClass functionality
   ///
   /// NOTE: we are mainly Piggybacking on ABMLClass for it's
   /// .translate() and .unTranslate() capabilities. So disable these
   /// for good measure.
   destroy() {
      console.error("Multilingual:destroy(): Should not be called.");
      return Promise.resolve();
   }
   save() {
      console.error("Multilingual:save(): Should not be called.");
      return Promise.resolve();
   }
   toObj() {
      console.error("Multilingual:toObj(): Should not be called.");
      return {};
   }
   toDefinition() {
      console.error("Multilingual:toDefinition(): Should not be called.");
      return {};
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Multilingual());


/***/ }),

/***/ 93360:
/*!*************************************!*\
  !*** ./src/js/resources/Network.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
/* harmony import */ var _NetworkRest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NetworkRest */ 84292);
/* harmony import */ var _NetworkRestSocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NetworkRestSocket */ 27299);
/*
 * Network.js
 * A network manager for interfacing with our AppBuilder server.
 */



// import NetworkRelay from "./NetworkRelay";

class Network extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super();

      this.setMaxListeners(0);
      // we'll have > 10 for sure!

      this.queueLock = null;
      // {Lock} .queueLock
      // our semaphore for coordinating our access to our local storage.

      this._config = null;
      this._network = null;
      // {NetworkRelay | NetworkRest | NetworkSocket}
      // the underlying Network connection object actually performing the
      // communications with the Server.
      // Which one is specified in the config.appbuilder.networkType setting

      this._queueCount = 0;
      // {int} _queueCount
      // the # of network operations currently queued, pending Network
      // reconnect.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;

      this.queueLock = new this.AB.Lock();

      this._config = this.AB.Config.siteConfig();
      if (this._config) {
         switch (this._config.appbuilder.networkType) {
            case "relay":
               // this._network = new NetworkRelay();
               break;

            case "socket":
               this._network = new _NetworkRestSocket__WEBPACK_IMPORTED_MODULE_2__["default"](this);
               break;

            case "rest":
            default:
               this._network = new _NetworkRest__WEBPACK_IMPORTED_MODULE_1__["default"](this);
               break;
         }

         return this._network.init(AB);
      } else {
         console.error("??? Why No site config ???");
      }

      //
      // Handle reconnections and flushing the Queue:
      //
      if (io && io.socket) {
         // When our Socket reconnects, be sure to flush any pending transactions.
         io.socket.on("connected", () => {
            this.queueFlush();
            if (this.idConnectionCheck) {
               clearTimeout(this.idConnectionCheck);
               this.idConnectionCheck = null;
            }
         });
      } else {
         console.error("!!! Network.init() : Did not find io.socket");
         window.addEventListener("online", () => this.queueFlush());
      }

      return Promise.resolve();
   }

   //
   // Interface API
   //
   /**
    * Network.isRealTime
    * indicates wether or not the current network connection supports
    * RealTime updates.
    * @return {bool}
    */
   get isRealTime() {
      return this._network.isRealTime;
   }

   /**
    * Network.get(options, jobResponse)
    * perform a GET request back to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   get(...params) {
      return this._network.get(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.post()
    * perform an AJAX POST request to the AppBuilder server.
    * this is a CREATE operation.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   post(...params) {
      return this._network.post(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.put()
    * perform a PUT request to the AppBuilder server.
    * This is for UPDATE/REPLACE operations to data on the server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   put(...params) {
      return this._network.put(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.delete()
    * perform an AJAX DELETE request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   delete(...params) {
      return this._network.delete(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   ////
   //// Network Utilities
   ////

   _connectionCheck() {
      // if (!this.idConnectionCheck) {
      if (this.isNetworkConnected()) {
         this.queueFlush().catch(() => {
            // on an error, we are still having connection issues
            this.idConnectionCheck = setTimeout(() => {
               this._connectionCheck();
            }, 250);
         });
         this.idConnectionCheck = null;
      } else {
         this.idConnectionCheck = setTimeout(() => {
            this._connectionCheck();
         }, 250);
      }
      // }
   }

   /**
    * @method networkStatus
    * return the connection type currently registered with the network
    * plugin.
    * @return {string}
    */
   networkStatus() {
      return navigator.connection.type;
   }

   /**
    * @method isNetworkConnected
    * return true/false if the device is currently connected to the
    * internet.
    * @return {bool}
    */
   isNetworkConnected() {
      // console.log(
      //    "TODO: Network.isNetworkConnected(): replace online check to expected order."
      // );
      // // if this isn't a Cordova Plugin, then return navigator data:
      // if (typeof Connection == "undefined") {
      //    // NOTE: this technically only detects if we are connected to a
      //    // network.  It doesn't guarantee we can communicate across the 'net
      //    return navigator.onLine;
      // }

      // if this is a Web Client and using sails.socket.io
      if (typeof io != "undefined" && io.socket && io.socket.isConnected) {
         return io.socket.isConnected();
      }

      // if this isn't a Cordova Plugin, then return navigator data:
      if (typeof Connection == "undefined") {
         // NOTE: this technically only detects if we are connected to a
         // network.  It doesn't guarantee we can communicate across the 'net
         return navigator.onLine;
      }

      // Cordova Plugin:
      return this.networkStatus() != Connection.NONE;
   }

   /**
    * publishResponse()
    * emit the requested response for this network operation.
    * @param {obj} jobResponse
    * @param {obj} error
    * @param {obj} data
    */
   publishResponse(jobResponse, error, data) {
      if (data) {
         data = this.normalizeData(data);
      }
      this.emit(jobResponse.key, jobResponse.context, error, data);
   }

   normalizeData(data) {
      // Data returning from our server is wrapped in an outer layer of
      // information that is for our Networking API.
      // the outer wrapper should be:
      // on success :
      // {
      //   status: "success",
      //   data:{Data For App}
      // }
      // on Error:
      // {
      //   status: "error",
      //   id: {int} error code
      //   ... other data here
      // }

      // we have physically received a data packet from the server,
      // but we are informed that our transaction was problematic
      // (400 level USER problem?)
      if (data.status === "error") {
         // TODO: review Error procedure here
         return data;
      }

      // on success
      // make sure we return the Application Level Data packet:
      return data.data || data;
   }

   ////
   //// Queued Requests
   ////

   /**
    * refQueue()
    * sub classes can override this for their own separate Queue Data
    * @return {string}
    */
   refQueue() {
      return "networkQueue";
   }

   /**
    * queueCount()
    * return the # of messages in the queue.
    * @return {int}
    */
   queueCount() {
      return this._queueCount;
   }

   /**
    * Adds a request to the outgoing queue.
    *
    * @param {object} data
    * @param {object} jobResponse
    * @return {Promise}
    */
   queue(data, jobResponse) {
      var refQueue = this.refQueue();

      return new Promise((resolve, reject) => {
         this.queueLock
            .acquire()
            .then(() => {
               return this.AB.Storage.get(refQueue);
            })
            .then((queue) => {
               queue = queue || [];
               queue.push({ data, jobResponse });
               this.AB.log(
                  `:::: ${queue.length} request${
                     queue.length > 1 ? "s" : ""
                  } queued`
               );
               this._queueCount = queue.length;
               return this.AB.Storage.set(refQueue, queue);
            })
            .then(() => {
               this.emit("queued");
               // if we are not already polling the network, start
               if (!this.idConnectionCheck) {
                  this._connectionCheck();
               }
               this.queueLock.release();
               resolve();
            })
            .catch((err) => {
               this.AB.notify.developer(err, {
                  message: "Error while queueing data",
               });
               this.AB.Analytics.logError(err);
               reject(err);

               this.queueLock.release();
            });
      });
   }

   /**
    * queueFlush()
    * Flush the queue and send the contents to the relay server.
    */
   queueFlush() {
      var refQueue = this.refQueue();

      // if we are not connected, then stop
      if (!this.isNetworkConnected()) {
         var error = new Error("Not connected to the internet.");
         error.code = "E_NOTCONNECTED";
         return Promise.reject(error);
      }

      // otherwise, attempt to flush the queue:
      return new Promise((resolve, reject) => {
         this.queueLock
            .acquire()

            //
            // Get queue contents
            //
            .then(() => {
               return this.AB.Storage.get(refQueue);
            })

            //
            // Send off each queued request
            //
            .then((queue) => {
               // default to [] if not found
               queue = queue || [];

               // recursively process each pending queue request
               var processRequest = (cb) => {
                  if (queue.length == 0) {
                     cb();
                  } else {
                     var entry = queue.shift();
                     var params = entry.data;
                     var job = entry.jobResponse;
                     this._network
                        .resend(params, job)
                        .then(() => {
                           processRequest(cb);
                        })
                        .catch((err) => {
                           // if the err was due to a network connection error
                           if (err && err.code == "E_TOMANYRETRIES") {
                              cb(err);
                              return;
                           }
                           // otherwise, try the next
                           processRequest(cb);
                        });
                  }
               };

               return new Promise((res, rej) => {
                  processRequest((err) => {
                     if (err) {
                        rej(err);
                     } else {
                        res();
                     }
                  });
               });
            })

            //
            // Clear queue contents
            //
            .then(() => {
               this._queueCount = 0;
               return this.AB.Storage.set(refQueue, []);
            })

            // release the Lock
            .then(() => {
               this.emit("queue.synced");
               return this.queueLock.release();
            })

            // all done.
            .then(() => {
               resolve();
            })

            // respond to errors:
            .catch((err) => {
               this.AB.notify.developer(err, {
                  message: "commAPI queueFlush error",
               });
               this.AB.Analytics.logError(err);

               this.queueLock.release().then(() => {
                  reject(err);
               });
            });
      });
   }

   /**
    * Reset credentials to a blank state.
    * @return {Promise}
    */
   reset() {
      return Promise.resolve();
   }

   /**
    * type()
    * return the type of network connection we are using.
    * ["rest", "socket", "relay"]
    * @return {string}
    */
   type() {
      return this._config.appbuilder.networkType;
   }

   // uuid() {
   //    return this.AB.uuid();
   // }

   getTokens() {
      // called in appPage.js : openRelayLoader()
      return {};
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Network());


/***/ }),

/***/ 84292:
/*!*****************************************!*\
  !*** ./src/js/resources/NetworkRest.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
/*
 * NetworkRest.js
 * The base Networking class.  This class is responsible for job submissions
 * and outlines the basic Network interface.
 */

/* global navigator Connection */
// import Account from "./Account";
// import analytics from "./Analytics";
// import EventEmitter from "eventemitter2";

// import Lock from "./Lock";

// import { storage } from "./Storage";
// import Tenant from "./Tenant";
// import { v4 as uuidv4 } from "uuid";

// Temp placeholders until Resources are implemented:

// End Temp
// var Atomic = Window.atomic;
// import Atomic from "../../../node_modules/atomicjs/dist/atomic.polyfills.js";
// Atomic : a small $.ajax() replacement

var Config = null;
// {} Config
// the site specific configuration information

class NetworkRest extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(parent) {
      // {Network} parent

      super({
         wildcard: true,
         newListener: false,
         maxListeners: 0,
      });

      this.baseURL = null;
      // {string} .baseURL
      // the url of our site.

      this.numRetries = 3;
      // {int} .numRetries
      // the number or times we should attempt to issue a network request.

      this._network = parent;
      // {Network} ._network
      // the Parent Network Resource that the rest of the Platform actually
      // works with.

      this.isRealTime = false;
      // {bool}
      // does this Network type support RealTime updates. (socket = true);
   }

   /**
    * @method init
    * @param {ABFactory} AB
    * @param {object} options
    * @param {string} options.baseURL
    * @return {Promise}
    */
   init(AB, options) {
      this.AB = AB;

      Config = this.AB.Config.siteConfig();
      options = options || {};
      if (options) {
         this.baseURL = options.baseURL || Config.appbuilder.urlCoreServer;
         this.numRetries =
            options.networkNumRetries || Config.appbuilder.networkNumRetries;
      }
      return Promise.resolve();
   }

   //
   // Interface API
   //
   /**
    * Network.get(options, jobResponse)
    * perform a GET request back to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   get(params, jobResponse) {
      params.type = params.type || "GET";

      // data sent to params on a "GET" request need to be converted to
      // uri querystring values:
      var data = params.data || params.params;
      if (data) {
         var useThese = ["string", "number", "boolean"];
         var search = Object.keys(data)
            .map(function (key) {
               var val = data[key];
               if (useThese.indexOf(typeof val) == -1) {
                  val = JSON.stringify(val);
               }
               return key + "=" + encodeURIComponent(val);
            })
            .join("&");

         var join = "?";
         if (params.url.indexOf("?") > -1) {
            join = "&";
         }
         params.url = [params.url, search].join(join);
      }

      return this._request(params, jobResponse);
   }

   /**
    * Network.post()
    * perform an AJAX POST request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   post(params, jobResponse) {
      params.type = params.type || "POST";
      return this._request(params, jobResponse);
   }

   /**
    * Network.put()
    * perform a PUT request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   put(params, jobResponse) {
      params.type = params.type || "PUT";
      return this._request(params, jobResponse);
   }

   /**
    * Network.delete()
    * perform an AJAX DELETE request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   delete(params, jobResponse) {
      params.type = params.type || "DELETE";
      return this._request(params, jobResponse);
   }

   ////
   //// Network Utilities
   ////

   isNetworkConnected() {
      return this._network.isNetworkConnected();
   }

   salSend(params) {
      return Window.atomic(params.url, params).then((packet) => {
         // {json} packet
         // the response from Atomic is in format:
         // {data: {}, xhr: XMLHttpRequest}
         // we just want to send back our { status:"", data:xxx } packet.
         return packet.data;
      });
   }

   /**
    * _request()
    * perform the actual AJAX request for this operation.
    * @param {obj} params  the jQuery.ajax() formatted params
    * @param {obj} jobRequest  the information about the request's response.
    * @return {Promise}
    */
   _request(params, jobResponse) {
      // make sure we don't process too many retries:
      params._retry = params._retry || 0;
      if (params._retry >= this.numRetries) {
         var err = new Error(
            `Too many retries (${this.numRetries}) for ${params.url}`
         );
         err.code = "E_TOMANYRETRIES";
         this.AB.notify.developer(err, {
            context: "NetworkRest:_request: Too Many Retries",
         });
         // this.AB.Analytics.logError(err);
         if (jobResponse) {
            this._network.publishResponse(jobResponse, err);
         }

         return Promise.reject(err);
      }

      return new Promise((resolve, reject) => {
         params.withCredentials = true;
         params.url = params.url || "/";
         if (params.url[0] == "/") {
            params.url = this.baseURL + params.url;
         }

         params.data = params.data || params.params;
         delete params.params;

         params.headers = params.headers || {};
         if (this.AB.Account.authToken) {
            params.headers.Authorization = this.AB.Account.authToken;
         }
         // Fix: don't set content-type if passed in data is a FormData object.
         if (
            Object.prototype.toString.call(params.data) !== "[object FormData]"
         ) {
            params.headers["Content-type"] = "application/json";
         }

         var tenantID = this.AB.Tenant.id();
         if (tenantID) {
            params.headers["tenant-token"] = tenantID;
         }

         // params.timeout = params.timeout || 6000;

         if (this.isNetworkConnected()) {
            params.method = params.method || params.type;
            params.timeout = 6000; // ??

            // if params.data is a FormData object, don't set Content-type
            if (
               Object.prototype.toString.call(params.data) ===
               "[object FormData]"
            ) {
               Object.keys(params.headers).forEach((k) => {
                  if (k.toUpperCase() == "CONTENT-TYPE") {
                     delete params.headers[k];
                  }
               });
            }

            this.salSend(params)
               .then((packet) => {
                  // TODO: check if packet.status == "error"
                  // and then .publishResponse() as an error

                  //
                  var data = packet;
                  if (jobResponse) {
                     this._network.publishResponse(jobResponse, null, data);
                  }
                  resolve(data);
               })
               .catch((err) => {
                  // err.status
                  // err.statusText
                  // err.responseText
                  // err.message  {socket}
                  // err.stack    {socket}

                  // if this is a network connection error, send the attempt again:
                  if (
                     err.statusText == "Request timeout" ||
                     (err.message && err.message.indexOf("disconnected") > -1)
                  ) {
                     //// Network Error: conneciton refused, access denied, etc...
                     this.AB.Analytics.log(
                        "NetworkRest._request():network connection error detected. Trying again"
                     );

                     params._retry++;

                     // retry the attempt:
                     this._request(params)
                        .then((data) => {
                           // console.log('--- timeout.then():',data);
                           this.AB.warn(
                              "*** NetworkRest._request().then(): attempt resolved."
                           );
                           resolve(data);
                        })
                        .catch((_err) => {
                           this.AB.notify.developer(_err, {
                              message:
                                 "*** NetworkRest._request().catch(): retry failed:",
                           });
                           reject(_err);
                        });

                     return;
                  } else {
                     // Else attempt to emit() some common Error types for
                     // additional Platform Handling.
                     if (err.status == 403) {
                        this.emit("error.badAuth", err);
                     } else if (err.status >= 400 && err.status < 500) {
                        this.emit("error.badRequest", err);
                     } else if (err.status >= 500) {
                        this.emit("error.badServer", err);
                     }
                  }

                  var packet = null;
                  if (err.responseText) {
                     try {
                        packet = JSON.parse(err.responseText);
                     } catch (e) {}
                  }
                  // if this is an req.ab.error() response:
                  if (packet && packet.status == "error") {
                     // check if REAUTH Error:
                     if (packet.id == 5 || packet.code == "E_REAUTH") {
                        this._network.emit("reauth");
                        return;
                     }

                     this.AB.notify.developer(packet, {
                        context:
                           "NetworkRest:_request:Error returned from Server (req.ab.error())",
                        data: packet.data,
                        message: packet.message,
                     });
                     // this.AB.Analytics.logError(packet.data);
                     // this.AB.error(packet.data);
                     if (jobResponse) {
                        this._network.publishResponse(
                           jobResponse,
                           packet,
                           null
                        );
                     }
                     let error = new Error(packet.message ?? packet.data);
                     error.response = packet;
                     error.text = packet.message;
                     error.url = `${params.method} ${params.url}`;
                     return reject(error);
                  } else {
                     // unknown/unexpected error:
                     let error = new Error(
                        `${err.status} ${err.statusText || err.message}: ${
                           params.method
                        } ${params.url}`
                     );
                     error.response = err.responseText;
                     error.text = err.statusText;
                     error.err = err;
                     error.url = `${params.method} ${params.url}`;
                     this.AB.notify.developer(error, {
                        context:
                           "NetworkRest:_request:Unknown Error returned from server",
                     });
                     // this.AB.Analytics.logError(error);
                     // this.AB.error(error);
                     if (jobResponse) {
                        this._network.publishResponse(jobResponse, error);
                     }
                     return reject(error);
                  }
               });
         } else {
            // now Queue this request params.
            this.AB.Analytics.log(
               "NetworkRest:_request(): Network is offline. Queuing request."
            );
            this._network
               .queue(params, jobResponse)
               .then(() => {
                  resolve({ status: "queued" });
               })
               .catch(reject);
         }
      });
   }

   /**
    * resend()
    * processes messages that were queued due to network connectivity
    * issues.
    * @param {obj} params  the jQuery.ajax() formatted params
    * @param {obj} jobRequest  the information about the request's response.
    * @return {Promise}
    */
   resend(params, jobResponse) {
      // var op = params.type.toLowerCase();
      return this._request(params, jobResponse);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NetworkRest);


/***/ }),

/***/ 27299:
/*!***********************************************!*\
  !*** ./src/js/resources/NetworkRestSocket.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _NetworkRest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NetworkRest */ 84292);
/*
 * NetworkRest.js
 * The base Networking class.  This class is responsible for job submissions
 * and outlines the basic Network interface.
 */



const listSocketEvents = [
   // NOTE: ABFactory.definitionXXX() will manage emitting these
   // events internally:
   // "ab.abdefinition.create",
   // "ab.abdefinition.update",
   // "ab.abdefinition.delete",
   "ab.datacollection.create",
   "ab.datacollection.update",
   "ab.datacollection.stale",
   "ab.datacollection.delete",
   "ab.inbox.create",
   "ab.inbox.update",
   // "ab.object.update",
];
// {array}
// The io.socket.* events we are listening for that relate to our datacollection
// maintainence.

class NetworkRestSocket extends _NetworkRest__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(parent) {
      // {Network} parent

      super(parent);

      this.isRealTime = true;
      // {bool}
      // does this Network type support RealTime updates. (socket = true);

      // Pass the io.socket.on(*) events to our AB factory.
      listSocketEvents.forEach((ev) => {
         io.socket.on(ev, (data) => {
            // data should be in the format:
            // {
            //    objectId: {uuid},
            //    data: {object}
            // }

            // check if the ev contains 'datacollection'
            // and do a single normalizeData() on the incoming data here
            // before sending it off to be processed.
            if (ev.indexOf("ab.datacollection") > -1) {
               let values = data.data;
               if (values) {
                  let obj = this.AB.objectByID(data.objectId);
                  if (obj) {
                     let model = obj.model();
                     if (ev != "ab.datacollection.delete") {
                        // if data is packed, then unpack it
                        let model = obj.model();
                        if (model.isCsvPacked(values)) {
                           let lengthPacked = JSON.stringify(data).length;
                           values = model.csvUnpack(values);
                           data.data = values.data;
                           let lengthUnpacked = JSON.stringify(data).length;
                           data.__length = lengthUnpacked;
                           data.__lengthPacked = lengthPacked;
                           console.log(
                              `CSV Pack: ${lengthUnpacked} -> ${lengthPacked} (${(
                                 (lengthPacked / lengthUnpacked) *
                                 100
                              ).toFixed(2)}%)`
                           );
                        }

                        let jobID = this.AB.jobID();
                        console.log(`${jobID} : ${ev}:normalization begin`);
                        let timeFrom = performance.now();
                        model.normalizeData(data.data);
                        let timeTo = performance.now();
                        console.log(
                           `${jobID} : ${ev}:normalization end:  ${
                              timeTo - timeFrom
                           }ms`
                        );
                     }
                  }
               }
            }
            this.AB.emit(ev, data);
         });
      });
   }

   //
   // Interface API
   //

   ////
   //// Network Utilities
   ////

   isNetworkConnected() {
      return io.socket.isConnected();
   }

   salSend(params) {
      return new Promise((resolve, reject) => {
         params.method = params.method.toLowerCase();

         io.socket.request(params, (data, jwres) => {
            // {json} data
            // the data response from the request
            // {json} jwres
            // A JSON WebSocket Response object.
            //    {json} jwres.headers :  header values
            //    {int}  jwres.statusCode : http response code
            //    {json} jwres.body === resData

            // if this is an  error
            if (jwres.statusCode >= 400) {
               // Our NetworkRest.error( err ) should be in this format:
               // err.status
               // err.statusText
               // err.responseText

               var errStr = jwres.error ? jwres.error.toString() : jwres.body;

               var err = new Error(`Socket Error: ${errStr}`);
               err.status = jwres.statusCode;
               err.statusText = errStr;
               err.responseText = jwres.body;

               // on RequestTimeout:
               // err.statusText == "Request timeout"

               reject(err);
            } else {
               // some errors like socket disconnected return an Error for data
               if (data instanceof Error) {
                  reject(data);
                  return;
               }

               if (typeof data == "string") {
                  data = JSON.parse(data);
               }

               // Got a JSON response but was the service response an error?
               // this would be a strange case where the .statusCode < 400
               if (data.status && data.status == "error") {
                  // make sure to reject an err.responseText = data
                  reject({
                     status: jwres.statusCode,
                     responseText: JSON.Stringify(data),
                  });
               }
               // Success!
               else {
                  resolve(data);
               }
            }
         });
      });
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NetworkRestSocket);


/***/ }),

/***/ 35397:
/*!*************************************!*\
  !*** ./src/js/resources/Storage.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
/* harmony import */ var _StorageLocal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StorageLocal.js */ 20813);




class Storage extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super();

      this.tenantStorage = null;
      this._config = null;
      this._storage = null;
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      var config = this.AB.Config.siteConfig();
      if (config) {
         if (config.storage && config.storage.encrypted) {
            console.error("TODO: Implement Encrypted Storage");
            // this._storage = StorageEncrypted;
            this._storage = _StorageLocal_js__WEBPACK_IMPORTED_MODULE_1__["default"];
         } else {
            this._storage = _StorageLocal_js__WEBPACK_IMPORTED_MODULE_1__["default"];
         }

         return this._storage.init(AB);
      } else {
         console.error("??? Why No site config ???");
      }

      return Promise.resolve();
   }

   set(...params) {
      return this._storage.set(...params);
   }

   get(...params) {
      return this._storage.get(...params);
   }

   clear(...params) {
      return this._storage.clear(...params);
   }

   clearAll(...params) {
      return this._storage.clearAll(...params);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Storage());


/***/ }),

/***/ 20813:
/*!******************************************!*\
  !*** ./src/js/resources/StorageLocal.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
/*
 * StorageLocal
 *
 * An interface for storing and retrieving Client Side data.  Data stored
 * in StorageLoacal is NOT encrypted.
 *
 * This implementation is based upon the webix.storage.local library.
 * See: https://docs.webix.com/api__refs__storage.local.html
 *
 */



class StorageLocal extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super();

      this.tenantStorage = null;
      // {Webix.storage} object.
      // We divide the storage data according to the tenant we are working
      // with.  This way Users who can move between different Tenants can
      // keep their local data separated.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      this.tenantID = this.AB.Tenant.id();
      if (!this.tenantID) {
         this.tenantID = "noAuth";
         // "noAuth" is considered the tenant on our Login sequence
         // which should have a minimum of data stored (language maybe?)
      }

      this.tenantStorage = JSON.parse(
         window.localStorage.getItem(this.tenantID) || "{}"
      );

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   _save() {
      return Promise.resolve(
         localStorage.setItem(this.tenantID, JSON.stringify(this.tenantStorage))
      );
   }

   set(key, value /* , options = {} */) {
      return Promise.resolve().then(() => {
         this.tenantStorage[key] = value;
         return this._save();
      });
   }

   get(key /*, options = {} */) {
      return Promise.resolve().then(() => {
         return this.tenantStorage[key];
      });
   }

   clear(key) {
      return Promise.resolve().then(() => {
         delete this.tenantStorage[key];
         return this._save();
      });
   }

   clearAll() {
      return Promise.resolve().then(() => {
         this.tenantStorage = {};
         return this._save();
      });
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new StorageLocal());


/***/ }),

/***/ 75342:
/*!************************************!*\
  !*** ./src/js/resources/Tenant.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
/* harmony import */ var _Config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Config.js */ 77269);



class Tenant extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super();

      this.text = false;
      this._config = null;
      this.textClickToEnter = null;
   }

   init() {
      var config = _Config_js__WEBPACK_IMPORTED_MODULE_1__["default"].tenantConfig();
      if (config) {
         // check if we have options that are stored as a string
         if (
            typeof config.options === "string" ||
            config.options instanceof String
         ) {
            // if we do try to parse them into a JSON object
            try {
               config.options = JSON.parse(config.options);
            } catch (error) {
               console.error(error);
            }
         }
         this._config = config;
         this.textClickToEnter = config.options.textClickToEnter;
      }

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   id() {
      if (!this._config || this._config.id == "??") {
         return _Config_js__WEBPACK_IMPORTED_MODULE_1__["default"].setting("tenant");
      }
      return this._config.id;
   }

   setting(key, value) {
      if (this._config) {
         if (value) {
            this._config.options[key] = value;
            return;
         }
         return this._config.options[key];
      }
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Tenant());


/***/ }),

/***/ 43183:
/*!**************************!*\
  !*** ./src/js/routes.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pages_404_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pages/404.f7.jsx */ 22167);
/* harmony import */ var _pages_form_f7_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pages/form.f7.jsx */ 84723);
/* harmony import */ var _pages_home_f7_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pages/home.f7.jsx */ 59289);
/* harmony import */ var _pages_list_f7_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pages/list.f7.jsx */ 42767);





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((AB) => {
   const Application = AB.applications()[0]; // AB.applicationByID("4b7a489a-5fe5-4044-8565-aaa3654300f2");

   AB.isInitialized = false;

   AB.Network.on("reauth", () => {
      AB.isInitialized = false;
      AB.$f7.loginScreen.open("#my-login-screen");
   });

   const routes = [
      {
         path: "/",
         component: (0,_pages_home_f7_jsx__WEBPACK_IMPORTED_MODULE_2__["default"])(AB),
      },
      // These (/form and /list) are temporary reference pages we are using
      // in our design. These should be removed after we have our Pages &
      // Widgets up and working:
      {
         path: "/form",
         component: (0,_pages_form_f7_jsx__WEBPACK_IMPORTED_MODULE_1__["default"])(AB),
      },
      {
         path: "/list",
         component: (0,_pages_list_f7_jsx__WEBPACK_IMPORTED_MODULE_3__["default"])(AB),
      },
   ];

   if (!AB.Account.isAuthenticated) return routes;

   // build our Tabs:
   // NOTE: we build links only for the Root level Tabs
   let pagesTabsRoot = Application.pages((p) => p.menuType == "tab");
   if (pagesTabsRoot.length > 0) {
      let tabRoute = {
         path: "/tabs/",
         content: "",
         tabs: [],
      };

      let content = `<div class="page">
<!--
  <div class="navbar">
    <div class="navbar-bg"></div>
    <div class="navbar-inner">
                      <div class="left">
                     <a
                        href="#"
                        data-panel=".panel-left"
                        class="link icon-only panel-open"
                     >
                        <i class="icon material-icons">menu</i>
                     </a>
                  </div>
      <div class="title">Routable Tabs</div>
    </div>
  </div>
-->
  <div class="toolbar tabbar toolbar-bottom">
    <div class="toolbar-inner">`;

      // <!-- additional "data-route-tab-id" must match to tab's ID in the specified routes -->
      pagesTabsRoot.forEach((p) => {
         content += `<a href="/tabs/${p.route}" class="tab-link" data-route-tab-id="${p.route}">${p.name}</a>`;
      });

      content += `</div>
  </div>
  <!-- Additional "tabs-routable" is required on tabs -->
  <div class="tabs tabs-routable">`;

      // Make sure ALL tabs have a defined content <div>
      let pagesTabsAll = Application.pages((p) => p.menuType == "tab", true);

      pagesTabsAll.forEach((p) => {
         content += `<div class="tab page-content" id="${p.route}">${p.name}</div>`;
         tabRoute.tabs.push(p.routeComponent());
      });

      content += `
  </div>
</div>`;

      tabRoute.content = content;

      routes.push(tabRoute);
   }

   const listPages = Application.pages((p) => p.menuType == "menu", true);

   listPages.forEach((Page) => {
      routes.push(Page.routeComponent());
   });

   // Now add the final NotFoundPage for all other references:
   routes.push({
      path: "(.*)",
      component: (0,_pages_404_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"])(AB),
   });

   return routes;
});


/***/ }),

/***/ 55730:
/*!****************************!*\
  !*** ./src/js/sails.io.js ***!
  \****************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable */

/**
 * To use sails.io.js in an AMD environment (e.g. with require.js),
 * replace this file with the sails.io.js file from the root of:
 * https://github.com/balderdashy/sails.io.js
 * and download a standalone copy of socket.io-client from:
 * https://github.com/socketio/socket.io-client
 * then follow the instructions at:
 * https://github.com/balderdashy/sails.io.js#requirejsamd-usage
 */

// socket.io-client version 2.0.3
// https://github.com/socketio/socket.io-client

!(function(a, b) {
   true
    ? (module.exports = b())
    : 0;
})(this, function() {
  return (function(a) {
    function b(d) {
      if (c[d]) return c[d].exports;
      var e = (c[d] = { exports: {}, id: d, loaded: !1 });
      return a[d].call(e.exports, e, e.exports, b), (e.loaded = !0), e.exports;
    }
    var c = {};
    return (b.m = a), (b.c = c), (b.p = ""), b(0);
  })([
    function(a, b, c) {
      "use strict";
      function d(a, b) {
        "object" === ("undefined" == typeof a ? "undefined" : e(a)) &&
          ((b = a), (a = void 0)),
          (b = b || {});
        var c,
          d = f(a),
          g = d.source,
          k = d.id,
          l = d.path,
          m = j[k] && l in j[k].nsps,
          n =
            b.forceNew || b["force new connection"] || !1 === b.multiplex || m;
        return (
          n
            ? (i("ignoring socket cache for %s", g), (c = h(g, b)))
            : (j[k] || (i("new io instance for %s", g), (j[k] = h(g, b))),
              (c = j[k])),
          d.query && !b.query && (b.query = d.query),
          c.socket(d.path, b)
        );
      }
      var e =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function(a) {
                return typeof a;
              }
            : function(a) {
                return a &&
                  "function" == typeof Symbol &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a;
              },
        f = c(1),
        g = c(7),
        h = c(13),
        i = c(3)("socket.io-client");
      a.exports = b = d;
      var j = (b.managers = {});
      (b.protocol = g.protocol),
        (b.connect = d),
        (b.Manager = c(13)),
        (b.Socket = c(39));
    },
    function(a, b, c) {
      (function(b) {
        "use strict";
        function d(a, c) {
          var d = a;
          (c = c || b.location),
            null == a && (a = c.protocol + "//" + c.host),
            "string" == typeof a &&
              ("/" === a.charAt(0) &&
                (a = "/" === a.charAt(1) ? c.protocol + a : c.host + a),
              /^(https?|wss?):\/\//.test(a) ||
                (f("protocol-less url %s", a),
                (a =
                  "undefined" != typeof c
                    ? c.protocol + "//" + a
                    : "https://" + a)),
              f("parse %s", a),
              (d = e(a))),
            d.port ||
              (/^(http|ws)$/.test(d.protocol)
                ? (d.port = "80")
                : /^(http|ws)s$/.test(d.protocol) && (d.port = "443")),
            (d.path = d.path || "/");
          var g = d.host.indexOf(":") !== -1,
            h = g ? "[" + d.host + "]" : d.host;
          return (
            (d.id = d.protocol + "://" + h + ":" + d.port),
            (d.href =
              d.protocol +
              "://" +
              h +
              (c && c.port === d.port ? "" : ":" + d.port)),
            d
          );
        }
        var e = c(2),
          f = c(3)("socket.io-client:url");
        a.exports = d;
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      var c = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
        d = [
          "source",
          "protocol",
          "authority",
          "userInfo",
          "user",
          "password",
          "host",
          "port",
          "relative",
          "path",
          "directory",
          "file",
          "query",
          "anchor"
        ];
      a.exports = function(a) {
        var b = a,
          e = a.indexOf("["),
          f = a.indexOf("]");
        e != -1 &&
          f != -1 &&
          (a =
            a.substring(0, e) +
            a.substring(e, f).replace(/:/g, ";") +
            a.substring(f, a.length));
        for (var g = c.exec(a || ""), h = {}, i = 14; i--; )
          h[d[i]] = g[i] || "";
        return (
          e != -1 &&
            f != -1 &&
            ((h.source = b),
            (h.host = h.host
              .substring(1, h.host.length - 1)
              .replace(/;/g, ":")),
            (h.authority = h.authority
              .replace("[", "")
              .replace("]", "")
              .replace(/;/g, ":")),
            (h.ipv6uri = !0)),
          h
        );
      };
    },
    function(a, b, c) {
      (function(d) {
        function e() {
          return (
            !(
              "undefined" == typeof window ||
              !window.process ||
              "renderer" !== window.process.type
            ) ||
            ("undefined" != typeof document &&
              document.documentElement &&
              document.documentElement.style &&
              document.documentElement.style.WebkitAppearance) ||
            ("undefined" != typeof window &&
              window.console &&
              (window.console.firebug ||
                (window.console.exception && window.console.table))) ||
            ("undefined" != typeof navigator &&
              navigator.userAgent &&
              navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
              parseInt(RegExp.$1, 10) >= 31) ||
            ("undefined" != typeof navigator &&
              navigator.userAgent &&
              navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
          );
        }
        function f(a) {
          var c = this.useColors;
          if (
            ((a[0] =
              (c ? "%c" : "") +
              this.namespace +
              (c ? " %c" : " ") +
              a[0] +
              (c ? "%c " : " ") +
              "+" +
              b.humanize(this.diff)),
            c)
          ) {
            var d = "color: " + this.color;
            a.splice(1, 0, d, "color: inherit");
            var e = 0,
              f = 0;
            a[0].replace(/%[a-zA-Z%]/g, function(a) {
              "%%" !== a && (e++, "%c" === a && (f = e));
            }),
              a.splice(f, 0, d);
          }
        }
        function g() {
          return (
            "object" == typeof console &&
            console.log &&
            Function.prototype.apply.call(console.log, console, arguments)
          );
        }
        function h(a) {
          try {
            null == a ? b.storage.removeItem("debug") : (b.storage.debug = a);
          } catch (c) {}
        }
        function i() {
          var a;
          try {
            a = b.storage.debug;
          } catch (c) {}
          return (
            !a && "undefined" != typeof d && "env" in d && (a = d.env.DEBUG), a
          );
        }
        function j() {
          try {
            return window.localStorage;
          } catch (a) {}
        }
        (b = a.exports = c(5)),
          (b.log = g),
          (b.formatArgs = f),
          (b.save = h),
          (b.load = i),
          (b.useColors = e),
          (b.storage =
            "undefined" != typeof chrome && "undefined" != typeof chrome.storage
              ? chrome.storage.local
              : j()),
          (b.colors = [
            "lightseagreen",
            "forestgreen",
            "goldenrod",
            "dodgerblue",
            "darkorchid",
            "crimson"
          ]),
          (b.formatters.j = function(a) {
            try {
              return JSON.stringify(a);
            } catch (b) {
              return "[UnexpectedJSONParseError]: " + b.message;
            }
          }),
          b.enable(i());
      }.call(b, c(4)));
    },
    function(a, b) {
      function c() {
        throw new Error("setTimeout has not been defined");
      }
      function d() {
        throw new Error("clearTimeout has not been defined");
      }
      function e(a) {
        if (k === setTimeout) return setTimeout(a, 0);
        if ((k === c || !k) && setTimeout)
          return (k = setTimeout), setTimeout(a, 0);
        try {
          return k(a, 0);
        } catch (b) {
          try {
            return k.call(null, a, 0);
          } catch (b) {
            return k.call(this, a, 0);
          }
        }
      }
      function f(a) {
        if (l === clearTimeout) return clearTimeout(a);
        if ((l === d || !l) && clearTimeout)
          return (l = clearTimeout), clearTimeout(a);
        try {
          return l(a);
        } catch (b) {
          try {
            return l.call(null, a);
          } catch (b) {
            return l.call(this, a);
          }
        }
      }
      function g() {
        p &&
          n &&
          ((p = !1), n.length ? (o = n.concat(o)) : (q = -1), o.length && h());
      }
      function h() {
        if (!p) {
          var a = e(g);
          p = !0;
          for (var b = o.length; b; ) {
            for (n = o, o = []; ++q < b; ) n && n[q].run();
            (q = -1), (b = o.length);
          }
          (n = null), (p = !1), f(a);
        }
      }
      function i(a, b) {
        (this.fun = a), (this.array = b);
      }
      function j() {}
      var k,
        l,
        m = (a.exports = {});
      !(function() {
        try {
          k = "function" == typeof setTimeout ? setTimeout : c;
        } catch (a) {
          k = c;
        }
        try {
          l = "function" == typeof clearTimeout ? clearTimeout : d;
        } catch (a) {
          l = d;
        }
      })();
      var n,
        o = [],
        p = !1,
        q = -1;
      (m.nextTick = function(a) {
        var b = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];
        o.push(new i(a, b)), 1 !== o.length || p || e(h);
      }),
        (i.prototype.run = function() {
          this.fun.apply(null, this.array);
        }),
        (m.title = "browser"),
        (m.browser = !0),
        (m.env = {}),
        (m.argv = []),
        (m.version = ""),
        (m.versions = {}),
        (m.on = j),
        (m.addListener = j),
        (m.once = j),
        (m.off = j),
        (m.removeListener = j),
        (m.removeAllListeners = j),
        (m.emit = j),
        (m.prependListener = j),
        (m.prependOnceListener = j),
        (m.listeners = function(a) {
          return [];
        }),
        (m.binding = function(a) {
          throw new Error("process.binding is not supported");
        }),
        (m.cwd = function() {
          return "/";
        }),
        (m.chdir = function(a) {
          throw new Error("process.chdir is not supported");
        }),
        (m.umask = function() {
          return 0;
        });
    },
    function(a, b, c) {
      function d(a) {
        var c,
          d = 0;
        for (c in a) (d = (d << 5) - d + a.charCodeAt(c)), (d |= 0);
        return b.colors[Math.abs(d) % b.colors.length];
      }
      function e(a) {
        function c() {
          if (c.enabled) {
            var a = c,
              d = +new Date(),
              e = d - (j || d);
            (a.diff = e), (a.prev = j), (a.curr = d), (j = d);
            for (var f = new Array(arguments.length), g = 0; g < f.length; g++)
              f[g] = arguments[g];
            (f[0] = b.coerce(f[0])), "string" != typeof f[0] && f.unshift("%O");
            var h = 0;
            (f[0] = f[0].replace(/%([a-zA-Z%])/g, function(c, d) {
              if ("%%" === c) return c;
              h++;
              var e = b.formatters[d];
              if ("function" == typeof e) {
                var g = f[h];
                (c = e.call(a, g)), f.splice(h, 1), h--;
              }
              return c;
            })),
              b.formatArgs.call(a, f);
            var i = c.log || b.log || console.log.bind(console);
            i.apply(a, f);
          }
        }
        return (
          (c.namespace = a),
          (c.enabled = b.enabled(a)),
          (c.useColors = b.useColors()),
          (c.color = d(a)),
          "function" == typeof b.init && b.init(c),
          c
        );
      }
      function f(a) {
        b.save(a), (b.names = []), (b.skips = []);
        for (
          var c = ("string" == typeof a ? a : "").split(/[\s,]+/),
            d = c.length,
            e = 0;
          e < d;
          e++
        )
          c[e] &&
            ((a = c[e].replace(/\*/g, ".*?")),
            "-" === a[0]
              ? b.skips.push(new RegExp("^" + a.substr(1) + "$"))
              : b.names.push(new RegExp("^" + a + "$")));
      }
      function g() {
        b.enable("");
      }
      function h(a) {
        var c, d;
        for (c = 0, d = b.skips.length; c < d; c++)
          if (b.skips[c].test(a)) return !1;
        for (c = 0, d = b.names.length; c < d; c++)
          if (b.names[c].test(a)) return !0;
        return !1;
      }
      function i(a) {
        return a instanceof Error ? a.stack || a.message : a;
      }
      (b = a.exports = e.debug = e["default"] = e),
        (b.coerce = i),
        (b.disable = g),
        (b.enable = f),
        (b.enabled = h),
        (b.humanize = c(6)),
        (b.names = []),
        (b.skips = []),
        (b.formatters = {});
      var j;
    },
    function(a, b) {
      function c(a) {
        if (((a = String(a)), !(a.length > 100))) {
          var b = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
            a
          );
          if (b) {
            var c = parseFloat(b[1]),
              d = (b[2] || "ms").toLowerCase();
            switch (d) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return c * k;
              case "days":
              case "day":
              case "d":
                return c * j;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return c * i;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return c * h;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return c * g;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return c;
              default:
                return;
            }
          }
        }
      }
      function d(a) {
        return a >= j
          ? Math.round(a / j) + "d"
          : a >= i
          ? Math.round(a / i) + "h"
          : a >= h
          ? Math.round(a / h) + "m"
          : a >= g
          ? Math.round(a / g) + "s"
          : a + "ms";
      }
      function e(a) {
        return (
          f(a, j, "day") ||
          f(a, i, "hour") ||
          f(a, h, "minute") ||
          f(a, g, "second") ||
          a + " ms"
        );
      }
      function f(a, b, c) {
        if (!(a < b))
          return a < 1.5 * b
            ? Math.floor(a / b) + " " + c
            : Math.ceil(a / b) + " " + c + "s";
      }
      var g = 1e3,
        h = 60 * g,
        i = 60 * h,
        j = 24 * i,
        k = 365.25 * j;
      a.exports = function(a, b) {
        b = b || {};
        var f = typeof a;
        if ("string" === f && a.length > 0) return c(a);
        if ("number" === f && isNaN(a) === !1) return b["long"] ? e(a) : d(a);
        throw new Error(
          "val is not a non-empty string or a valid number. val=" +
            JSON.stringify(a)
        );
      };
    },
    function(a, b, c) {
      function d() {}
      function e(a) {
        var c = "" + a.type;
        return (
          (b.BINARY_EVENT !== a.type && b.BINARY_ACK !== a.type) ||
            (c += a.attachments + "-"),
          a.nsp && "/" !== a.nsp && (c += a.nsp + ","),
          null != a.id && (c += a.id),
          null != a.data && (c += JSON.stringify(a.data)),
          l("encoded %j as %s", a, c),
          c
        );
      }
      function f(a, b) {
        function c(a) {
          var c = o.deconstructPacket(a),
            d = e(c.packet),
            f = c.buffers;
          f.unshift(d), b(f);
        }
        o.removeBlobs(a, c);
      }
      function g() {
        this.reconstructor = null;
      }
      function h(a) {
        var c = 0,
          d = { type: Number(a.charAt(0)) };
        if (null == b.types[d.type]) return k();
        if (b.BINARY_EVENT === d.type || b.BINARY_ACK === d.type) {
          for (
            var e = "";
            "-" !== a.charAt(++c) && ((e += a.charAt(c)), c != a.length);

          );
          if (e != Number(e) || "-" !== a.charAt(c))
            throw new Error("Illegal attachments");
          d.attachments = Number(e);
        }
        if ("/" === a.charAt(c + 1))
          for (d.nsp = ""; ++c; ) {
            var f = a.charAt(c);
            if ("," === f) break;
            if (((d.nsp += f), c === a.length)) break;
          }
        else d.nsp = "/";
        var g = a.charAt(c + 1);
        if ("" !== g && Number(g) == g) {
          for (d.id = ""; ++c; ) {
            var f = a.charAt(c);
            if (null == f || Number(f) != f) {
              --c;
              break;
            }
            if (((d.id += a.charAt(c)), c === a.length)) break;
          }
          d.id = Number(d.id);
        }
        return (
          a.charAt(++c) && (d = i(d, a.substr(c))),
          l("decoded %s as %j", a, d),
          d
        );
      }
      function i(a, b) {
        try {
          a.data = JSON.parse(b);
        } catch (c) {
          return k();
        }
        return a;
      }
      function j(a) {
        (this.reconPack = a), (this.buffers = []);
      }
      function k() {
        return { type: b.ERROR, data: "parser error" };
      }
      var l = c(3)("socket.io-parser"),
        m = c(8),
        n = c(9),
        o = c(11),
        p = c(12);
      (b.protocol = 4),
        (b.types = [
          "CONNECT",
          "DISCONNECT",
          "EVENT",
          "ACK",
          "ERROR",
          "BINARY_EVENT",
          "BINARY_ACK"
        ]),
        (b.CONNECT = 0),
        (b.DISCONNECT = 1),
        (b.EVENT = 2),
        (b.ACK = 3),
        (b.ERROR = 4),
        (b.BINARY_EVENT = 5),
        (b.BINARY_ACK = 6),
        (b.Encoder = d),
        (b.Decoder = g),
        (d.prototype.encode = function(a, c) {
          if (
            ((a.type !== b.EVENT && a.type !== b.ACK) ||
              !n(a.data) ||
              (a.type = a.type === b.EVENT ? b.BINARY_EVENT : b.BINARY_ACK),
            l("encoding packet %j", a),
            b.BINARY_EVENT === a.type || b.BINARY_ACK === a.type)
          )
            f(a, c);
          else {
            var d = e(a);
            c([d]);
          }
        }),
        m(g.prototype),
        (g.prototype.add = function(a) {
          var c;
          if ("string" == typeof a)
            (c = h(a)),
              b.BINARY_EVENT === c.type || b.BINARY_ACK === c.type
                ? ((this.reconstructor = new j(c)),
                  0 === this.reconstructor.reconPack.attachments &&
                    this.emit("decoded", c))
                : this.emit("decoded", c);
          else {
            if (!p(a) && !a.base64) throw new Error("Unknown type: " + a);
            if (!this.reconstructor)
              throw new Error(
                "got binary data when not reconstructing a packet"
              );
            (c = this.reconstructor.takeBinaryData(a)),
              c && ((this.reconstructor = null), this.emit("decoded", c));
          }
        }),
        (g.prototype.destroy = function() {
          this.reconstructor && this.reconstructor.finishedReconstruction();
        }),
        (j.prototype.takeBinaryData = function(a) {
          if (
            (this.buffers.push(a),
            this.buffers.length === this.reconPack.attachments)
          ) {
            var b = o.reconstructPacket(this.reconPack, this.buffers);
            return this.finishedReconstruction(), b;
          }
          return null;
        }),
        (j.prototype.finishedReconstruction = function() {
          (this.reconPack = null), (this.buffers = []);
        });
    },
    function(a, b, c) {
      function d(a) {
        if (a) return e(a);
      }
      function e(a) {
        for (var b in d.prototype) a[b] = d.prototype[b];
        return a;
      }
      (a.exports = d),
        (d.prototype.on = d.prototype.addEventListener = function(a, b) {
          return (
            (this._callbacks = this._callbacks || {}),
            (this._callbacks["$" + a] = this._callbacks["$" + a] || []).push(b),
            this
          );
        }),
        (d.prototype.once = function(a, b) {
          function c() {
            this.off(a, c), b.apply(this, arguments);
          }
          return (c.fn = b), this.on(a, c), this;
        }),
        (d.prototype.off = d.prototype.removeListener = d.prototype.removeAllListeners = d.prototype.removeEventListener = function(
          a,
          b
        ) {
          if (
            ((this._callbacks = this._callbacks || {}), 0 == arguments.length)
          )
            return (this._callbacks = {}), this;
          var c = this._callbacks["$" + a];
          if (!c) return this;
          if (1 == arguments.length)
            return delete this._callbacks["$" + a], this;
          for (var d, e = 0; e < c.length; e++)
            if (((d = c[e]), d === b || d.fn === b)) {
              c.splice(e, 1);
              break;
            }
          return this;
        }),
        (d.prototype.emit = function(a) {
          this._callbacks = this._callbacks || {};
          var b = [].slice.call(arguments, 1),
            c = this._callbacks["$" + a];
          if (c) {
            c = c.slice(0);
            for (var d = 0, e = c.length; d < e; ++d) c[d].apply(this, b);
          }
          return this;
        }),
        (d.prototype.listeners = function(a) {
          return (
            (this._callbacks = this._callbacks || {}),
            this._callbacks["$" + a] || []
          );
        }),
        (d.prototype.hasListeners = function(a) {
          return !!this.listeners(a).length;
        });
    },
    function(a, b, c) {
      (function(b) {
        function d(a) {
          if (!a || "object" != typeof a) return !1;
          if (e(a)) {
            for (var c = 0, f = a.length; c < f; c++) if (d(a[c])) return !0;
            return !1;
          }
          if (
            ("function" == typeof b.Buffer &&
              b.Buffer.isBuffer &&
              b.Buffer.isBuffer(a)) ||
            ("function" == typeof b.ArrayBuffer && a instanceof ArrayBuffer) ||
            (g && a instanceof Blob) ||
            (h && a instanceof File)
          )
            return !0;
          if (
            a.toJSON &&
            "function" == typeof a.toJSON &&
            1 === arguments.length
          )
            return d(a.toJSON(), !0);
          for (var i in a)
            if (Object.prototype.hasOwnProperty.call(a, i) && d(a[i]))
              return !0;
          return !1;
        }
        var e = c(10),
          f = Object.prototype.toString,
          g =
            "function" == typeof b.Blob ||
            "[object BlobConstructor]" === f.call(b.Blob),
          h =
            "function" == typeof b.File ||
            "[object FileConstructor]" === f.call(b.File);
        a.exports = d;
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      var c = {}.toString;
      a.exports =
        Array.isArray ||
        function(a) {
          return "[object Array]" == c.call(a);
        };
    },
    function(a, b, c) {
      (function(a) {
        function d(a, b) {
          if (!a) return a;
          if (g(a)) {
            var c = { _placeholder: !0, num: b.length };
            return b.push(a), c;
          }
          if (f(a)) {
            for (var e = new Array(a.length), h = 0; h < a.length; h++)
              e[h] = d(a[h], b);
            return e;
          }
          if ("object" == typeof a && !(a instanceof Date)) {
            var e = {};
            for (var i in a) e[i] = d(a[i], b);
            return e;
          }
          return a;
        }
        function e(a, b) {
          if (!a) return a;
          if (a && a._placeholder) return b[a.num];
          if (f(a)) for (var c = 0; c < a.length; c++) a[c] = e(a[c], b);
          else if ("object" == typeof a) for (var d in a) a[d] = e(a[d], b);
          return a;
        }
        var f = c(10),
          g = c(12),
          h = Object.prototype.toString,
          i =
            "function" == typeof a.Blob ||
            "[object BlobConstructor]" === h.call(a.Blob),
          j =
            "function" == typeof a.File ||
            "[object FileConstructor]" === h.call(a.File);
        (b.deconstructPacket = function(a) {
          var b = [],
            c = a.data,
            e = a;
          return (
            (e.data = d(c, b)),
            (e.attachments = b.length),
            { packet: e, buffers: b }
          );
        }),
          (b.reconstructPacket = function(a, b) {
            return (a.data = e(a.data, b)), (a.attachments = void 0), a;
          }),
          (b.removeBlobs = function(a, b) {
            function c(a, h, k) {
              if (!a) return a;
              if ((i && a instanceof Blob) || (j && a instanceof File)) {
                d++;
                var l = new FileReader();
                (l.onload = function() {
                  k ? (k[h] = this.result) : (e = this.result), --d || b(e);
                }),
                  l.readAsArrayBuffer(a);
              } else if (f(a)) for (var m = 0; m < a.length; m++) c(a[m], m, a);
              else if ("object" == typeof a && !g(a))
                for (var n in a) c(a[n], n, a);
            }
            var d = 0,
              e = a;
            c(e), d || b(e);
          });
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      (function(b) {
        function c(a) {
          return (
            (b.Buffer && b.Buffer.isBuffer(a)) ||
            (b.ArrayBuffer && a instanceof ArrayBuffer)
          );
        }
        a.exports = c;
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      "use strict";
      function d(a, b) {
        if (!(this instanceof d)) return new d(a, b);
        a &&
          "object" === ("undefined" == typeof a ? "undefined" : e(a)) &&
          ((b = a), (a = void 0)),
          (b = b || {}),
          (b.path = b.path || "/socket.io"),
          (this.nsps = {}),
          (this.subs = []),
          (this.opts = b),
          this.reconnection(b.reconnection !== !1),
          this.reconnectionAttempts(b.reconnectionAttempts || 1 / 0),
          this.reconnectionDelay(b.reconnectionDelay || 1e3),
          this.reconnectionDelayMax(b.reconnectionDelayMax || 5e3),
          this.randomizationFactor(b.randomizationFactor || 0.5),
          (this.backoff = new n({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
          })),
          this.timeout(null == b.timeout ? 2e4 : b.timeout),
          (this.readyState = "closed"),
          (this.uri = a),
          (this.connecting = []),
          (this.lastPing = null),
          (this.encoding = !1),
          (this.packetBuffer = []);
        var c = b.parser || i;
        (this.encoder = new c.Encoder()),
          (this.decoder = new c.Decoder()),
          (this.autoConnect = b.autoConnect !== !1),
          this.autoConnect && this.open();
      }
      var e =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function(a) {
                return typeof a;
              }
            : function(a) {
                return a &&
                  "function" == typeof Symbol &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a;
              },
        f = c(14),
        g = c(39),
        h = c(8),
        i = c(7),
        j = c(41),
        k = c(42),
        l = c(3)("socket.io-client:manager"),
        m = c(37),
        n = c(43),
        o = Object.prototype.hasOwnProperty;
      (a.exports = d),
        (d.prototype.emitAll = function() {
          this.emit.apply(this, arguments);
          for (var a in this.nsps)
            o.call(this.nsps, a) &&
              this.nsps[a].emit.apply(this.nsps[a], arguments);
        }),
        (d.prototype.updateSocketIds = function() {
          for (var a in this.nsps)
            o.call(this.nsps, a) && (this.nsps[a].id = this.generateId(a));
        }),
        (d.prototype.generateId = function(a) {
          return ("/" === a ? "" : a + "#") + this.engine.id;
        }),
        h(d.prototype),
        (d.prototype.reconnection = function(a) {
          return arguments.length
            ? ((this._reconnection = !!a), this)
            : this._reconnection;
        }),
        (d.prototype.reconnectionAttempts = function(a) {
          return arguments.length
            ? ((this._reconnectionAttempts = a), this)
            : this._reconnectionAttempts;
        }),
        (d.prototype.reconnectionDelay = function(a) {
          return arguments.length
            ? ((this._reconnectionDelay = a),
              this.backoff && this.backoff.setMin(a),
              this)
            : this._reconnectionDelay;
        }),
        (d.prototype.randomizationFactor = function(a) {
          return arguments.length
            ? ((this._randomizationFactor = a),
              this.backoff && this.backoff.setJitter(a),
              this)
            : this._randomizationFactor;
        }),
        (d.prototype.reconnectionDelayMax = function(a) {
          return arguments.length
            ? ((this._reconnectionDelayMax = a),
              this.backoff && this.backoff.setMax(a),
              this)
            : this._reconnectionDelayMax;
        }),
        (d.prototype.timeout = function(a) {
          return arguments.length ? ((this._timeout = a), this) : this._timeout;
        }),
        (d.prototype.maybeReconnectOnOpen = function() {
          !this.reconnecting &&
            this._reconnection &&
            0 === this.backoff.attempts &&
            this.reconnect();
        }),
        (d.prototype.open = d.prototype.connect = function(a, b) {
          if (
            (l("readyState %s", this.readyState),
            ~this.readyState.indexOf("open"))
          )
            return this;
          l("opening %s", this.uri), (this.engine = f(this.uri, this.opts));
          var c = this.engine,
            d = this;
          (this.readyState = "opening"), (this.skipReconnect = !1);
          var e = j(c, "open", function() {
              d.onopen(), a && a();
            }),
            g = j(c, "error", function(b) {
              if (
                (l("connect_error"),
                d.cleanup(),
                (d.readyState = "closed"),
                d.emitAll("connect_error", b),
                a)
              ) {
                var c = new Error("Connection error");
                (c.data = b), a(c);
              } else d.maybeReconnectOnOpen();
            });
          if (!1 !== this._timeout) {
            var h = this._timeout;
            l("connect attempt will timeout after %d", h);
            var i = setTimeout(function() {
              l("connect attempt timed out after %d", h),
                e.destroy(),
                c.close(),
                c.emit("error", "timeout"),
                d.emitAll("connect_timeout", h);
            }, h);
            this.subs.push({
              destroy: function() {
                clearTimeout(i);
              }
            });
          }
          return this.subs.push(e), this.subs.push(g), this;
        }),
        (d.prototype.onopen = function() {
          l("open"),
            this.cleanup(),
            (this.readyState = "open"),
            this.emit("open");
          var a = this.engine;
          this.subs.push(j(a, "data", k(this, "ondata"))),
            this.subs.push(j(a, "ping", k(this, "onping"))),
            this.subs.push(j(a, "pong", k(this, "onpong"))),
            this.subs.push(j(a, "error", k(this, "onerror"))),
            this.subs.push(j(a, "close", k(this, "onclose"))),
            this.subs.push(j(this.decoder, "decoded", k(this, "ondecoded")));
        }),
        (d.prototype.onping = function() {
          (this.lastPing = new Date()), this.emitAll("ping");
        }),
        (d.prototype.onpong = function() {
          this.emitAll("pong", new Date() - this.lastPing);
        }),
        (d.prototype.ondata = function(a) {
          this.decoder.add(a);
        }),
        (d.prototype.ondecoded = function(a) {
          this.emit("packet", a);
        }),
        (d.prototype.onerror = function(a) {
          l("error", a), this.emitAll("error", a);
        }),
        (d.prototype.socket = function(a, b) {
          function c() {
            ~m(e.connecting, d) || e.connecting.push(d);
          }
          var d = this.nsps[a];
          if (!d) {
            (d = new g(this, a, b)), (this.nsps[a] = d);
            var e = this;
            d.on("connecting", c),
              d.on("connect", function() {
                d.id = e.generateId(a);
              }),
              this.autoConnect && c();
          }
          return d;
        }),
        (d.prototype.destroy = function(a) {
          var b = m(this.connecting, a);
          ~b && this.connecting.splice(b, 1),
            this.connecting.length || this.close();
        }),
        (d.prototype.packet = function(a) {
          l("writing packet %j", a);
          var b = this;
          a.query && 0 === a.type && (a.nsp += "?" + a.query),
            b.encoding
              ? b.packetBuffer.push(a)
              : ((b.encoding = !0),
                this.encoder.encode(a, function(c) {
                  for (var d = 0; d < c.length; d++)
                    b.engine.write(c[d], a.options);
                  (b.encoding = !1), b.processPacketQueue();
                }));
        }),
        (d.prototype.processPacketQueue = function() {
          if (this.packetBuffer.length > 0 && !this.encoding) {
            var a = this.packetBuffer.shift();
            this.packet(a);
          }
        }),
        (d.prototype.cleanup = function() {
          l("cleanup");
          for (var a = this.subs.length, b = 0; b < a; b++) {
            var c = this.subs.shift();
            c.destroy();
          }
          (this.packetBuffer = []),
            (this.encoding = !1),
            (this.lastPing = null),
            this.decoder.destroy();
        }),
        (d.prototype.close = d.prototype.disconnect = function() {
          l("disconnect"),
            (this.skipReconnect = !0),
            (this.reconnecting = !1),
            "opening" === this.readyState && this.cleanup(),
            this.backoff.reset(),
            (this.readyState = "closed"),
            this.engine && this.engine.close();
        }),
        (d.prototype.onclose = function(a) {
          l("onclose"),
            this.cleanup(),
            this.backoff.reset(),
            (this.readyState = "closed"),
            this.emit("close", a),
            this._reconnection && !this.skipReconnect && this.reconnect();
        }),
        (d.prototype.reconnect = function() {
          if (this.reconnecting || this.skipReconnect) return this;
          var a = this;
          if (this.backoff.attempts >= this._reconnectionAttempts)
            l("reconnect failed"),
              this.backoff.reset(),
              this.emitAll("reconnect_failed"),
              (this.reconnecting = !1);
          else {
            var b = this.backoff.duration();
            l("will wait %dms before reconnect attempt", b),
              (this.reconnecting = !0);
            var c = setTimeout(function() {
              a.skipReconnect ||
                (l("attempting reconnect"),
                a.emitAll("reconnect_attempt", a.backoff.attempts),
                a.emitAll("reconnecting", a.backoff.attempts),
                a.skipReconnect ||
                  a.open(function(b) {
                    b
                      ? (l("reconnect attempt error"),
                        (a.reconnecting = !1),
                        a.reconnect(),
                        a.emitAll("reconnect_error", b.data))
                      : (l("reconnect success"), a.onreconnect());
                  }));
            }, b);
            this.subs.push({
              destroy: function() {
                clearTimeout(c);
              }
            });
          }
        }),
        (d.prototype.onreconnect = function() {
          var a = this.backoff.attempts;
          (this.reconnecting = !1),
            this.backoff.reset(),
            this.updateSocketIds(),
            this.emitAll("reconnect", a);
        });
    },
    function(a, b, c) {
      a.exports = c(15);
    },
    function(a, b, c) {
      (a.exports = c(16)), (a.exports.parser = c(23));
    },
    function(a, b, c) {
      (function(b) {
        function d(a, c) {
          if (!(this instanceof d)) return new d(a, c);
          (c = c || {}),
            a && "object" == typeof a && ((c = a), (a = null)),
            a
              ? ((a = k(a)),
                (c.hostname = a.host),
                (c.secure = "https" === a.protocol || "wss" === a.protocol),
                (c.port = a.port),
                a.query && (c.query = a.query))
              : c.host && (c.hostname = k(c.host).host),
            (this.secure =
              null != c.secure
                ? c.secure
                : b.location && "https:" === location.protocol),
            c.hostname && !c.port && (c.port = this.secure ? "443" : "80"),
            (this.agent = c.agent || !1),
            (this.hostname =
              c.hostname || (b.location ? location.hostname : "localhost")),
            (this.port =
              c.port ||
              (b.location && location.port
                ? location.port
                : this.secure
                ? 443
                : 80)),
            (this.query = c.query || {}),
            "string" == typeof this.query &&
              (this.query = m.decode(this.query)),
            (this.upgrade = !1 !== c.upgrade),
            (this.path = (c.path || "/engine.io").replace(/\/$/, "") + "/"),
            (this.forceJSONP = !!c.forceJSONP),
            (this.jsonp = !1 !== c.jsonp),
            (this.forceBase64 = !!c.forceBase64),
            (this.enablesXDR = !!c.enablesXDR),
            (this.timestampParam = c.timestampParam || "t"),
            (this.timestampRequests = c.timestampRequests),
            (this.transports = c.transports || ["polling", "websocket"]),
            (this.transportOptions = c.transportOptions || {}),
            (this.readyState = ""),
            (this.writeBuffer = []),
            (this.prevBufferLen = 0),
            (this.policyPort = c.policyPort || 843),
            (this.rememberUpgrade = c.rememberUpgrade || !1),
            (this.binaryType = null),
            (this.onlyBinaryUpgrades = c.onlyBinaryUpgrades),
            (this.perMessageDeflate =
              !1 !== c.perMessageDeflate && (c.perMessageDeflate || {})),
            !0 === this.perMessageDeflate && (this.perMessageDeflate = {}),
            this.perMessageDeflate &&
              null == this.perMessageDeflate.threshold &&
              (this.perMessageDeflate.threshold = 1024),
            (this.pfx = c.pfx || null),
            (this.key = c.key || null),
            (this.passphrase = c.passphrase || null),
            (this.cert = c.cert || null),
            (this.ca = c.ca || null),
            (this.ciphers = c.ciphers || null),
            (this.rejectUnauthorized =
              void 0 === c.rejectUnauthorized || c.rejectUnauthorized),
            (this.forceNode = !!c.forceNode);
          var e = "object" == typeof b && b;
          e.global === e &&
            (c.extraHeaders &&
              Object.keys(c.extraHeaders).length > 0 &&
              (this.extraHeaders = c.extraHeaders),
            c.localAddress && (this.localAddress = c.localAddress)),
            (this.id = null),
            (this.upgrades = null),
            (this.pingInterval = null),
            (this.pingTimeout = null),
            (this.pingIntervalTimer = null),
            (this.pingTimeoutTimer = null),
            this.open();
        }
        function e(a) {
          var b = {};
          for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]);
          return b;
        }
        var f = c(17),
          g = c(8),
          h = c(3)("engine.io-client:socket"),
          i = c(37),
          j = c(23),
          k = c(2),
          l = c(38),
          m = c(31);
        (a.exports = d),
          (d.priorWebsocketSuccess = !1),
          g(d.prototype),
          (d.protocol = j.protocol),
          (d.Socket = d),
          (d.Transport = c(22)),
          (d.transports = c(17)),
          (d.parser = c(23)),
          (d.prototype.createTransport = function(a) {
            h('creating transport "%s"', a);
            var b = e(this.query);
            (b.EIO = j.protocol), (b.transport = a);
            var c = this.transportOptions[a] || {};
            this.id && (b.sid = this.id);
            var d = new f[a]({
              query: b,
              socket: this,
              agent: c.agent || this.agent,
              hostname: c.hostname || this.hostname,
              port: c.port || this.port,
              secure: c.secure || this.secure,
              path: c.path || this.path,
              forceJSONP: c.forceJSONP || this.forceJSONP,
              jsonp: c.jsonp || this.jsonp,
              forceBase64: c.forceBase64 || this.forceBase64,
              enablesXDR: c.enablesXDR || this.enablesXDR,
              timestampRequests: c.timestampRequests || this.timestampRequests,
              timestampParam: c.timestampParam || this.timestampParam,
              policyPort: c.policyPort || this.policyPort,
              pfx: c.pfx || this.pfx,
              key: c.key || this.key,
              passphrase: c.passphrase || this.passphrase,
              cert: c.cert || this.cert,
              ca: c.ca || this.ca,
              ciphers: c.ciphers || this.ciphers,
              rejectUnauthorized:
                c.rejectUnauthorized || this.rejectUnauthorized,
              perMessageDeflate: c.perMessageDeflate || this.perMessageDeflate,
              extraHeaders: c.extraHeaders || this.extraHeaders,
              forceNode: c.forceNode || this.forceNode,
              localAddress: c.localAddress || this.localAddress,
              requestTimeout: c.requestTimeout || this.requestTimeout,
              protocols: c.protocols || void 0
            });
            return d;
          }),
          (d.prototype.open = function() {
            var a;
            if (
              this.rememberUpgrade &&
              d.priorWebsocketSuccess &&
              this.transports.indexOf("websocket") !== -1
            )
              a = "websocket";
            else {
              if (0 === this.transports.length) {
                var b = this;
                return void setTimeout(function() {
                  b.emit("error", "No transports available");
                }, 0);
              }
              a = this.transports[0];
            }
            this.readyState = "opening";
            try {
              a = this.createTransport(a);
            } catch (c) {
              return this.transports.shift(), void this.open();
            }
            a.open(), this.setTransport(a);
          }),
          (d.prototype.setTransport = function(a) {
            h("setting transport %s", a.name);
            var b = this;
            this.transport &&
              (h("clearing existing transport %s", this.transport.name),
              this.transport.removeAllListeners()),
              (this.transport = a),
              a
                .on("drain", function() {
                  b.onDrain();
                })
                .on("packet", function(a) {
                  b.onPacket(a);
                })
                .on("error", function(a) {
                  b.onError(a);
                })
                .on("close", function() {
                  b.onClose("transport close");
                });
          }),
          (d.prototype.probe = function(a) {
            function b() {
              if (m.onlyBinaryUpgrades) {
                var b = !this.supportsBinary && m.transport.supportsBinary;
                l = l || b;
              }
              l ||
                (h('probe transport "%s" opened', a),
                k.send([{ type: "ping", data: "probe" }]),
                k.once("packet", function(b) {
                  if (!l)
                    if ("pong" === b.type && "probe" === b.data) {
                      if (
                        (h('probe transport "%s" pong', a),
                        (m.upgrading = !0),
                        m.emit("upgrading", k),
                        !k)
                      )
                        return;
                      (d.priorWebsocketSuccess = "websocket" === k.name),
                        h('pausing current transport "%s"', m.transport.name),
                        m.transport.pause(function() {
                          l ||
                            ("closed" !== m.readyState &&
                              (h(
                                "changing transport and sending upgrade packet"
                              ),
                              j(),
                              m.setTransport(k),
                              k.send([{ type: "upgrade" }]),
                              m.emit("upgrade", k),
                              (k = null),
                              (m.upgrading = !1),
                              m.flush()));
                        });
                    } else {
                      h('probe transport "%s" failed', a);
                      var c = new Error("probe error");
                      (c.transport = k.name), m.emit("upgradeError", c);
                    }
                }));
            }
            function c() {
              l || ((l = !0), j(), k.close(), (k = null));
            }
            function e(b) {
              var d = new Error("probe error: " + b);
              (d.transport = k.name),
                c(),
                h('probe transport "%s" failed because of error: %s', a, b),
                m.emit("upgradeError", d);
            }
            function f() {
              e("transport closed");
            }
            function g() {
              e("socket closed");
            }
            function i(a) {
              k &&
                a.name !== k.name &&
                (h('"%s" works - aborting "%s"', a.name, k.name), c());
            }
            function j() {
              k.removeListener("open", b),
                k.removeListener("error", e),
                k.removeListener("close", f),
                m.removeListener("close", g),
                m.removeListener("upgrading", i);
            }
            h('probing transport "%s"', a);
            var k = this.createTransport(a, { probe: 1 }),
              l = !1,
              m = this;
            (d.priorWebsocketSuccess = !1),
              k.once("open", b),
              k.once("error", e),
              k.once("close", f),
              this.once("close", g),
              this.once("upgrading", i),
              k.open();
          }),
          (d.prototype.onOpen = function() {
            if (
              (h("socket open"),
              (this.readyState = "open"),
              (d.priorWebsocketSuccess = "websocket" === this.transport.name),
              this.emit("open"),
              this.flush(),
              "open" === this.readyState &&
                this.upgrade &&
                this.transport.pause)
            ) {
              h("starting upgrade probes");
              for (var a = 0, b = this.upgrades.length; a < b; a++)
                this.probe(this.upgrades[a]);
            }
          }),
          (d.prototype.onPacket = function(a) {
            if (
              "opening" === this.readyState ||
              "open" === this.readyState ||
              "closing" === this.readyState
            )
              switch (
                (h('socket receive: type "%s", data "%s"', a.type, a.data),
                this.emit("packet", a),
                this.emit("heartbeat"),
                a.type)
              ) {
                case "open":
                  this.onHandshake(l(a.data));
                  break;
                case "pong":
                  this.setPing(), this.emit("pong");
                  break;
                case "error":
                  var b = new Error("server error");
                  (b.code = a.data), this.onError(b);
                  break;
                case "message":
                  this.emit("data", a.data), this.emit("message", a.data);
              }
            else
              h('packet received with socket readyState "%s"', this.readyState);
          }),
          (d.prototype.onHandshake = function(a) {
            this.emit("handshake", a),
              (this.id = a.sid),
              (this.transport.query.sid = a.sid),
              (this.upgrades = this.filterUpgrades(a.upgrades)),
              (this.pingInterval = a.pingInterval),
              (this.pingTimeout = a.pingTimeout),
              this.onOpen(),
              "closed" !== this.readyState &&
                (this.setPing(),
                this.removeListener("heartbeat", this.onHeartbeat),
                this.on("heartbeat", this.onHeartbeat));
          }),
          (d.prototype.onHeartbeat = function(a) {
            clearTimeout(this.pingTimeoutTimer);
            var b = this;
            b.pingTimeoutTimer = setTimeout(function() {
              "closed" !== b.readyState && b.onClose("ping timeout");
            }, a || b.pingInterval + b.pingTimeout);
          }),
          (d.prototype.setPing = function() {
            var a = this;
            clearTimeout(a.pingIntervalTimer),
              (a.pingIntervalTimer = setTimeout(function() {
                h(
                  "writing ping packet - expecting pong within %sms",
                  a.pingTimeout
                ),
                  a.ping(),
                  a.onHeartbeat(a.pingTimeout);
              }, a.pingInterval));
          }),
          (d.prototype.ping = function() {
            var a = this;
            this.sendPacket("ping", function() {
              a.emit("ping");
            });
          }),
          (d.prototype.onDrain = function() {
            this.writeBuffer.splice(0, this.prevBufferLen),
              (this.prevBufferLen = 0),
              0 === this.writeBuffer.length ? this.emit("drain") : this.flush();
          }),
          (d.prototype.flush = function() {
            "closed" !== this.readyState &&
              this.transport.writable &&
              !this.upgrading &&
              this.writeBuffer.length &&
              (h("flushing %d packets in socket", this.writeBuffer.length),
              this.transport.send(this.writeBuffer),
              (this.prevBufferLen = this.writeBuffer.length),
              this.emit("flush"));
          }),
          (d.prototype.write = d.prototype.send = function(a, b, c) {
            return this.sendPacket("message", a, b, c), this;
          }),
          (d.prototype.sendPacket = function(a, b, c, d) {
            if (
              ("function" == typeof b && ((d = b), (b = void 0)),
              "function" == typeof c && ((d = c), (c = null)),
              "closing" !== this.readyState && "closed" !== this.readyState)
            ) {
              (c = c || {}), (c.compress = !1 !== c.compress);
              var e = { type: a, data: b, options: c };
              this.emit("packetCreate", e),
                this.writeBuffer.push(e),
                d && this.once("flush", d),
                this.flush();
            }
          }),
          (d.prototype.close = function() {
            function a() {
              d.onClose("forced close"),
                h("socket closing - telling transport to close"),
                d.transport.close();
            }
            function b() {
              d.removeListener("upgrade", b),
                d.removeListener("upgradeError", b),
                a();
            }
            function c() {
              d.once("upgrade", b), d.once("upgradeError", b);
            }
            if ("opening" === this.readyState || "open" === this.readyState) {
              this.readyState = "closing";
              var d = this;
              this.writeBuffer.length
                ? this.once("drain", function() {
                    this.upgrading ? c() : a();
                  })
                : this.upgrading
                ? c()
                : a();
            }
            return this;
          }),
          (d.prototype.onError = function(a) {
            h("socket error %j", a),
              (d.priorWebsocketSuccess = !1),
              this.emit("error", a),
              this.onClose("transport error", a);
          }),
          (d.prototype.onClose = function(a, b) {
            if (
              "opening" === this.readyState ||
              "open" === this.readyState ||
              "closing" === this.readyState
            ) {
              h('socket close with reason: "%s"', a);
              var c = this;
              clearTimeout(this.pingIntervalTimer),
                clearTimeout(this.pingTimeoutTimer),
                this.transport.removeAllListeners("close"),
                this.transport.close(),
                this.transport.removeAllListeners(),
                (this.readyState = "closed"),
                (this.id = null),
                this.emit("close", a, b),
                (c.writeBuffer = []),
                (c.prevBufferLen = 0);
            }
          }),
          (d.prototype.filterUpgrades = function(a) {
            for (var b = [], c = 0, d = a.length; c < d; c++)
              ~i(this.transports, a[c]) && b.push(a[c]);
            return b;
          });
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      (function(a) {
        function d(b) {
          var c,
            d = !1,
            h = !1,
            i = !1 !== b.jsonp;
          if (a.location) {
            var j = "https:" === location.protocol,
              k = location.port;
            k || (k = j ? 443 : 80),
              (d = b.hostname !== location.hostname || k !== b.port),
              (h = b.secure !== j);
          }
          if (
            ((b.xdomain = d),
            (b.xscheme = h),
            (c = new e(b)),
            "open" in c && !b.forceJSONP)
          )
            return new f(b);
          if (!i) throw new Error("JSONP disabled");
          return new g(b);
        }
        var e = c(18),
          f = c(20),
          g = c(34),
          h = c(35);
        (b.polling = d), (b.websocket = h);
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      (function(b) {
        var d = c(19);
        a.exports = function(a) {
          var c = a.xdomain,
            e = a.xscheme,
            f = a.enablesXDR;
          try {
            if ("undefined" != typeof XMLHttpRequest && (!c || d))
              return new XMLHttpRequest();
          } catch (g) {}
          try {
            if ("undefined" != typeof XDomainRequest && !e && f)
              return new XDomainRequest();
          } catch (g) {}
          if (!c)
            try {
              return new b[(["Active"].concat("Object").join("X"))](
                "Microsoft.XMLHTTP"
              );
            } catch (g) {}
        };
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      try {
        a.exports =
          "undefined" != typeof XMLHttpRequest &&
          "withCredentials" in new XMLHttpRequest();
      } catch (c) {
        a.exports = !1;
      }
    },
    function(a, b, c) {
      (function(b) {
        function d() {}
        function e(a) {
          if (
            (i.call(this, a),
            (this.requestTimeout = a.requestTimeout),
            (this.extraHeaders = a.extraHeaders),
            b.location)
          ) {
            var c = "https:" === location.protocol,
              d = location.port;
            d || (d = c ? 443 : 80),
              (this.xd = a.hostname !== b.location.hostname || d !== a.port),
              (this.xs = a.secure !== c);
          }
        }
        function f(a) {
          (this.method = a.method || "GET"),
            (this.uri = a.uri),
            (this.xd = !!a.xd),
            (this.xs = !!a.xs),
            (this.async = !1 !== a.async),
            (this.data = void 0 !== a.data ? a.data : null),
            (this.agent = a.agent),
            (this.isBinary = a.isBinary),
            (this.supportsBinary = a.supportsBinary),
            (this.enablesXDR = a.enablesXDR),
            (this.requestTimeout = a.requestTimeout),
            (this.pfx = a.pfx),
            (this.key = a.key),
            (this.passphrase = a.passphrase),
            (this.cert = a.cert),
            (this.ca = a.ca),
            (this.ciphers = a.ciphers),
            (this.rejectUnauthorized = a.rejectUnauthorized),
            (this.extraHeaders = a.extraHeaders),
            this.create();
        }
        function g() {
          for (var a in f.requests)
            f.requests.hasOwnProperty(a) && f.requests[a].abort();
        }
        var h = c(18),
          i = c(21),
          j = c(8),
          k = c(32),
          l = c(3)("engine.io-client:polling-xhr");
        (a.exports = e),
          (a.exports.Request = f),
          k(e, i),
          (e.prototype.supportsBinary = !0),
          (e.prototype.request = function(a) {
            return (
              (a = a || {}),
              (a.uri = this.uri()),
              (a.xd = this.xd),
              (a.xs = this.xs),
              (a.agent = this.agent || !1),
              (a.supportsBinary = this.supportsBinary),
              (a.enablesXDR = this.enablesXDR),
              (a.pfx = this.pfx),
              (a.key = this.key),
              (a.passphrase = this.passphrase),
              (a.cert = this.cert),
              (a.ca = this.ca),
              (a.ciphers = this.ciphers),
              (a.rejectUnauthorized = this.rejectUnauthorized),
              (a.requestTimeout = this.requestTimeout),
              (a.extraHeaders = this.extraHeaders),
              new f(a)
            );
          }),
          (e.prototype.doWrite = function(a, b) {
            var c = "string" != typeof a && void 0 !== a,
              d = this.request({ method: "POST", data: a, isBinary: c }),
              e = this;
            d.on("success", b),
              d.on("error", function(a) {
                e.onError("xhr post error", a);
              }),
              (this.sendXhr = d);
          }),
          (e.prototype.doPoll = function() {
            l("xhr poll");
            var a = this.request(),
              b = this;
            a.on("data", function(a) {
              b.onData(a);
            }),
              a.on("error", function(a) {
                b.onError("xhr poll error", a);
              }),
              (this.pollXhr = a);
          }),
          j(f.prototype),
          (f.prototype.create = function() {
            var a = {
              agent: this.agent,
              xdomain: this.xd,
              xscheme: this.xs,
              enablesXDR: this.enablesXDR
            };
            (a.pfx = this.pfx),
              (a.key = this.key),
              (a.passphrase = this.passphrase),
              (a.cert = this.cert),
              (a.ca = this.ca),
              (a.ciphers = this.ciphers),
              (a.rejectUnauthorized = this.rejectUnauthorized);
            var c = (this.xhr = new h(a)),
              d = this;
            try {
              l("xhr open %s: %s", this.method, this.uri),
                c.open(this.method, this.uri, this.async);
              try {
                if (this.extraHeaders) {
                  c.setDisableHeaderCheck && c.setDisableHeaderCheck(!0);
                  for (var e in this.extraHeaders)
                    this.extraHeaders.hasOwnProperty(e) &&
                      c.setRequestHeader(e, this.extraHeaders[e]);
                }
              } catch (g) {}
              if ("POST" === this.method)
                try {
                  this.isBinary
                    ? c.setRequestHeader(
                        "Content-type",
                        "application/octet-stream"
                      )
                    : c.setRequestHeader(
                        "Content-type",
                        "text/plain;charset=UTF-8"
                      );
                } catch (g) {}
              try {
                c.setRequestHeader("Accept", "*/*");
              } catch (g) {}
              "withCredentials" in c && (c.withCredentials = !0),
                this.requestTimeout && (c.timeout = this.requestTimeout),
                this.hasXDR()
                  ? ((c.onload = function() {
                      d.onLoad();
                    }),
                    (c.onerror = function() {
                      d.onError(c.responseText);
                    }))
                  : (c.onreadystatechange = function() {
                      if (2 === c.readyState) {
                        var a;
                        try {
                          a = c.getResponseHeader("Content-Type");
                        } catch (b) {}
                        "application/octet-stream" === a &&
                          (c.responseType = "arraybuffer");
                      }
                      4 === c.readyState &&
                        (200 === c.status || 1223 === c.status
                          ? d.onLoad()
                          : setTimeout(function() {
                              d.onError(c.status);
                            }, 0));
                    }),
                l("xhr data %s", this.data),
                c.send(this.data);
            } catch (g) {
              return void setTimeout(function() {
                d.onError(g);
              }, 0);
            }
            b.document &&
              ((this.index = f.requestsCount++),
              (f.requests[this.index] = this));
          }),
          (f.prototype.onSuccess = function() {
            this.emit("success"), this.cleanup();
          }),
          (f.prototype.onData = function(a) {
            this.emit("data", a), this.onSuccess();
          }),
          (f.prototype.onError = function(a) {
            this.emit("error", a), this.cleanup(!0);
          }),
          (f.prototype.cleanup = function(a) {
            if ("undefined" != typeof this.xhr && null !== this.xhr) {
              if (
                (this.hasXDR()
                  ? (this.xhr.onload = this.xhr.onerror = d)
                  : (this.xhr.onreadystatechange = d),
                a)
              )
                try {
                  this.xhr.abort();
                } catch (c) {}
              b.document && delete f.requests[this.index], (this.xhr = null);
            }
          }),
          (f.prototype.onLoad = function() {
            var a;
            try {
              var b;
              try {
                b = this.xhr.getResponseHeader("Content-Type");
              } catch (c) {}
              a =
                "application/octet-stream" === b
                  ? this.xhr.response || this.xhr.responseText
                  : this.xhr.responseText;
            } catch (c) {
              this.onError(c);
            }
            null != a && this.onData(a);
          }),
          (f.prototype.hasXDR = function() {
            return (
              "undefined" != typeof b.XDomainRequest &&
              !this.xs &&
              this.enablesXDR
            );
          }),
          (f.prototype.abort = function() {
            this.cleanup();
          }),
          (f.requestsCount = 0),
          (f.requests = {}),
          b.document &&
            (b.attachEvent
              ? b.attachEvent("onunload", g)
              : b.addEventListener &&
                b.addEventListener("beforeunload", g, !1));
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      function d(a) {
        var b = a && a.forceBase64;
        (k && !b) || (this.supportsBinary = !1), e.call(this, a);
      }
      var e = c(22),
        f = c(31),
        g = c(23),
        h = c(32),
        i = c(33),
        j = c(3)("engine.io-client:polling");
      a.exports = d;
      var k = (function() {
        var a = c(18),
          b = new a({ xdomain: !1 });
        return null != b.responseType;
      })();
      h(d, e),
        (d.prototype.name = "polling"),
        (d.prototype.doOpen = function() {
          this.poll();
        }),
        (d.prototype.pause = function(a) {
          function b() {
            j("paused"), (c.readyState = "paused"), a();
          }
          var c = this;
          if (((this.readyState = "pausing"), this.polling || !this.writable)) {
            var d = 0;
            this.polling &&
              (j("we are currently polling - waiting to pause"),
              d++,
              this.once("pollComplete", function() {
                j("pre-pause polling complete"), --d || b();
              })),
              this.writable ||
                (j("we are currently writing - waiting to pause"),
                d++,
                this.once("drain", function() {
                  j("pre-pause writing complete"), --d || b();
                }));
          } else b();
        }),
        (d.prototype.poll = function() {
          j("polling"), (this.polling = !0), this.doPoll(), this.emit("poll");
        }),
        (d.prototype.onData = function(a) {
          var b = this;
          j("polling got data %s", a);
          var c = function(a, c, d) {
            return (
              "opening" === b.readyState && b.onOpen(),
              "close" === a.type ? (b.onClose(), !1) : void b.onPacket(a)
            );
          };
          g.decodePayload(a, this.socket.binaryType, c),
            "closed" !== this.readyState &&
              ((this.polling = !1),
              this.emit("pollComplete"),
              "open" === this.readyState
                ? this.poll()
                : j('ignoring poll - transport state "%s"', this.readyState));
        }),
        (d.prototype.doClose = function() {
          function a() {
            j("writing close packet"), b.write([{ type: "close" }]);
          }
          var b = this;
          "open" === this.readyState
            ? (j("transport open - closing"), a())
            : (j("transport not open - deferring close"), this.once("open", a));
        }),
        (d.prototype.write = function(a) {
          var b = this;
          this.writable = !1;
          var c = function() {
            (b.writable = !0), b.emit("drain");
          };
          g.encodePayload(a, this.supportsBinary, function(a) {
            b.doWrite(a, c);
          });
        }),
        (d.prototype.uri = function() {
          var a = this.query || {},
            b = this.secure ? "https" : "http",
            c = "";
          !1 !== this.timestampRequests && (a[this.timestampParam] = i()),
            this.supportsBinary || a.sid || (a.b64 = 1),
            (a = f.encode(a)),
            this.port &&
              (("https" === b && 443 !== Number(this.port)) ||
                ("http" === b && 80 !== Number(this.port))) &&
              (c = ":" + this.port),
            a.length && (a = "?" + a);
          var d = this.hostname.indexOf(":") !== -1;
          return (
            b +
            "://" +
            (d ? "[" + this.hostname + "]" : this.hostname) +
            c +
            this.path +
            a
          );
        });
    },
    function(a, b, c) {
      function d(a) {
        (this.path = a.path),
          (this.hostname = a.hostname),
          (this.port = a.port),
          (this.secure = a.secure),
          (this.query = a.query),
          (this.timestampParam = a.timestampParam),
          (this.timestampRequests = a.timestampRequests),
          (this.readyState = ""),
          (this.agent = a.agent || !1),
          (this.socket = a.socket),
          (this.enablesXDR = a.enablesXDR),
          (this.pfx = a.pfx),
          (this.key = a.key),
          (this.passphrase = a.passphrase),
          (this.cert = a.cert),
          (this.ca = a.ca),
          (this.ciphers = a.ciphers),
          (this.rejectUnauthorized = a.rejectUnauthorized),
          (this.forceNode = a.forceNode),
          (this.extraHeaders = a.extraHeaders),
          (this.localAddress = a.localAddress);
      }
      var e = c(23),
        f = c(8);
      (a.exports = d),
        f(d.prototype),
        (d.prototype.onError = function(a, b) {
          var c = new Error(a);
          return (
            (c.type = "TransportError"),
            (c.description = b),
            this.emit("error", c),
            this
          );
        }),
        (d.prototype.open = function() {
          return (
            ("closed" !== this.readyState && "" !== this.readyState) ||
              ((this.readyState = "opening"), this.doOpen()),
            this
          );
        }),
        (d.prototype.close = function() {
          return (
            ("opening" !== this.readyState && "open" !== this.readyState) ||
              (this.doClose(), this.onClose()),
            this
          );
        }),
        (d.prototype.send = function(a) {
          if ("open" !== this.readyState) throw new Error("Transport not open");
          this.write(a);
        }),
        (d.prototype.onOpen = function() {
          (this.readyState = "open"), (this.writable = !0), this.emit("open");
        }),
        (d.prototype.onData = function(a) {
          var b = e.decodePacket(a, this.socket.binaryType);
          this.onPacket(b);
        }),
        (d.prototype.onPacket = function(a) {
          this.emit("packet", a);
        }),
        (d.prototype.onClose = function() {
          (this.readyState = "closed"), this.emit("close");
        });
    },
    function(a, b, c) {
      (function(a) {
        function d(a, c) {
          var d = "b" + b.packets[a.type] + a.data.data;
          return c(d);
        }
        function e(a, c, d) {
          if (!c) return b.encodeBase64Packet(a, d);
          var e = a.data,
            f = new Uint8Array(e),
            g = new Uint8Array(1 + e.byteLength);
          g[0] = s[a.type];
          for (var h = 0; h < f.length; h++) g[h + 1] = f[h];
          return d(g.buffer);
        }
        function f(a, c, d) {
          if (!c) return b.encodeBase64Packet(a, d);
          var e = new FileReader();
          return (
            (e.onload = function() {
              (a.data = e.result), b.encodePacket(a, c, !0, d);
            }),
            e.readAsArrayBuffer(a.data)
          );
        }
        function g(a, c, d) {
          if (!c) return b.encodeBase64Packet(a, d);
          if (r) return f(a, c, d);
          var e = new Uint8Array(1);
          e[0] = s[a.type];
          var g = new v([e.buffer, a.data]);
          return d(g);
        }
        function h(a) {
          try {
            a = o.decode(a, { strict: !1 });
          } catch (b) {
            return !1;
          }
          return a;
        }
        function i(a, b, c) {
          for (
            var d = new Array(a.length),
              e = n(a.length, c),
              f = function(a, c, e) {
                b(c, function(b, c) {
                  (d[a] = c), e(b, d);
                });
              },
              g = 0;
            g < a.length;
            g++
          )
            f(g, a[g], e);
        }
        var j,
          k = c(24),
          l = c(9),
          m = c(25),
          n = c(26),
          o = c(27);
        a && a.ArrayBuffer && (j = c(29));
        var p =
            "undefined" != typeof navigator &&
            /Android/i.test(navigator.userAgent),
          q =
            "undefined" != typeof navigator &&
            /PhantomJS/i.test(navigator.userAgent),
          r = p || q;
        b.protocol = 3;
        var s = (b.packets = {
            open: 0,
            close: 1,
            ping: 2,
            pong: 3,
            message: 4,
            upgrade: 5,
            noop: 6
          }),
          t = k(s),
          u = { type: "error", data: "parser error" },
          v = c(30);
        (b.encodePacket = function(b, c, f, h) {
          "function" == typeof c && ((h = c), (c = !1)),
            "function" == typeof f && ((h = f), (f = null));
          var i = void 0 === b.data ? void 0 : b.data.buffer || b.data;
          if (a.ArrayBuffer && i instanceof ArrayBuffer) return e(b, c, h);
          if (v && i instanceof a.Blob) return g(b, c, h);
          if (i && i.base64) return d(b, h);
          var j = s[b.type];
          return (
            void 0 !== b.data &&
              (j += f
                ? o.encode(String(b.data), { strict: !1 })
                : String(b.data)),
            h("" + j)
          );
        }),
          (b.encodeBase64Packet = function(c, d) {
            var e = "b" + b.packets[c.type];
            if (v && c.data instanceof a.Blob) {
              var f = new FileReader();
              return (
                (f.onload = function() {
                  var a = f.result.split(",")[1];
                  d(e + a);
                }),
                f.readAsDataURL(c.data)
              );
            }
            var g;
            try {
              g = String.fromCharCode.apply(null, new Uint8Array(c.data));
            } catch (h) {
              for (
                var i = new Uint8Array(c.data), j = new Array(i.length), k = 0;
                k < i.length;
                k++
              )
                j[k] = i[k];
              g = String.fromCharCode.apply(null, j);
            }
            return (e += a.btoa(g)), d(e);
          }),
          (b.decodePacket = function(a, c, d) {
            if (void 0 === a) return u;
            if ("string" == typeof a) {
              if ("b" === a.charAt(0))
                return b.decodeBase64Packet(a.substr(1), c);
              if (d && ((a = h(a)), a === !1)) return u;
              var e = a.charAt(0);
              return Number(e) == e && t[e]
                ? a.length > 1
                  ? { type: t[e], data: a.substring(1) }
                  : { type: t[e] }
                : u;
            }
            var f = new Uint8Array(a),
              e = f[0],
              g = m(a, 1);
            return (
              v && "blob" === c && (g = new v([g])), { type: t[e], data: g }
            );
          }),
          (b.decodeBase64Packet = function(a, b) {
            var c = t[a.charAt(0)];
            if (!j) return { type: c, data: { base64: !0, data: a.substr(1) } };
            var d = j.decode(a.substr(1));
            return "blob" === b && v && (d = new v([d])), { type: c, data: d };
          }),
          (b.encodePayload = function(a, c, d) {
            function e(a) {
              return a.length + ":" + a;
            }
            function f(a, d) {
              b.encodePacket(a, !!g && c, !1, function(a) {
                d(null, e(a));
              });
            }
            "function" == typeof c && ((d = c), (c = null));
            var g = l(a);
            return c && g
              ? v && !r
                ? b.encodePayloadAsBlob(a, d)
                : b.encodePayloadAsArrayBuffer(a, d)
              : a.length
              ? void i(a, f, function(a, b) {
                  return d(b.join(""));
                })
              : d("0:");
          }),
          (b.decodePayload = function(a, c, d) {
            if ("string" != typeof a) return b.decodePayloadAsBinary(a, c, d);
            "function" == typeof c && ((d = c), (c = null));
            var e;
            if ("" === a) return d(u, 0, 1);
            for (var f, g, h = "", i = 0, j = a.length; i < j; i++) {
              var k = a.charAt(i);
              if (":" === k) {
                if ("" === h || h != (f = Number(h))) return d(u, 0, 1);
                if (((g = a.substr(i + 1, f)), h != g.length))
                  return d(u, 0, 1);
                if (g.length) {
                  if (
                    ((e = b.decodePacket(g, c, !1)),
                    u.type === e.type && u.data === e.data)
                  )
                    return d(u, 0, 1);
                  var l = d(e, i + f, j);
                  if (!1 === l) return;
                }
                (i += f), (h = "");
              } else h += k;
            }
            return "" !== h ? d(u, 0, 1) : void 0;
          }),
          (b.encodePayloadAsArrayBuffer = function(a, c) {
            function d(a, c) {
              b.encodePacket(a, !0, !0, function(a) {
                return c(null, a);
              });
            }
            return a.length
              ? void i(a, d, function(a, b) {
                  var d = b.reduce(function(a, b) {
                      var c;
                      return (
                        (c = "string" == typeof b ? b.length : b.byteLength),
                        a + c.toString().length + c + 2
                      );
                    }, 0),
                    e = new Uint8Array(d),
                    f = 0;
                  return (
                    b.forEach(function(a) {
                      var b = "string" == typeof a,
                        c = a;
                      if (b) {
                        for (
                          var d = new Uint8Array(a.length), g = 0;
                          g < a.length;
                          g++
                        )
                          d[g] = a.charCodeAt(g);
                        c = d.buffer;
                      }
                      b ? (e[f++] = 0) : (e[f++] = 1);
                      for (
                        var h = c.byteLength.toString(), g = 0;
                        g < h.length;
                        g++
                      )
                        e[f++] = parseInt(h[g]);
                      e[f++] = 255;
                      for (var d = new Uint8Array(c), g = 0; g < d.length; g++)
                        e[f++] = d[g];
                    }),
                    c(e.buffer)
                  );
                })
              : c(new ArrayBuffer(0));
          }),
          (b.encodePayloadAsBlob = function(a, c) {
            function d(a, c) {
              b.encodePacket(a, !0, !0, function(a) {
                var b = new Uint8Array(1);
                if (((b[0] = 1), "string" == typeof a)) {
                  for (
                    var d = new Uint8Array(a.length), e = 0;
                    e < a.length;
                    e++
                  )
                    d[e] = a.charCodeAt(e);
                  (a = d.buffer), (b[0] = 0);
                }
                for (
                  var f = a instanceof ArrayBuffer ? a.byteLength : a.size,
                    g = f.toString(),
                    h = new Uint8Array(g.length + 1),
                    e = 0;
                  e < g.length;
                  e++
                )
                  h[e] = parseInt(g[e]);
                if (((h[g.length] = 255), v)) {
                  var i = new v([b.buffer, h.buffer, a]);
                  c(null, i);
                }
              });
            }
            i(a, d, function(a, b) {
              return c(new v(b));
            });
          }),
          (b.decodePayloadAsBinary = function(a, c, d) {
            "function" == typeof c && ((d = c), (c = null));
            for (var e = a, f = []; e.byteLength > 0; ) {
              for (
                var g = new Uint8Array(e), h = 0 === g[0], i = "", j = 1;
                255 !== g[j];
                j++
              ) {
                if (i.length > 310) return d(u, 0, 1);
                i += g[j];
              }
              (e = m(e, 2 + i.length)), (i = parseInt(i));
              var k = m(e, 0, i);
              if (h)
                try {
                  k = String.fromCharCode.apply(null, new Uint8Array(k));
                } catch (l) {
                  var n = new Uint8Array(k);
                  k = "";
                  for (var j = 0; j < n.length; j++)
                    k += String.fromCharCode(n[j]);
                }
              f.push(k), (e = m(e, i));
            }
            var o = f.length;
            f.forEach(function(a, e) {
              d(b.decodePacket(a, c, !0), e, o);
            });
          });
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      a.exports =
        Object.keys ||
        function(a) {
          var b = [],
            c = Object.prototype.hasOwnProperty;
          for (var d in a) c.call(a, d) && b.push(d);
          return b;
        };
    },
    function(a, b) {
      a.exports = function(a, b, c) {
        var d = a.byteLength;
        if (((b = b || 0), (c = c || d), a.slice)) return a.slice(b, c);
        if (
          (b < 0 && (b += d),
          c < 0 && (c += d),
          c > d && (c = d),
          b >= d || b >= c || 0 === d)
        )
          return new ArrayBuffer(0);
        for (
          var e = new Uint8Array(a), f = new Uint8Array(c - b), g = b, h = 0;
          g < c;
          g++, h++
        )
          f[h] = e[g];
        return f.buffer;
      };
    },
    function(a, b) {
      function c(a, b, c) {
        function e(a, d) {
          if (e.count <= 0) throw new Error("after called too many times");
          --e.count,
            a ? ((f = !0), b(a), (b = c)) : 0 !== e.count || f || b(null, d);
        }
        var f = !1;
        return (c = c || d), (e.count = a), 0 === a ? b() : e;
      }
      function d() {}
      a.exports = c;
    },
    function(a, b, c) {
      var d;
      (function(a, e) {
        !(function(f) {
          function g(a) {
            for (var b, c, d = [], e = 0, f = a.length; e < f; )
              (b = a.charCodeAt(e++)),
                b >= 55296 && b <= 56319 && e < f
                  ? ((c = a.charCodeAt(e++)),
                    56320 == (64512 & c)
                      ? d.push(((1023 & b) << 10) + (1023 & c) + 65536)
                      : (d.push(b), e--))
                  : d.push(b);
            return d;
          }
          function h(a) {
            for (var b, c = a.length, d = -1, e = ""; ++d < c; )
              (b = a[d]),
                b > 65535 &&
                  ((b -= 65536),
                  (e += u(((b >>> 10) & 1023) | 55296)),
                  (b = 56320 | (1023 & b))),
                (e += u(b));
            return e;
          }
          function i(a, b) {
            if (a >= 55296 && a <= 57343) {
              if (b)
                throw Error(
                  "Lone surrogate U+" +
                    a.toString(16).toUpperCase() +
                    " is not a scalar value"
                );
              return !1;
            }
            return !0;
          }
          function j(a, b) {
            return u(((a >> b) & 63) | 128);
          }
          function k(a, b) {
            if (0 == (4294967168 & a)) return u(a);
            var c = "";
            return (
              0 == (4294965248 & a)
                ? (c = u(((a >> 6) & 31) | 192))
                : 0 == (4294901760 & a)
                ? (i(a, b) || (a = 65533),
                  (c = u(((a >> 12) & 15) | 224)),
                  (c += j(a, 6)))
                : 0 == (4292870144 & a) &&
                  ((c = u(((a >> 18) & 7) | 240)),
                  (c += j(a, 12)),
                  (c += j(a, 6))),
              (c += u((63 & a) | 128))
            );
          }
          function l(a, b) {
            b = b || {};
            for (
              var c,
                d = !1 !== b.strict,
                e = g(a),
                f = e.length,
                h = -1,
                i = "";
              ++h < f;

            )
              (c = e[h]), (i += k(c, d));
            return i;
          }
          function m() {
            if (t >= s) throw Error("Invalid byte index");
            var a = 255 & r[t];
            if ((t++, 128 == (192 & a))) return 63 & a;
            throw Error("Invalid continuation byte");
          }
          function n(a) {
            var b, c, d, e, f;
            if (t > s) throw Error("Invalid byte index");
            if (t == s) return !1;
            if (((b = 255 & r[t]), t++, 0 == (128 & b))) return b;
            if (192 == (224 & b)) {
              if (((c = m()), (f = ((31 & b) << 6) | c), f >= 128)) return f;
              throw Error("Invalid continuation byte");
            }
            if (224 == (240 & b)) {
              if (
                ((c = m()),
                (d = m()),
                (f = ((15 & b) << 12) | (c << 6) | d),
                f >= 2048)
              )
                return i(f, a) ? f : 65533;
              throw Error("Invalid continuation byte");
            }
            if (
              240 == (248 & b) &&
              ((c = m()),
              (d = m()),
              (e = m()),
              (f = ((7 & b) << 18) | (c << 12) | (d << 6) | e),
              f >= 65536 && f <= 1114111)
            )
              return f;
            throw Error("Invalid UTF-8 detected");
          }
          function o(a, b) {
            b = b || {};
            var c = !1 !== b.strict;
            (r = g(a)), (s = r.length), (t = 0);
            for (var d, e = []; (d = n(c)) !== !1; ) e.push(d);
            return h(e);
          }
          var p = "object" == typeof b && b,
            q = ("object" == typeof a && a && a.exports == p && a,
            "object" == typeof e && e);
          (q.global !== q && q.window !== q) || (f = q);
          var r,
            s,
            t,
            u = String.fromCharCode,
            v = { version: "2.1.2", encode: l, decode: o };
          (d = function() {
            return v;
          }.call(b, c, b, a)),
            !(void 0 !== d && (a.exports = d));
        })(this);
      }.call(
        b,
        c(28)(a),
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      a.exports = function(a) {
        return (
          a.webpackPolyfill ||
            ((a.deprecate = function() {}),
            (a.paths = []),
            (a.children = []),
            (a.webpackPolyfill = 1)),
          a
        );
      };
    },
    function(a, b) {
      !(function() {
        "use strict";
        for (
          var a =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            c = new Uint8Array(256),
            d = 0;
          d < a.length;
          d++
        )
          c[a.charCodeAt(d)] = d;
        (b.encode = function(b) {
          var c,
            d = new Uint8Array(b),
            e = d.length,
            f = "";
          for (c = 0; c < e; c += 3)
            (f += a[d[c] >> 2]),
              (f += a[((3 & d[c]) << 4) | (d[c + 1] >> 4)]),
              (f += a[((15 & d[c + 1]) << 2) | (d[c + 2] >> 6)]),
              (f += a[63 & d[c + 2]]);
          return (
            e % 3 === 2
              ? (f = f.substring(0, f.length - 1) + "=")
              : e % 3 === 1 && (f = f.substring(0, f.length - 2) + "=="),
            f
          );
        }),
          (b.decode = function(a) {
            var b,
              d,
              e,
              f,
              g,
              h = 0.75 * a.length,
              i = a.length,
              j = 0;
            "=" === a[a.length - 1] && (h--, "=" === a[a.length - 2] && h--);
            var k = new ArrayBuffer(h),
              l = new Uint8Array(k);
            for (b = 0; b < i; b += 4)
              (d = c[a.charCodeAt(b)]),
                (e = c[a.charCodeAt(b + 1)]),
                (f = c[a.charCodeAt(b + 2)]),
                (g = c[a.charCodeAt(b + 3)]),
                (l[j++] = (d << 2) | (e >> 4)),
                (l[j++] = ((15 & e) << 4) | (f >> 2)),
                (l[j++] = ((3 & f) << 6) | (63 & g));
            return k;
          });
      })();
    },
    function(a, b) {
      (function(b) {
        function c(a) {
          for (var b = 0; b < a.length; b++) {
            var c = a[b];
            if (c.buffer instanceof ArrayBuffer) {
              var d = c.buffer;
              if (c.byteLength !== d.byteLength) {
                var e = new Uint8Array(c.byteLength);
                e.set(new Uint8Array(d, c.byteOffset, c.byteLength)),
                  (d = e.buffer);
              }
              a[b] = d;
            }
          }
        }
        function d(a, b) {
          b = b || {};
          var d = new f();
          c(a);
          for (var e = 0; e < a.length; e++) d.append(a[e]);
          return b.type ? d.getBlob(b.type) : d.getBlob();
        }
        function e(a, b) {
          return c(a), new Blob(a, b || {});
        }
        var f =
            b.BlobBuilder ||
            b.WebKitBlobBuilder ||
            b.MSBlobBuilder ||
            b.MozBlobBuilder,
          g = (function() {
            try {
              var a = new Blob(["hi"]);
              return 2 === a.size;
            } catch (b) {
              return !1;
            }
          })(),
          h =
            g &&
            (function() {
              try {
                var a = new Blob([new Uint8Array([1, 2])]);
                return 2 === a.size;
              } catch (b) {
                return !1;
              }
            })(),
          i = f && f.prototype.append && f.prototype.getBlob;
        a.exports = (function() {
          return g ? (h ? b.Blob : e) : i ? d : void 0;
        })();
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      (b.encode = function(a) {
        var b = "";
        for (var c in a)
          a.hasOwnProperty(c) &&
            (b.length && (b += "&"),
            (b += encodeURIComponent(c) + "=" + encodeURIComponent(a[c])));
        return b;
      }),
        (b.decode = function(a) {
          for (var b = {}, c = a.split("&"), d = 0, e = c.length; d < e; d++) {
            var f = c[d].split("=");
            b[decodeURIComponent(f[0])] = decodeURIComponent(f[1]);
          }
          return b;
        });
    },
    function(a, b) {
      a.exports = function(a, b) {
        var c = function() {};
        (c.prototype = b.prototype),
          (a.prototype = new c()),
          (a.prototype.constructor = a);
      };
    },
    function(a, b) {
      "use strict";
      function c(a) {
        var b = "";
        do (b = g[a % h] + b), (a = Math.floor(a / h));
        while (a > 0);
        return b;
      }
      function d(a) {
        var b = 0;
        for (k = 0; k < a.length; k++) b = b * h + i[a.charAt(k)];
        return b;
      }
      function e() {
        var a = c(+new Date());
        return a !== f ? ((j = 0), (f = a)) : a + "." + c(j++);
      }
      for (
        var f,
          g = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(
            ""
          ),
          h = 64,
          i = {},
          j = 0,
          k = 0;
        k < h;
        k++
      )
        i[g[k]] = k;
      (e.encode = c), (e.decode = d), (a.exports = e);
    },
    function(a, b, c) {
      (function(b) {
        function d() {}
        function e(a) {
          f.call(this, a),
            (this.query = this.query || {}),
            h || (b.___eio || (b.___eio = []), (h = b.___eio)),
            (this.index = h.length);
          var c = this;
          h.push(function(a) {
            c.onData(a);
          }),
            (this.query.j = this.index),
            b.document &&
              b.addEventListener &&
              b.addEventListener(
                "beforeunload",
                function() {
                  c.script && (c.script.onerror = d);
                },
                !1
              );
        }
        var f = c(21),
          g = c(32);
        a.exports = e;
        var h,
          i = /\n/g,
          j = /\\n/g;
        g(e, f),
          (e.prototype.supportsBinary = !1),
          (e.prototype.doClose = function() {
            this.script &&
              (this.script.parentNode.removeChild(this.script),
              (this.script = null)),
              this.form &&
                (this.form.parentNode.removeChild(this.form),
                (this.form = null),
                (this.iframe = null)),
              f.prototype.doClose.call(this);
          }),
          (e.prototype.doPoll = function() {
            var a = this,
              b = document.createElement("script");
            this.script &&
              (this.script.parentNode.removeChild(this.script),
              (this.script = null)),
              (b.async = !0),
              (b.src = this.uri()),
              (b.onerror = function(b) {
                a.onError("jsonp poll error", b);
              });
            var c = document.getElementsByTagName("script")[0];
            c
              ? c.parentNode.insertBefore(b, c)
              : (document.head || document.body).appendChild(b),
              (this.script = b);
            var d =
              "undefined" != typeof navigator &&
              /gecko/i.test(navigator.userAgent);
            d &&
              setTimeout(function() {
                var a = document.createElement("iframe");
                document.body.appendChild(a), document.body.removeChild(a);
              }, 100);
          }),
          (e.prototype.doWrite = function(a, b) {
            function c() {
              d(), b();
            }
            function d() {
              if (e.iframe)
                try {
                  e.form.removeChild(e.iframe);
                } catch (a) {
                  e.onError("jsonp polling iframe removal error", a);
                }
              try {
                var b = '<iframe src="javascript:0" name="' + e.iframeId + '">';
                f = document.createElement(b);
              } catch (a) {
                (f = document.createElement("iframe")),
                  (f.name = e.iframeId),
                  (f.src = "javascript:0");
              }
              (f.id = e.iframeId), e.form.appendChild(f), (e.iframe = f);
            }
            var e = this;
            if (!this.form) {
              var f,
                g = document.createElement("form"),
                h = document.createElement("textarea"),
                k = (this.iframeId = "eio_iframe_" + this.index);
              (g.className = "socketio"),
                (g.style.position = "absolute"),
                (g.style.top = "-1000px"),
                (g.style.left = "-1000px"),
                (g.target = k),
                (g.method = "POST"),
                g.setAttribute("accept-charset", "utf-8"),
                (h.name = "d"),
                g.appendChild(h),
                document.body.appendChild(g),
                (this.form = g),
                (this.area = h);
            }
            (this.form.action = this.uri()),
              d(),
              (a = a.replace(j, "\\\n")),
              (this.area.value = a.replace(i, "\\n"));
            try {
              this.form.submit();
            } catch (l) {}
            this.iframe.attachEvent
              ? (this.iframe.onreadystatechange = function() {
                  "complete" === e.iframe.readyState && c();
                })
              : (this.iframe.onload = c);
          });
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      (function(b) {
        function d(a) {
          var b = a && a.forceBase64;
          b && (this.supportsBinary = !1),
            (this.perMessageDeflate = a.perMessageDeflate),
            (this.usingBrowserWebSocket = l && !a.forceNode),
            (this.protocols = a.protocols),
            this.usingBrowserWebSocket || (n = e),
            f.call(this, a);
        }
        var e,
          f = c(22),
          g = c(23),
          h = c(31),
          i = c(32),
          j = c(33),
          k = c(3)("engine.io-client:websocket"),
          l = b.WebSocket || b.MozWebSocket;
        if ("undefined" == typeof window)
          try {
            e = c(36);
          } catch (m) {}
        var n = l;
        n || "undefined" != typeof window || (n = e),
          (a.exports = d),
          i(d, f),
          (d.prototype.name = "websocket"),
          (d.prototype.supportsBinary = !0),
          (d.prototype.doOpen = function() {
            if (this.check()) {
              var a = this.uri(),
                b = this.protocols,
                c = {
                  agent: this.agent,
                  perMessageDeflate: this.perMessageDeflate
                };
              (c.pfx = this.pfx),
                (c.key = this.key),
                (c.passphrase = this.passphrase),
                (c.cert = this.cert),
                (c.ca = this.ca),
                (c.ciphers = this.ciphers),
                (c.rejectUnauthorized = this.rejectUnauthorized),
                this.extraHeaders && (c.headers = this.extraHeaders),
                this.localAddress && (c.localAddress = this.localAddress);
              try {
                this.ws = this.usingBrowserWebSocket
                  ? b
                    ? new n(a, b)
                    : new n(a)
                  : new n(a, b, c);
              } catch (d) {
                return this.emit("error", d);
              }
              void 0 === this.ws.binaryType && (this.supportsBinary = !1),
                this.ws.supports && this.ws.supports.binary
                  ? ((this.supportsBinary = !0),
                    (this.ws.binaryType = "nodebuffer"))
                  : (this.ws.binaryType = "arraybuffer"),
                this.addEventListeners();
            }
          }),
          (d.prototype.addEventListeners = function() {
            var a = this;
            (this.ws.onopen = function() {
              a.onOpen();
            }),
              (this.ws.onclose = function() {
                a.onClose();
              }),
              (this.ws.onmessage = function(b) {
                a.onData(b.data);
              }),
              (this.ws.onerror = function(b) {
                a.onError("websocket error", b);
              });
          }),
          (d.prototype.write = function(a) {
            function c() {
              d.emit("flush"),
                setTimeout(function() {
                  (d.writable = !0), d.emit("drain");
                }, 0);
            }
            var d = this;
            this.writable = !1;
            for (var e = a.length, f = 0, h = e; f < h; f++)
              !(function(a) {
                g.encodePacket(a, d.supportsBinary, function(f) {
                  if (!d.usingBrowserWebSocket) {
                    var g = {};
                    if (
                      (a.options && (g.compress = a.options.compress),
                      d.perMessageDeflate)
                    ) {
                      var h =
                        "string" == typeof f
                          ? b.Buffer.byteLength(f)
                          : f.length;
                      h < d.perMessageDeflate.threshold && (g.compress = !1);
                    }
                  }
                  try {
                    d.usingBrowserWebSocket ? d.ws.send(f) : d.ws.send(f, g);
                  } catch (i) {
                    k("websocket closed before onclose event");
                  }
                  --e || c();
                });
              })(a[f]);
          }),
          (d.prototype.onClose = function() {
            f.prototype.onClose.call(this);
          }),
          (d.prototype.doClose = function() {
            "undefined" != typeof this.ws && this.ws.close();
          }),
          (d.prototype.uri = function() {
            var a = this.query || {},
              b = this.secure ? "wss" : "ws",
              c = "";
            this.port &&
              (("wss" === b && 443 !== Number(this.port)) ||
                ("ws" === b && 80 !== Number(this.port))) &&
              (c = ":" + this.port),
              this.timestampRequests && (a[this.timestampParam] = j()),
              this.supportsBinary || (a.b64 = 1),
              (a = h.encode(a)),
              a.length && (a = "?" + a);
            var d = this.hostname.indexOf(":") !== -1;
            return (
              b +
              "://" +
              (d ? "[" + this.hostname + "]" : this.hostname) +
              c +
              this.path +
              a
            );
          }),
          (d.prototype.check = function() {
            return !(
              !n ||
              ("__initialize" in n && this.name === d.prototype.name)
            );
          });
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {},
    function(a, b) {
      var c = [].indexOf;
      a.exports = function(a, b) {
        if (c) return a.indexOf(b);
        for (var d = 0; d < a.length; ++d) if (a[d] === b) return d;
        return -1;
      };
    },
    function(a, b) {
      (function(b) {
        var c = /^[\],:{}\s]*$/,
          d = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
          e = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
          f = /(?:^|:|,)(?:\s*\[)+/g,
          g = /^\s+/,
          h = /\s+$/;
        a.exports = function(a) {
          return "string" == typeof a && a
            ? ((a = a.replace(g, "").replace(h, "")),
              b.JSON && JSON.parse
                ? JSON.parse(a)
                : c.test(
                    a
                      .replace(d, "@")
                      .replace(e, "]")
                      .replace(f, "")
                  )
                ? new Function("return " + a)()
                : void 0)
            : null;
        };
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      "use strict";
      function d(a, b, c) {
        (this.io = a),
          (this.nsp = b),
          (this.json = this),
          (this.ids = 0),
          (this.acks = {}),
          (this.receiveBuffer = []),
          (this.sendBuffer = []),
          (this.connected = !1),
          (this.disconnected = !0),
          c && c.query && (this.query = c.query),
          this.io.autoConnect && this.open();
      }
      var e =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function(a) {
                return typeof a;
              }
            : function(a) {
                return a &&
                  "function" == typeof Symbol &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a;
              },
        f = c(7),
        g = c(8),
        h = c(40),
        i = c(41),
        j = c(42),
        k = c(3)("socket.io-client:socket"),
        l = c(31);
      a.exports = b = d;
      var m = {
          connect: 1,
          connect_error: 1,
          connect_timeout: 1,
          connecting: 1,
          disconnect: 1,
          error: 1,
          reconnect: 1,
          reconnect_attempt: 1,
          reconnect_failed: 1,
          reconnect_error: 1,
          reconnecting: 1,
          ping: 1,
          pong: 1
        },
        n = g.prototype.emit;
      g(d.prototype),
        (d.prototype.subEvents = function() {
          if (!this.subs) {
            var a = this.io;
            this.subs = [
              i(a, "open", j(this, "onopen")),
              i(a, "packet", j(this, "onpacket")),
              i(a, "close", j(this, "onclose"))
            ];
          }
        }),
        (d.prototype.open = d.prototype.connect = function() {
          return this.connected
            ? this
            : (this.subEvents(),
              this.io.open(),
              "open" === this.io.readyState && this.onopen(),
              this.emit("connecting"),
              this);
        }),
        (d.prototype.send = function() {
          var a = h(arguments);
          return a.unshift("message"), this.emit.apply(this, a), this;
        }),
        (d.prototype.emit = function(a) {
          if (m.hasOwnProperty(a)) return n.apply(this, arguments), this;
          var b = h(arguments),
            c = { type: f.EVENT, data: b };
          return (
            (c.options = {}),
            (c.options.compress = !this.flags || !1 !== this.flags.compress),
            "function" == typeof b[b.length - 1] &&
              (k("emitting packet with ack id %d", this.ids),
              (this.acks[this.ids] = b.pop()),
              (c.id = this.ids++)),
            this.connected ? this.packet(c) : this.sendBuffer.push(c),
            delete this.flags,
            this
          );
        }),
        (d.prototype.packet = function(a) {
          (a.nsp = this.nsp), this.io.packet(a);
        }),
        (d.prototype.onopen = function() {
          if ((k("transport is open - connecting"), "/" !== this.nsp))
            if (this.query) {
              var a =
                "object" === e(this.query) ? l.encode(this.query) : this.query;
              k("sending connect packet with query %s", a),
                this.packet({ type: f.CONNECT, query: a });
            } else this.packet({ type: f.CONNECT });
        }),
        (d.prototype.onclose = function(a) {
          k("close (%s)", a),
            (this.connected = !1),
            (this.disconnected = !0),
            delete this.id,
            this.emit("disconnect", a);
        }),
        (d.prototype.onpacket = function(a) {
          if (a.nsp === this.nsp)
            switch (a.type) {
              case f.CONNECT:
                this.onconnect();
                break;
              case f.EVENT:
                this.onevent(a);
                break;
              case f.BINARY_EVENT:
                this.onevent(a);
                break;
              case f.ACK:
                this.onack(a);
                break;
              case f.BINARY_ACK:
                this.onack(a);
                break;
              case f.DISCONNECT:
                this.ondisconnect();
                break;
              case f.ERROR:
                this.emit("error", a.data);
            }
        }),
        (d.prototype.onevent = function(a) {
          var b = a.data || [];
          k("emitting event %j", b),
            null != a.id &&
              (k("attaching ack callback to event"), b.push(this.ack(a.id))),
            this.connected ? n.apply(this, b) : this.receiveBuffer.push(b);
        }),
        (d.prototype.ack = function(a) {
          var b = this,
            c = !1;
          return function() {
            if (!c) {
              c = !0;
              var d = h(arguments);
              k("sending ack %j", d), b.packet({ type: f.ACK, id: a, data: d });
            }
          };
        }),
        (d.prototype.onack = function(a) {
          var b = this.acks[a.id];
          "function" == typeof b
            ? (k("calling ack %s with %j", a.id, a.data),
              b.apply(this, a.data),
              delete this.acks[a.id])
            : k("bad ack %s", a.id);
        }),
        (d.prototype.onconnect = function() {
          (this.connected = !0),
            (this.disconnected = !1),
            this.emit("connect"),
            this.emitBuffered();
        }),
        (d.prototype.emitBuffered = function() {
          var a;
          for (a = 0; a < this.receiveBuffer.length; a++)
            n.apply(this, this.receiveBuffer[a]);
          for (this.receiveBuffer = [], a = 0; a < this.sendBuffer.length; a++)
            this.packet(this.sendBuffer[a]);
          this.sendBuffer = [];
        }),
        (d.prototype.ondisconnect = function() {
          k("server disconnect (%s)", this.nsp),
            this.destroy(),
            this.onclose("io server disconnect");
        }),
        (d.prototype.destroy = function() {
          if (this.subs) {
            for (var a = 0; a < this.subs.length; a++) this.subs[a].destroy();
            this.subs = null;
          }
          this.io.destroy(this);
        }),
        (d.prototype.close = d.prototype.disconnect = function() {
          return (
            this.connected &&
              (k("performing disconnect (%s)", this.nsp),
              this.packet({ type: f.DISCONNECT })),
            this.destroy(),
            this.connected && this.onclose("io client disconnect"),
            this
          );
        }),
        (d.prototype.compress = function(a) {
          return (
            (this.flags = this.flags || {}), (this.flags.compress = a), this
          );
        });
    },
    function(a, b) {
      function c(a, b) {
        var c = [];
        b = b || 0;
        for (var d = b || 0; d < a.length; d++) c[d - b] = a[d];
        return c;
      }
      a.exports = c;
    },
    function(a, b) {
      "use strict";
      function c(a, b, c) {
        return (
          a.on(b, c),
          {
            destroy: function() {
              a.removeListener(b, c);
            }
          }
        );
      }
      a.exports = c;
    },
    function(a, b) {
      var c = [].slice;
      a.exports = function(a, b) {
        if (("string" == typeof b && (b = a[b]), "function" != typeof b))
          throw new Error("bind() requires a function");
        var d = c.call(arguments, 2);
        return function() {
          return b.apply(a, d.concat(c.call(arguments)));
        };
      };
    },
    function(a, b) {
      function c(a) {
        (a = a || {}),
          (this.ms = a.min || 100),
          (this.max = a.max || 1e4),
          (this.factor = a.factor || 2),
          (this.jitter = a.jitter > 0 && a.jitter <= 1 ? a.jitter : 0),
          (this.attempts = 0);
      }
      (a.exports = c),
        (c.prototype.duration = function() {
          var a = this.ms * Math.pow(this.factor, this.attempts++);
          if (this.jitter) {
            var b = Math.random(),
              c = Math.floor(b * this.jitter * a);
            a = 0 == (1 & Math.floor(10 * b)) ? a - c : a + c;
          }
          return 0 | Math.min(a, this.max);
        }),
        (c.prototype.reset = function() {
          this.attempts = 0;
        }),
        (c.prototype.setMin = function(a) {
          this.ms = a;
        }),
        (c.prototype.setMax = function(a) {
          this.max = a;
        }),
        (c.prototype.setJitter = function(a) {
          this.jitter = a;
        });
    }
  ]);
});

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                               //
//                           //
//                              //
//                            //
//             //
//                 //
//                                                                                //
//                                //
//                                        //
//                                      //
//                   //
//                           //
//      o              //
//                                                                                //
//////////////////////////////////////////////////////////////////////////////////////

/**
 * sails.io.js
 * v1.2.1
 * ------------------------------------------------------------------------
 * JavaScript Client (SDK) for communicating with Sails.
 *
 * Note that this script is completely optional, but it is handy if you're
 * using WebSockets from the browser to talk to your Sails server.
 *
 * For tips and documentation, visit:
 * http://sailsjs.com/documentation/reference/web-sockets/socket-client
 * ------------------------------------------------------------------------
 *
 * This file allows you to send and receive socket.io messages to & from Sails
 * by simulating a REST client interface on top of socket.io. It models its API
 * after the $.ajax pattern from jQuery you might already be familiar with.
 *
 * So if you're switching from using AJAX to sockets, instead of:
 *    `$.post( url, [data], [cb] )`
 *
 * You would use:
 *    `socket.post( url, [data], [cb] )`
 */

(function() {
  //             
  //      
  //                        
  //                      
  //                  
  //                       
  //

  /**
   * Constant containing the names of all available options
   * for individual sockets.
   *
   * @type {Array}
   */
  var SOCKET_OPTIONS = [
    "useCORSRouteToGetCookie",
    "url",
    "multiplex",
    "transports",
    "query",
    "path",
    "headers",
    "initialConnectionHeaders",
    "reconnection",
    "reconnectionAttempts",
    "reconnectionDelay",
    "reconnectionDelayMax",
    "rejectUnauthorized",
    "randomizationFactor",
    "timeout"
  ];

  /**
   * Constant containing the names of properties on `io.sails` which
   * may be configured using HTML attributes on the script tag which
   * loaded this file.
   *
   * @type {Array}
   *
   * (this is unused if loading from node.js)
   */
  var CONFIGURABLE_VIA_HTML_ATTR = [
    "autoConnect",
    "reconnection",
    "environment",
    "headers",
    "url",
    "transports",
    "path"
  ];

  /**
   * Constant containing the names of querystring
   * parameters sent when connecting any SailsSocket.
   *
   * @type {Dictionary}
   */
  var CONNECTION_METADATA_PARAMS = {
    version: "__sails_io_sdk_version",
    platform: "__sails_io_sdk_platform",
    language: "__sails_io_sdk_language"
  };

  /**
   * Constant containing metadata about the platform, language, and
   * current version of this SDK.
   *
   * @type {Dictionary}
   */
  var SDK_INFO = {
    version: "1.2.1", // <-- pulled automatically from package.json, do not change!
    language: "javascript",
    platform: (function() {
      if ( true && typeof module.exports !== "undefined") {
        return "node";
      } else {
        return "browser";
      }
    })()
  };

  // Build `versionString` (a querystring snippet) by
  // combining SDK_INFO and CONNECTION_METADATA_PARAMS.
  SDK_INFO.versionString =
    CONNECTION_METADATA_PARAMS.version +
    "=" +
    SDK_INFO.version +
    "&" +
    CONNECTION_METADATA_PARAMS.platform +
    "=" +
    SDK_INFO.platform +
    "&" +
    CONNECTION_METADATA_PARAMS.language +
    "=" +
    SDK_INFO.language;

  //                  
  //         
  //               
  //               
  //                    
  //                           
  //
  //         
  //     
  //                         
  //                         
  //                        
  //                           
  //
  //                 
  //        
  //                        
  //                         
  //                             
  //                                    
  //
  //
  // If available, grab the DOM element for the script tag which imported this file.
  // (skip this if this SDK is being used outside of the DOM, i.e. in a Node process)
  //
  // This is used below to parse client-side sails.io.js configuration encoded as
  // HTML attributes, as well as grabbing hold of the URL from whence the SDK was fetched.
  var thisScriptTag = (function() {
    if (
      typeof window !== "object" ||
      typeof window.document !== "object" ||
      typeof window.document.getElementsByTagName !== "function"
    ) {
      return null;
    }

    // Return the URL of the last script loaded (i.e. this one)
    // (this must run before nextTick; see http://stackoverflow.com/a/2976714/486547)
    var allScriptsCurrentlyInDOM = window.document.getElementsByTagName(
      "script"
    );
    return allScriptsCurrentlyInDOM[allScriptsCurrentlyInDOM.length - 1];
  })();

  // Variables to contain src URL and other script tag config (for use below).
  var urlThisScriptWasFetchedFrom = "";
  var scriptTagConfig = {};

  if (thisScriptTag) {
    // Save the URL that this script was fetched from.
    urlThisScriptWasFetchedFrom = thisScriptTag.src;

    // Now parse the most common client-side configuration settings
    // from the script tag where they may be encoded as HTML attributes.
    //
    // Any configuration which may be provided as an HTML attribute may
    // also be provided prefixed with `data-`.  This is for folks who
    // need to support browsers that have issues with nonstandard
    // HTML attributes (or if the idea of using nonstandard HTML attributes
    // just creeps you out)
    //
    // If a `data-` prefixed attr is provided, it takes precedence.
    // (this is so that if you are already using one of these HTML
    //  attrs for some reason, you can keep it as-is and override
    //  it using `data-`. If you are using the `data-` prefixed version
    //  for some other purpose... well, in that case you'll just have to
    //  configure programmatically using `io.sails` instead.)
    CONFIGURABLE_VIA_HTML_ATTR.forEach(function(configKey) {
      scriptTagConfig[configKey] = (function() {
        // Support 'data-' prefixed or normal attributes.
        // (prefixed versions take precedence if provided)
        var htmlAttrVal = thisScriptTag.getAttribute("data-" + configKey);
        if (!htmlAttrVal) {
          htmlAttrVal = thisScriptTag.getAttribute(configKey);
        }

        // The HTML attribute value should always be a string or `null`.
        // We'll try to parse it as JSON and use that, but worst case fall back
        // to the default situation of it being a string.
        if (typeof htmlAttrVal === "string") {
          try {
            return JSON.parse(htmlAttrVal);
          } catch (e) {
            return htmlAttrVal;
          }
        }
        // If `null` was returned from getAttribute(), it means that the HTML attribute
        // was not specified, so we treat it as undefined (which will cause the property
        // to be removed below)
        else if (htmlAttrVal === null) {
          return undefined;
        }
        // Any other contingency shouldn't be possible:
        // - if no quotes are used in the HTML attribute, it still comes in as a string.
        // - if no RHS is provided for the attribute, it still comes in as "" (empty string)
        // (but we still handle this with an explicit error just in case--for debugging and support purposes)
        else
          throw new Error(
            "sails.io.js :: Unexpected/invalid script tag configuration for `" +
              configKey +
              "`: `" +
              htmlAttrVal +
              "` (a `" +
              typeof htmlAttrVal +
              "`). Should be a string."
          );
      })();

      if (scriptTagConfig[configKey] === undefined) {
        delete scriptTagConfig[configKey];
      }
    });

    // Now that they've been parsed, do an extremely lean version of
    // logical type validation/coercion of provided values.
    //////////////////////////////////////////////////////////////////

    // `autoConnect`
    if (typeof scriptTagConfig.autoConnect !== "undefined") {
      if (scriptTagConfig.autoConnect === "") {
        // Special case for empty string.  It means `true` (see above).
        scriptTagConfig.autoConnect = true;
      } else if (typeof scriptTagConfig.autoConnect !== "boolean") {
        throw new Error(
          "sails.io.js :: Unexpected/invalid configuration for `autoConnect` provided in script tag: `" +
            scriptTagConfig.autoConnect +
            "` (a `" +
            typeof scriptTagConfig.autoConnect +
            "`). Should be a boolean."
        );
      }
    }

    // `environment`
    if (typeof scriptTagConfig.environment !== "undefined") {
      if (typeof scriptTagConfig.environment !== "string") {
        throw new Error(
          "sails.io.js :: Unexpected/invalid configuration for `environment` provided in script tag: `" +
            scriptTagConfig.environment +
            "` (a `" +
            typeof scriptTagConfig.environment +
            "`). Should be a string."
        );
      }
    }

    // `headers`
    if (typeof scriptTagConfig.headers !== "undefined") {
      if (
        typeof scriptTagConfig.headers !== "object" ||
        Array.isArray(scriptTagConfig.headers)
      ) {
        throw new Error(
          "sails.io.js :: Unexpected/invalid configuration for `headers` provided in script tag: `" +
            scriptTagConfig.headers +
            "` (a `" +
            typeof scriptTagConfig.headers +
            '`). Should be a JSON-compatible dictionary (i.e. `{}`).  Don\'t forget those double quotes (""), even on key names!  Use single quotes (\'\') to wrap the HTML attribute value; e.g. `headers=\'{"X-Auth": "foo"}\'`'
        );
      }
    }

    // `url`
    if (typeof scriptTagConfig.url !== "undefined") {
      if (typeof scriptTagConfig.url !== "string") {
        throw new Error(
          "sails.io.js :: Unexpected/invalid configuration for `url` provided in script tag: `" +
            scriptTagConfig.url +
            "` (a `" +
            typeof scriptTagConfig.url +
            "`). Should be a string."
        );
      }
    }

    // OTHER `io.sails` options are NOT CURRENTLY SUPPORTED VIA HTML ATTRIBUTES.
  }

  // Grab a reference to the global socket.io client (if one is available).
  // This is used via closure below to determine which `io` to use when the
  // socket.io client instance (`io`) is augmented to become the Sails client
  // SDK instance (still `io`).
  var _existingGlobalSocketIO = typeof io !== "undefined" ? io : undefined;

  //////////////////////////////////////////////////////////////
  /////
  ///// NOW FOR BUNCHES OF:
  /////  - PRIVATE FUNCTION DEFINITIONS
  /////  - CONSTRUCTORS
  /////  - AND METHODS
  /////
  //////////////////////////////////////////////////////////////
  //

  //                                
  //                          
  //                          
  //                         
  //                    
  //                        
  //

  /**
   * SailsIOClient()
   *
   * Augment the provided Socket.io client object (`io`) with methods for
   * talking and listening to one or more Sails backend(s).  If no `io` was
   * provided (i.e. in a browser setting), then attempt to use the global.
   *
   * This absorbs implicit `io.sails` configuration, sets a timer for
   * automatically connecting a socket (if `io.sails.autoConnect` is enabled)
   * and returns the augmented `io`.
   *
   * Note:
   * The automatically-connected socket is exposed as `io.socket`.  If this
   * socket attempts to bind event listeners or send requests before it is
   * connected, it will be queued up and replayed when the connection is
   * successfully opened.
   *
   * @param {SocketIO} io
   * @returns {SailsIOClient} [also called `io`]
   */

  function SailsIOClient(_providedSocketIO) {
    // First, determine which `io` we're augmenting.
    //
    // Prefer the passed-in `io` instance, but fall back to the
    // global one if we've got it.
    var io;
    if (_providedSocketIO) {
      io = _providedSocketIO;
    } else {
      io = _existingGlobalSocketIO;
    }
    // (note that for readability, we deliberately do not short circuit or use the tertiary operator above)

    // If a socket.io client (`io`) is not available, none of this will work.
    if (!io) {
      // If node:
      if (SDK_INFO.platform === "node") {
        throw new Error(
          "No socket.io client available.  When requiring `sails.io.js` from Node.js, a socket.io client (`io`) must be passed in; e.g.:\n```\nvar io = require('sails.io.js')( require('socket.io-client') )\n```\n(see https://github.com/balderdashy/sails.io.js/tree/master/test for more examples)"
        );
      }
      // Otherwise, this is a web browser:
      else {
        throw new Error(
          "The Sails socket SDK depends on the socket.io client, but the socket.io global (`io`) was not available when `sails.io.js` loaded.  Normally, the socket.io client code is bundled with sails.io.js, so something is a little off.  Please check to be sure this version of `sails.io.js` has the minified Socket.io client at the top of the file."
        );
      }
    }

    // If the chosen socket.io client (`io`) has ALREADY BEEN AUGMENTED by this SDK,
    // (i.e. if it already has a `.sails` property) then throw an error.
    if (io.sails) {
      // If node:
      if (SDK_INFO.platform === "node") {
        throw new Error(
          "The provided socket.io client (`io`) has already been augmented into a Sails socket SDK instance (it has `io.sails`)."
        );
      }
      // Otherwise, this is a web browser:
      else {
        throw new Error(
          "The socket.io client (`io`) has already been augmented into a Sails socket SDK instance.  Usually, this means you are bringing `sails.io.js` onto the page more than once."
        );
      }
    }

    /**
     * A little logger for this library to use internally.
     * Basically just a wrapper around `console.log` with
     * support for feature-detection.
     *
     * @api private
     * @factory
     */
    function LoggerFactory(options) {
      options = options || {
        prefix: true
      };

      // If `console.log` is not accessible, `log` is a noop.
      if (
        typeof console !== "object" ||
        typeof console.log !== "function" ||
        typeof console.log.bind !== "function"
      ) {
        return function noop() {};
      }

      return function log() {
        var args = Array.prototype.slice.call(arguments);

        // All logs are disabled when `io.sails.environment = 'production'`.
        if (io.sails.environment === "production") return;

        // Add prefix to log messages (unless disabled)
        var PREFIX = "";
        if (options.prefix) {
          args.unshift(PREFIX);
        }

        // Call wrapped logger
        console.log.bind(console).apply(this, args);
      };
    } //</LoggerFactory>

    // Create a private logger instance
    var consolog = LoggerFactory();
    consolog.noPrefix = LoggerFactory({
      prefix: false
    });

    /**
     * What is the `requestQueue`?
     *
     * The request queue is used to simplify app-level connection logic--
     * i.e. so you don't have to wait for the socket to be connected
     * to start trying to  synchronize data.
     *
     * @api private
     * @param  {SailsSocket}  socket
     */

    function runRequestQueue(socket) {
      var queue = socket.requestQueue;

      if (!queue) return;
      for (var i in queue) {
        // Double-check that `queue[i]` will not
        // inadvertently discover extra properties attached to the Object
        // and/or Array prototype by other libraries/frameworks/tools.
        // (e.g. Ember does this. See https://github.com/balderdashy/sails.io.js/pull/5)
        var isSafeToDereference = {}.hasOwnProperty.call(queue, i);
        if (isSafeToDereference) {
          // Get the arguments that were originally made to the "request" method
          var requestArgs = queue[i];
          // Call the request method again in the context of the socket, with the original args
          socket.request.apply(socket, requestArgs);
        }
      }

      // Now empty the queue to remove it as a source of additional complexity.
      socket.requestQueue = null;
    }

    /**
     * Send a JSONP request.
     *
     * @param  {Object}   opts [optional]
     * @param  {Function} cb
     * @return {XMLHttpRequest}
     */

    function jsonp(opts, cb) {
      opts = opts || {};

      if (typeof window === "undefined") {
        // FUTURE: refactor node usage to live in here
        return cb();
      }

      var scriptEl = document.createElement("script");
      window._sailsIoJSConnect = function(response) {
        // In rare circumstances our script may have been vaporised.
        // Remove it, but only if it still exists
        // https://github.com/balderdashy/sails.io.js/issues/92
        if (scriptEl && scriptEl.parentNode) {
          scriptEl.parentNode.removeChild(scriptEl);
        }

        cb(response);
      };
      scriptEl.src = opts.url;
      document.getElementsByTagName("head")[0].appendChild(scriptEl);
    }

    //                            
    //                    
    //                             
    //                        
    //              
    //                         
    //
    //                        
    //                 
    //                       
    //                   
    //                
    //                        
    //

    /**
     * The JWR (JSON WebSocket Response) received from a Sails server.
     *
     * @api public
     * @param  {Object}  responseCtx
     *         => :body
     *         => :statusCode
     *         => :headers
     *
     * @constructor
     */

    function JWR(responseCtx) {
      this.body = responseCtx.body;
      this.headers = responseCtx.headers || {};
      this.statusCode =
        typeof responseCtx.statusCode === "undefined"
          ? 200
          : responseCtx.statusCode;
      // FUTURE: Replace this typeof short-circuit with an assertion (statusCode should always be set)

      if (this.statusCode < 200 || this.statusCode >= 400) {
        // Determine the appropriate error message.
        var msg;
        if (this.statusCode === 0) {
          msg = "The socket request failed.";
        } else {
          msg = "Server responded with a " + this.statusCode + " status code";
          msg += ":\n```\n" + JSON.stringify(this.body, null, 2) + "\n```";
          // (^^Note that we should always be able to rely on socket.io to give us
          // non-circular data here, so we don't have to worry about wrapping the
          // above in a try...catch)
        }

        // Now build and attach Error instance.
        this.error = new Error(msg);
      }
    }
    JWR.prototype.toString = function() {
      return (
        "[ResponseFromSails]" +
        "  -- " +
        "Status: " +
        this.statusCode +
        "  -- " +
        "Headers: " +
        this.headers +
        "  -- " +
        "Body: " +
        this.body
      );
    };
    JWR.prototype.toPOJO = function() {
      return {
        body: this.body,
        headers: this.headers,
        statusCode: this.statusCode
      };
    };
    JWR.prototype.pipe = function() {
      // FUTURE: look at substack's stuff
      return new Error("Client-side streaming support not implemented yet.");
    };

    //                    
    //            
    //                         
    //                         
    //                   
    //                            
    //

    /**
     * @api private
     * @param  {SailsSocket} socket  [description]
     * @param  {Object} requestCtx [description]
     */

    function _emitFrom(socket, requestCtx) {
      if (!socket._raw) {
        throw new Error(
          "Failed to emit from socket- raw SIO socket is missing."
        );
      }

      // Since callback is embedded in requestCtx,
      // retrieve it and delete the key before continuing.
      var cb = requestCtx.cb;
      delete requestCtx.cb;

      // Name of the appropriate socket.io listener on the server
      // ( === the request method or "verb", e.g. 'get', 'post', 'put', etc. )
      var sailsEndpoint = requestCtx.method;

      socket._raw.emit(sailsEndpoint, requestCtx, function serverResponded(
        responseCtx
      ) {
        // Send back (emulatedHTTPBody, jsonWebSocketResponse)
        if (cb && !requestCtx.calledCb) {
          cb(responseCtx.body, new JWR(responseCtx));
          // Set flag indicating that callback was called, to avoid duplicate calls.
          requestCtx.calledCb = true;
          // Remove the callback from the list.
          socket._responseCbs.splice(socket._responseCbs.indexOf(cb), 1);
          // Remove the context from the list.
          socket._requestCtxs.splice(
            socket._requestCtxs.indexOf(requestCtx),
            1
          );
        }
      });
    }

    //              
    //        
    //                     
    //                     
    //         
    //            
    //

    /**
     * SailsSocket
     *
     * A wrapper for an underlying Socket instance that communicates directly
     * to the Socket.io server running inside of Sails.
     *
     * If no `socket` option is provied, SailsSocket will function as a mock. It will queue socket
     * requests and event handler bindings, replaying them when the raw underlying socket actually
     * connects. This is handy when we don't necessarily have the valid configuration to know
     * WHICH SERVER to talk to yet, etc.  It is also used by `io.socket` for your convenience.
     *
     * @constructor
     * @api private
     *
     * ----------------------------------------------------------------------
     * Note: This constructor should not be used directly. To obtain a `SailsSocket`
     * instance of your very own, run:
     * ```
     * var mySocket = io.sails.connect();
     * ```
     * ----------------------------------------------------------------------
     */
    function SailsSocket(opts) {
      var self = this;
      opts = opts || {};

      // Initialize private properties
      self._isConnecting = false;
      self._mightBeAboutToAutoConnect = false;

      // Set up connection options so that they can only be changed when socket is disconnected.
      var _opts = {};
      SOCKET_OPTIONS.forEach(function(option) {
        // Okay to change global headers while socket is connected
        if (option == "headers") {
          return;
        }
        Object.defineProperty(self, option, {
          get: function() {
            if (option == "url") {
              return (
                _opts[option] || (self._raw && self._raw.io && self._raw.io.uri)
              );
            }
            return _opts[option];
          },
          set: function(value) {
            // Don't allow value to be changed while socket is connected
            if (
              self.isConnected() &&
              io.sails.strict !== false &&
              value != _opts[option]
            ) {
              throw new Error(
                "Cannot change value of `" +
                  option +
                  "` while socket is connected."
              );
            }
            // If socket is attempting to reconnect, stop it.
            if (
              self._raw &&
              self._raw.io &&
              self._raw.io.reconnecting &&
              !self._raw.io.skipReconnect
            ) {
              self._raw.io.skipReconnect = true;
              consolog(
                "Stopping reconnect; use .reconnect() to connect socket after changing options."
              );
            }
            _opts[option] = value;
          }
        });
      });

      // Absorb opts into SailsSocket instance
      // See http://sailsjs.com/documentation/reference/web-sockets/socket-client/sails-socket/properties
      // for description of options
      SOCKET_OPTIONS.forEach(function(option) {
        self[option] = opts[option];
      });

      // Set up "eventQueue" to hold event handlers which have not been set on the actual raw socket yet.
      self.eventQueue = {};

      // Listen for special `parseError` event sent from sockets hook on the backend
      // if an error occurs but a valid callback was not received from the client
      // (i.e. so the server had no other way to send back the error information)
      self.on("sails:parseError", function(err) {
        consolog(
          "Sails encountered an error parsing a socket message sent from this client, and did not have access to a callback function to respond with."
        );
        consolog("Error details:", err);
      });

      // FUTURE:
      // Listen for a special private message on any connected that allows the server
      // to set the environment (giving us 100% certainty that we guessed right)
      // However, note that the `console.log`s called before and after connection
      // are still forced to rely on our existing heuristics (to disable, tack #production
      // onto the URL used to fetch this file.)
    } //</SailsSocket>

    /**
     * `SailsSocket.prototype._connect()`
     *
     * Begin connecting this socket to the server.
     *
     * @api private
     */
    SailsSocket.prototype._connect = function() {
      var self = this;

      self._isConnecting = true;

      // Apply `io.sails` config as defaults
      // (now that at least one tick has elapsed)
      // See http://sailsjs.com/documentation/reference/web-sockets/socket-client/sails-socket/properties
      // for description of options and default values
      SOCKET_OPTIONS.forEach(function(option) {
        if ("undefined" == typeof self[option]) {
          self[option] = io.sails[option];
        }
      });

      // Headers that will be sent with the initial request to /socket.io (Node.js only)
      self.extraHeaders = self.initialConnectionHeaders || {};

      // For browser usage (currently works with "polling" transport only)
      self.transportOptions = self.transportOptions || {};
      self.transports.forEach(function(transport) {
        self.transportOptions[transport] =
          self.transportOptions[transport] || {};
        self.transportOptions[transport].extraHeaders =
          self.initialConnectionHeaders || {};
      });

      // Log a warning if non-Node.js platform attempts to use `initialConnectionHeaders` for anything other than `polling`.
      if (
        (self.initialConnectionHeaders &&
          SDK_INFO.platform !== "node" &&
          self.transports.indexOf("polling") === -1) ||
        self.transports.length > 1
      ) {
        if (typeof console === "object" && typeof console.warn === "function") {
          console.warn(
            "When running in browser, `initialConnectionHeaders` option is only available for the `polling` transport."
          );
        }
      }

      // Ensure URL has no trailing slash
      self.url = self.url ? self.url.replace(/(\/)$/, "") : undefined;

      // Mix the current SDK version into the query string in
      // the connection request to the server:
      if (typeof self.query === "string") {
        // (If provided as a string, trim leading question mark,
        // just in case one was provided.)
        self.query = self.query.replace(/^\?/, "");
        self.query += "&" + SDK_INFO.versionString;
      } else if (self.query && typeof self.query === "object") {
        throw new Error(
          "`query` setting does not currently support configuration as a dictionary (`{}`).  Instead, it must be specified as a string like `foo=89&bar=hi`"
        );
      } else if (!self.query) {
        self.query = SDK_INFO.versionString;
      } else {
        throw new Error(
          "Unexpected data type provided for `query` setting: " + self.query
        );
      }

      // Determine whether this is a cross-origin socket by examining the
      // hostname and port on the `window.location` object.  If it's cross-origin,
      // we'll attempt to get a cookie for the domain so that a Sails session can
      // be established.
      var isXOrigin = (function() {
        // If `window` doesn't exist (i.e. being used from Node.js), then
        // we won't bother attempting to get a cookie.  If you're using sockets
        // from Node.js and find you need to share a session between multiple
        // socket connections, you'll need to make an HTTP request to the /__getcookie
        // endpoint of the Sails server (or any endpoint that returns a set-cookie header)
        // and then use the cookie value in the `initialConnectionHeaders` option to
        // io.sails.connect()
        if (
          typeof window === "undefined" ||
          typeof window.location === "undefined"
        ) {
          return false;
        }

        // If `self.url` (aka "target") is falsy, then we don't need to worry about it.
        if (typeof self.url !== "string") {
          return false;
        }

        // Get information about the "target" (`self.url`)
        var targetProtocol = (function() {
          try {
            targetProtocol = self.url.match(/^([a-z]+:\/\/)/i)[1].toLowerCase();
          } catch (e) {}
          targetProtocol = targetProtocol || "http://";
          return targetProtocol;
        })();
        var isTargetSSL = !!self.url.match("^https");
        var targetPort = (function() {
          try {
            return self.url.match(/^[a-z]+:\/\/[^:]*:([0-9]*)/i)[1];
          } catch (e) {}
          return isTargetSSL ? "443" : "80";
        })();
        var targetAfterProtocol = self.url.replace(/^([a-z]+:\/\/)/i, "");

        // If target protocol is different than the actual protocol,
        // then we'll consider this cross-origin.
        if (
          targetProtocol.replace(/[:\/]/g, "") !==
          window.location.protocol.replace(/[:\/]/g, "")
        ) {
          return true;
        }

        // If target hostname is different than actual hostname, we'll consider this cross-origin.
        var hasSameHostname =
          targetAfterProtocol.search(window.location.hostname) === 0;
        if (!hasSameHostname) {
          return true;
        }

        // If no actual port is explicitly set on the `window.location` object,
        // we'll assume either 80 or 443.
        var isLocationSSL = window.location.protocol.match(/https/i);
        var locationPort =
          window.location.port + "" || (isLocationSSL ? "443" : "80");

        // Finally, if ports don't match, we'll consider this cross-origin.
        if (targetPort !== locationPort) {
          return true;
        }

        // Otherwise, it's the same origin.
        return false;
      })();

      // Prepare to start connecting the socket
      (function selfInvoking(cb) {
        // If this is an attempt at a cross-origin or cross-port
        // socket connection via a browswe, send a JSONP request
        // first to ensure that a valid cookie is available.
        // This can be disabled by setting `io.sails.useCORSRouteToGetCookie`
        // to false.
        //
        // Otherwise, skip the stuff below.
        //
        if (!(self.useCORSRouteToGetCookie && isXOrigin)) {
          return cb();
        }

        // Figure out the x-origin CORS route
        // (Sails provides a default)
        var xOriginCookieURL = self.url;
        if (typeof self.useCORSRouteToGetCookie === "string") {
          xOriginCookieURL += self.useCORSRouteToGetCookie;
        } else {
          xOriginCookieURL += "/__getcookie";
        }

        // Make the AJAX request (CORS)
        jsonp(
          {
            url: xOriginCookieURL,
            method: "GET"
          },
          cb
        );
      })(function goAheadAndActuallyConnect() {
        // Now that we're ready to connect, create a raw underlying Socket
        // using Socket.io and save it as `_raw` (this will start it connecting)
        self._raw = io(self.url, self);

        // If the low-level transport throws an error _while connecting_, then set the _isConnecting flag
        // to false (since we're no longer connecting with any chance of success anyway).
        // Also, in this case (and in dev mode only) log a helpful message.
        self._raw.io.engine.transport.on("error", function(err) {
          if (!self._isConnecting) {
            return;
          }

          self._isConnecting = false;

          // Track this timestamp for use in reconnection messages
          // (only relevant if reconnection is enabled.)
          self.connectionErrorTimestamp = new Date().getTime();

          // Development-only message:
          consolog("====================================");
          consolog("The socket was unable to connect.");
          consolog("The server may be offline, or the");
          consolog("socket may have failed authorization");
          consolog("based on its origin or other factors.");
          consolog("You may want to check the values of");
          consolog("`sails.config.sockets.onlyAllowOrigins`");
          consolog("or (more rarely) `sails.config.sockets.beforeConnect`");
          consolog("in your app.");
          consolog("More info: https://sailsjs.com/config/sockets");
          consolog("For help: https://sailsjs.com/support");
          consolog("");
          consolog("Technical details:");
          consolog(err);
          consolog("====================================");
        });

        // Replay event bindings from the eager socket
        self.replay();

        /**
         * 'connect' event is triggered when the socket establishes a connection
         *  successfully.
         */
        self.on("connect", function socketConnected() {
          self._isConnecting = false;
          consolog.noPrefix(
            "\n" +
              "\n" +
              // '    |>    ' + '\n' +
              // '  \\___/  '+
              // '\n'+
              "  |>    Now connected to " +
              (self.url ? self.url : "Sails") +
              "." +
              "\n" +
              "\\___/   For help, see: http://bit.ly/2q0QDpf" +
              "\n" +
              "        (using sails.io.js " +
              io.sails.sdk.platform +
              " SDK @v" +
              io.sails.sdk.version +
              ")" +
              "\n" +
              "         Connected at: " +
              new Date() +
              "\n" +
              "\n" +
              "\n" +
              // '\n'+
              ""
            // '  (development mode)'
            // 'e.g. to send a GET request to Sails via WebSockets, run:'+ '\n' +
            // '`io.socket.get("/foo", function serverRespondedWith (body, jwr) { console.log(body); })`'+ '\n' +
          );
        });

        self.on("disconnect", function() {
          // Get a timestamp of when the disconnect was detected.
          self.connectionLostTimestamp = new Date().getTime();

          // Get a shallow clone of the internal array of response callbacks, in case any of the callbacks mutate it.
          var responseCbs = [].concat(self._responseCbs || []);
          // Wipe the internal array of response callbacks before executing them, in case a callback happens to add
          // a new request to the queue.
          self._responseCbs = [];

          // Do the same for the internal request context list.
          var requestCtxs = [].concat(self._requestCtxs || []);
          self._requestCtxs = [];

          // Loop through the callbacks for all in-progress requests, and call them each with an error indicating the disconnect.
          if (responseCbs.length) {
            responseCbs.forEach(function(responseCb) {
              responseCb(
                new Error(
                  "The socket disconnected before the request completed."
                ),
                {
                  body: null,
                  statusCode: 0,
                  headers: {}
                }
              );
            });
          }

          // If there is a list of request contexts, indicate that their callbacks have been
          // called and then wipe the list.  This prevents errors in the edge case of a response
          // somehow coming back after the socket reconnects.
          if (requestCtxs.length) {
            requestCtxs.forEach(function(requestCtx) {
              requestCtx.calledCb = true;
            });
          }

          consolog("====================================");
          consolog("Socket was disconnected from Sails.");
          consolog(
            "Usually, this is due to one of the following reasons:" +
              "\n" +
              " -> the server " +
              (self.url ? self.url + " " : "") +
              "was taken down" +
              "\n" +
              " -> your browser lost internet connectivity"
          );
          consolog("====================================");
        });

        self.on("reconnecting", function(numAttempts) {
          consolog(
            "\n" +
              "        Socket is trying to reconnect to " +
              (self.url ? self.url : "Sails") +
              "...\n" +
              "_-|>_-  (attempt #" +
              numAttempts +
              ")" +
              "\n" +
              "\n"
          );
        });

        self.on("reconnect", function(transport, numAttempts) {
          if (!self._isConnecting) {
            self.on("connect", runRequestQueue.bind(self, self));
          }

          var msSinceLastOffline;
          var numSecsOffline;
          if (self.connectionLostTimestamp) {
            msSinceLastOffline =
              new Date().getTime() - self.connectionLostTimestamp;
            numSecsOffline = msSinceLastOffline / 1000;
          } else if (self.connectionErrorTimestamp) {
            msSinceLastOffline =
              new Date().getTime() - self.connectionErrorTimestamp;
            numSecsOffline = msSinceLastOffline / 1000;
          } else {
            msSinceLastOffline = "???";
            numSecsOffline = "???";
          }

          consolog(
            "\n" +
              "  |>    Socket reconnected successfully after" +
              "\n" +
              "\\___/   being offline at least " +
              numSecsOffline +
              " seconds." +
              "\n" +
              "\n"
          );
        });

        // 'error' event is triggered if connection can not be established.
        // (usually because of a failed authorization, which is in turn
        // usually due to a missing or invalid cookie)
        self.on("error", function failedToConnect(err) {
          self._isConnecting = false;
          ////////////////////////////////////////////////////////////////////////////////////
          // Note:
          // In the future, we could provide a separate event for when a socket cannot connect
          // due to a failed `beforeConnect` (aka "authorization" if you're old school).
          // this could probably be implemented by emitting a special event from the server.
          ////////////////////////////////////////////////////////////////////////////////////

          consolog(
            "Failed to connect socket (possibly due to failed `beforeConnect` on server)",
            "Error:",
            err
          );
        });
      });
    };

    /**
     * Reconnect the underlying socket.
     *
     * @api public
     */
    SailsSocket.prototype.reconnect = function() {
      if (this._isConnecting) {
        throw new Error("Cannot connect- socket is already connecting");
      }
      if (this.isConnected()) {
        throw new Error("Cannot connect- socket is already connected");
      }
      return this._connect();
    };

    /**
     * Disconnect the underlying socket.
     *
     * @api public
     */
    SailsSocket.prototype.disconnect = function() {
      this._isConnecting = false;
      if (!this.isConnected()) {
        throw new Error("Cannot disconnect- socket is already disconnected");
      }
      return this._raw.disconnect();
    };

    /**
     * isConnected
     *
     * @return {Boolean} whether the socket is connected and able to
     *                   communicate w/ the server.
     */

    SailsSocket.prototype.isConnected = function() {
      if (!this._raw) {
        return false;
      }

      return !!this._raw.connected;
    };

    /**
     * isConnecting
     *
     * @return {Boolean} whether the socket is in the process of connecting
     *                   to the server.
     */

    SailsSocket.prototype.isConnecting = function() {
      return this._isConnecting;
    };

    /**
     * isConnecting
     *
     * @return {Boolean} flag that is `true` after a SailsSocket instance is
     *                   initialized but before one tick of the event loop
     *                   has passed (so that it hasn't attempted to connect
     *                   yet, if autoConnect ends up being configured `true`)
     */
    SailsSocket.prototype.mightBeAboutToAutoConnect = function() {
      return this._mightBeAboutToAutoConnect;
    };

    /**
     * [replay description]
     * @return {[type]} [description]
     */
    SailsSocket.prototype.replay = function() {
      var self = this;

      // Pass events and a reference to the request queue
      // off to the self._raw for consumption
      for (var evName in self.eventQueue) {
        for (var i in self.eventQueue[evName]) {
          self._raw.on(evName, self.eventQueue[evName][i]);
        }
      }

      // Bind a one-time function to run the request queue
      // when the self._raw connects.
      if (!self.isConnected()) {
        self._raw.once("connect", runRequestQueue.bind(self, self));
      }
      // Or run it immediately if self._raw is already connected
      else {
        runRequestQueue(self);
      }

      return self;
    };

    /**
     * Chainable method to bind an event to the socket.
     *
     * @param  {String}   evName [event name]
     * @param  {Function} fn     [event handler function]
     * @return {SailsSocket}
     */
    SailsSocket.prototype.on = function(evName, fn) {
      // Bind the event to the raw underlying socket if possible.
      if (this._raw) {
        this._raw.on(evName, fn);
        return this;
      }

      // Otherwise queue the event binding.
      if (!this.eventQueue[evName]) {
        this.eventQueue[evName] = [fn];
      } else {
        this.eventQueue[evName].push(fn);
      }

      return this;
    };

    /**
     * Chainable method to unbind an event from the socket.
     *
     * @param  {String}   evName [event name]
     * @param  {Function} fn     [event handler function]
     * @return {SailsSocket}
     */
    SailsSocket.prototype.off = function(evName, fn) {
      // Bind the event to the raw underlying socket if possible.
      if (this._raw) {
        this._raw.off(evName, fn);
        return this;
      }

      // Otherwise queue the event binding.
      if (this.eventQueue[evName] && this.eventQueue[evName].indexOf(fn) > -1) {
        this.eventQueue[evName].splice(this.eventQueue[evName].indexOf(fn), 1);
      }

      return this;
    };

    /**
     * Chainable method to unbind all events from the socket.
     *
     * @return {SailsSocket}
     */
    SailsSocket.prototype.removeAllListeners = function() {
      // Bind the event to the raw underlying socket if possible.
      if (this._raw) {
        this._raw.removeAllListeners();
        return this;
      }

      // Otherwise queue the event binding.
      this.eventQueue = {};

      return this;
    };

    /**
     * Simulate a GET request to sails
     * e.g.
     *    `socket.get('/user/3', Stats.populate)`
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} data   ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype.get = function(url, data, cb) {
      // `data` is optional
      if (typeof data === "function") {
        cb = data;
        data = {};
      }

      return this.request(
        {
          method: "get",
          params: data,
          url: url
        },
        cb
      );
    };

    /**
     * Simulate a POST request to sails
     * e.g.
     *    `socket.post('/event', newMeeting, $spinner.hide)`
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} data   ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype.post = function(url, data, cb) {
      // `data` is optional
      if (typeof data === "function") {
        cb = data;
        data = {};
      }

      return this.request(
        {
          method: "post",
          data: data,
          url: url
        },
        cb
      );
    };

    /**
     * Simulate a PUT request to sails
     * e.g.
     *    `socket.post('/event/3', changedFields, $spinner.hide)`
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} data   ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype.put = function(url, data, cb) {
      // `data` is optional
      if (typeof data === "function") {
        cb = data;
        data = {};
      }

      return this.request(
        {
          method: "put",
          params: data,
          url: url
        },
        cb
      );
    };

    /**
     * Simulate a PATCH request to sails
     * e.g.
     *    `socket.patch('/event/3', changedFields, $spinner.hide)`
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} data   ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype.patch = function(url, data, cb) {
      // `data` is optional
      if (typeof data === "function") {
        cb = data;
        data = {};
      }

      return this.request(
        {
          method: "patch",
          params: data,
          url: url
        },
        cb
      );
    };

    /**
     * Simulate a DELETE request to sails
     * e.g.
     *    `socket.delete('/event', $spinner.hide)`
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} data   ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype["delete"] = function(url, data, cb) {
      // `data` is optional
      if (typeof data === "function") {
        cb = data;
        data = {};
      }

      return this.request(
        {
          method: "delete",
          params: data,
          url: url
        },
        cb
      );
    };

    /**
     * Simulate an HTTP request to sails
     * e.g.
     * ```
     * socket.request({
     *   url:'/user',
     *   params: {},
     *   method: 'POST',
     *   headers: {}
     * }, function (responseBody, JWR) {
     *   // ...
     * });
     * ```
     *
     * @api public
     * @option {String} url    ::    destination URL
     * @option {Object} params ::    parameters to send with the request [optional]
     * @option {Object} headers::    headers to send with the request [optional]
     * @option {Function} cb   ::    callback function to call when finished [optional]
     * @option {String} method ::    HTTP request method [optional]
     */

    SailsSocket.prototype.request = function(options, cb) {
      var usage =
        "Usage:\n" +
        "socket.request( options, [fnToCallWhenComplete] )\n\n" +
        'options.url :: e.g. "/foo/bar"' +
        "\n" +
        'options.method :: e.g. "get", "post", "put", or "delete", etc.' +
        "\n" +
        'options.params :: e.g. { emailAddress: "mike@example.com" }' +
        "\n" +
        'options.headers :: e.g. { "x-my-custom-header": "some string" }';
      // Old usage:
      // var usage = 'Usage:\n socket.'+(options.method||'request')+'('+
      //   ' destinationURL, [dataToSend], [fnToCallWhenComplete] )';

      // Validate options and callback
      if (typeof cb !== "undefined" && typeof cb !== "function") {
        throw new Error("Invalid callback function!\n" + usage);
      }
      if (typeof options !== "object" || typeof options.url !== "string") {
        throw new Error("Invalid or missing URL!\n" + usage);
      }
      if (options.method && typeof options.method !== "string") {
        throw new Error(
          'Invalid `method` provided (should be a string like "post" or "put")\n' +
            usage
        );
      }
      if (options.headers && typeof options.headers !== "object") {
        throw new Error(
          "Invalid `headers` provided (should be a dictionary with string values)\n" +
            usage
        );
      }
      if (options.params && typeof options.params !== "object") {
        throw new Error(
          "Invalid `params` provided (should be a dictionary with JSON-serializable values)\n" +
            usage
        );
      }
      if (options.data && typeof options.data !== "object") {
        throw new Error(
          "Invalid `data` provided (should be a dictionary with JSON-serializable values)\n" +
            usage
        );
      }

      // Accept either `params` or `data` for backwards compatibility (but not both!)
      if (options.data && options.params) {
        throw new Error(
          "Cannot specify both `params` and `data`!  They are aliases of each other.\n" +
            usage
        );
      } else if (options.data) {
        options.params = options.data;
        delete options.data;
      }

      // If this socket is not connected yet, queue up this request
      // instead of sending it.
      // (so it can be replayed when the socket comes online.)
      if (!this.isConnected()) {
        // If no queue array exists for this socket yet, create it.
        this.requestQueue = this.requestQueue || [];
        this.requestQueue.push([options, cb]);
        return;
      }

      // Otherwise, our socket is connected, so continue prepping
      // the request.

      // Default headers to an empty object
      options.headers = options.headers || {};

      // Build a simulated request object
      // (and sanitize/marshal options along the way)
      var requestCtx = {
        method: (options.method || "get").toLowerCase(),

        headers: options.headers,

        data: options.params || options.data || {},

        // Remove trailing slashes and spaces to make packets smaller.
        url: options.url.replace(/^(.+)\/*\s*$/, "$1"),

        cb: cb
      };

      // Get a reference to the callback list, or create a new one.
      this._responseCbs = this._responseCbs || [];

      // Get a reference to the request context list, or create a new one.
      this._requestCtxs = this._requestCtxs || [];

      // Add this callback to the list.  If the socket disconnects, we'll call
      // each cb in the list with an error and reset the list.  Otherwise the
      // cb will be removed from the list when the server responds.
      // Also add the request context to the list.  It will be removed once
      // the response comes back, or if the socket disconnects.
      if (cb) {
        this._responseCbs.push(cb);
        this._requestCtxs.push(requestCtx);
      }

      // Merge global headers in, if there are any.
      if (this.headers && "object" === typeof this.headers) {
        for (var header in this.headers) {
          if (!options.headers.hasOwnProperty(header)) {
            options.headers[header] = this.headers[header];
          }
        }
      }

      // Send the request.
      _emitFrom(this, requestCtx);
    };

    /**
     * Socket.prototype._request
     *
     * Simulate HTTP over Socket.io.
     *
     * @api private
     * @param  {[type]}   options [description]
     * @param  {Function} cb      [description]
     */
    SailsSocket.prototype._request = function(options, cb) {
      throw new Error(
        "`_request()` was a private API deprecated as of v0.11 of the sails.io.js client. Use `.request()` instead."
      );
    };

    //              
    //          
    //             
    //             
    //    
    //      
    //
    // Set an `io.sails` object that may be used for configuration before the
    // first socket connects (i.e. to allow auto-connect behavior to be
    // prevented by setting `io.sails.autoConnect` in an inline script
    // directly after the script tag which loaded this file).

    //                
    //                           
    //                    o 
    io.sails = {
      // Whether to automatically connect a socket and save it as `io.socket`.
      autoConnect: true,

      // Whether to automatically try to reconnect after connection is lost
      reconnection: false,

      // The route (path) to hit to get a x-origin (CORS) cookie
      // (or true to use the default: '/__getcookie')
      useCORSRouteToGetCookie: true,

      // The environment we're running in.
      // (logs are not displayed when this is set to 'production')
      //
      // Defaults to "development" unless this script was fetched from a URL
      // that ends in `*.min.js` or '#production', or if the conventional
      // `SAILS_LOCALS` global is set with an `_environment` of "production"
      // or "staging".  (This setting may also be manually overridden.)
      environment:
        urlThisScriptWasFetchedFrom.match(/(\#production|\.min\.js)/g) ||
        (typeof window === "object" &&
          window &&
          typeof window.SAILS_LOCALS === "object" &&
          window.SAILS_LOCALS &&
          (window.SAILS_LOCALS._environment === "staging" ||
            window.SAILS_LOCALS._environment === "production"))
          ? "production"
          : "development",

      // The version of this sails.io.js client SDK
      sdk: SDK_INFO,

      // Transports to use when communicating with the server, in the order they will be tried
      transports: ["websocket"]
    };

    //            
    //                      
    //       o       
    //                
    //                         
    //                         
    //         
    //                    
    //                     
    //
    // Now fold in config provided as HTML attributes on the script tag:
    // (note that if `io.sails.*` is changed after this script, those changes
    //  will still take precedence)
    CONFIGURABLE_VIA_HTML_ATTR.forEach(function(configKey) {
      if (typeof scriptTagConfig[configKey] !== "undefined") {
        io.sails[configKey] = scriptTagConfig[configKey];
      }
    });
    //////////////////////////////////////////////////////////////////////////////
    // Note that the new HTML attribute configuration style may eventually
    // completely replace the original approach of setting `io.sails` properties,
    // since the new strategy is easier to reason about.  Also, it would allow us
    // to remove the timeout below someday.
    //////////////////////////////////////////////////////////////////////////////

    //        /  \
    //                /   /
    //  o o   \  /

    /**
     * Add `io.sails.connect` function as a wrapper for the built-in `io()` aka `io.connect()`
     * method, returning a SailsSocket. This special function respects the configured io.sails
     * connection URL, as well as sending other identifying information (most importantly, the
     * current version of this SDK).
     *
     * @param  {String} url  [optional]
     * @param  {Object} opts [optional]
     * @return {Socket}
     */
    io.sails.connect = function(url, opts) {
      // Make URL optional
      if ("object" === typeof url) {
        opts = url;
        url = null;
      }

      // Default opts to empty object
      opts = opts || {};

      // If explicit connection url is specified, save it to options
      opts.url = url || opts.url || undefined;

      // Instantiate and return a new SailsSocket- and try to connect immediately.
      var socket = new SailsSocket(opts);
      socket._connect();
      return socket;
    };

    //            
    //      
    //                      
    //                      
    //       
    //            
    //
    // io.socket
    //
    // The eager instance of Socket which will automatically try to connect
    // using the host that this js file was served from.
    //
    // This can be disabled or configured by setting properties on `io.sails.*` within the
    // first cycle of the event loop.
    //

    // Build `io.socket` so it exists
    // (note that this DOES NOT start the connection process)
    io.socket = new SailsSocket();
    //
    // This socket is not connected yet, and has not even _started_ connecting.
    //
    // But in the mean time, this eager socket will be queue events bound by the user
    // before the first cycle of the event loop (using `.on()`), which will later
    // be rebound on the raw underlying socket.

    //          
    //                        
    //                   
    // If configured to do so, start auto-connecting after the first cycle of the event loop
    // has completed (to allow time for this behavior to be configured/disabled
    // by specifying properties on `io.sails`)

    // Indicate that the autoConnect timer has started.
    io.socket._mightBeAboutToAutoConnect = true;

    setTimeout(function() {
      // Indicate that the autoConect timer fired.
      io.socket._mightBeAboutToAutoConnect = false;

      // If autoConnect is disabled, delete the eager socket (io.socket) and bail out.
      if (io.sails.autoConnect === false || io.sails.autoconnect === false) {
        delete io.socket;
        return;
      }

      // consolog('Eagerly auto-connecting socket to Sails... (requests will be queued in the mean-time)');
      io.socket._connect();
    }, 0); // </setTimeout>

    // Return the `io` object.
    return io;
  } //</SailsIOClient>

  //
  /////////////////////////////////////////////////////////////////////////////////
  ///// </bunches of private function definitions, constructors, and methods>
  /////////////////////////////////////////////////////////////////////////////////

  //              
  //       
  //                 
  //                  
  //              
  //                  
  //

  // Add CommonJS support to allow this client SDK to be used from Node.js.
  if (SDK_INFO.platform === "node") {
    module.exports = SailsIOClient;
  }
  // Add AMD support, registering this client SDK as an anonymous module.
  else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return SailsIOClient;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})();

/* eslint-enable */


/***/ }),

/***/ 40659:
/*!*************************!*\
  !*** ./src/js/store.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7 */ 31223);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((AB) => {
   const allDCs = AB.datacollections();

   const configStore = {
      state: {
         // "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322": [],
         // "19e566e3-a6b0-4ed5-83ea-a42b1ddbf5c5": [],
         user: { username: "" },
         version: "",
      },
      getters: {
         // "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"({ state }) {
         //    return state["0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"];
         // },
         // "19e566e3-a6b0-4ed5-83ea-a42b1ddbf5c5"({ state }) {
         //    return state["19e566e3-a6b0-4ed5-83ea-a42b1ddbf5c5"];
         // },
         user({ state }) {
            return state["user"];
         },
         version({ state }) {
            return state.version;
         },
      },
      actions: {
         getAppBuilderData({ state }, id) {
            let DC = AB.datacollectionByID(id);
            DC.setState(state);
            DC.loadData();
         },
         setUser({ state }, user) {
            state["user"] = user;
         },
         updateRecord({ state }, props) {
            let records = [...state[props.dcID].records];
            let foundIndex = records.findIndex((x) => x.uuid == props.recordID);
            let recordToUpdate = records[foundIndex];

            for (var propt in props.record) {
               if (Object.prototype.hasOwnProperty.call(recordToUpdate, propt))
                  recordToUpdate[propt] = props.record[propt];
            }
            state[props.dcID] = {
               loading: false,
               hasMore: records.length >= 60 ? false : true,
               records: records,
            };
         },
         getVersion({ state }) {
            state.version = app.f7.params.version;
         },
      },
   };

   allDCs.forEach((DC) => {
      DC.initStore(configStore);
   });

   const store = (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])(configStore);

   return store;
});


/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["vendors"], () => (__webpack_exec__(62107)));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);
//# sourceMappingURL=mobile_app.js.map